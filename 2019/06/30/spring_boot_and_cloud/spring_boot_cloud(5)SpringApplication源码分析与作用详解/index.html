<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">

<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"ceaser.wang","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.12.1","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="SpringApplication的初始化流程源码分析">
<meta property="og:type" content="article">
<meta property="og:title" content="spring_boot_cloud(5)SpringApplication源码分析与作用详解">
<meta property="og:url" content="https://ceaser.wang/2019/06/30/spring_boot_and_cloud/spring_boot_cloud(5)SpringApplication%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="南贺神社">
<meta property="og:description" content="SpringApplication的初始化流程源码分析">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://ceaser.wang/getName.png">
<meta property="og:image" content="https://ceaser.wang/url.png">
<meta property="og:image" content="https://ceaser.wang/url1.png">
<meta property="og:image" content="https://ceaser.wang/url2.png">
<meta property="og:image" content="https://ceaser.wang/url2.png">
<meta property="og:image" content="https://ceaser.wang/instance.png">
<meta property="og:image" content="https://ceaser.wang/EventPublishingRunListener.png">
<meta property="og:image" content="https://ceaser.wang/banner.png">
<meta property="og:image" content="https://ceaser.wang/stopwatch.png">
<meta property="article:published_time" content="2019-06-30T16:54:32.000Z">
<meta property="article:modified_time" content="2024-04-24T05:29:46.374Z">
<meta property="article:author" content="CeaserWang">
<meta property="article:tag" content="SpringBootApplication">
<meta property="article:tag" content="源码解析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ceaser.wang/getName.png">


<link rel="canonical" href="https://ceaser.wang/2019/06/30/spring_boot_and_cloud/spring_boot_cloud(5)SpringApplication%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://ceaser.wang/2019/06/30/spring_boot_and_cloud/spring_boot_cloud(5)SpringApplication%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3/","path":"2019/06/30/spring_boot_and_cloud/spring_boot_cloud(5)SpringApplication源码分析与作用详解/","title":"spring_boot_cloud(5)SpringApplication源码分析与作用详解"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>spring_boot_cloud(5)SpringApplication源码分析与作用详解 | 南贺神社</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">南贺神社</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">你写程序有写诗一样的感觉吗?</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">210</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">26</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">221</span></a></li><li class="menu-item menu-item-0xcc"><a href="/0xcc/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>0XCC</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringApplication%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.</span> <span class="nav-text">SpringApplication的初始化流程源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringApplication%E5%85%A5%E5%8F%A3"><span class="nav-number">1.1.</span> <span class="nav-text">SpringApplication入口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringApplication%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E4%B8%BB%E6%B5%81%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">SpringApplication构造器的主流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ResourceLoader"><span class="nav-number">1.3.</span> <span class="nav-text">ResourceLoader</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WebApplicationType%E6%8E%A2%E6%B5%8B%E5%BA%94%E7%94%A8%E7%B1%BB%E5%9E%8B%E9%80%BB%E8%BE%91"><span class="nav-number">1.4.</span> <span class="nav-text">WebApplicationType探测应用类型逻辑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ApplicationContextInitializer%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E9%80%BB%E8%BE%91"><span class="nav-number">1.5.</span> <span class="nav-text">ApplicationContextInitializer的加载和初始化逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ApplicationContextInitializer%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.5.1.</span> <span class="nav-text">ApplicationContextInitializer介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E6%89%80%E6%9C%89%E5%B7%A5%E5%8E%82%E5%B9%B6%E7%BC%93%E5%AD%98"><span class="nav-number">1.5.2.</span> <span class="nav-text">加载所有工厂并缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#factoryClass-getName%E6%89%A9%E5%B1%95"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">factoryClass.getName扩展</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#classLoader-getResources%E6%89%A9%E5%B1%95%EF%BC%9A"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">classLoader.getResources扩展：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E4%B8%89%E4%B8%AAspring-jar%E7%9A%84%E5%B7%A5%E5%8E%82"><span class="nav-number">1.5.3.</span> <span class="nav-text">加载三个spring jar的工厂</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E5%B7%A5%E5%8E%82%E7%9A%84%E5%90%88%E5%B9%B6%E7%BB%93%E6%9E%9C"><span class="nav-number">1.5.4.</span> <span class="nav-text">所有工厂的合并结果</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%97%E5%88%B0ApplicationContextInitializer%E7%9A%84%E6%89%80%E6%9C%89%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.6.</span> <span class="nav-text">得到ApplicationContextInitializer的所有实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAApplicationContextInitializer%E6%89%80%E6%9C%89%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.7.</span> <span class="nav-text">创建ApplicationContextInitializer所有实现的实例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#BeanUtils-instantiateClass%E6%89%A9%E5%B1%95"><span class="nav-number">1.7.1.</span> <span class="nav-text">BeanUtils.instantiateClass扩展</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setInitializers%E5%92%8C%E6%8E%92%E5%BA%8F"><span class="nav-number">1.8.</span> <span class="nav-text">setInitializers和排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ApplicationListener"><span class="nav-number">1.9.</span> <span class="nav-text">ApplicationListener</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E5%BA%94%E7%94%A8%E7%B1%BB%E8%8E%B7%E5%8F%96deduceMainApplicationClass"><span class="nav-number">1.10.</span> <span class="nav-text">主应用类获取deduceMainApplicationClass</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">2.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringApplication%E7%9A%84run%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">SpringApplication的run方法源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#StopWatch"><span class="nav-number">3.1.</span> <span class="nav-text">StopWatch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConfigurableApplicationContext"><span class="nav-number">3.2.</span> <span class="nav-text">ConfigurableApplicationContext</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ApplicationContext"><span class="nav-number">3.2.1.</span> <span class="nav-text">ApplicationContext</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConfigurableApplicationContext-1"><span class="nav-number">3.3.</span> <span class="nav-text">ConfigurableApplicationContext</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringBootExceptionReporter"><span class="nav-number">3.4.</span> <span class="nav-text">SpringBootExceptionReporter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#configureHeadlessProperty-%E6%96%B9%E6%B3%95"><span class="nav-number">3.5.</span> <span class="nav-text">configureHeadlessProperty()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getRunListeners-%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E7%9B%91%E5%90%AC%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%8F%E5%85%B8%E5%BA%94%E7%94%A8"><span class="nav-number">3.6.</span> <span class="nav-text">getRunListeners()方法以及监听器模式的经典应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SpringApplicationRunListener%E7%B1%BB"><span class="nav-number">3.6.1.</span> <span class="nav-text">SpringApplicationRunListener类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SpringApplicationRunListeners"><span class="nav-number">3.6.2.</span> <span class="nav-text">SpringApplicationRunListeners</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#EventPublishingRunListener"><span class="nav-number">3.6.3.</span> <span class="nav-text">EventPublishingRunListener</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#SimpleApplicationEventMulticaster"><span class="nav-number">3.6.3.1.</span> <span class="nav-text">SimpleApplicationEventMulticaster</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ApplicationStartingEvent"><span class="nav-number">3.6.3.2.</span> <span class="nav-text">ApplicationStartingEvent</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="nav-number">3.6.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#environment%E7%BB%84%E4%BB%B6%E7%9A%84%E9%87%8D%E8%A6%81%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3"><span class="nav-number">3.7.</span> <span class="nav-text">environment组件的重要作用详解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Environment-doc%E8%A7%A3%E8%AF%BB"><span class="nav-number">3.7.1.</span> <span class="nav-text">Environment doc解读</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ConfigurableEnvironment-doc%E8%A7%A3%E8%AF%BB"><span class="nav-number">3.7.2.</span> <span class="nav-text">ConfigurableEnvironment doc解读</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#prepareEnvironment%E6%96%B9%E6%B3%95"><span class="nav-number">3.7.3.</span> <span class="nav-text">prepareEnvironment方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#getOrCreateEnvironment-%E6%96%B9%E6%B3%95"><span class="nav-number">3.7.3.1.</span> <span class="nav-text">getOrCreateEnvironment()方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#configureEnvironment-%E6%96%B9%E6%B3%95"><span class="nav-number">3.7.3.2.</span> <span class="nav-text">configureEnvironment()方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#listeners-environmentPrepared-environment"><span class="nav-number">3.7.3.3.</span> <span class="nav-text">listeners.environmentPrepared(environment)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Banner"><span class="nav-number">3.8.</span> <span class="nav-text">Banner</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SpringApplicationBannerPrinter"><span class="nav-number">3.8.1.</span> <span class="nav-text">SpringApplicationBannerPrinter</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#createApplicationContext-%E6%96%B9%E6%B3%95"><span class="nav-number">3.9.</span> <span class="nav-text">createApplicationContext()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#prepareContext-context-environment-listeners-applicationArguments-printedBanner-%E6%96%B9%E6%B3%95"><span class="nav-number">3.10.</span> <span class="nav-text">prepareContext(context, environment, listeners, applicationArguments,printedBanner)方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#refreshContext-%E5%88%B7%E6%96%B0%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-number">3.11.</span> <span class="nav-text">refreshContext()刷新上下文</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#afterRefresh-context-applicationArguments-%E6%96%B9%E6%B3%95"><span class="nav-number">3.12.</span> <span class="nav-text">afterRefresh(context, applicationArguments)方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stopWatch-stop-%E7%A7%92%E8%A1%A8%E8%AE%A1%E6%97%B6%E7%BB%93%E6%9D%9F"><span class="nav-number">3.13.</span> <span class="nav-text">stopWatch.stop()秒表计时结束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%8D%B0%E5%90%AF%E5%8A%A8%E4%BF%A1%E6%81%AF"><span class="nav-number">3.14.</span> <span class="nav-text">打印启动信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#listeners-started-context"><span class="nav-number">3.15.</span> <span class="nav-text">listeners.started(context)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#callRunners-%E6%96%B9%E6%B3%95"><span class="nav-number">3.16.</span> <span class="nav-text">callRunners()方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ApplicationRunner"><span class="nav-number">3.16.1.</span> <span class="nav-text">ApplicationRunner</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CommandLineRunner"><span class="nav-number">3.16.2.</span> <span class="nav-text">CommandLineRunner</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#listeners-running-context"><span class="nav-number">3.17.</span> <span class="nav-text">listeners.running(context)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9D%9F"><span class="nav-number">4.</span> <span class="nav-text">结束</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="CeaserWang"
      src="/../0xcc/index/Uchiha.jpg">
  <p class="site-author-name" itemprop="name">CeaserWang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">221</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">210</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzExNTY3MjE4NzQ=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;1156721874"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmNlYXNlcndhbmdAb3V0bG9vay5jb20=" title="E-Mail → mailto:ceaserwang@outlook.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-user-friends fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly90d29kcmFnb25sYWtlLmNvbQ==" title="https:&#x2F;&#x2F;twodragonlake.com">TwoDragonLake</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9yb290Y2x1c3Rlci5naXRodWIuaW8=" title="https:&#x2F;&#x2F;rootcluster.github.io">RootCluster</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9tdXNlZmxvdy5pbw==" title="https:&#x2F;&#x2F;museflow.io">MuseFlow</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9pbmNvZGVyLm9yZw==" title="https:&#x2F;&#x2F;incoder.org">BladeCode</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9rYWlmYS5kZXY=" title="https:&#x2F;&#x2F;kaifa.dev">Alyenc</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmRhemhpZGF5b25nLmNu" title="https:&#x2F;&#x2F;blog.dazhidayong.cn">Killua</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly93d3cuY3lsb25nLmNvbQ==" title="https:&#x2F;&#x2F;www.cylong.com">Cylong</span>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ceaser.wang/2019/06/30/spring_boot_and_cloud/spring_boot_cloud(5)SpringApplication%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/../0xcc/index/Uchiha.jpg">
      <meta itemprop="name" content="CeaserWang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南贺神社">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="spring_boot_cloud(5)SpringApplication源码分析与作用详解 | 南贺神社">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          spring_boot_cloud(5)SpringApplication源码分析与作用详解
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-06-30 16:54:32" itemprop="dateCreated datePublished" datetime="2019-06-30T16:54:32+00:00">2019-06-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-04-24 05:29:46" itemprop="dateModified" datetime="2024-04-24T05:29:46+00:00">2024-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/spring-boot-cloud/" itemprop="url" rel="index"><span itemprop="name">spring_boot_cloud</span></a>
        </span>
    </span>

  
    <span id="/2019/06/30/spring_boot_and_cloud/spring_boot_cloud(5)SpringApplication%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3/" class="post-meta-item leancloud_visitors" data-flag-title="spring_boot_cloud(5)SpringApplication源码分析与作用详解" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h3 id="SpringApplication的初始化流程源码分析"><a href="#SpringApplication的初始化流程源码分析" class="headerlink" title="SpringApplication的初始化流程源码分析"></a>SpringApplication的初始化流程源码分析</h3><span id="more"></span>

<h4 id="SpringApplication入口"><a href="#SpringApplication入口" class="headerlink" title="SpringApplication入口"></a>SpringApplication入口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class MyApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的spring boot的启动都是从这个main方法开始的，，那么这个方法的主要的一行代码就是SpringApplication.run(MyApplication.class,args);我们本次要看一下他的执行流程。<br>run方法点进去之后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) &#123;</span><br><span class="line">  return run(new Class&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConfigurableApplicationContext是一个即使不是所有应用上下文 也是大部分的应用上下文实现的spi接口，提供了一些设施用来配置应用上下文，配置和生命周期方法封装在这里，避免他们出现在应用上下文的客户端代码里边，ConfigurableApplicationContext罗列的方法用来启动和关闭的代码里边。<br>run方法的入参是一个Class类型的参数，然后掉了另一个重载的run方法，这个run方法的第一个入参是Class类型的数组，第二个参数是传进来的args，这种变成风格很常见，一般一个方法是通用的，接受数组类型的，一个方法是只接受一个参数的，一个参数的方法是接受数组参数方法的特例，那么接受一个参数的方法会调用通用的那个方法。跟进去：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources,</span><br><span class="line">    String[] args) &#123;</span><br><span class="line">  return new SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法new 了一个SpringApplication的实例执行了SpringApplication实例的run方法，返回值就是SpringApplication的run方法的返回值。<br>接着往里走：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public SpringApplication(Class&lt;?&gt;... primarySources) &#123;</span><br><span class="line">  this(null, primarySources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SpringApplication构造器的主流程"><a href="#SpringApplication构造器的主流程" class="headerlink" title="SpringApplication构造器的主流程"></a>SpringApplication构造器的主流程</h4><p>最终来到了这个构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">Create a new SpringApplication instance. The application context will load beans from the specified primary sources (see class-level documentation for details. The instance can be customized before calling run(String...).</span><br><span class="line">创建一个应用上下文，应用 上下文会从指定的primarySources加载，这个实例可以在调用run方法之前进行一个定制化。</span><br><span class="line">*/</span><br><span class="line">public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;</span><br><span class="line">  this.resourceLoader = resourceLoader;//为null</span><br><span class="line">  Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);</span><br><span class="line">  this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));//com.twodragonlake.boot.MyApplication.class</span><br><span class="line">  this.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">  setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">  setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">  this.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h4><p>  ResourceLoader：用来加载资源的策略接口（class path，类路劲，文件资源），org.springframework.context.ApplicationContext被要求提供这个功能，再加上org.springframework.core.io.support.ResourcePatternResolver这样一个支持。DefaultResourceLoader是一个独立的实现，他被用在ApplicationContext之外，也是被资源编辑器ResourceEditor所使用。<br>  ResourceLoader结构：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ResourceLoader</span><br><span class="line">  //加载资源都离不开类加载器</span><br><span class="line">  getClassLoader</span><br><span class="line">  getResource</span><br><span class="line">  CLASSPATH_URL_PREFIX</span><br></pre></td></tr></table></figure></p>
<h4 id="WebApplicationType探测应用类型逻辑"><a href="#WebApplicationType探测应用类型逻辑" class="headerlink" title="WebApplicationType探测应用类型逻辑"></a>WebApplicationType探测应用类型逻辑</h4><p>  this.webApplicationType &#x3D; WebApplicationType.deduceFromClasspath();这一行是确定应用类型，进到枚举WebApplicationType看一下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public enum WebApplicationType &#123;</span><br><span class="line"></span><br><span class="line">  	/**</span><br><span class="line">  	 * The application should not run as a web application and should not start an</span><br><span class="line">  	 * embedded web server.</span><br><span class="line">  	 */</span><br><span class="line">     什么类型也不是</span><br><span class="line">  	NONE,</span><br><span class="line"></span><br><span class="line">  	/**</span><br><span class="line">  	 * The application should run as a servlet-based web application and should start an</span><br><span class="line">  	 * embedded servlet web server.</span><br><span class="line">  	 */</span><br><span class="line">     servlet应用类型</span><br><span class="line">  	SERVLET,</span><br><span class="line"></span><br><span class="line">  	/**</span><br><span class="line">  	 * The application should run as a reactive web application and should start an</span><br><span class="line">  	 * embedded reactive web server.</span><br><span class="line">  	 */</span><br><span class="line">     反应式应用类型</span><br><span class="line">  	REACTIVE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    	private static final String[] SERVLET_INDICATOR_CLASSES = &#123; &quot;javax.servlet.Servlet&quot;,</span><br><span class="line">    			&quot;org.springframework.web.context.ConfigurableWebApplicationContext&quot; &#125;;</span><br><span class="line"></span><br><span class="line">    	private static final String WEBMVC_INDICATOR_CLASS = &quot;org.springframework.&quot;</span><br><span class="line">    			+ &quot;web.servlet.DispatcherServlet&quot;;</span><br><span class="line"></span><br><span class="line">    	private static final String WEBFLUX_INDICATOR_CLASS = &quot;org.&quot;</span><br><span class="line">    			+ &quot;springframework.web.reactive.DispatcherHandler&quot;;</span><br><span class="line"></span><br><span class="line">    	private static final String JERSEY_INDICATOR_CLASS = &quot;org.glassfish.jersey.servlet.ServletContainer&quot;;</span><br><span class="line"></span><br><span class="line">    	private static final String SERVLET_APPLICATION_CONTEXT_CLASS = &quot;org.springframework.web.context.WebApplicationContext&quot;;</span><br><span class="line"></span><br><span class="line">    	private static final String REACTIVE_APPLICATION_CONTEXT_CLASS = &quot;org.springframework.boot.web.reactive.context.ReactiveWebApplicationContext&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //推断应用类型</span><br><span class="line">    	static WebApplicationType deduceFromClasspath() &#123;</span><br><span class="line">        //反应式应用的推荐条件</span><br><span class="line">    		if (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null)</span><br><span class="line">    				&amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null)</span><br><span class="line">    				&amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) &#123;</span><br><span class="line">    			return WebApplicationType.REACTIVE;</span><br><span class="line">    		&#125;</span><br><span class="line">        //SERVLET_INDICATOR_CLASSES里边的都没有出现就是什么类型都不是的应用</span><br><span class="line">        //因为工程里边引入了tomcat的jar包所有javax.servlet.Servlet肯定存在classpath下，而ConfigurableWebApplicationContext</span><br><span class="line">        //是spring里边的类，也会出现在classpath里边。</span><br><span class="line">    		for (String className : SERVLET_INDICATOR_CLASSES) &#123;</span><br><span class="line">    			if (!ClassUtils.isPresent(className, null)) &#123;</span><br><span class="line">    				return WebApplicationType.NONE;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">        //其他的都是servlet应用[当前的demo会返回这个值，即，当前demo是一个servlet类型的应用]</span><br><span class="line">    		return WebApplicationType.SERVLET;</span><br><span class="line">    	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ApplicationContextInitializer的加载和初始化逻辑"><a href="#ApplicationContextInitializer的加载和初始化逻辑" class="headerlink" title="ApplicationContextInitializer的加载和初始化逻辑"></a>ApplicationContextInitializer的加载和初始化逻辑</h4><h5 id="ApplicationContextInitializer介绍"><a href="#ApplicationContextInitializer介绍" class="headerlink" title="ApplicationContextInitializer介绍"></a>ApplicationContextInitializer介绍</h5><p>接下来是 setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));<br>getSpringFactoriesInstances的作用就是加载实现了ApplicationContextInitializer接口的这些工厂的实例。<br>首先看一下getSpringFactoriesInstances的参数ApplicationContextInitializer.class<br>看一下doc:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Callback interface for initializing a Spring ConfigurableApplicationContext prior to being refreshed.</span><br><span class="line">Typically used within web applications that require some programmatic initialization of the application context. For example, registering property sources or activating profiles against the context&#x27;s environment. See ContextLoader and FrameworkServlet support for declaring a &quot;contextInitializerClasses&quot; context-param and init-param, respectively.</span><br><span class="line">ApplicationContextInitializer processors are encouraged to detect whether Spring&#x27;s Ordered interface has been implemented or if the @Order annotation is present and to sort instances accordingly if so prior to invocation.</span><br></pre></td></tr></table></figure>
<p>在bean刷新之前初始化 Spring ConfigurableApplicationContext的一个回调接口。<br>通常用于在web应用当中，需要编程的方式初始化应用的上下文。<br>比如我们注册 一个属性源，激活profile这对于上下文的环境。<br>ApplicationContextInitializer被鼓励探测spring排序接口是不是被实现或者<code>@Order</code>注解是不是存在，存在的话用来排序。<br>ApplicationContextInitializer主要用来完成初始化工作。</p>
<h5 id="加载所有工厂并缓存"><a href="#加载所有工厂并缓存" class="headerlink" title="加载所有工厂并缓存"></a>加载所有工厂并缓存</h5><p>那为什么getSpringFactoriesInstances方法要传入初始化器呢，跟进去看一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type) &#123;</span><br><span class="line">  return getSpringFactoriesInstances(type, new Class&lt;?&gt;[] &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type,</span><br><span class="line">    Class&lt;?&gt;[] parameterTypes, Object... arg s) &#123;</span><br><span class="line">  ClassLoader classLoader = getClassLoader();//应用类加载器</span><br><span class="line">  // Use names and ensure unique to protect against duplicates</span><br><span class="line">  Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(</span><br><span class="line">      SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">  List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes,</span><br><span class="line">      classLoader, args, names);</span><br><span class="line">  AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">  return instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getClassLoader()方法是获取类的加载器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//如果resourceLoader不是空，就返回resourceLoader的类加载器，此处resourceLoader是空的，if语句不会执行</span><br><span class="line">public ClassLoader getClassLoader() &#123;</span><br><span class="line">  if (this.resourceLoader != null) &#123;</span><br><span class="line">    return this.resourceLoader.getClassLoader();</span><br><span class="line">  &#125;</span><br><span class="line">  return ClassUtils.getDefaultClassLoader();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后看一下ClassUtils.getDefaultClassLoader()：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">逻辑很简单，默认返回线程上下文类加载器</span><br><span class="line">public static ClassLoader getDefaultClassLoader() &#123;</span><br><span class="line">  ClassLoader cl = null;</span><br><span class="line">  try &#123;</span><br><span class="line">    cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">  &#125;</span><br><span class="line">  catch (Throwable ex) &#123;</span><br><span class="line">    // Cannot access thread context ClassLoader - falling back...</span><br><span class="line">  &#125;</span><br><span class="line">  //如果线程上下文类加载器是空的，就返回ClassUtils的类加载器</span><br><span class="line">  if (cl == null) &#123;</span><br><span class="line">    // No thread context class loader -&gt; use class loader of this class.</span><br><span class="line">    cl = ClassUtils.class.getClassLoader();</span><br><span class="line">    //如果ClassUtils的类加载器也是空的就返回系统类加载器</span><br><span class="line">    if (cl == null) &#123;</span><br><span class="line">      // getClassLoader() returning null indicates the bootstrap ClassLoader</span><br><span class="line">      try &#123;</span><br><span class="line">        cl = ClassLoader.getSystemClassLoader();</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Throwable ex) &#123;</span><br><span class="line">        // Cannot access system ClassLoader - oh well, maybe the caller can live with null...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return cl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们的程序返回的是系统类加载器(线程上下文类加载器中的)<br>Set<String> names &#x3D; new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));<br>type是ApplicationContextInitializer.class，<br>这里SpringFactoriesLoader加载了工厂的名字：<br>SpringFactoriesLoader解析:<br>doc：<br>General purpose factory loading mechanism for internal use within the framework.<br>SpringFactoriesLoader loads and instantiates factories of a given type from “META-INF&#x2F;spring.factories” files which may be present in multiple JAR files in the classpath. The spring.factories file must be in Properties format, where the key is the fully qualified name of the interface or abstract class, and the value is a comma-separated list of implementation class names. For example:<br>example.MyService&#x3D;example.MyServiceImpl1,example.MyServiceImpl2<br>where example.MyService is the name of the interface, and MyServiceImpl1 and MyServiceImpl2 are two implementations.<br>在框架内部所使用的的一种通用工厂加载机制。<br>SpringFactoriesLoader从文件 “META-INF&#x2F;spring.factories” 里边指定的类型工厂进行加载和实例化。<br>这个文件可能位于classpath下多个jar文件当中。spring.factories文件必须要是Properties格式的，其中key就是接口或者抽象类的完全限定的名字，值是逗号分隔的实现类名字的列表。举例：<br>example.MyService&#x3D;example.MyServiceImpl1,example.MyServiceImpl2<br>其中example.MyService是接口的名字，example.MyServiceImpl1,example.MyServiceImpl2是2个实现类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123;</span><br><span class="line">  String factoryClassName = factoryClass.getName();//ApplicationContextInitializer.class的全限定名</span><br><span class="line">  return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="factoryClass-getName扩展"><a href="#factoryClass-getName扩展" class="headerlink" title="factoryClass.getName扩展"></a>factoryClass.getName扩展</h6><p> factoryClass.getName()：<br>这里做一下扩展结合之前jvm字节码的章节，我们看一下这个方法的doc：<br><img src="/getName.png" alt="getName.png"><br>返回调用getName的class对象的实体（类，接口，数组，原生类型，或者void）的名字。并且作为字符串的形式返回<br>如果class对象代表的是引用类新型，并且不是数组类型，就会返回这个类的二进制的名字，名字是java 语言规范规定的格式返回的。<br>如果class的对象代表的是原生类型或者是void，调用getName返回的名称就是原生类型的名字或者void。<br>如果class对象表示的是数组类，那么返回的名字的内部形式就会包含元素类型的名字，其中”[“代表的是数组的维度数量。</p>
<p>接下来回到主流程，进入到loadSpringFactories()：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//进入loadSpringFactories</span><br><span class="line">private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123;</span><br><span class="line">  //cache的结构：Map&lt;ClassLoader, MultiValueMap&lt;String, String&gt;&gt;</span><br><span class="line">  MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line">  //缓存加载出来的是null，继续往下走</span><br><span class="line">  if (result != null) &#123;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    /**</span><br><span class="line">    	 * The location to look for factories.</span><br><span class="line">    	 * &lt;p&gt;Can be present in multiple JAR files.</span><br><span class="line">       寻找工厂的位置，可以存在于多个jar文件当中</span><br><span class="line">       public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;;</span><br><span class="line">    */</span><br><span class="line">    Enumeration&lt;URL&gt; urls = (classLoader != null ?</span><br><span class="line">        classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">        ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">    result = new LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">    while (urls.hasMoreElements()) &#123;</span><br><span class="line">      //</span><br><span class="line">      URL url = urls.nextElement();</span><br><span class="line">      UrlResource resource = new UrlResource(url);</span><br><span class="line">      Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">      for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">        String factoryClassName = ((String) entry.getKey()).trim();</span><br><span class="line">        for (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">          result.add(factoryClassName, factoryName.trim());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cache.put(classLoader, result);</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">  catch (IOException ex) &#123;</span><br><span class="line">    throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; +</span><br><span class="line">        FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="classLoader-getResources扩展："><a href="#classLoader-getResources扩展：" class="headerlink" title="classLoader.getResources扩展："></a>classLoader.getResources扩展：</h6><p>classLoader.getResources(FACTORIES_RESOURCE_LOCATION) 解析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">根据名称得到资源（图片、音频、文本等），这些资源可以被class字节码访问，并且和字节码在位置上是独立存在的。</span><br><span class="line">name对应的资源路径是被&quot;/&quot;分隔的。</span><br><span class="line">返回值是一个枚举，如果资源找不到，枚举就是空的，如果资源没法访问，那么资源就不会出现在枚举里边。</span><br><span class="line">CompoundEnumeration是sun.misc包下的枚举的实现，它的结构如下：</span><br><span class="line">public class CompoundEnumeration&lt;E&gt; implements Enumeration&lt;E&gt; &#123;</span><br><span class="line">    private Enumeration&lt;E&gt;[] enums;</span><br><span class="line">    private int index = 0;</span><br><span class="line">&#125;    </span><br><span class="line">从代码结构来看它实现了Enumeration，就有Enumeration的一些特性，同时它有一个Enumeration数组，意味着它下面还可以存在Enumeration</span><br><span class="line">是一个多级的结构。</span><br><span class="line">public Enumeration&lt;URL&gt; getResources(String name) throws IOException &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    Enumeration&lt;URL&gt;[] tmp = (Enumeration&lt;URL&gt;[]) new Enumeration&lt;?&gt;[2];</span><br><span class="line">    if (parent != null) &#123;</span><br><span class="line">        tmp[0] = parent.getResources(name);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        tmp[0] = getBootstrapResources(name);</span><br><span class="line">    &#125;</span><br><span class="line">    tmp[1] = findResources(name);</span><br><span class="line"></span><br><span class="line">    return new CompoundEnumeration&lt;&gt;(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="加载三个spring-jar的工厂"><a href="#加载三个spring-jar的工厂" class="headerlink" title="加载三个spring jar的工厂"></a>加载三个spring jar的工厂</h5><p>我们debug可以看到url的位置<br>!(url.png)[url.png]<br>jar:file:&#x2F;D:&#x2F;gradlerepo&#x2F;caches&#x2F;modules-2&#x2F;files-2.1&#x2F;org.springframework.boot&#x2F;spring-boot-autoconfigure&#x2F;2.1.3.RELEASE&#x2F;58e07f69638a3ca13dffe8a2b68d284af376d105&#x2F;spring-boot-autoconfigure-2.1.3.RELEASE.jar!&#x2F;META-INF&#x2F;spring.factories<br><img src="/url.png" alt="url.png"><br>然后打开这个spring.factories<br><img src="/url1.png" alt="url1.png"><br>里边有七个主要的类(接口)：</p>
<ul>
<li>org.springframework.context.ApplicationContextInitializer</li>
<li>org.springframework.context.ApplicationListener</li>
<li>org.springframework.boot.autoconfigure.AutoConfigurationImportListener</li>
<li>org.springframework.boot.autoconfigure.AutoConfigurationImportFilter</li>
<li>org.springframework.boot.autoconfigure.EnableAutoConfiguration</li>
<li>org.springframework.boot.diagnostics.FailureAnalyzer</li>
<li>org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider<br>接下往下走就会看到这七个接口：<br><img src="/url2.png" alt="url2.png"><br>最后loadSpringFactories返回的result是一个map，key是接口的名称，value是接口的实现类：<br>比如刚才的spring.factories里边 org.springframework.boot.autoconfigure.EnableAutoConfiguration有118个实现，那么map的key就是 org.springframework.boot.autoconfigure.EnableAutoConfiguration，value是她的118个实现。</li>
</ul>
<p>然后再看一下第二个工厂的jar位置：<br>jar:file:&#x2F;D:&#x2F;gradlerepo&#x2F;caches&#x2F;modules-2&#x2F;files-2.1&#x2F;org.springframework.boot&#x2F;spring-boot&#x2F;2.1.3.RELEASE&#x2F;92bb92cd73212cefc1e5112e3bbf1f31c154c3fd&#x2F;spring-boot-2.1.3.RELEASE.jar!&#x2F;META-INF&#x2F;spring.factories<br>看一下它里边的结构：<br><img src="/url2.png" alt="url2.png"><br>主要接口如下：</p>
<ul>
<li>org.springframework.boot.diagnostics.FailureAnalysisReporter</li>
<li>org.springframework.boot.diagnostics.FailureAnalyzer</li>
<li>org.springframework.boot.env.EnvironmentPostProcessor</li>
<li>org.springframework.boot.env.PropertySourceLoader</li>
<li>org.springframework.boot.SpringApplicationRunListener</li>
<li>org.springframework.boot.SpringBootExceptionReporter</li>
<li>org.springframework.context.ApplicationContextInitializer</li>
<li>org.springframework.context.ApplicationListener</li>
</ul>
<p>我们看到有一个org.springframework.context.ApplicationListener但是在spring-boot-autoconfigure-2.1.3.RELEASE.jar里边也有一个org.springframework.context.ApplicationListener，这个时候就能看到MultiValueMap&lt;String, String&gt;所起的作用，相同key的value会进行合并。</p>
<p>继续放下看下一个工厂jar的位置：<br>jar:file:&#x2F;D:&#x2F;gradlerepo&#x2F;caches&#x2F;modules-2&#x2F;files-2.1&#x2F;org.springframework&#x2F;spring-beans&#x2F;5.1.5.RELEASE&#x2F;58b10c61f6bf2362909d884813c4049b657735f5&#x2F;spring-beans-5.1.5.RELEASE.jar!&#x2F;META-INF&#x2F;spring.factories</p>
<p>然后打开对应的spring.factories文件：<br>这里边只有一行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.BeanInfoFactory=org.springframework.beans.ExtendedBeanInfoFactory</span><br></pre></td></tr></table></figure>

<h5 id="所有工厂的合并结果"><a href="#所有工厂的合并结果" class="headerlink" title="所有工厂的合并结果"></a>所有工厂的合并结果</h5><p>由此我们可以得出结论spring boot启动的时候会初始化三个jar包的工厂。<br>得到的result是三个jar包所有的数据进行了合并，合并之后一共有13个工厂接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0 = &#123;LinkedHashMap$Entry@1746&#125; &quot;org.springframework.boot.autoconfigure.AutoConfigurationImportFilter&quot; -&gt; &quot; size = 3&quot;</span><br><span class="line">1 = &#123;LinkedHashMap$Entry@1747&#125; &quot;org.springframework.boot.diagnostics.FailureAnalyzer&quot; -&gt; &quot; size = 17&quot;</span><br><span class="line">2 = &#123;LinkedHashMap$Entry@1748&#125; &quot;org.springframework.boot.autoconfigure.AutoConfigurationImportListener&quot; -&gt; &quot; size = 1&quot;</span><br><span class="line">3 = &#123;LinkedHashMap$Entry@1749&#125; &quot;org.springframework.context.ApplicationContextInitializer&quot; -&gt; &quot; size = 6&quot;</span><br><span class="line">4 = &#123;LinkedHashMap$Entry@1750&#125; &quot;org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider&quot; -&gt; &quot; size = 5&quot;</span><br><span class="line">5 = &#123;LinkedHashMap$Entry@1751&#125; &quot;org.springframework.context.ApplicationListener&quot; -&gt; &quot; size = 10&quot;</span><br><span class="line">6 = &#123;LinkedHashMap$Entry@1752&#125; &quot;org.springframework.boot.autoconfigure.EnableAutoConfiguration&quot; -&gt; &quot; size = 118&quot;</span><br><span class="line">7 = &#123;LinkedHashMap$Entry@1753&#125; &quot;org.springframework.boot.env.EnvironmentPostProcessor&quot; -&gt; &quot; size = 3&quot;</span><br><span class="line">8 = &#123;LinkedHashMap$Entry@1754&#125; &quot;org.springframework.boot.SpringApplicationRunListener&quot; -&gt; &quot; size = 1&quot;</span><br><span class="line">9 = &#123;LinkedHashMap$Entry@1755&#125; &quot;org.springframework.boot.env.PropertySourceLoader&quot; -&gt; &quot; size = 2&quot;</span><br><span class="line">10 = &#123;LinkedHashMap$Entry@1756&#125; &quot;org.springframework.boot.diagnostics.FailureAnalysisReporter&quot; -&gt; &quot; size = 1&quot;</span><br><span class="line">11 = &#123;LinkedHashMap$Entry@1757&#125; &quot;org.springframework.boot.SpringBootExceptionReporter&quot; -&gt; &quot; size = 1&quot;</span><br><span class="line">12 = &#123;LinkedHashMap$Entry@1758&#125; &quot;org.springframework.beans.BeanInfoFactory&quot; -&gt; &quot; size = 1&quot;</span><br></pre></td></tr></table></figure>

<h4 id="得到ApplicationContextInitializer的所有实现"><a href="#得到ApplicationContextInitializer的所有实现" class="headerlink" title="得到ApplicationContextInitializer的所有实现"></a>得到ApplicationContextInitializer的所有实现</h4><p>loadSpringFactories(classLoader)的结果就是上边的13个实例，然后loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());<br>里边getOrDefault方法的参数是factoryClassName是interface org.springframework.context.ApplicationContextInitializer，<br>意思是从13个接口里边找到ApplicationContextInitializer这个接口，是能找到的，一共有6个ApplicationContextInitializer的实现类:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0 = &quot;org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer&quot;</span><br><span class="line">1 = &quot;org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener&quot;</span><br><span class="line">2 = &quot;org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer&quot;</span><br><span class="line">3 = &quot;org.springframework.boot.context.ContextIdApplicationContextInitializer&quot;</span><br><span class="line">4 = &quot;org.springframework.boot.context.config.DelegatingApplicationContextInitializer&quot;</span><br><span class="line">5 = &quot;org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer&quot;</span><br></pre></td></tr></table></figure>

<h4 id="创建ApplicationContextInitializer所有实现的实例"><a href="#创建ApplicationContextInitializer所有实现的实例" class="headerlink" title="创建ApplicationContextInitializer所有实现的实例"></a>创建ApplicationContextInitializer所有实现的实例</h4><p>接下来的逻辑是：<br>List<T> instances &#x3D; createSpringFactoriesInstances(type, parameterTypes,classLoader, args, names);<br>type：interface org.springframework.context.ApplicationContextInitializer<br>parameterTypes：是空数组。<br>classLoader：应用类加载器<br>args：空数组<br>names：即我们上边得到的有6个对象的数组。<br>逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private &lt;T&gt; List&lt;T&gt; createSpringFactoriesInstances(Class&lt;T&gt; type,  Class&lt;?&gt;[] parameterTypes,</span><br><span class="line">  ClassLoader classLoader,Object[] args,Set&lt;String&gt; names) &#123;</span><br><span class="line">  List&lt;T&gt; instances = new ArrayList&lt;&gt;(names.size());</span><br><span class="line">  for (String name : names) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      //先从ClassUtils内部的缓存加载，如果缓存不存在就会调用Class.forName(name, false, classLoader)这种原始的方式加载。</span><br><span class="line">      Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader);</span><br><span class="line">      Assert.isAssignable(type, instanceClass);</span><br><span class="line">      //得到构造器</span><br><span class="line">      Constructor&lt;?&gt; constructor = instanceClass</span><br><span class="line">          .getDeclaredConstructor(parameterTypes);</span><br><span class="line">      //创建实例，instantiateClass方法会尝试将不可访问（非public的）的改为可访问的，而且支持kotlin的类</span><br><span class="line">      T instance = (T) BeanUtils.instantiateClass(constructor, args);</span><br><span class="line">      instances.add(instance);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable ex) &#123;</span><br><span class="line">      throw new IllegalArgumentException(</span><br><span class="line">          &quot;Cannot instantiate &quot; + type + &quot; : &quot; + name, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="BeanUtils-instantiateClass扩展"><a href="#BeanUtils-instantiateClass扩展" class="headerlink" title="BeanUtils.instantiateClass扩展"></a>BeanUtils.instantiateClass扩展</h5><p> BeanUtils.instantiateClass：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; T instantiateClass(Constructor&lt;T&gt; ctor, Object... args) throws BeanInstantiationException &#123;</span><br><span class="line">    Assert.notNull(ctor, &quot;Constructor must not be null&quot;);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">       /**</span><br><span class="line">        ReflectionUtils.makeAccessible实现，即如果不可访问的改为可访问的。</span><br><span class="line">       public static void makeAccessible(Constructor&lt;?&gt; ctor) &#123;</span><br><span class="line">         if ((!Modifier.isPublic(ctor.getModifiers()) ||</span><br><span class="line">             !Modifier.isPublic(ctor.getDeclaringClass().getModifiers())) &amp;&amp; !ctor.isAccessible()) &#123;</span><br><span class="line">           ctor.setAccessible(true);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       **/</span><br><span class="line">        ReflectionUtils.makeAccessible(ctor);</span><br><span class="line">        //对java和kotlin类型的进行生成。</span><br><span class="line">        return KotlinDetector.isKotlinReflectPresent() &amp;&amp; KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ? BeanUtils.KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args);</span><br><span class="line">    &#125; catch (InstantiationException var3) &#123;</span><br><span class="line">        throw new BeanInstantiationException(ctor, &quot;Is it an abstract class?&quot;, var3);</span><br><span class="line">    &#125; catch (IllegalAccessException var4) &#123;</span><br><span class="line">        throw new BeanInstantiationException(ctor, &quot;Is the constructor accessible?&quot;, var4);</span><br><span class="line">    &#125; catch (IllegalArgumentException var5) &#123;</span><br><span class="line">        throw new BeanInstantiationException(ctor, &quot;Illegal arguments for constructor&quot;, var5);</span><br><span class="line">    &#125; catch (InvocationTargetException var6) &#123;</span><br><span class="line">        throw new BeanInstantiationException(ctor, &quot;Constructor threw exception&quot;, var6.getTargetException());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>创建出来的对象：<br><img src="/instance.png" alt="instance.png"></p>
<h4 id="setInitializers和排序"><a href="#setInitializers和排序" class="headerlink" title="setInitializers和排序"></a>setInitializers和排序</h4><p>回到getSpringFactoriesInstances，返回的map类型的result放到LinkedHashSet里边：<br>Set<String> names &#x3D; new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));<br>接下来是  List<T> instances &#x3D; createSpringFactoriesInstances(type, parameterTypes,classLoader, args, names);<br>创建工厂的实例。<br>AnnotationAwareOrderComparator.sort(instances);是进行排序，然后这个方法就返回了。</p>
<p>回到了SpringApplication的构造器，执行到了：<br>setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));<br>setInitializers的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void setInitializers(</span><br><span class="line">    Collection&lt;? extends ApplicationContextInitializer&lt;?&gt;&gt; initializers) &#123;</span><br><span class="line">  this.initializers = new ArrayList&lt;&gt;();</span><br><span class="line">  this.initializers.addAll(initializers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只是添加到集合当中。</p>
<p>注意：【setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));】和<br>【setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));】的执行流程是一模一样的。</p>
<h4 id="ApplicationListener"><a href="#ApplicationListener" class="headerlink" title="ApplicationListener"></a>ApplicationListener</h4><p>org.springframework.context @FunctionalInterface<br>public interface ApplicationListener<E extends ApplicationEvent><br>extends EventListener<br>Interface to be implemented by application event listeners. Based on the standard java.util.EventListener interface for the Observer design pattern.<br>As of Spring 3.0, an ApplicationListener can generically declare the event type that it is interested in. When registered with a Spring ApplicationContext, events will be filtered accordingly, with the listener getting invoked for matching event objects only.<br>一个用来被应用事件监听实现的接口，基于标准的java.util.EventListener接口，是一种观察者模式。<br>在Spring 3.0版本，一个应用监听器可以声明一个它感兴趣的事件类型，当注册到spring的应用上下文里边，事件将相应的过滤，当注册的事件发生的时候，监听器就会被触发。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ApplicationListener是一个函数式接口</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Handle an application event.</span><br><span class="line">	 * @param event the event to respond to</span><br><span class="line">	 */</span><br><span class="line">	void onApplicationEvent(E event);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它最终初始化的所有监听器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0 = &#123;BackgroundPreinitializer@1931&#125;</span><br><span class="line">1 = &#123;ClearCachesApplicationListener@1966&#125;</span><br><span class="line">2 = &#123;ParentContextCloserApplicationListener@1967&#125;</span><br><span class="line">3 = &#123;FileEncodingApplicationListener@1968&#125;</span><br><span class="line">4 = &#123;AnsiOutputApplicationListener@1969&#125;</span><br><span class="line">5 = &#123;ConfigFileApplicationListener@1970&#125;</span><br><span class="line">6 = &#123;DelegatingApplicationListener@1971&#125;</span><br><span class="line">7 = &#123;ClasspathLoggingApplicationListener@1972&#125;</span><br><span class="line">8 = &#123;LoggingApplicationListener@1973&#125;</span><br><span class="line">9 = &#123;LiquibaseServiceLocatorApplicationListener@1974&#125;</span><br></pre></td></tr></table></figure>

<h4 id="主应用类获取deduceMainApplicationClass"><a href="#主应用类获取deduceMainApplicationClass" class="headerlink" title="主应用类获取deduceMainApplicationClass"></a>主应用类获取deduceMainApplicationClass</h4><p>SpringApplication的SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;… primarySources) 方法最后一行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.mainApplicationClass = deduceMainApplicationClass();</span><br></pre></td></tr></table></figure>
<p>即获取主应用类的逻辑，我们进去看一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private Class&lt;?&gt; deduceMainApplicationClass() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    StackTraceElement[] stackTrace = new RuntimeException().getStackTrace();</span><br><span class="line">    for (StackTraceElement stackTraceElement : stackTrace) &#123;</span><br><span class="line">      if (&quot;main&quot;.equals(stackTraceElement.getMethodName())) &#123;</span><br><span class="line">        return Class.forName(stackTraceElement.getClassName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  catch (ClassNotFoundException ex) &#123;</span><br><span class="line">    // Swallow and continue</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br></pre></td></tr></table></figure>
<p>这种获取主应用类的凡是非常讨巧，首先new一个运行时异常，同时得到它的堆栈信息，然后遍历堆栈信息，当某一条的堆栈信息调用的方式是main方法的时候，得到main方法所在的类就是主应用类。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>到目前为止SpringApplication的【public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;… primarySources)】方法已经分析完毕，返回到上一层的逻辑：<br>SpringApplication(primarySources).run(args);<br>接下来会分析run方法的执行逻辑，，run方法逻辑分析完毕整个spring boot的启动流程也就完毕了。</p>
<h3 id="SpringApplication的run方法源码分析"><a href="#SpringApplication的run方法源码分析" class="headerlink" title="SpringApplication的run方法源码分析"></a>SpringApplication的run方法源码分析</h3><p>run方法逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">运行spring应用，创建并且刷新一个新的ApplicationContext</span><br><span class="line">args：main方法的参数</span><br><span class="line">*/</span><br><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">  //计时器</span><br><span class="line">  StopWatch stopWatch = new StopWatch();</span><br><span class="line">  //记录开始时间</span><br><span class="line">  stopWatch.start();</span><br><span class="line">  //配置上下文</span><br><span class="line">  ConfigurableApplicationContext context = null;</span><br><span class="line">  //异常构造器集合</span><br><span class="line">  Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();</span><br><span class="line">  //是一个服务器端应用</span><br><span class="line">  configureHeadlessProperty();</span><br><span class="line">  //加载所有SpringApplicationRunListener监听器</span><br><span class="line">  SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">  //启动所有监听器，发布Application启动事件。</span><br><span class="line">  listeners.starting();</span><br><span class="line">  try &#123;</span><br><span class="line">    //将参数封装为ApplicationArguments</span><br><span class="line">    ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);</span><br><span class="line">    //环境的准备</span><br><span class="line">    ConfigurableEnvironment environment = prepareEnvironment(listeners,applicationArguments);</span><br><span class="line">    //配置忽略的bean信息</span><br><span class="line">    configureIgnoreBeanInfo(environment);</span><br><span class="line">    //打印banner</span><br><span class="line">    Banner printedBanner = printBanner(environment);</span><br><span class="line">    //根据应用类型实例化上下文</span><br><span class="line">    context = createApplicationContext();</span><br><span class="line">    //之前介绍过的，加载接口的所有实现，context是它的实现类构造器的参数，这里会加载出一个异常报告器</span><br><span class="line">    exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line">        new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">    //准备上下文</span><br><span class="line">    prepareContext(context, environment, listeners, applicationArguments,printedBanner);</span><br><span class="line">    refreshContext(context);</span><br><span class="line">    afterRefresh(context, applicationArguments);</span><br><span class="line">    stopWatch.stop();</span><br><span class="line">    if (this.logStartupInfo) &#123;</span><br><span class="line">      new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">    &#125;</span><br><span class="line">    listeners.started(context);</span><br><span class="line">    callRunners(context, applicationArguments);</span><br><span class="line">  &#125;</span><br><span class="line">  catch (Throwable ex) &#123;</span><br><span class="line">    handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">    throw new IllegalStateException(ex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    listeners.running(context);</span><br><span class="line">  &#125;</span><br><span class="line">  catch (Throwable ex) &#123;</span><br><span class="line">    handleRunFailure(context, ex, exceptionReporters, null);</span><br><span class="line">    throw new IllegalStateException(ex);</span><br><span class="line">  &#125;</span><br><span class="line">  return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="StopWatch"><a href="#StopWatch" class="headerlink" title="StopWatch"></a>StopWatch</h4><p>看一下它的doc<br>Simple stop watch, allowing for timing of a number of tasks, exposing total running time and running time for each named task.<br>Conceals use of System.currentTimeMillis(), improving the readability of application code and reducing the likelihood of calculation errors.<br>Note that this object is not designed to be thread-safe and does not use synchronization.<br>This class is normally used to verify performance during proof-of-concepts and in development, rather than as part of production applications.<br>Since:<br>May 2, 2001</p>
<p>这个类的作者是Rod Johnson在20015月2号写的，时间飞逝，现在已经是2019年了，18年过去了，我也写了快5年的代码了，希望每个人技术爱好者能够坚持自己的初衷，也希望你们早日找到女朋友，闲言少叙看一下StopWatch的介绍。</p>
<p>一个简单的计数器，它支持一些列任务的计时工作，公开总的运行时间，还有具名任务的时间。<br>可以不去让我们使用 System.currentTimeMillis()得到系统时间，目的是为了应用代码的可读性以及可能的计算错误。</p>
<p>注意和这个对象没有设计为线程安全的，不能用于同步。<br>这个类通常用于在 proof-of-concepts阶段验证性能，并不是产品应用的一部分。<br>这里就用于统计我们应用的启动时间。</p>
<p>它的内部有一个private final List<TaskInfo> taskList &#x3D; new LinkedList&lt;&gt;(); 因为可以用于多个任务的统计工作。</p>
<h4 id="ConfigurableApplicationContext"><a href="#ConfigurableApplicationContext" class="headerlink" title="ConfigurableApplicationContext"></a>ConfigurableApplicationContext</h4><h5 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h5><p>ConfigurableApplicationContext继承了ApplicationContext，我们现在看到的应用启动过程都是围绕ApplicationContext进行的，有必要看一下ApplicationContext的doc：</p>
<p>org.springframework.context public interface ApplicationContext<br>extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver</p>
<p>Central interface to provide configuration for an application. This is read-only while the application is running, but may be reloaded if the implementation supports this.<br>An ApplicationContext provides:</p>
<ul>
<li>Bean factory methods for accessing application components. Inherited from ListableBeanFactory.</li>
<li>The ability to load file resources in a generic fashion. Inherited from the org.springframework.core.io.ResourceLoader interface.</li>
<li>The ability to publish events to registered listeners. Inherited from the ApplicationEventPublisher interface.</li>
<li>The ability to resolve messages, supporting internationalization. Inherited from the MessageSource interface.</li>
<li>Inheritance from a parent context. Definitions in a descendant context will always take priority. This means, for example, that a single parent context can be used by an entire web application, while each servlet has its own child context that is independent of that of any other servlet.</li>
</ul>
<p>In addition to standard org.springframework.beans.factory.BeanFactory lifecycle capabilities, ApplicationContext implementations detect and invoke ApplicationContextAware beans as well as ResourceLoaderAware, ApplicationEventPublisherAware and MessageSourceAware beans.<br>See Also:<br>ConfigurableApplicationContext,<br>org.springframework.beans.factory.BeanFactory,<br> org.springframework.core.io.ResourceLoader</p>
<p>一个用于提供应用配置的中心接口，当应用运行的时候是只读的，但是如果他的实现支持刷新，它也是会被刷新的。<br>一个应用上下文提供如下：</p>
<ul>
<li>bean工厂的方法，用于访问应用的组件，来自于ListableBeanFactory。</li>
<li>以一种通用的风格加载文件资源的能力，从org.springframework.core.io.ResourceLoader接口沿袭下来的能力</li>
<li>向注册的监听器发布事件的能力，来自于ApplicationEventPublisher接口</li>
<li>解析消息的能力，支持国际化，来自于MessageSource接口</li>
<li>可以从父的上下文继承能力，定义的后代的上下文拥有更高的优先级，这意味着，比如，一个单例的父上下文，可以被整个web应用使用，这样每个servlet的和其他的都是独立的。</li>
</ul>
<h4 id="ConfigurableApplicationContext-1"><a href="#ConfigurableApplicationContext-1" class="headerlink" title="ConfigurableApplicationContext"></a>ConfigurableApplicationContext</h4><p>org.springframework.context public interface ConfigurableApplicationContext<br>extends ApplicationContext, Lifecycle, Closeable<br>SPI interface to be implemented by most if not all application contexts. Provides facilities to configure an application context in addition to the application context client methods in the ApplicationContext interface.<br>Configuration and lifecycle methods are encapsulated here to avoid making them obvious to ApplicationContext client code. The present methods should only be used by startup and shutdown code.</p>
<p>被大部分，但不是全部的应用上下文实现的spi接口，在ApplicationContext接口的基础上通过附加的应用上下文客户端方法的形式提供了一些配置应用上下文的基础设施。<br>配置与生命周期方法被封装在这里，以避免显式的公开给客户端代码，只能被启动和关闭代码使用。</p>
<h4 id="SpringBootExceptionReporter"><a href="#SpringBootExceptionReporter" class="headerlink" title="SpringBootExceptionReporter"></a>SpringBootExceptionReporter</h4><p>SpringBootExceptionReporter是一个函数式接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">Callback interface used to support custom reporting of SpringApplication startup errors. reporters are loaded via the SpringFactoriesLoader and must declare a public constructor with a single ConfigurableApplicationContext parameter.</span><br><span class="line">用来支持对于SpringApplication启动错误的自定义的报告的回调接口，reporters是通过SpringFactoriesLoader加载的，并且声明一个public的带有ConfigurableApplicationContext类型的参数的构造器。</span><br><span class="line">*/</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface SpringBootExceptionReporter &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Report a startup failure to the user.</span><br><span class="line">	 * @param failure the source failure 失败的源</span><br><span class="line">	 * @return &#123;@code true&#125; if the failure was reported or &#123;@code false&#125; if default</span><br><span class="line">	 * reporting should occur.</span><br><span class="line">   报告一个启动失败，</span><br><span class="line">	 */</span><br><span class="line">	boolean reportException(Throwable failure);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它有唯一一个实现类FailureAnalyzers，构造器如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FailureAnalyzers(ConfigurableApplicationContext context, ClassLoader classLoader) &#123;</span><br><span class="line">  Assert.notNull(context, &quot;Context must not be null&quot;);</span><br><span class="line">  this.classLoader = (classLoader != null) ? classLoader : context.getClassLoader();</span><br><span class="line">  this.analyzers = loadFailureAnalyzers(this.classLoader);</span><br><span class="line">  prepareFailureAnalyzers(this.analyzers, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="configureHeadlessProperty-方法"><a href="#configureHeadlessProperty-方法" class="headerlink" title="configureHeadlessProperty()方法"></a>configureHeadlessProperty()方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static final String SYSTEM_PROPERTY_JAVA_AWT_HEADLESS = &quot;java.awt.headless&quot;;</span><br><span class="line">private boolean headless = true;</span><br><span class="line">private void configureHeadlessProperty() &#123;</span><br><span class="line">  System.setProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, System.getProperty(</span><br><span class="line">      SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, Boolean.toString(this.headless)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SYSTEM_PROPERTY_JAVA_AWT_HEADLESS属性表达意图：这是一个服务器应用，没有显示器，没有键盘，没有鼠标的应用。</p>
<h4 id="getRunListeners-方法以及监听器模式的经典应用"><a href="#getRunListeners-方法以及监听器模式的经典应用" class="headerlink" title="getRunListeners()方法以及监听器模式的经典应用"></a>getRunListeners()方法以及监听器模式的经典应用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private SpringApplicationRunListeners getRunListeners(String[] args) &#123;</span><br><span class="line">  // SpringApplicationRunListener的构造器需要2个参数：SpringApplication和string数组。</span><br><span class="line">  Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">  return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances(</span><br><span class="line">      SpringApplicationRunListener.class, types, this, args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后返回的是SpringApplicationRunListeners，SpringApplicationRunListeners里边有一个集合【	private final List<SpringApplicationRunListener> listeners;】<br>因为有必要看那一下 SpringApplicationRunListener的doc</p>
<h5 id="SpringApplicationRunListener类"><a href="#SpringApplicationRunListener类" class="headerlink" title="SpringApplicationRunListener类"></a>SpringApplicationRunListener类</h5><p>org.springframework.boot public interface SpringApplicationRunListener<br>Listener for the SpringApplication run method. SpringApplicationRunListeners are loaded via the SpringFactoriesLoader and should declare a public constructor that accepts a SpringApplication instance and a String[] of arguments. A new SpringApplicationRunListener instance will be created for each run.</p>
<p>针对SpringApplication run方法的监听器，SpringApplicationRunListeners通过SpringFactoriesLoader加载的，而且声明一个public的构造器，并且接受一个SpringApplication类型的参数，和一个string类型的数组(这也是为什么上面介绍的getRunListeners方法携带【Class<?>[] types = new Class<?>[] { SpringApplication.class, String[].class };】参数的原因，SpringApplicationRunListener实例将会针对于运行一个新的SpringApplication的run被创建。<br>主要是对run方法的监听的作用。观察者模式的体现。<br>由于是一个监听器，它的方法接口都体现了声明周期的,SpringApplicationRunListener方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//ApplicationContext已经被加载，但是它还没有被刷新之前调用</span><br><span class="line">contextLoaded</span><br><span class="line">//ApplicationContext已经创建和准备好了，但是资源还没有被加载</span><br><span class="line">contextPrepared</span><br><span class="line">//环境准备完毕，但是ApplicationContext被创建之前调用</span><br><span class="line">environmentPrepared</span><br><span class="line">//应用启动失败的时候被调用</span><br><span class="line">failed</span><br><span class="line">//run方法已经完成，应用上下文已经被刷新，并且CommandLineRunners和ApplicationRunner也已经被调用，running才会被调用。</span><br><span class="line">running</span><br><span class="line">//ApplicationContext已经被刷新，应用也已经启动，但是CommandLineRunners和ApplicationRunner还没有被调用</span><br><span class="line">started</span><br><span class="line">//run方法已开始启动的时候就会被调用，常常用于非常早期的工作。</span><br><span class="line">starting</span><br></pre></td></tr></table></figure>

<h5 id="SpringApplicationRunListeners"><a href="#SpringApplicationRunListeners" class="headerlink" title="SpringApplicationRunListeners"></a>SpringApplicationRunListeners</h5><p>代码结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private final List&lt;SpringApplicationRunListener&gt; listeners;</span><br><span class="line"></span><br><span class="line">SpringApplicationRunListeners(Log log,</span><br><span class="line">    Collection&lt;? extends SpringApplicationRunListener&gt; listeners) &#123;</span><br><span class="line">  this.log = log;</span><br><span class="line">  this.listeners = new ArrayList&lt;&gt;(listeners);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其他的方法：</span><br><span class="line">callFailedListener</span><br><span class="line">contextLoaded</span><br><span class="line">contextPrepared</span><br><span class="line">environmentPrepared</span><br><span class="line">failed</span><br><span class="line">running</span><br><span class="line">started</span><br><span class="line">starting</span><br></pre></td></tr></table></figure>
<p>这些方法和SpringApplicationRunListener方法是一致的，SpringApplicationRunListeners对所有的SpringApplicationRunListener统一管理。</p>
<h5 id="EventPublishingRunListener"><a href="#EventPublishingRunListener" class="headerlink" title="EventPublishingRunListener"></a>EventPublishingRunListener</h5><p>我们断点一下看一下有几个监听器：<br><img src="/EventPublishingRunListener.png" alt="EventPublishingRunListener.png"><br>通过断点可以看到只有一个EventPublishingRunListener，用于发布SpringApplicationEvent，通过ApplicationEventMulticaster在上下文发布之前发布事件。</p>
<p>EventPublishingRunListener构造器如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private final SpringApplication application;</span><br><span class="line"></span><br><span class="line">private final String[] args;</span><br><span class="line"></span><br><span class="line">private final SimpleApplicationEventMulticaster initialMulticaster;</span><br><span class="line"></span><br><span class="line">public EventPublishingRunListener(SpringApplication application, String[] args) &#123;</span><br><span class="line">  this.application = application;</span><br><span class="line">  this.args = args;</span><br><span class="line">  this.initialMulticaster = new SimpleApplicationEventMulticaster();</span><br><span class="line">  for (ApplicationListener&lt;?&gt; listener : application.getListeners()) &#123;</span><br><span class="line">    this.initialMulticaster.addApplicationListener(listener);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="SimpleApplicationEventMulticaster"><a href="#SimpleApplicationEventMulticaster" class="headerlink" title="SimpleApplicationEventMulticaster"></a>SimpleApplicationEventMulticaster</h6><p>构造器里边初始化了一个SimpleApplicationEventMulticaster，看一下介绍：<br>org.springframework.context.event public class SimpleApplicationEventMulticaster<br>extends AbstractApplicationEventMulticaster<br>Simple implementation of the ApplicationEventMulticaster interface.<br>Multicasts all events to all registered listeners, leaving it up to the listeners to ignore events that they are not interested in. Listeners will usually perform corresponding instanceof checks on the passed-in event object.<br>By default, all listeners are invoked in the calling thread. This allows the danger of a rogue listener blocking the entire application, but adds minimal overhead. Specify an alternative task executor to have listeners executed in different threads, for example from a thread pool.<br>ApplicationEventMulticaster接口的简单实现。<br>广播所有的事件给所有注册的监听器，对于不感兴趣的事件的过滤的决定权留给每个监听器自己去处理。监听器对于传递过来的时间对象通常会进行instanceof检查，默认情况，所有的监听器都会在被调用的线程去执行，这样就会存在一种危险，某一些监听器会阻塞整个的应用，但确是最小的成本，用一个替代的任务执行器拥有这个监听器，这样在不同的线程去执行，比如在线程池里边。</p>
<p>看一下EventPublishingRunListener的starting方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void starting() &#123;</span><br><span class="line">  this.initialMulticaster.multicastEvent(</span><br><span class="line">      new ApplicationStartingEvent(this.application, this.args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里冒出来一个ApplicationStartingEvent。</p>
<h6 id="ApplicationStartingEvent"><a href="#ApplicationStartingEvent" class="headerlink" title="ApplicationStartingEvent"></a>ApplicationStartingEvent</h6><p>org.springframework.boot.context.event public class ApplicationStartingEvent<br>extends SpringApplicationEvent<br>Event published as early as conceivably possible as soon as a SpringApplication has been started - before the Environment or ApplicationContext is available, but after the ApplicationListeners have been registered. The source of the event is the SpringApplication itself, but beware of using its internal state too much at this early stage since it might be modified later in the lifecycle.</p>
<p>当spring应用已经启动的时候尽早的把事件发布出去，并且在Environment或者ApplicationContext可用之前，但是在ApplicationListeners已经被注册之后，时间的源是SpringApplication本身，但是请注意使用它的内部状态太多的话，会对后续的生命周期有一些影响。<br>它的父类是SpringApplicationEvent，父类的实现类有如下事件：<br>ApplicationContextInitializedEvent<br>ApplicationEnvironmentPreparedEvent<br>ApplicationFailedEvent<br>ApplicationPreparedEvent<br>ApplicationReadyEvent<br>ApplicationStartedEvent<br>ApplicationStartingEvent<br>诠释了Application的生命周期。</p>
<h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>应用在启动的时候，会在某一些时间点发布一些事件，发对对象是所有注册的事件监听器，事件监听器自己决定是否感兴趣和处理这个事件，这是一种监听器设计模式的体现，监听器都有一个源，就是监听器的主题，源是Application本身，SpringApplicationRunListeners在不同的时间点发布不同的事件对象。</p>
<h4 id="environment组件的重要作用详解"><a href="#environment组件的重要作用详解" class="headerlink" title="environment组件的重要作用详解"></a>environment组件的重要作用详解</h4><h5 id="Environment-doc解读"><a href="#Environment-doc解读" class="headerlink" title="Environment doc解读"></a>Environment doc解读</h5><p>我们走到了【ConfigurableEnvironment environment &#x3D; prepareEnvironment(listeners,applicationArguments);】这行代码，首先理解下ConfigurableEnvironment,它的父类是Environment，看下Environment的doc：</p>
<p>org.springframework.core.env<br>public interface Environment extends PropertyResolver</p>
<p>Interface representing the environment in which the current application is running. Models two key aspects of the application environment: profiles and properties. Methods related to property access are exposed via the PropertyResolver superinterface.<br>A profile is a named, logical group of bean definitions to be registered with the container only if the given profile is active. Beans may be assigned to a profile whether defined in XML or via annotations; see the spring-beans 3.1 schema or the <code>@Profile</code> annotation for syntax details. The role of the Environment object with relation to profiles is in determining which profiles (if any) are currently active, and which profiles (if any) should be active by default.<br>Properties play an important role in almost all applications, and may originate from a variety of sources: properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc Properties objects, Maps, and so on. The role of the environment object with relation to properties is to provide the user with a convenient service interface for configuring property sources and resolving properties from them.<br>Beans managed within an ApplicationContext may register to be EnvironmentAware or <code>@Inject</code> the Environment in order to query profile state or resolve properties directly.<br>In most cases, however, application-level beans should not need to interact with the Environment directly but instead may have to have ${…} property values replaced by a property placeholder configurer such as PropertySourcesPlaceholderConfigurer, which itself is EnvironmentAware and as of Spring 3.1 is registered by default when using <span class="exturl" data-url="Y29udGV4dDpwcm9wZXJ0eS1wbGFjZWhvbGRlci8=">context:property-placeholder/<i class="fa fa-external-link-alt"></i></span>.<br>Configuration of the environment object must be done through the ConfigurableEnvironment interface, returned from all AbstractApplicationContext subclass getEnvironment() methods. See ConfigurableEnvironment Javadoc for usage examples demonstrating manipulation of property sources prior to application context refresh().</p>
<p>代表了一种当前应用正在运行的环境，有两个很重要应用环境的方面：prifile和properties,访问属性的方法通过PropertyResolver父接口提供。<br>profile是被具名的，逻辑的bean的分组，当给定的profile是活动的状态时，这些bean定义会被被注册到容器当中，bean无论是xml定义或者annotation的形式，bean会被关联一个profile，请看 spring-beans 3.1的schema了解Profile注解的语法详情，环境的角色用来决定它关联的profiles，那些profile当前是活动的，并且这些profiles默认情况下是活动的。<br>在大多数的应用中，Properties扮演了一个重要的角色，它可能来自各种各样的来源，比如属性文件，jvm的系统属性，系统环境变量，jndi，servlet山下文参数，及时变更的属性对象，map，等等，关联属性的environment对象的这种角色，为用户提供了方便的属性配置属性解析的接口服务。<br>ApplicationContext里边注册的这些bean可以是EnvironmentAware或者是 <code>@Inject</code>的，这些可以用来查询profile状态和属性解析。<br>在大多数的情况下，应用级别的bean不需要直接和Environment交互，但是可以用一种 ${…}这种形式的占位符配置器的方式去配置，比如PropertySourcesPlaceholderConfigurer，他自己本身就是环境组件，在Spring 3.1当中，通过使用<span class="exturl" data-url="Y29udGV4dDpwcm9wZXJ0eS1wbGFjZWhvbGRlci8=">context:property-placeholder/<i class="fa fa-external-link-alt"></i></span>进行注册。<br>环境对象的配置必须通过ConfigurableEnvironment接口，从AbstractApplicationContext所有子类的getEnvironment方法返回。</p>
<h5 id="ConfigurableEnvironment-doc解读"><a href="#ConfigurableEnvironment-doc解读" class="headerlink" title="ConfigurableEnvironment doc解读"></a>ConfigurableEnvironment doc解读</h5><p>接下来是ConfigurableEnvironment，也就是Environment的子类，看一下doc：<br>org.springframework.core.env public interface ConfigurableEnvironment extends Environment, ConfigurablePropertyResolver</p>
<p>Configuration interface to be implemented by most if not all Environment types. Provides facilities for setting active and default profiles and manipulating underlying property sources. Allows clients to set and validate required properties, customize the conversion service and more through the ConfigurablePropertyResolver superinterface.<br>Manipulating property sources<br>Property sources may be removed, reordered, or replaced; and additional property sources may be added using the MutablePropertySources instance returned from getPropertySources(). The following examples are against the StandardEnvironment implementation of ConfigurableEnvironment, but are generally applicable to any implementation, though particular default property sources may differ.<br>Example: adding a new property source with highest search priority<br>   ConfigurableEnvironment environment &#x3D; new StandardEnvironment();<br>   MutablePropertySources propertySources &#x3D; environment.getPropertySources();<br>   Map&lt;String, String&gt; myMap &#x3D; new HashMap&lt;&gt;();<br>   myMap.put(“xyz”, “myValue”);<br>   propertySources.addFirst(new MapPropertySource(“MY_MAP”, myMap));</p>
<p>Example: removing the default system properties property source<br>   MutablePropertySources propertySources &#x3D; environment.getPropertySources();<br>   propertySources.remove(StandardEnvironment.SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME)</p>
<p>Example: mocking the system environment for testing purposes<br>   MutablePropertySources propertySources &#x3D; environment.getPropertySources();<br>   MockPropertySource mockEnvVars &#x3D; new MockPropertySource().withProperty(“xyz”, “myValue”);<br>   propertySources.replace(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, mockEnvVars);</p>
<p>When an Environment is being used by an ApplicationContext, it is important that any such PropertySource manipulations be performed before the context’s refresh() method is called. This ensures that all property sources are available during the container bootstrap process, including use by property placeholder configurers.<br>一个不是被所有也是被大多数Environment类型所实现的配置接口，提供了设置活动的默认的profiles，以及操作底层的属性元的基础设施，允许客户端设置和验证所要求的属性，定制转换服务，都是通过ConfigurablePropertyResolver这样的一个父接口进行的。<br>如何操纵属性源？<br>属性源可以被删除，重排序也可以被替换，并且额外的属性来源可以通过MutablePropertySources进行添加，通过getPropertySources方法进行获取，接下来的举例针对于ConfigurableEnvironment的标准环境的实现，不过和特定的默认的属性源有点不同。<br>例子：添加了一个高搜索优先级的属性源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableEnvironment environment = new StandardEnvironment();</span><br><span class="line">MutablePropertySources propertySources = environment.getPropertySources();</span><br><span class="line">Map&lt;String, String&gt; myMap = new HashMap&lt;&gt;();</span><br><span class="line">myMap.put(&quot;xyz&quot;, &quot;myValue&quot;);</span><br><span class="line">propertySources.addFirst(new MapPropertySource(&quot;MY_MAP&quot;, myMap));</span><br></pre></td></tr></table></figure>
<p>举例：删除默认系统属性源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MutablePropertySources propertySources = environment.getPropertySources();</span><br><span class="line">propertySources.remove(StandardEnvironment.SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME)</span><br></pre></td></tr></table></figure>
<p>举例：针对测试的目的模拟系统的环境：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MutablePropertySources propertySources = environment.getPropertySources();</span><br><span class="line">MockPropertySource mockEnvVars = new MockPropertySource().withProperty(&quot;xyz&quot;, &quot;myValue&quot;);</span><br><span class="line">propertySources.replace(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, mockEnvVars);</span><br></pre></td></tr></table></figure>
<h5 id="prepareEnvironment方法"><a href="#prepareEnvironment方法" class="headerlink" title="prepareEnvironment方法"></a>prepareEnvironment方法</h5><p>它的逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners,  ApplicationArguments applicationArguments) &#123;</span><br><span class="line">  // Create and configure the environment</span><br><span class="line">  //存在环境就返回，不存在就创建</span><br><span class="line">  ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class="line">  configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line">  listeners.environmentPrepared(environment);</span><br><span class="line">  bindToSpringApplication(environment);</span><br><span class="line">  if (!this.isCustomEnvironment) &#123;</span><br><span class="line">    environment = new EnvironmentConverter(getClassLoader())</span><br><span class="line">        .convertEnvironmentIfNecessary(environment, deduceEnvironmentClass());</span><br><span class="line">  &#125;</span><br><span class="line">  ConfigurationPropertySources.attach(environment);</span><br><span class="line">  return environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="getOrCreateEnvironment-方法"><a href="#getOrCreateEnvironment-方法" class="headerlink" title="getOrCreateEnvironment()方法"></a>getOrCreateEnvironment()方法</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private ConfigurableEnvironment getOrCreateEnvironment() &#123;</span><br><span class="line">  //环境存在就返回</span><br><span class="line">  if (this.environment != null) &#123;</span><br><span class="line">    return this.environment;</span><br><span class="line">  &#125;</span><br><span class="line">  //根据应用类型返回对应应用类型的环境</span><br><span class="line">  switch (this.webApplicationType) &#123;</span><br><span class="line">  case SERVLET:</span><br><span class="line">    return new StandardServletEnvironment();</span><br><span class="line">  case REACTIVE:</span><br><span class="line">    return new StandardReactiveWebEnvironment();</span><br><span class="line">  default:</span><br><span class="line">    return new StandardEnvironment();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="configureEnvironment-方法"><a href="#configureEnvironment-方法" class="headerlink" title="configureEnvironment()方法"></a>configureEnvironment()方法</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected void configureEnvironment(ConfigurableEnvironment environment,</span><br><span class="line">    String[] args) &#123;</span><br><span class="line">  if (this.addConversionService) &#123;</span><br><span class="line">    ConversionService conversionService = ApplicationConversionService</span><br><span class="line">        .getSharedInstance();</span><br><span class="line">    environment.setConversionService(</span><br><span class="line">        (ConfigurableConversionService) conversionService);</span><br><span class="line">  &#125;</span><br><span class="line">  configurePropertySources(environment, args);</span><br><span class="line">  configureProfiles(environment, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConversionService:一个用来进行类型转换的服务接口，装换系统的入口点，调用convert实现线程安全的转换。<br>ApplicationConversionService.getSharedInstance();用的单利模式，而且是线程安全的，这是经典的单利模式的使用，懒汉模式，注意配合volatile关键字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static volatile ApplicationConversionService sharedInstance;</span><br><span class="line">public static ConversionService getSharedInstance() &#123;</span><br><span class="line">  ApplicationConversionService sharedInstance = ApplicationConversionService.sharedInstance;</span><br><span class="line">  if (sharedInstance == null) &#123;</span><br><span class="line">    synchronized (ApplicationConversionService.class) &#123;</span><br><span class="line">      sharedInstance = ApplicationConversionService.sharedInstance;</span><br><span class="line">      if (sharedInstance == null) &#123;</span><br><span class="line">        sharedInstance = new ApplicationConversionService();</span><br><span class="line">        ApplicationConversionService.sharedInstance = sharedInstance;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【configurePropertySources(environment, args);】<br>添加，移除，重排序属性源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">protected void configurePropertySources(ConfigurableEnvironment environment,</span><br><span class="line">    String[] args) &#123;</span><br><span class="line">  MutablePropertySources sources = environment.getPropertySources();</span><br><span class="line">  if (this.defaultProperties != null &amp;&amp; !this.defaultProperties.isEmpty()) &#123;</span><br><span class="line">    sources.addLast(</span><br><span class="line">        new MapPropertySource(&quot;defaultProperties&quot;, this.defaultProperties));</span><br><span class="line">  &#125;</span><br><span class="line">  if (this.addCommandLineProperties &amp;&amp; args.length &gt; 0) &#123;</span><br><span class="line">    String name = CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME;</span><br><span class="line">    if (sources.contains(name)) &#123;</span><br><span class="line">      PropertySource&lt;?&gt; source = sources.get(name);</span><br><span class="line">      CompositePropertySource composite = new CompositePropertySource(name);</span><br><span class="line">      composite.addPropertySource(new SimpleCommandLinePropertySource(</span><br><span class="line">          &quot;springApplicationCommandLineArgs&quot;, args));</span><br><span class="line">      composite.addPropertySource(source);</span><br><span class="line">      sources.replace(name, composite);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      sources.addFirst(new SimpleCommandLinePropertySource(args));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【configureProfiles(environment, args);】<br>针对于整个应用的环境，配置那些profile是活动的或者是默认的，其他额外的profile可以在配置文件处理过程中通过spring.profiles.active属性激活。</p>
<h6 id="listeners-environmentPrepared-environment"><a href="#listeners-environmentPrepared-environment" class="headerlink" title="listeners.environmentPrepared(environment)"></a>listeners.environmentPrepared(environment)</h6><p>触发了一个新的事件——环境准备好的事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void environmentPrepared(ConfigurableEnvironment environment) &#123;</span><br><span class="line">  for (SpringApplicationRunListener listener : this.listeners) &#123;</span><br><span class="line">    listener.environmentPrepared(environment);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Banner"><a href="#Banner" class="headerlink" title="Banner"></a>Banner</h4><p>在进行往下进行之前，我们先对banner做一个实验，我们在resources目录下新建一个banner.txt文件，里边输入一段文字，然后启动应用，会看到打印了我们输入的信息，banner自定义生效：<br><img src="/banner.png" alt="banner.png"><br>Banner是一个函数式接口，里边有一个枚举，用于配置banner的模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">enum Mode &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Disable printing of the banner.</span><br><span class="line">   */</span><br><span class="line">  OFF,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Print the banner to System.out.</span><br><span class="line">   */</span><br><span class="line">  CONSOLE,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Print the banner to the log file.</span><br><span class="line">   */</span><br><span class="line">  LOG</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主流程了printBanner()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private Banner printBanner(ConfigurableEnvironment environment) &#123;</span><br><span class="line">  //默认是CONSOLE</span><br><span class="line">  if (this.bannerMode == Banner.Mode.OFF) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  //获取资源加载器</span><br><span class="line">  ResourceLoader resourceLoader = (this.resourceLoader != null)</span><br><span class="line">      ? this.resourceLoader : new DefaultResourceLoader(getClassLoader());</span><br><span class="line">  SpringApplicationBannerPrinter bannerPrinter = new SpringApplicationBannerPrinter(</span><br><span class="line">      resourceLoader, this.banner);</span><br><span class="line">  //当前程序不会走这个if</span><br><span class="line">  if (this.bannerMode == Mode.LOG) &#123;</span><br><span class="line">    return bannerPrinter.print(environment, this.mainApplicationClass, logger);</span><br><span class="line">  &#125;</span><br><span class="line">  //当前程序会执行这个</span><br><span class="line">  return bannerPrinter.print(environment, this.mainApplicationClass, System.out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="SpringApplicationBannerPrinter"><a href="#SpringApplicationBannerPrinter" class="headerlink" title="SpringApplicationBannerPrinter"></a>SpringApplicationBannerPrinter</h5><p>用来打印application的banner，其内部有一个成员变量【static final String DEFAULT_BANNER_LOCATION &#x3D; “banner.txt”;】<br>即默认的banner文件。<br>构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SpringApplicationBannerPrinter(ResourceLoader resourceLoader, Banner fallbackBanner) &#123;</span><br><span class="line">  //资源加载器，可能要使用resourceLoader加载banner文件</span><br><span class="line">  this.resourceLoader = resourceLoader;</span><br><span class="line">  //回退banner</span><br><span class="line">  this.fallbackBanner = fallbackBanner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下SpringApplicationBannerPrinter的print方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Banner print(Environment environment, Class&lt;?&gt; sourceClass, PrintStream out) &#123;</span><br><span class="line">  //获取banner</span><br><span class="line">  Banner banner = getBanner(environment);</span><br><span class="line">  //打印banner</span><br><span class="line">  banner.printBanner(environment, sourceClass, out);</span><br><span class="line">  return new PrintedBanner(banner, sourceClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getBanner根据环境得到banner。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private Banner getBanner(Environment environment) &#123;</span><br><span class="line">  Banners banners = new Banners();</span><br><span class="line">  //图像banner存在就会加载</span><br><span class="line">  banners.addIfNotNull(getImageBanner(environment));</span><br><span class="line">  //文字banner存在就会加载</span><br><span class="line">  banners.addIfNotNull(getTextBanner(environment));</span><br><span class="line">  if (banners.hasAtLeastOneBanner()) &#123;</span><br><span class="line">    return banners;</span><br><span class="line">  &#125;</span><br><span class="line">  if (this.fallbackBanner != null) &#123;</span><br><span class="line">    return this.fallbackBanner;</span><br><span class="line">  &#125;</span><br><span class="line">  //没有找到banner就会使用spring默认的banner（SpringBootBanner）</span><br><span class="line">  return DEFAULT_BANNER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中看一下getTextBanner():</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static final String DEFAULT_BANNER_LOCATION = &quot;banner.txt&quot;;</span><br><span class="line">private Banner getTextBanner(Environment environment) &#123;</span><br><span class="line">  String location = environment.getProperty(BANNER_LOCATION_PROPERTY,</span><br><span class="line">      DEFAULT_BANNER_LOCATION);</span><br><span class="line">  Resource resource = this.resourceLoader.getResource(location);</span><br><span class="line">  //如果文件banner.txt存在就会加载这个资源。</span><br><span class="line">  if (resource.exists()) &#123;</span><br><span class="line">    return new ResourceBanner(resource);</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们看一下SpringBootBanner的printBanner()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private static final String[] BANNER = &#123; &quot;&quot;,</span><br><span class="line">    &quot;  .   ____          _            __ _ _&quot;,</span><br><span class="line">    &quot; /\\\\ / ___&#x27;_ __ _ _(_)_ __  __ _ \\ \\ \\ \\&quot;,</span><br><span class="line">    &quot;( ( )\\___ | &#x27;_ | &#x27;_| | &#x27;_ \\/ _` | \\ \\ \\ \\&quot;,</span><br><span class="line">    &quot; \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )&quot;,</span><br><span class="line">    &quot;  &#x27;  |____| .__|_| |_|_| |_\\__, | / / / /&quot;,</span><br><span class="line">    &quot; =========|_|==============|___/=/_/_/_/&quot; &#125;;</span><br><span class="line">public void printBanner(Environment environment, Class&lt;?&gt; sourceClass,PrintStream printStream) &#123;</span><br><span class="line">  for (String line : BANNER) &#123;</span><br><span class="line">    printStream.println(line);</span><br><span class="line">  &#125;</span><br><span class="line">  String version = SpringBootVersion.getVersion();</span><br><span class="line">  version = (version != null) ? &quot; (v&quot; + version + &quot;)&quot; : &quot;&quot;;</span><br><span class="line">  StringBuilder padding = new StringBuilder();</span><br><span class="line">  while (padding.length() &lt; STRAP_LINE_SIZE</span><br><span class="line">      - (version.length() + SPRING_BOOT.length())) &#123;</span><br><span class="line">    padding.append(&quot; &quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printStream.println(AnsiOutput.toString(AnsiColor.GREEN, SPRING_BOOT,</span><br><span class="line">      AnsiColor.DEFAULT, padding.toString(), AnsiStyle.FAINT, version));</span><br><span class="line">  printStream.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到之前我们没有配置banner.txt的时候打印就是这个”spring”输出，即输出了BANNER数组。</p>
<h4 id="createApplicationContext-方法"><a href="#createApplicationContext-方法" class="headerlink" title="createApplicationContext()方法"></a>createApplicationContext()方法</h4><p>一个用来创建上下文的策略方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">protected ConfigurableApplicationContext createApplicationContext() &#123;</span><br><span class="line">  //applicationContextClass默认是空的</span><br><span class="line">  Class&lt;?&gt; contextClass = this.applicationContextClass;</span><br><span class="line">  if (contextClass == null) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      switch (this.webApplicationType) &#123;</span><br><span class="line">        //我们的应用是SERVLET</span><br><span class="line">      case SERVLET:</span><br><span class="line">      /**</span><br><span class="line">      public static final String DEFAULT_SERVLET_WEB_CONTEXT_CLASS = &quot;org.springframework.boot.&quot;</span><br><span class="line">    			+ &quot;web.servlet.context.AnnotationConfigServletWebServerApplicationContext&quot;;</span><br><span class="line">      **/</span><br><span class="line">        contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line">        break;</span><br><span class="line">      case REACTIVE:</span><br><span class="line">        contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ClassNotFoundException ex) &#123;</span><br><span class="line">      throw new IllegalStateException(</span><br><span class="line">          &quot;Unable create a default ApplicationContext, &quot;</span><br><span class="line">              + &quot;please specify an ApplicationContextClass&quot;,</span><br><span class="line">          ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //通过反射创建contextClass</span><br><span class="line">  return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="prepareContext-context-environment-listeners-applicationArguments-printedBanner-方法"><a href="#prepareContext-context-environment-listeners-applicationArguments-printedBanner-方法" class="headerlink" title="prepareContext(context, environment, listeners, applicationArguments,printedBanner)方法"></a>prepareContext(context, environment, listeners, applicationArguments,printedBanner)方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private void prepareContext(ConfigurableApplicationContext context,</span><br><span class="line">    ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span><br><span class="line">    ApplicationArguments applicationArguments, Banner printedBanner) &#123;</span><br><span class="line">  context.setEnvironment(environment);</span><br><span class="line">  //处理上下文</span><br><span class="line">  postProcessApplicationContext(context);</span><br><span class="line">  applyInitializers(context);</span><br><span class="line">  //触发事件，上下文已经创建和准备完毕，但是资源还没有加载</span><br><span class="line">  listeners.contextPrepared(context);</span><br><span class="line">  if (this.logStartupInfo) &#123;</span><br><span class="line">    logStartupInfo(context.getParent() == null);</span><br><span class="line">    //启动日志的处理</span><br><span class="line">    logStartupProfileInfo(context);</span><br><span class="line">  &#125;</span><br><span class="line">  // Add boot specific singleton beans</span><br><span class="line">  ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">  beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments);</span><br><span class="line">  if (printedBanner != null) &#123;</span><br><span class="line">    beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner);</span><br><span class="line">  &#125;</span><br><span class="line">  if (beanFactory instanceof DefaultListableBeanFactory) &#123;</span><br><span class="line">    ((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">        .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);</span><br><span class="line">  &#125;</span><br><span class="line">  // Load the sources 加载资源</span><br><span class="line">  Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">  Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);</span><br><span class="line">  load(context, sources.toArray(new Object[0]));</span><br><span class="line">  //触发事件，上下文已经被加载，但是还没有被刷新</span><br><span class="line">  listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="refreshContext-刷新上下文"><a href="#refreshContext-刷新上下文" class="headerlink" title="refreshContext()刷新上下文"></a>refreshContext()刷新上下文</h4><p>此方法按照规定的顺序执行， 这个方法做的事情非常多，不会过多介绍， 最终走到AbstractApplicationContext的refresh()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">  synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">    // Prepare this context for refreshing.</span><br><span class="line">    prepareRefresh();</span><br><span class="line"></span><br><span class="line">    // Tell the subclass to refresh the internal bean factory.</span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">    // Prepare the bean factory for use in this context.</span><br><span class="line">    prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      // Allows post-processing of the bean factory in context subclasses.</span><br><span class="line">      postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      // Invoke factory processors registered as beans in the context.</span><br><span class="line">      invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">      // Register bean processors that intercept bean creation.</span><br><span class="line">      registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">      // Initialize message source for this context.</span><br><span class="line">      initMessageSource();</span><br><span class="line"></span><br><span class="line">      // Initialize event multicaster for this context.</span><br><span class="line">      initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">      // Initialize other special beans in specific context subclasses.</span><br><span class="line">      onRefresh();</span><br><span class="line"></span><br><span class="line">      // Check for listener beans and register them.</span><br><span class="line">      registerListeners();</span><br><span class="line"></span><br><span class="line">      // Instantiate all remaining (non-lazy-init) singletons.</span><br><span class="line">      finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">      // Last step: publish corresponding event.</span><br><span class="line">      finishRefresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    catch (BeansException ex) &#123;</span><br><span class="line">      if (logger.isWarnEnabled()) &#123;</span><br><span class="line">        logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">            &quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Destroy already created singletons to avoid dangling resources.</span><br><span class="line">      destroyBeans();</span><br><span class="line"></span><br><span class="line">      // Reset &#x27;active&#x27; flag.</span><br><span class="line">      cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">      // Propagate exception to caller.</span><br><span class="line">      throw ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    finally &#123;</span><br><span class="line">      // Reset common introspection caches in Spring&#x27;s core, since we</span><br><span class="line">      // might not ever need metadata for singleton beans anymore...</span><br><span class="line">      resetCommonCaches();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="afterRefresh-context-applicationArguments-方法"><a href="#afterRefresh-context-applicationArguments-方法" class="headerlink" title="afterRefresh(context, applicationArguments)方法"></a>afterRefresh(context, applicationArguments)方法</h4><p>这个方法没有做任何事情，目的是为了留给子类继承的想象空间的。</p>
<h4 id="stopWatch-stop-秒表计时结束"><a href="#stopWatch-stop-秒表计时结束" class="headerlink" title="stopWatch.stop()秒表计时结束"></a>stopWatch.stop()秒表计时结束</h4><p>不做过多解释。</p>
<h4 id="打印启动信息"><a href="#打印启动信息" class="headerlink" title="打印启动信息"></a>打印启动信息</h4><p><img src="/stopwatch.png" alt="stopwatch.png"></p>
<h4 id="listeners-started-context"><a href="#listeners-started-context" class="headerlink" title="listeners.started(context)"></a>listeners.started(context)</h4><p>触发事件，上下文已经被刷新，应用已经启动，但是命令行运行器和应用运行器还没有被调用</p>
<h4 id="callRunners-方法"><a href="#callRunners-方法" class="headerlink" title="callRunners()方法"></a>callRunners()方法</h4><p>看一下它的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void callRunners(ApplicationContext context, ApplicationArguments args) &#123;</span><br><span class="line">  List&lt;Object&gt; runners = new ArrayList&lt;&gt;();</span><br><span class="line">  runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());</span><br><span class="line">  runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());</span><br><span class="line">  AnnotationAwareOrderComparator.sort(runners);</span><br><span class="line">  for (Object runner : new LinkedHashSet&lt;&gt;(runners)) &#123;</span><br><span class="line">    if (runner instanceof ApplicationRunner) &#123;</span><br><span class="line">      //启动应用运行器</span><br><span class="line">      callRunner((ApplicationRunner) runner, args);</span><br><span class="line">    &#125;</span><br><span class="line">    if (runner instanceof CommandLineRunner) &#123;</span><br><span class="line">      //启动命令行运行器</span><br><span class="line">      callRunner((CommandLineRunner) runner, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ApplicationRunner"><a href="#ApplicationRunner" class="headerlink" title="ApplicationRunner"></a>ApplicationRunner</h5><p>Interface used to indicate that a bean should run when it is contained within a SpringApplication. Multiple ApplicationRunner beans can be defined within the same application context and can be ordered using the Ordered interface or @Order annotation.</p>
<p>用于标示一个bean应该被运行，当它包含在一个SpringApplication当中，一个应用上下文可以有多个ApplicationRunner，可以使用Ordered接口或者<code>@Order</code>直接进行排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface ApplicationRunner &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Callback used to run the bean.</span><br><span class="line">	 * @param args incoming application arguments</span><br><span class="line">	 * @throws Exception on error</span><br><span class="line">	 */</span><br><span class="line">	void run(ApplicationArguments args) throws Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="CommandLineRunner"><a href="#CommandLineRunner" class="headerlink" title="CommandLineRunner"></a>CommandLineRunner</h5><p>Interface used to indicate that a bean should run when it is contained within a SpringApplication. Multiple CommandLineRunner beans can be defined within the same application context and can be ordered using the Ordered interface or @Order annotation.<br>If you need access to ApplicationArguments instead of the raw String array consider using ApplicationRunner.</p>
<p>用于标示一个bean应该被运行，当它包含在一个SpringApplication当中，一个应用上下文可以有多个CommandLineRunner，可以使用Ordered接口或者<code>@Order</code>直接进行排序。<br>如果你想访问ApplicationArguments而不是原生的字符串数组，请使用ApplicationRunner。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface CommandLineRunner &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Callback used to run the bean.</span><br><span class="line">	 * @param args incoming main method arguments</span><br><span class="line">	 * @throws Exception on error</span><br><span class="line">	 */</span><br><span class="line">	void run(String... args) throws Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="listeners-running-context"><a href="#listeners-running-context" class="headerlink" title="listeners.running(context)"></a>listeners.running(context)</h4><p>run方法调用完毕之前立即会被触发和调用，应用上下文已经被刷新，CommandLineRunner和ApplicationRunner已经被调用。</p>
<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>当listeners.running(context)调用完毕之后run也就结束了，run方法返回一个ConfigurableApplicationContext，会返回到我们的main方法,到此应用的启动过程分析完毕。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class MyApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      ConfigurableApplicationContext configurableApplicationContext =   SpringApplication.run(MyApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>Post author:  </strong>CeaserWang
  </li>
  <li class="post-copyright-link">
      <strong>Post link: </strong>
      <a href="https://ceaser.wang/2019/06/30/spring_boot_and_cloud/spring_boot_cloud(5)SpringApplication%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3/" title="spring_boot_cloud(5)SpringApplication源码分析与作用详解">https://ceaser.wang/2019/06/30/spring_boot_and_cloud/spring_boot_cloud(5)SpringApplication源码分析与作用详解/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/SpringBootApplication/" rel="tag"><i class="fa fa-tag"></i> SpringBootApplication</a>
              <a href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="tag"><i class="fa fa-tag"></i> 源码解析</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/06/23/spring_boot_and_cloud/spring_boot_cloud(4)SpringBootApplication%E4%B8%8EConfiguration%E6%B3%A8%E8%A7%A3%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/" rel="prev" title="spring_boot_cloud(4)SpringBootApplication与Configuration注解深度解析">
                  <i class="fa fa-chevron-left"></i> spring_boot_cloud(4)SpringBootApplication与Configuration注解深度解析
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/07/16/elasticsearch/elasticsearch_center/" rel="next" title="elasticsearch_center">
                  elasticsearch_center <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2015 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CeaserWang</span>
</div>
  <div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9tdXNlLw==">NexT.Muse</span>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.1/mermaid.min.js","integrity":"sha256-8L3O8tirFUa8Va4NSTAyIbHJeLd6OnlcxgupV9F77e0="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>

  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>

  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"ryAR9bttS7fex1FPEPAylmmJ-gzGzoHsz","app_key":"dYqygoN4Y01Bl38OdRoCHUYn","server_url":null,"security":false}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>



</body>
</html>
