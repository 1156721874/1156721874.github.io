<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">

<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"ceaser.wang","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.12.1","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="@Value注解的使用方式">
<meta property="og:type" content="article">
<meta property="og:title" content="spring_boot_cloud(13)Value注解与BeanPostProcessor作用与分析">
<meta property="og:url" content="https://ceaser.wang/2019/11/21/spring_boot_and_cloud/spring_boot_cloud(13)Value%E6%B3%A8%E8%A7%A3%E4%B8%8EBeanPostProcessor%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="南贺神社">
<meta property="og:description" content="@Value注解的使用方式">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://ceaser.wang/desc.png">
<meta property="og:image" content="https://ceaser.wang/debug1.png">
<meta property="og:image" content="https://ceaser.wang/debug2.png">
<meta property="og:image" content="https://ceaser.wang/debug3.png">
<meta property="article:published_time" content="2019-11-21T21:14:32.000Z">
<meta property="article:modified_time" content="2023-12-31T02:17:09.806Z">
<meta property="article:author" content="CeaserWang">
<meta property="article:tag" content="Value注解 SpringBoot BeanPostProcessor">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ceaser.wang/desc.png">


<link rel="canonical" href="https://ceaser.wang/2019/11/21/spring_boot_and_cloud/spring_boot_cloud(13)Value%E6%B3%A8%E8%A7%A3%E4%B8%8EBeanPostProcessor%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%88%86%E6%9E%90/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://ceaser.wang/2019/11/21/spring_boot_and_cloud/spring_boot_cloud(13)Value%E6%B3%A8%E8%A7%A3%E4%B8%8EBeanPostProcessor%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%88%86%E6%9E%90/","path":"2019/11/21/spring_boot_and_cloud/spring_boot_cloud(13)Value注解与BeanPostProcessor作用与分析/","title":"spring_boot_cloud(13)Value注解与BeanPostProcessor作用与分析"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>spring_boot_cloud(13)Value注解与BeanPostProcessor作用与分析 | 南贺神社</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">南贺神社</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">你写程序有写诗一样的感觉吗?</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">209</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">26</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">221</span></a></li><li class="menu-item menu-item-0xcc"><a href="/0xcc/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>0XCC</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Value%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text">@Value注解的使用方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanPostProcessor"><span class="nav-number">2.</span> <span class="nav-text">BeanPostProcessor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanFactoryPostProcessor"><span class="nav-number">3.</span> <span class="nav-text">BeanFactoryPostProcessor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AutowiredAnnotationBeanPostProcessor"><span class="nav-number">4.</span> <span class="nav-text">AutowiredAnnotationBeanPostProcessor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Autowired%E6%B3%A8%E8%A7%A3"><span class="nav-number">5.</span> <span class="nav-text">Autowired注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Configuration%E6%B3%A8%E8%A7%A3"><span class="nav-number">6.</span> <span class="nav-text">Configuration注解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8Configuration"><span class="nav-number">6.1.</span> <span class="nav-text">启动Configuration</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-AnnotationConfigApplicationContext"><span class="nav-number">6.1.1.</span> <span class="nav-text">通过 AnnotationConfigApplicationContext</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E8%BF%87Spring-XML%E6%96%B9%E5%BC%8F"><span class="nav-number">6.1.2.</span> <span class="nav-text">通过Spring XML方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E6%89%AB%E6%8F%8F%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">6.1.3.</span> <span class="nav-text">组件扫描的方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A5%E5%A4%96%E9%83%A8%E7%9A%84%E5%80%BC%E5%8E%BB%E5%B7%A5%E4%BD%9C"><span class="nav-number">6.2.</span> <span class="nav-text">以外部的值去工作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">6.2.1.</span> <span class="nav-text">使用环境变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-Value%E6%B3%A8%E8%A7%A3"><span class="nav-number">6.2.2.</span> <span class="nav-text">通过@Value注解</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E5%90%88-Configuration-%E7%B1%BB"><span class="nav-number">6.3.</span> <span class="nav-text">组合 @Configuration 类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Import-%E6%B3%A8%E8%A7%A3"><span class="nav-number">6.3.1.</span> <span class="nav-text">使用 @Import 注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-Profile-%E6%B3%A8%E8%A7%A3"><span class="nav-number">6.3.2.</span> <span class="nav-text">通过@Profile 注解</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%92%8Cspring-xml%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8-ImportResource-%E6%B3%A8%E8%A7%A3"><span class="nav-number">6.4.</span> <span class="nav-text">和spring xml配合使用@ImportResource 注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%B5%8C%E5%A5%97%E7%9A%84-Configuration-%E7%B1%BB"><span class="nav-number">6.5.</span> <span class="nav-text">使用嵌套的 @Configuration 类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AnnotationConfigApplicationContext"><span class="nav-number">7.</span> <span class="nav-text">AnnotationConfigApplicationContext</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AnnotationConfigWebApplicationContext"><span class="nav-number">8.</span> <span class="nav-text">AnnotationConfigWebApplicationContext</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">9.</span> <span class="nav-text">注解解析的流程</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="CeaserWang"
      src="/../0xcc/index/Uchiha.jpg">
  <p class="site-author-name" itemprop="name">CeaserWang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">221</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">209</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzExNTY3MjE4NzQ=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;1156721874"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmNlYXNlcndhbmdAb3V0bG9vay5jb20=" title="E-Mail → mailto:ceaserwang@outlook.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-user-friends fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly90d29kcmFnb25sYWtlLmNvbQ==" title="https:&#x2F;&#x2F;twodragonlake.com">TwoDragonLake</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9yb290Y2x1c3Rlci5naXRodWIuaW8=" title="https:&#x2F;&#x2F;rootcluster.github.io">RootCluster</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9tdXNlZmxvdy5pbw==" title="https:&#x2F;&#x2F;museflow.io">MuseFlow</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9pbmNvZGVyLm9yZw==" title="https:&#x2F;&#x2F;incoder.org">BladeCode</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9rYWlmYS5kZXY=" title="https:&#x2F;&#x2F;kaifa.dev">Alyenc</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmRhemhpZGF5b25nLmNu" title="https:&#x2F;&#x2F;blog.dazhidayong.cn">Killua</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly93d3cuY3lsb25nLmNvbQ==" title="https:&#x2F;&#x2F;www.cylong.com">Cylong</span>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ceaser.wang/2019/11/21/spring_boot_and_cloud/spring_boot_cloud(13)Value%E6%B3%A8%E8%A7%A3%E4%B8%8EBeanPostProcessor%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/../0xcc/index/Uchiha.jpg">
      <meta itemprop="name" content="CeaserWang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南贺神社">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="spring_boot_cloud(13)Value注解与BeanPostProcessor作用与分析 | 南贺神社">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          spring_boot_cloud(13)Value注解与BeanPostProcessor作用与分析
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-11-21 21:14:32" itemprop="dateCreated datePublished" datetime="2019-11-21T21:14:32+00:00">2019-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-12-31 02:17:09" itemprop="dateModified" datetime="2023-12-31T02:17:09+00:00">2023-12-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/spring-boot-cloud/" itemprop="url" rel="index"><span itemprop="name">spring_boot_cloud</span></a>
        </span>
    </span>

  
    <span id="/2019/11/21/spring_boot_and_cloud/spring_boot_cloud(13)Value%E6%B3%A8%E8%A7%A3%E4%B8%8EBeanPostProcessor%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%88%86%E6%9E%90/" class="post-meta-item leancloud_visitors" data-flag-title="spring_boot_cloud(13)Value注解与BeanPostProcessor作用与分析" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h3 id="Value注解的使用方式"><a href="#Value注解的使用方式" class="headerlink" title="@Value注解的使用方式"></a>@Value注解的使用方式</h3><span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(value = &quot;/person&quot;, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)</span><br><span class="line">public class MyController &#123;</span><br><span class="line">    @Value(&quot;$&#123;myConfig.myObject.myName&#125;&quot;)</span><br><span class="line">    private  String myName;</span><br><span class="line">    @Value(&quot;$&#123;myConfig.myObject.myAge&#125;&quot;)</span><br><span class="line">    private int myAge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>myConfig.myObject.myName和myConfig.myObject.myAge都是配置里边的属性。</p>
<p>那么 <code>@Value</code>注解是怎样把其表达式的值赋值给它所作用的变量的呢？<br>接下来看一下它的doc说明：<br>Annotation at the field or method&#x2F;constructor parameter level that indicates a default value expression for the affected argument.<br>Typically used for expression-driven dependency injection. Also supported for dynamic resolution of handler method parameters, e.g. in Spring MVC.<br>A common use case is to assign default field values using #{systemProperties.myProp} style expressions.<br>Note that actual processing of the @Value annotation is performed by a BeanPostProcessor which in turn means that you cannot use @Value within BeanPostProcessor or BeanFactoryPostProcessor types. Please consult the javadoc for the AutowiredAnnotationBeanPostProcessor class (which, by default, checks for the presence of this annotation).</p>
<p>作用在方法&#x2F;构造方法&#x2F;字段等上面，用于受影响的参数一个值表达式。<br>通常用于表达式驱动依赖注入的场景上边，此外还支持处理器方法的动态解析，比如spring mvc得到了大量使用。<br>一种常用的使用场景是使用#{systemProperties.myProp}风格的表达式赋值一个字段的值。<br>注意，对于<code>@Value</code>注解的处理是使用BeanPostProcessor来去完成的，表示不能在BeanPostProcessor或者BeanFactoryPostProcessor类型上使用注解，请参考AutowiredAnnotationBeanPostProcessor类（默认情况下会检查<code>@Value</code>这个注解是否存在）</p>
<h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Factory hook that allows for custom modification of new bean instances, e.g. checking for marker interfaces or wrapping them with proxies.</span><br><span class="line">ApplicationContexts can autodetect BeanPostProcessor beans in their bean definitions and apply them to any beans subsequently created. Plain bean factories allow for programmatic registration of post-processors, applying to all beans created through this factory.</span><br><span class="line">Typically, post-processors that populate beans via marker interfaces or the like will implement postProcessBeforeInitialization, while post-processors that wrap beans with proxies will normally implement postProcessAfterInitialization.</span><br><span class="line">BeanPostProcessor是一个工厂的钩子，对于新的bean的实例进行一种定制化的修改，比如，会检查marker interface或者将其包装成一个代理。</span><br><span class="line">ApplicationContexts可以在bean的定义当中自动探测到BeanPostProcessor，然后将BeanPostProcessor应用到随后创建出来的bean上面，</span><br><span class="line">普通的bean工厂允许post-processors进行一种编程式注册，将其应用到经过这个工厂创建的所有的bean上面。</span><br><span class="line">典型的，post-processors 或者类似的bean，通过marker interfaces或者类型的组件，都会实现postProcessBeforeInitialization，其他的包装了post-processors的代理通常实现postProcessAfterInitialization。</span><br><span class="line">public interface BeanPostProcessor &#123;</span><br><span class="line">  /**</span><br><span class="line">    Apply this BeanPostProcessor to the given new bean instance before any bean initialization callbacks (like InitializingBean&#x27;s afterPropertiesSet or a custom init-method). The bean will already be populated with property values. The returned bean instance may be a wrapper around the original.</span><br><span class="line">    The default implementation returns the given bean as-is.</span><br><span class="line">    在任何的bean实例初始化回调(比如说InitializingBean的afterPropertiesSet，或者自定义的初始化方法)之前应用这个BeanPostProcessor，这些bean已经使用给定的属性值进行了装配，返回的bean的实例可能是一个原始实例的一个包装，</span><br><span class="line">    默认的实现是返回给定的bean的自身。</span><br><span class="line">  **/</span><br><span class="line">  default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">    return bean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">    Apply this BeanPostProcessor to the given new bean instance after any bean initialization callbacks (like InitializingBean&#x27;s afterPropertiesSet or a custom init-method). The bean will already be populated with property values. The returned bean instance may be a wrapper around the original.</span><br><span class="line">    In case of a FactoryBean, this callback will be invoked for both the FactoryBean instance and the objects created by the FactoryBean (as of Spring 2.0). The post-processor can decide whether to apply to either the FactoryBean or created objects or both through corresponding bean instanceof FactoryBean checks.</span><br><span class="line">    This callback will also be invoked after a short-circuiting triggered by a InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation method, in contrast to all other BeanPostProcessor callbacks.</span><br><span class="line">    The default implementation returns the given bean as-is.</span><br><span class="line">    在任何的bean实例初始化回调(比如说InitializingBean的afterPropertiesSet，或者自定义的初始化方法)之后应用这个BeanPostProcessor，这些bean已经使用给定的属性值进行了装配，返回的bean的实例可能是一个原始实例的一个包装，</span><br><span class="line">    默认的实现是返回给定的bean的自身。</span><br><span class="line">    对于FactoryBean来说，针对于FactoryBean实例和通过FactoryBean创建的对象都会得到回调，post-processor可以决定是否应用到FactoryBean上边，或者说FactoryBean创建的对象上边，或者2者之上，都是可以通过FactoryBean的检查来决定。</span><br><span class="line">    当一个短路操作被触发对的时候，这个方法也会被调用，通过InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation方法的调用触发，这和其他的BeanPostProcessor回调是相反的。</span><br><span class="line">    默认的实现是返回给定的bean的自身。</span><br><span class="line">  **/</span><br><span class="line">  default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">    return bean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>postProcessBeforeInitialization和postProcessAfterInitialization为什么到了jdk1.8改成默认方法了，是因为在1.7里边如果实现一个接口，就必须去实现它的所有方法，有些时候我们只需要实现其中的一个方法，只不过另一个方法返回原来的bean，而使用default method可以不去实现所有的方法，用到那个就重写那个即可。<br><img src="/desc.png" alt="desc.png"></p>
<p>上面说到 <code>@Value</code>不能在BeanPostProcessor或者BeanFactoryPostProcessor上使用，那么BeanFactoryPostProcessor是做啥的呢？</p>
<h3 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">Allows for custom modification of an application context&#x27;s bean definitions, adapting the bean property values of the context&#x27;s underlying bean factory.</span><br><span class="line">Application contexts can auto-detect BeanFactoryPostProcessor beans in their bean definitions and apply them before any other beans get created.</span><br><span class="line">Useful for custom config files targeted at system administrators that override bean properties configured in the application context.</span><br><span class="line">See PropertyResourceConfigurer and its concrete implementations for out-of-the-box solutions that address such configuration needs.</span><br><span class="line">A BeanFactoryPostProcessor may interact with and modify bean definitions, but never bean instances. Doing so may cause premature bean instantiation, violating the container and causing unintended side-effects. If bean instance interaction is required, consider implementing BeanPostProcessor instead.</span><br><span class="line">允许对于应用上下文的bean定义进行定制化修改，适配上下文底层bean工厂的属性值。</span><br><span class="line">在其他任何的bean创建之前，应用上下文可以在bean的定义当中自动检测BeanFactoryPostProcessor，</span><br><span class="line">主要作用于定制化的配置文件，目标是系统管理员，用于覆盖应用上下文当中的属性。</span><br><span class="line">参考PropertyResourceConfigurer和具体的实现，针对于这种配置需要的开箱即用的解决方案。</span><br><span class="line">一个BeanFactoryPostProcessor可能和修改bean的定义或者和bean的定义进行交互相关，但是从来不会和 bean的实例进行交互和修改，如果是面向bean的实例，会导致一个不成熟的bean的实例化，违背了容器的一些约定，并且会导致一些意想不到的副作用，如果需要和bean的实例进行交互，可以考虑使用BeanPostProcessor的实现代替。</span><br><span class="line">*/</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface BeanFactoryPostProcessor &#123;</span><br><span class="line">  /**</span><br><span class="line">  Modify the application context&#x27;s internal bean factory after its standard initialization. All bean definitions will have been loaded, but no beans will have been instantiated yet. This allows for overriding or adding properties even to eager-initializing beans.</span><br><span class="line">  在bean工厂初始化完毕之后，修改应用上下文里边的bean工厂，所有的bean的定义将会被加载，但是还没有bean的实例，这样就允许我们覆盖甚至添加一些属性，甚至于对于非延迟初始化的bean的属性进行覆盖。</span><br><span class="line">  **/</span><br><span class="line">  void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BeanFactoryPostProcessor是在bena的定义已经加载，但是bean的实例还没有初始化这个间隙，加入一些逻辑。</p>
<p>上面提到检查<code>Value</code>是否存在，用的是AutowiredAnnotationBeanPostProcessor，那么看一下这个类的介绍：</p>
<h3 id="AutowiredAnnotationBeanPostProcessor"><a href="#AutowiredAnnotationBeanPostProcessor" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a>AutowiredAnnotationBeanPostProcessor</h3><p>org.springframework.beans.factory.config.BeanPostProcessor implementation that autowires annotated fields, setter methods and arbitrary config methods. Such members to be injected are detected through a Java 5 annotation: by default, Spring’s <code>@Autowired</code> and <code>@Value</code> annotations.<br>Also supports JSR-330’s <code>@Inject</code> annotation, if available, as a direct alternative to Spring’s own <code>@Autowired</code>.<br>Only one constructor (at max) of any given bean class may declare this annotation with the ‘required’ parameter set to true, indicating the constructor to autowire when used as a Spring bean. If multiple non-required constructors declare the annotation, they will be considered as candidates for autowiring. The constructor with the greatest number of dependencies that can be satisfied by matching beans in the Spring container will be chosen. If none of the candidates can be satisfied, then a primary&#x2F;default constructor (if present) will be used. If a class only declares a single constructor to begin with, it will always be used, even if not annotated. An annotated constructor does not have to be public.<br>Fields are injected right after construction of a bean, before any config methods are invoked. Such a config field does not have to be public.<br>Config methods may have an arbitrary name and any number of arguments; each of those arguments will be autowired with a matching bean in the Spring container. Bean property setter methods are effectively just a special case of such a general config method. Config methods do not have to be public.<br>Note: A default AutowiredAnnotationBeanPostProcessor will be registered by the “context:annotation-config” and “context:component-scan” XML tags. Remove or turn off the default annotation configuration there if you intend to specify a custom AutowiredAnnotationBeanPostProcessor bean definition.<br>NOTE: Annotation injection will be performed before XML injection; thus the latter configuration will override the former for properties wired through both approaches.<br>In addition to regular injection points as discussed above, this post-processor also handles Spring’s <code>@Lookup</code> annotation which identifies lookup methods to be replaced by the container at runtime. This is essentially a type-safe version of getBean(Class, args) and getBean(String, args), See <code>@Lookup&#39;s</code> javadoc for details.<br>AutowiredAnnotationBeanPostProcessor是BeanPostProcessor的实现（AutowiredAnnotationBeanPostProcessor面向bena的实例），她会自动装配被注解的fields，setter方法，被配置好的方法，这些被用于注入的方法，是通过java 5的一个注解进行检测，默认是通过 <code>@Autowired</code> and <code>@Value</code> 注解。<br>当然也支持JSR-330标准的 <code>@Inject</code>注解，如果有的话可以作为spring  <code>@Autowired</code>的替代方案，给定的bean的class只有一个构造器(最多一个)，并且声明了<code>@Autowired</code>这个注解的参数required是true，这个构造方法会自动的进行装配，当用做一个spring bean的时候，<br>如果有多个没有声明require的<code>@Autowired</code>注解的构造器，他们会被认为是自动注入的备选，如果一个拥有最多依赖的构造器将会作为满足spring容器的选择，如果没有候选的依赖，那么主构造器或者默认构造器，如果有的话，将会被使用，如果一个class只有一个单个构造器，那么这个构造器将会永远被使用，一个构造器不必是一个public的构造器，既是她没有被<code>@Autowired</code>注解。<br> 成员变量的注入是在bean的构造之后进行的，在所有的配置方法执行之前，这样的成员变量没有必要是public的。<br>配置方法拥有一些自由的名称和一些参数；每个方法的参数都会自动匹配一个spring容器里边的一个bean，bean的属性的setter方法就是一个配置方法，配置方法没有必要是public的。<br>注意：默认的AutowiredAnnotationBeanPostProcessor将会被”context:annotation-config” 和 “context:component-scan” XML 标签注册，如果你倾向于移除或者关闭默认注解配置，那么可以使用定制化的AutowiredAnnotationBeanPostProcessor 的bean定义。<br>注意：注解的注入比xml的注入的优先级比较高，如果使用这两种方式，这样后来的配置将会覆盖之前的属性配置。<br>除了常规的注入点之外，post-processor后置处理器可以处理spring的lookup注解，lookup注解是用来标示或者指定一个lookup方法，可以被容器在 运行时的时候别替换，这本质上是一个类替换的安全的getBean的版本，有兴趣参考<code>@Lookup</code>java 文档。<br>AutowiredAnnotationBeanPostProcessor的构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class AutowiredAnnotationBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter</span><br><span class="line">		implements MergedBeanDefinitionPostProcessor, PriorityOrdered, BeanFactoryAware&#123;</span><br><span class="line">        public AutowiredAnnotationBeanPostProcessor() &#123;</span><br><span class="line">            this.autowiredAnnotationTypes.add(Autowired.class);</span><br><span class="line">            this.autowiredAnnotationTypes.add(Value.class);</span><br><span class="line">            //try catch的作用是检测JSR-330的Inject注解的防御性设计。</span><br><span class="line">            try &#123;</span><br><span class="line">              this.autowiredAnnotationTypes.add((Class&lt;? extends Annotation&gt;)</span><br><span class="line">                  ClassUtils.forName(&quot;javax.inject.Inject&quot;, AutowiredAnnotationBeanPostProcessor.class.getClassLoader()));</span><br><span class="line">              logger.trace(&quot;JSR-330 &#x27;javax.inject.Inject&#x27; annotation found and supported for autowiring&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (ClassNotFoundException ex) &#123;</span><br><span class="line">              // JSR-330 API not available - simply skip.</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Autowired注解"><a href="#Autowired注解" class="headerlink" title="Autowired注解"></a>Autowired注解</h3><p>Marks a constructor, field, setter method or config method as to be autowired by Spring’s dependency injection facilities. This is an alternative to the JSR-330 javax.inject.Inject annotation, adding required-vs-optional semantics.<br>Only one constructor (at max) of any given bean class may declare this annotation with the ‘required’ parameter set to true, indicating the constructor to autowire when used as a Spring bean. If multiple non-required constructors declare the annotation, they will be considered as candidates for autowiring. The constructor with the greatest number of dependencies that can be satisfied by matching beans in the Spring container will be chosen. If none of the candidates can be satisfied, then a primary&#x2F;default constructor (if present) will be used. If a class only declares a single constructor to begin with, it will always be used, even if not annotated. An annotated constructor does not have to be public.<br>Fields are injected right after construction of a bean, before any config methods are invoked. Such a config field does not have to be public.<br>Config methods may have an arbitrary name and any number of arguments; each of those arguments will be autowired with a matching bean in the Spring container. Bean property setter methods are effectively just a special case of such a general config method. Such config methods do not have to be public.<br>In the case of a multi-arg constructor or method, the ‘required’ parameter is applicable to all arguments. Individual parameters may be declared as Java-8-style java.util.Optional or, as of Spring Framework 5.0, also as @Nullable or a not-null parameter type in Kotlin, overriding the base required semantics.<br>In case of a java.util.Collection or java.util.Map dependency type, the container autowires all beans matching the declared value type. For such purposes, the map keys must be declared as type String which will be resolved to the corresponding bean names. Such a container-provided collection will be ordered, taking into account org.springframework.core.Ordered&#x2F;org.springframework.core.annotation.Order values of the target components, otherwise following their registration order in the container. Alternatively, a single matching target bean may also be a generally typed Collection or Map itself, getting injected as such.<br>Note that actual injection is performed through a BeanPostProcessor which in turn means that you cannot use @Autowired to inject references into BeanPostProcessor or BeanFactoryPostProcessor types. Please consult the javadoc for the AutowiredAnnotationBeanPostProcessor class (which, by default, checks for the presence of this annotation).<br>标记一个构造器，成员变量，setter方法，配置方法，作为spring依赖管理自动注入的标示。 是JSR-330的javax.inject.Inject的替代方案，添加了require和optional的语义。<br>给定的类只有一个构造器可能声明这个注解，并且声明了require参数为true，标示这个构造去器会进行自动装配，如果有多个没有require参数的构造器被注解，他们都会被作为注入的候选者，拥有最多的依赖的构造会被spring容器作为满足注入的依赖最佳选择，如果没有一个候选，会使用默认的构造器，如果一个class只有一个构造器，那么这个构造器会被永远使用，甚至是没有被注解的构造器，一个被注解的构造器没有必要是public的。<br>成员变量的注入是在bean的构造之后进行的，在所有的配置方法执行之前，这样的成员变量没有必要是public的。<br>配置方法拥有一些自由的名称和一些参数；每个方法的参数都会自动匹配一个spring容器里边的一个bean，bean的属性的setter方法就是一个配置方法，配置方法没有必要是public的。<br>有多个参数的构造器或者方法，require参数是针对于所有的方法参数。单个参数的可以声明为java8风格的java.util.Optional 或者是说从spring5.0开始作为一个@Nullable，或者kotlin当中一个非空参数，可以覆盖一些基础的语义。<br>对于java.util.Collection和java.util.Map依赖的类型，spring容器可以匹配与其值类型匹配的所有的bean，假设一下，如果是map的key是String类型，它会被解析成与之对应的bean的名字，这样容器提供的集合将会被排序，，，，<br>略。。。</p>
<h3 id="Configuration注解"><a href="#Configuration注解" class="headerlink" title="Configuration注解"></a>Configuration注解</h3><p>Indicates that a class declares one or more @Bean methods and may be processed by the Spring container to generate bean definitions and service requests for those beans at runtime, for example:<br>   @Configuration<br>   public class AppConfig {</p>
<pre><code>   @Bean
   public MyBean myBean() &#123;
       // instantiate, configure and return bean ...
   &#125;
</code></pre>
<p>   }<br>Bootstrapping @Configuration classes<br>  Via AnnotationConfigApplicationContext<br>   @Configuration classes are typically bootstrapped using either AnnotationConfigApplicationContext or its web-capable variant, AnnotationConfigWebApplicationContext. A simple example with the former follows:<br>      AnnotationConfigApplicationContext ctx &#x3D; new AnnotationConfigApplicationContext();<br>      ctx.register(AppConfig.class);<br>      ctx.refresh();<br>      MyBean myBean &#x3D; ctx.getBean(MyBean.class);<br>      &#x2F;&#x2F; use myBean …</p>
<p>   See the AnnotationConfigApplicationContext javadocs for further details, and see AnnotationConfigWebApplicationContext for web configuration instructions in a Servlet container.<br> Via Spring <beans> XML<br>   As an alternative to registering @Configuration classes directly against an AnnotationConfigApplicationContext, @Configuration classes may be declared as normal <bean> definitions within Spring XML files:<br>      <beans><br>         <span class="exturl" data-url="Y29udGV4dDphbm5vdGF0aW9uLWNvbmZpZy8=">context:annotation-config/<i class="fa fa-external-link-alt"></i></span><br>         <bean class="com.acme.AppConfig"/><br>      </beans></p>
<p>   In the example above, <span class="exturl" data-url="Y29udGV4dDphbm5vdGF0aW9uLWNvbmZpZy8=">context:annotation-config/<i class="fa fa-external-link-alt"></i></span> is required in order to enable ConfigurationClassPostProcessor and other annotation-related post processors that facilitate handling @Configuration classes.<br> Via component scanning<br>   @Configuration is meta-annotated with @Component, therefore @Configuration classes are candidates for component scanning (typically using Spring XML’s <span class="exturl" data-url="Y29udGV4dDpjb21wb25lbnQtc2Nhbi8=">context:component-scan/<i class="fa fa-external-link-alt"></i></span> element) and therefore may also take advantage of @Autowired&#x2F;@Inject like any regular @Component. In particular, if a single constructor is present autowiring semantics will be applied transparently for that constructor:<br>      @Configuration<br>      public class AppConfig {</p>
<pre><code>      private final SomeBean someBean;

      public AppConfig(SomeBean someBean) &#123;
          this.someBean = someBean;
      &#125;

      // @Bean definition using &quot;SomeBean&quot;

  &#125;
</code></pre>
<p>   @Configuration classes may not only be bootstrapped using component scanning, but may also themselves configure component scanning using the @ComponentScan annotation:<br>      @Configuration<br>      @ComponentScan(“com.acme.app.services”)<br>      public class AppConfig {<br>          &#x2F;&#x2F; various @Bean definitions …<br>      }<br>   See the @ComponentScan javadocs for details.</p>
<p> Working with externalized values<br>   Using the Environment API<br>   Externalized values may be looked up by injecting the Spring org.springframework.core.env.Environment into a @Configuration class — for example, using the @Autowired annotation:<br>      @Configuration<br>      public class AppConfig {</p>
<pre><code>      @Autowired Environment env;

      @Bean
      public MyBean myBean() &#123;
          MyBean myBean = new MyBean();
          myBean.setName(env.getProperty(&quot;bean.name&quot;));
          return myBean;
      &#125;
  &#125;
</code></pre>
<p>   Properties resolved through the Environment reside in one or more “property source” objects, and @Configuration classes may contribute property sources to the Environment object using the @PropertySource annotation:<br>      @Configuration<br>      @PropertySource(“classpath:&#x2F;com&#x2F;acme&#x2F;app.properties”)<br>      public class AppConfig {</p>
<pre><code>      @Inject Environment env;

      @Bean
      public MyBean myBean() &#123;
          return new MyBean(env.getProperty(&quot;bean.name&quot;));
      &#125;
  &#125;
</code></pre>
<p>   See the Environment and @PropertySource javadocs for further details.<br> Using the @Value annotation</p>
<p>Composing @Configuration classes<br>With the @Import annotation<br>@Configuration classes may be composed using the @Import annotation, similar to the way that <import> works in Spring XML. Because @Configuration objects are managed as Spring beans within the container, imported configurations may be injected — for example, via constructor injection:<br>   @Configuration<br>   public class DatabaseConfig {</p>
<pre><code>   @Bean
   public DataSource dataSource() &#123;
       // instantiate, configure and return DataSource
   &#125;
</code></pre>
<p>   }</p>
<p>   @Configuration<br>   @Import(DatabaseConfig.class)<br>   public class AppConfig {</p>
<pre><code>   private final DatabaseConfig dataConfig;

   public AppConfig(DatabaseConfig dataConfig) &#123;
       this.dataConfig = dataConfig;
   &#125;

   @Bean
   public MyBean myBean() &#123;
       // reference the dataSource() bean method
       return new MyBean(dataConfig.dataSource());
   &#125;
</code></pre>
<p>   }<br>Now both AppConfig and the imported DatabaseConfig can be bootstrapped by registering only AppConfig against the Spring context:<br>   new AnnotationConfigApplicationContext(AppConfig.class);<br>With the @Profile annotation<br>@Configuration classes may be marked with the @Profile annotation to indicate they should be processed only if a given profile or profiles are active:<br>   @Profile(“development”)<br>   @Configuration<br>   public class EmbeddedDatabaseConfig {</p>
<pre><code>   @Bean
   public DataSource dataSource() &#123;
       // instantiate, configure and return embedded DataSource
   &#125;
</code></pre>
<p>   }</p>
<p>   @Profile(“production”)<br>   @Configuration<br>   public class ProductionDatabaseConfig {</p>
<pre><code>   @Bean
   public DataSource dataSource() &#123;
       // instantiate, configure and return production DataSource
   &#125;
</code></pre>
<p>   }<br>Alternatively, you may also declare profile conditions at the @Bean method level — for example, for alternative bean variants within the same configuration class:<br>   @Configuration<br>   public class ProfileDatabaseConfig {</p>
<pre><code>   @Bean(&quot;dataSource&quot;)
   @Profile(&quot;development&quot;)
   public DataSource embeddedDatabase() &#123; ... &#125;

   @Bean(&quot;dataSource&quot;)
   @Profile(&quot;production&quot;)
   public DataSource productionDatabase() &#123; ... &#125;
</code></pre>
<p>   }<br>See the @Profile and org.springframework.core.env.Environment javadocs for further details.<br>With Spring XML using the @ImportResource annotation<br>As mentioned above, @Configuration classes may be declared as regular Spring <bean> definitions within Spring XML files. It is also possible to import Spring XML configuration files into @Configuration classes using the @ImportResource annotation. Bean definitions imported from XML can be injected — for example, using the @Inject annotation:<br>   @Configuration<br>   @ImportResource(“classpath:&#x2F;com&#x2F;acme&#x2F;database-config.xml”)<br>   public class AppConfig {</p>
<pre><code>   @Inject DataSource dataSource; // from XML

   @Bean
   public MyBean myBean() &#123;
       // inject the XML-defined dataSource bean
       return new MyBean(this.dataSource);
   &#125;
</code></pre>
<p>   }<br>With nested @Configuration classes<br>@Configuration classes may be nested within one another as follows:<br>   @Configuration<br>   public class AppConfig {</p>
<pre><code>   @Inject DataSource dataSource;

   @Bean
   public MyBean myBean() &#123;
       return new MyBean(dataSource);
   &#125;

   @Configuration
   static class DatabaseConfig &#123;
       @Bean
       DataSource dataSource() &#123;
           return new EmbeddedDatabaseBuilder().build();
       &#125;
   &#125;
</code></pre>
<p>   }<br>When bootstrapping such an arrangement, only AppConfig need be registered against the application context. By virtue of being a nested @Configuration class, DatabaseConfig will be registered automatically. This avoids the need to use an @Import annotation when the relationship between AppConfig and DatabaseConfig is already implicitly clear.<br>Note also that nested @Configuration classes can be used to good effect with the @Profile annotation to provide two options of the same bean to the enclosing @Configuration class.<br>Configuring lazy initialization<br>By default, @Bean methods will be eagerly instantiated at container bootstrap time. To avoid this, @Configuration may be used in conjunction with the @Lazy annotation to indicate that all @Bean methods declared within the class are by default lazily initialized. Note that @Lazy may be used on individual @Bean methods as well.</p>
<p>标示声明有多个@Bean的方法的类，可以被spring的容器处理，用来生成bean的定义和针对于bean在运行期间你的服务请求，举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        // instantiate, configure and return bean ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="启动Configuration"><a href="#启动Configuration" class="headerlink" title="启动Configuration"></a>启动Configuration</h4><h5 id="通过-AnnotationConfigApplicationContext"><a href="#通过-AnnotationConfigApplicationContext" class="headerlink" title="通过 AnnotationConfigApplicationContext"></a>通过 AnnotationConfigApplicationContext</h5><p>@Configuration的启动通常有AnnotationConfigApplicationContext和 web-capable的变种AnnotationConfigWebApplicationContext，举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();</span><br><span class="line">ctx.register(AppConfig.class);</span><br><span class="line">ctx.refresh();</span><br><span class="line">MyBean myBean = ctx.getBean(MyBean.class);</span><br><span class="line">// use myBean ...</span><br></pre></td></tr></table></figure>
<p>参考AnnotationConfigApplicationContext 文档和AnnotationConfigWebApplicationContext 了解详情。</p>
<h5 id="通过Spring-XML方式"><a href="#通过Spring-XML方式" class="headerlink" title="通过Spring XML方式"></a>通过Spring XML方式</h5><p>作为Configuration注解的替代方案，直接使用AnnotationConfigApplicationContext的方式注册，@Configuration可以声明成spring xml的方式定义bean。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">   &lt;context:annotation-config/&gt;</span><br><span class="line">   &lt;bean class=&quot;com.acme.AppConfig&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>在上面的实例当中呢，<span class="exturl" data-url="Y29udGV4dDphbm5vdGF0aW9uLWNvbmZpZy8=">context:annotation-config/<i class="fa fa-external-link-alt"></i></span>是被要求的，用来启用ConfigurationClassPostProcessor和其他的和注解相关的后置处理器，处理@Configuration。</p>
<h5 id="组件扫描的方式"><a href="#组件扫描的方式" class="headerlink" title="组件扫描的方式"></a>组件扫描的方式</h5><p>@Configuration是由元注解@Component修饰的，所以@Configuration也是可以被认为是组件（通常使用<span class="exturl" data-url="Y29udGV4dDpjb21wb25lbnQtc2Nhbi8=">context:component-scan/<i class="fa fa-external-link-alt"></i></span>的元素），因此可以使用@Autowired&#x2F;@Inject 就像常规的组件一样，如果出现单个的构造方法，那么自动装配的语义会被透明的应用到这个构造方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    private final SomeBean someBean;</span><br><span class="line"></span><br><span class="line">    public AppConfig(SomeBean someBean) &#123;</span><br><span class="line">        this.someBean = someBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // @Bean definition using &quot;SomeBean&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Configuration不仅可以使用组件扫描启动，他自己也可以配置组件扫描使用 @ComponentScan注解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.acme.app.services&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    // various @Bean definitions ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="以外部的值去工作"><a href="#以外部的值去工作" class="headerlink" title="以外部的值去工作"></a>以外部的值去工作</h4><h5 id="使用环境变量"><a href="#使用环境变量" class="headerlink" title="使用环境变量"></a>使用环境变量</h5><p>外部的值可以通过spring的 org.springframework.core.env.Environment 注入到被@Configuration接的类里边， 举例，使用 @Autowired 注解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired Environment env;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        MyBean myBean = new MyBean();</span><br><span class="line">        myBean.setName(env.getProperty(&quot;bean.name&quot;));</span><br><span class="line">        return myBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过Environment可以解析属性源对象，并且 @Configuration 可以通过@PropertySource 注解给Environment提供属性源。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@PropertySource(&quot;classpath:/com/acme/app.properties&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;bean.name&#125;&quot;) String beanName;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        return new MyBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="通过-Value注解"><a href="#通过-Value注解" class="headerlink" title="通过@Value注解"></a>通过@Value注解</h5><p>外部的值的注入到@Configuration 注解的class，可以通过@Value 注解。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@PropertySource(&quot;classpath:/com/acme/app.properties&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;bean.name&#125;&quot;) String beanName;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        return new MyBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="组合-Configuration-类"><a href="#组合-Configuration-类" class="headerlink" title="组合 @Configuration 类"></a>组合 @Configuration 类</h4><h5 id="使用-Import-注解"><a href="#使用-Import-注解" class="headerlink" title="使用 @Import 注解"></a>使用 @Import 注解</h5><p>@Configuration注解可以使用 @Import 注解进行组合，有点像xml方式里边的 <import> 标签，因为被 @Configuration 注解的对象是作为spring 容器的bean被管理的，导入配置可以被注入的，举例，使用构造器注入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DatabaseConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        // instantiate, configure and return DataSource</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@Import(DatabaseConfig.class)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    private final DatabaseConfig dataConfig;</span><br><span class="line"></span><br><span class="line">    public AppConfig(DatabaseConfig dataConfig) &#123;</span><br><span class="line">        this.dataConfig = dataConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        // reference the dataSource() bean method</span><br><span class="line">        return new MyBean(dataConfig.dataSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，可以通过仅在Spring上下文中注册AppConfig来引导AppConfig和导入的DatabaseConfig：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new AnnotationConfigApplicationContext(AppConfig.class);</span><br></pre></td></tr></table></figure>
<h5 id="通过-Profile-注解"><a href="#通过-Profile-注解" class="headerlink" title="通过@Profile 注解"></a>通过@Profile 注解</h5><p>@Configuration注解可以被@Profile 注解标记，暗示它们在指定的profile或者活动profile需要被处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Profile(&quot;development&quot;)</span><br><span class="line">@Configuration</span><br><span class="line">public class EmbeddedDatabaseConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        // instantiate, configure and return embedded DataSource</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Profile(&quot;production&quot;)</span><br><span class="line">@Configuration</span><br><span class="line">public class ProductionDatabaseConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        // instantiate, configure and return production DataSource</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以在 @Bean 方法层面声明profile条件，举例，以下方式可以替代上面的@Profile的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ProfileDatabaseConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(&quot;dataSource&quot;)</span><br><span class="line">    @Profile(&quot;development&quot;)</span><br><span class="line">    public DataSource embeddedDatabase() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(&quot;dataSource&quot;)</span><br><span class="line">    @Profile(&quot;production&quot;)</span><br><span class="line">    public DataSource productionDatabase() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="和spring-xml配合使用-ImportResource-注解"><a href="#和spring-xml配合使用-ImportResource-注解" class="headerlink" title="和spring xml配合使用@ImportResource 注解"></a>和spring xml配合使用@ImportResource 注解</h4><p>前边提过，@Configuration 类可以在spring的 xml里边按照spring的bean定义声明，同样可以使用@ImportResource 注解导入 Spring XML配置到 @Configuration 的类里边。bean的xml定义被注入—举例，使用 @Inject注解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ImportResource(&quot;classpath:/com/acme/database-config.xml&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Inject DataSource dataSource; // from XML</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        // inject the XML-defined dataSource bean</span><br><span class="line">        return new MyBean(this.dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用嵌套的-Configuration-类"><a href="#使用嵌套的-Configuration-类" class="headerlink" title="使用嵌套的 @Configuration 类"></a>使用嵌套的 @Configuration 类</h4><p> @Configuration可以被嵌套到其他的 @Configuration类里边:<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Inject DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        return new MyBean(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Configuration</span><br><span class="line">    static class DatabaseConfig &#123;</span><br><span class="line">        @Bean</span><br><span class="line">        DataSource dataSource() &#123;</span><br><span class="line">            return new EmbeddedDatabaseBuilder().build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 这种写法启动的时候，只需要将AppConfig注册到spring的上下文，通过虚拟的嵌套的@Configuration类，DatabaseConfig将会被自动注册，避免了在AppConfig和DatabaseConfig存在联系的时候使用 @Import 注解，这样比较清晰。</p>
<h3 id="AnnotationConfigApplicationContext"><a href="#AnnotationConfigApplicationContext" class="headerlink" title="AnnotationConfigApplicationContext"></a>AnnotationConfigApplicationContext</h3><p>Standalone application context, accepting annotated classes as input - in particular @Configuration-annotated classes, but also plain @Component types and JSR-330 compliant classes using javax.inject annotations. Allows for registering classes one by one using register(Class…) as well as for classpath scanning using scan(String…).<br>In case of multiple @Configuration classes,@Bean  methods defined in later classes will override those defined in earlier classes. This can be leveraged to deliberately override certain bean definitions via an extra @Configuration class.<br>See @Configuration’s javadoc for usage examples.<br>独立应用上下文，以被注解的类作为参数输入，特别是 @Configuration注解的类，同时也是一个@Component组件类型，兼容JSR-330的javax.inject注解。允许通过register(Class…)方法一个一个的注册class，或者使用 scan(String…)方法扫描classPath下的，<br>当存在多个 @Configuration 的时候，后面的类的 @Bean注解的方法的定义将会覆盖前边的定义，这个可以用来故意覆盖一些bena的定义，通过外部的@Configuration 类。</p>
<h3 id="AnnotationConfigWebApplicationContext"><a href="#AnnotationConfigWebApplicationContext" class="headerlink" title="AnnotationConfigWebApplicationContext"></a>AnnotationConfigWebApplicationContext</h3><p>是AnnotationConfigApplicationContext在web环境下的实现</p>
<h3 id="注解解析的流程"><a href="#注解解析的流程" class="headerlink" title="注解解析的流程"></a>注解解析的流程</h3><p>我们打开AutowiredAnnotationBeanPostProcessor，这里面有AutowiredMethodElement、AutowiredFieldElement看上去分别是为了解析被注解的方法和字段的，我们拿AutowiredFieldElement的inject方法进行断点调试，启动我们的app。<br><img src="/debug1.png" alt="debug1.png"><br>断点到了inject方法里边，可以看到inject的beanname参数是我们的controller，controller的结构：<br><img src="/debug2.png" alt="debug2.png"><br>最终到了关键性的代码：<br><img src="/debug3.png" alt="debug3.png"><br>makeAccessible是为了打开访问设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void makeAccessible(Field field) &#123;</span><br><span class="line">    if ((!Modifier.isPublic(field.getModifiers()) || !Modifier.isPublic(field.getDeclaringClass().getModifiers()) || Modifier.isFinal(field.getModifiers())) &amp;&amp; !field.isAccessible()) &#123;</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>field.set(bean, value);<br>是java的反射appi，field是controller的myName字段，bean是MyController对象，value是从yml里边读取的值。<br>PS：其实MyController里边的getter和setter是无需提供的，而是spring通过反射设置的。</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>Post author:  </strong>CeaserWang
  </li>
  <li class="post-copyright-link">
      <strong>Post link: </strong>
      <a href="https://ceaser.wang/2019/11/21/spring_boot_and_cloud/spring_boot_cloud(13)Value%E6%B3%A8%E8%A7%A3%E4%B8%8EBeanPostProcessor%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%88%86%E6%9E%90/" title="spring_boot_cloud(13)Value注解与BeanPostProcessor作用与分析">https://ceaser.wang/2019/11/21/spring_boot_and_cloud/spring_boot_cloud(13)Value注解与BeanPostProcessor作用与分析/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Value%E6%B3%A8%E8%A7%A3-SpringBoot-BeanPostProcessor/" rel="tag"><i class="fa fa-tag"></i> Value注解 SpringBoot BeanPostProcessor</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/11/10/spring_boot_and_cloud/spring_boot_cloud(12)Spring_Boot%E9%9B%86%E6%88%90%E5%86%85%E5%B5%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8E%9F%E7%90%86%E6%8F%AD%E7%A7%98/" rel="prev" title="spring_boot_cloud(12)Spring_Boot集成内嵌服务器原理揭秘">
                  <i class="fa fa-chevron-left"></i> spring_boot_cloud(12)Spring_Boot集成内嵌服务器原理揭秘
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/12/08/Concurrent/concurrency(4)Lock%E9%94%81%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E8%AF%A6%E8%A7%A3/" rel="next" title="concurrency(4)Lock锁机制深入详解">
                  concurrency(4)Lock锁机制深入详解 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2015 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CeaserWang</span>
</div>
  <div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9tdXNlLw==">NexT.Muse</span>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.1/mermaid.min.js","integrity":"sha256-8L3O8tirFUa8Va4NSTAyIbHJeLd6OnlcxgupV9F77e0="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>

  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>

  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"ryAR9bttS7fex1FPEPAylmmJ-gzGzoHsz","app_key":"dYqygoN4Y01Bl38OdRoCHUYn","server_url":null,"security":false}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>



</body>
</html>
