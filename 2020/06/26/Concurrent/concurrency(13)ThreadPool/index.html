<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">

<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"ceaser.wang","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.12.1","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="ExecutorAn object that executes submitted Runnable tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use,">
<meta property="og:type" content="article">
<meta property="og:title" content="concurrency(13)ThreadPool">
<meta property="og:url" content="https://ceaser.wang/2020/06/26/Concurrent/concurrency(13)ThreadPool/index.html">
<meta property="og:site_name" content="南贺神社">
<meta property="og:description" content="ExecutorAn object that executes submitted Runnable tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use,">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://ceaser.wang/fork-join.png">
<meta property="og:image" content="https://ceaser.wang/fork-join-task-steal.png">
<meta property="article:published_time" content="2020-06-26T13:21:00.000Z">
<meta property="article:modified_time" content="2024-04-24T05:41:55.429Z">
<meta property="article:author" content="CeaserWang">
<meta property="article:tag" content="ThreadPool ForkJoinPool">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ceaser.wang/fork-join.png">


<link rel="canonical" href="https://ceaser.wang/2020/06/26/Concurrent/concurrency(13)ThreadPool/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://ceaser.wang/2020/06/26/Concurrent/concurrency(13)ThreadPool/","path":"2020/06/26/Concurrent/concurrency(13)ThreadPool/","title":"concurrency(13)ThreadPool"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>concurrency(13)ThreadPool | 南贺神社</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">南贺神社</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">你写程序有写诗一样的感觉吗?</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">210</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">26</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">221</span></a></li><li class="menu-item menu-item-0xcc"><a href="/0xcc/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>0XCC</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Executor"><span class="nav-number">1.</span> <span class="nav-text">Executor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ExecutorService"><span class="nav-number">1.1.</span> <span class="nav-text">ExecutorService</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadPoolExecutor"><span class="nav-number">1.2.</span> <span class="nav-text">ThreadPoolExecutor</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%9C%80%E8%A6%81%E7%AE%A1%E7%90%86%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.1.</span> <span class="nav-text">线程池需要管理的数据</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">1.3.</span> <span class="nav-text">线程池的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ThreadPoolExecutor%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">1.3.1.</span> <span class="nav-text">ThreadPoolExecutor的构造器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Executors%E5%B7%A5%E5%8E%82"><span class="nav-number">1.3.2.</span> <span class="nav-text">Executors工厂</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newCachedThreadPool"><span class="nav-number">1.4.</span> <span class="nav-text">newCachedThreadPool()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Executors-newSingleThreadExecutor"><span class="nav-number">1.5.</span> <span class="nav-text">Executors.newSingleThreadExecutor()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Executors-newFixedThreadPool-n"><span class="nav-number">1.6.</span> <span class="nav-text">Executors.newFixedThreadPool(n)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="nav-number">1.7.</span> <span class="nav-text">偏向锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89ThreadPoolExecutor%E5%8F%82%E6%95%B0"><span class="nav-number">1.8.</span> <span class="nav-text">自定义ThreadPoolExecutor参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91"><span class="nav-number">1.9.</span> <span class="nav-text">线程池任务创建与执行任务的核心逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%8F%90%E4%BA%A4"><span class="nav-number">1.9.1.</span> <span class="nav-text">关于线程池任务的提交</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%85%B3%E9%97%AD"><span class="nav-number">1.9.2.</span> <span class="nav-text">关于线程池的关闭</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E4%BB%BB%E5%8A%A1%E5%AE%8C%E6%88%90"><span class="nav-number">1.9.3.</span> <span class="nav-text">等待任务完成</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#forkjoin%E6%A1%86%E6%9E%B6"><span class="nav-number">1.10.</span> <span class="nav-text">forkjoin框架</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%AA%83%E5%8F%96"><span class="nav-number">1.10.1.</span> <span class="nav-text">任务窃取</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.11.</span> <span class="nav-text">源码介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ForkJoinTask"><span class="nav-number">1.11.1.</span> <span class="nav-text">ForkJoinTask</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.11.2.</span> <span class="nav-text">实例</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="CeaserWang"
      src="/../0xcc/index/Uchiha.jpg">
  <p class="site-author-name" itemprop="name">CeaserWang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">221</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">210</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzExNTY3MjE4NzQ=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;1156721874"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmNlYXNlcndhbmdAb3V0bG9vay5jb20=" title="E-Mail → mailto:ceaserwang@outlook.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-user-friends fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly90d29kcmFnb25sYWtlLmNvbQ==" title="https:&#x2F;&#x2F;twodragonlake.com">TwoDragonLake</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9yb290Y2x1c3Rlci5naXRodWIuaW8=" title="https:&#x2F;&#x2F;rootcluster.github.io">RootCluster</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9tdXNlZmxvdy5pbw==" title="https:&#x2F;&#x2F;museflow.io">MuseFlow</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9pbmNvZGVyLm9yZw==" title="https:&#x2F;&#x2F;incoder.org">BladeCode</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9rYWlmYS5kZXY=" title="https:&#x2F;&#x2F;kaifa.dev">Alyenc</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmRhemhpZGF5b25nLmNu" title="https:&#x2F;&#x2F;blog.dazhidayong.cn">Killua</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly93d3cuY3lsb25nLmNvbQ==" title="https:&#x2F;&#x2F;www.cylong.com">Cylong</span>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ceaser.wang/2020/06/26/Concurrent/concurrency(13)ThreadPool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/../0xcc/index/Uchiha.jpg">
      <meta itemprop="name" content="CeaserWang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南贺神社">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="concurrency(13)ThreadPool | 南贺神社">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          concurrency(13)ThreadPool
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-06-26 13:21:00" itemprop="dateCreated datePublished" datetime="2020-06-26T13:21:00+00:00">2020-06-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-04-24 05:41:55" itemprop="dateModified" datetime="2024-04-24T05:41:55+00:00">2024-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/concurrency/" itemprop="url" rel="index"><span itemprop="name">concurrency</span></a>
        </span>
    </span>

  
    <span id="/2020/06/26/Concurrent/concurrency(13)ThreadPool/" class="post-meta-item leancloud_visitors" data-flag-title="concurrency(13)ThreadPool" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>An object that executes submitted Runnable tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc. An Executor is normally used instead of explicitly creating threads. For example, rather than invoking new Thread(new(RunnableTask())).start() for each of a set of tasks, you might use:</p>
<span id="more"></span>
<p>Executor是一个可运行提交任务的对象，这个接口提供了一种将任务的提交和每个任务的运行机制解耦的方式，包括线程的具体使用，调度等，一个Executor一般用于替代手动创建线程的方式，可以使用如下的方式：<br>   Executor executor &#x3D; anExecutor;<br>   executor.execute(new RunnableTask1());<br>   executor.execute(new RunnableTask2());<br>   …</p>
<p>However, the Executor interface does not strictly require that execution be asynchronous. In the simplest case, an executor can run the submitted task immediately in the caller’s thread:</p>
<p> class DirectExecutor implements Executor {<br>   public void execute(Runnable r) {<br>     r.run();<br>   }<br> }<br>More typically, tasks are executed in some thread other than the caller’s thread. The executor below spawns a new thread for each task.</p>
<p> class ThreadPerTaskExecutor implements Executor {<br>   public void execute(Runnable r) {<br>     new Thread(r).start();<br>   }<br> }<br>Many Executor implementations impose some sort of limitation on how and when tasks are scheduled. The executor below serializes the submission of tasks to a second executor, illustrating a composite executor.</p>
<p> class SerialExecutor implements Executor {<br>   final Queue<Runnable> tasks &#x3D; new ArrayDeque<Runnable>();<br>   final Executor executor;<br>   Runnable active;</p>
<p>   SerialExecutor(Executor executor) {<br>     this.executor &#x3D; executor;<br>   }</p>
<p>   public synchronized void execute(final Runnable r) {<br>     tasks.offer(new Runnable() {<br>       public void run() {<br>         try {<br>           r.run();<br>         } finally {<br>           scheduleNext();<br>         }<br>       }<br>     });<br>     if (active &#x3D;&#x3D; null) {<br>       scheduleNext();<br>     }<br>   }</p>
<p>   protected synchronized void scheduleNext() {<br>     if ((active &#x3D; tasks.poll()) !&#x3D; null) {<br>       executor.execute(active);<br>     }<br>   }<br> }<br>The Executor implementations provided in this package implement ExecutorService, which is a more extensive interface. The ThreadPoolExecutor class provides an extensible thread pool implementation. The Executors class provides convenient factory methods for these Executors.<br>Memory consistency effects: Actions in a thread prior to submitting a Runnable object to an Executor happen-before its execution begins, perhaps in another thread</p>
<p>Executor包含的方法：<br>  execute</p>
<h4 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h4><p>An Executor that provides methods to manage termination and methods that can produce a Future for tracking progress of one or more asynchronous tasks.<br>一个Executor的实现，提供了一些管理终止任务和返回一个用来追踪处理过程或者更多异步任务future的方法。<br>An ExecutorService can be shut down, which will cause it to reject new tasks. Two different methods are provided for shutting down an ExecutorService. The shutdown method will allow previously submitted tasks to execute before terminating, while the shutdownNow method prevents waiting tasks from starting and attempts to stop currently executing tasks. Upon termination, an executor has no tasks actively executing, no tasks awaiting execution, and no new tasks can be submitted. An unused ExecutorService should be shut down to allow reclamation of its resources.<br>Method submit extends base method Executor.execute(Runnable) by creating and returning a Future that can be used to cancel execution and&#x2F;or wait for completion. Methods invokeAny and invokeAll perform the most commonly useful forms of bulk execution, executing a collection of tasks and then waiting for at least one, or all, to complete. (Class ExecutorCompletionService can be used to write customized variants of these methods.)<br>一个ExecutorService是可以被关闭的，这样的话拒绝一些新的任务，提供了shutdow和shutdownnow方法。<br>The Executors class provides factory methods for the executor services provided in this package</p>
<p>java.util.concurrent.ExecutorService<br>java.util.concurrent.ExecutorService#shutdown<br>java.util.concurrent.ExecutorService#shutdownNow<br>java.util.concurrent.ExecutorService#isShutdown<br>java.util.concurrent.ExecutorService#isTerminated<br>java.util.concurrent.ExecutorService#awaitTermination<br>java.util.concurrent.ExecutorService#submit(java.util.concurrent.Callable<T>)<br>java.util.concurrent.ExecutorService#submit(java.lang.Runnable, T)<br>java.util.concurrent.ExecutorService#submit(java.lang.Runnable)<br>java.util.concurrent.ExecutorService#invokeAll(java.util.Collection&lt;? extends java.util.concurrent.Callable<T>&gt;)<br>java.util.concurrent.ExecutorService#invokeAll(java.util.Collection&lt;? extends java.util.concurrent.Callable<T>&gt;, long, java.util.concurrent.TimeUnit)<br>java.util.concurrent.ExecutorService#invokeAny(java.util.Collection&lt;? extends java.util.concurrent.Callable<T>&gt;)<br>java.util.concurrent.ExecutorService#invokeAny(java.util.Collection&lt;? extends java.util.concurrent.Callable<T>&gt;, long, java.util.concurrent.TimeUnit)</p>
<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p>具体是线程池实现是由ThreadPoolExecutor实现，ThreadPoolExecutor是间接的实现了ExecutorService，ThreadPoolExecutor继承了AbstractExecutorService，AbstractExecutorService实现了ExecutorService。<br>AbstractExecutorService的实现方法：<br>java.util.concurrent.AbstractExecutorService<br>java.util.concurrent.AbstractExecutorService#newTaskFor(java.lang.Runnable, T)<br>java.util.concurrent.AbstractExecutorService#newTaskFor(java.util.concurrent.Callable<T>)<br>java.util.concurrent.AbstractExecutorService#submit(java.lang.Runnable)<br>java.util.concurrent.AbstractExecutorService#submit(java.lang.Runnable, T)<br>java.util.concurrent.AbstractExecutorService#submit(java.util.concurrent.Callable<T>)<br>java.util.concurrent.AbstractExecutorService#doInvokeAny<br>java.util.concurrent.AbstractExecutorService#invokeAny(java.util.Collection&lt;? extends java.util.concurrent.Callable<T>&gt;)<br>java.util.concurrent.AbstractExecutorService#invokeAny(java.util.Collection&lt;? extends java.util.concurrent.Callable<T>&gt;, long, java.util.concurrent.TimeUnit)<br>java.util.concurrent.AbstractExecutorService#invokeAll(java.util.Collection&lt;? extends java.util.concurrent.Callable<T>&gt;)<br>java.util.concurrent.AbstractExecutorService#invokeAll(java.util.Collection&lt;? extends java.util.concurrent.Callable<T>&gt;, long, java.util.concurrent.TimeUnit)</p>
<p>AbstractExecutorService是线程池实现的基础，提供了一些默认的实现。</p>
<h5 id="线程池需要管理的数据"><a href="#线程池需要管理的数据" class="headerlink" title="线程池需要管理的数据"></a>线程池需要管理的数据</h5><ul>
<li>线程池本身的状态</li>
<li>执行的线程的状态<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// ctl存储了【线程池的状态】以及【线程池里边线程的数量】</span><br><span class="line">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line">// 减去的3位是存储的是线程池的状态剩下的是管理的线程的数量：COUNT_BITS = 32-3=29</span><br><span class="line">private static final int COUNT_BITS = Integer.SIZE - 3;</span><br><span class="line">private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class="line"></span><br><span class="line">// runState is stored in the high-order bits</span><br><span class="line">private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int STOP       =  1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>
线程池里边的worker线程实现了AQS：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private final class Worker extends AbstractQueuedSynchronizer  implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h4><h5 id="ThreadPoolExecutor的构造器"><a href="#ThreadPoolExecutor的构造器" class="headerlink" title="ThreadPoolExecutor的构造器"></a>ThreadPoolExecutor的构造器</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial</span><br><span class="line"> * parameters.</span><br><span class="line"> *</span><br><span class="line"> * @param corePoolSize the number of threads to keep in the pool, even</span><br><span class="line"> *        if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set</span><br><span class="line"> * @param maximumPoolSize the maximum number of threads to allow in the</span><br><span class="line"> *        pool</span><br><span class="line"> * @param keepAliveTime when the number of threads is greater than</span><br><span class="line"> *        the core, this is the maximum time that excess idle threads</span><br><span class="line"> *        will wait for new tasks before terminating.</span><br><span class="line"> * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument</span><br><span class="line"> * @param workQueue the queue to use for holding tasks before they are</span><br><span class="line"> *        executed.  This queue will hold only the &#123;@code Runnable&#125;</span><br><span class="line"> *        tasks submitted by the &#123;@code execute&#125; method.</span><br><span class="line"> * @param threadFactory the factory to use when the executor</span><br><span class="line"> *        creates a new thread</span><br><span class="line"> * @param handler the handler to use when execution is blocked</span><br><span class="line"> *        because the thread bounds and queue capacities are reached</span><br><span class="line"> * @throws IllegalArgumentException if one of the following holds:&lt;br&gt;</span><br><span class="line"> *         &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt;</span><br><span class="line"> *         &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt;</span><br><span class="line"> *         &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span><br><span class="line"> *         &#123;@code maximumPoolSize &lt; corePoolSize&#125;</span><br><span class="line"> * @throws NullPointerException if &#123;@code workQueue&#125;</span><br><span class="line"> *         or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null</span><br><span class="line"> */</span><br><span class="line">public ThreadPoolExecutor(</span><br><span class="line">    int corePoolSize,  //核心的线程数量，即使没有任务执行也不会关闭</span><br><span class="line">    int maximumPoolSize, 最大的线程数量</span><br><span class="line">    long keepAliveTime, //线程等待新任务到来的时间超过keepAliveTime就会回收掉</span><br><span class="line">    TimeUnit unit, //时间单位</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; workQueue, //缓存提交的任务的队列</span><br><span class="line">    ThreadFactory threadFactory, //线程工厂</span><br><span class="line">    RejectedExecutionHandler handler // 拒绝策略</span><br><span class="line">                          ) &#123;</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;= 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.corePoolSize = corePoolSize;</span><br><span class="line">    this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    this.workQueue = workQueue;</span><br><span class="line">    this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory = threadFactory;</span><br><span class="line">    this.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
int corePoolSize：<br>核心的线程数量，即使没有任务执行也不会关闭。<br>int maximumPoolSize：<br>线程池当中维护的最大的线程数量<br>long keepAliveTime：<br>线程等待新任务到来的时间超过keepAliveTime就会被回收掉，回收的底线是corePoolSize。<br>TimeUnit unit：<br>keepAliveTime的时间单位<br>BlockingQueue<Runnable> workQueue：<br>缓存提交的任务的队列<br>ThreadFactory threadFactory：<br>线程工厂，推荐使用Executors#defaultThreadFactory。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static class DefaultThreadFactory implements ThreadFactory &#123;</span><br><span class="line">  //poolNumber是静态的，原因是系统中所有的线程池都是共享这个AtomicInteger，这样就不会出现名称相同的线程池</span><br><span class="line">  private static final AtomicInteger poolNumber = new AtomicInteger(1);</span><br><span class="line">  private final ThreadGroup group;</span><br><span class="line">  private final AtomicInteger threadNumber = new AtomicInteger(1);</span><br><span class="line">  private final String namePrefix;</span><br><span class="line"></span><br><span class="line">  DefaultThreadFactory() &#123;</span><br><span class="line">      SecurityManager s = System.getSecurityManager();</span><br><span class="line">      group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();</span><br><span class="line">      namePrefix = &quot;pool-&quot; + poolNumber.getAndIncrement() + &quot;-thread-&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Thread newThread(Runnable r) &#123;</span><br><span class="line">      Thread t = new Thread(group, r,</span><br><span class="line">                            namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                            0);</span><br><span class="line">      if (t.isDaemon())</span><br><span class="line">          t.setDaemon(false);//非守护线程，即为用户线程，main执行完之后，不会退出</span><br><span class="line">      if (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">          t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">      return t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
RejectedExecutionHandler handler：<br>拒绝策略，当达到队列上限或者再也不能创建现线程的时候被调用。<ul>
<li>AbortPolicy 直接抛出运行期异常，一直抛给执行execute的调用者，rejectedExecution抛出RejectedExecutionException</li>
<li>CallerRunsPolicy<br>调用者线程去执行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">  if (!e.isShutdown()) &#123;</span><br><span class="line">      r.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>DiscardOldestPolicy<br>将最老的一个未被处理的任务丢弃，然后让线程池执行当前的任务<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">    if (!e.isShutdown()) &#123;</span><br><span class="line">        //将最老的一个拿出来，不做处理，丢弃</span><br><span class="line">        e.getQueue().poll();</span><br><span class="line">        //执行当前的任务</span><br><span class="line">        e.execute(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>DiscardPolicy 直接丢弃，也不会抛出任何异常，rejectedExecution是空实现</li>
</ul>
</li>
</ul>
<h5 id="Executors工厂"><a href="#Executors工厂" class="headerlink" title="Executors工厂"></a>Executors工厂</h5><p>java.util.concurrent.Executors<br>java.util.concurrent.Executors#newFixedThreadPool(int)<br>java.util.concurrent.Executors#newWorkStealingPool(int)<br>java.util.concurrent.Executors#newWorkStealingPool()<br>java.util.concurrent.Executors#newFixedThreadPool(int, java.util.concurrent.ThreadFactory)<br>java.util.concurrent.Executors#newSingleThreadExecutor()<br>java.util.concurrent.Executors#newSingleThreadExecutor(java.util.concurrent.ThreadFactory)<br>java.util.concurrent.Executors#newCachedThreadPool()<br>java.util.concurrent.Executors#newCachedThreadPool(java.util.concurrent.ThreadFactory)<br>java.util.concurrent.Executors#newSingleThreadScheduledExecutor()<br>java.util.concurrent.Executors#newSingleThreadScheduledExecutor(java.util.concurrent.ThreadFactory)<br>java.util.concurrent.Executors#newScheduledThreadPool(int)<br>java.util.concurrent.Executors#newScheduledThreadPool(int, java.util.concurrent.ThreadFactory)<br>java.util.concurrent.Executors#unconfigurableExecutorService<br>java.util.concurrent.Executors#unconfigurableScheduledExecutorService<br>java.util.concurrent.Executors#defaultThreadFactory<br>java.util.concurrent.Executors#privilegedThreadFactory<br>java.util.concurrent.Executors#callable(java.lang.Runnable, T)<br>java.util.concurrent.Executors#callable(java.lang.Runnable)<br>java.util.concurrent.Executors#callable(java.security.PrivilegedAction<?>)
java.util.concurrent.Executors#callable(java.security.PrivilegedExceptionAction<?>)<br>java.util.concurrent.Executors#privilegedCallable<br>java.util.concurrent.Executors#privilegedCallableUsingCurrentClassLoader</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(3);</span><br><span class="line">        executorService.submit(() -&gt;&#123;</span><br><span class="line">            IntStream.range(0,50).forEach(i -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印的线程名称都是同一个名称，以为只提交了一个任务，会使用其中一个线程去执行。<br>代码运行之后，jvm线程并不会退出，那是因为线程池创建的线程都是用户线程，而非守护线程，我们只有显式的调用线程池的shutdow之类的方法停止线程池。<br>Executors.newFixedThreadPool(3):创建只有三个线程的线程池，永远不会增加减少<br>Executors.newSingleThreadExecutor():创建只有1个线程的线程池，永远不会增加减少<br>Executors.newCachedThreadPool(): 带缓冲的线程池，它里边的线程的数量会根据提交的任务的多少来动态创建线程。</p>
<p>提交多个任务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(3);</span><br><span class="line">        IntStream.range(0,10).forEach(i -&gt;&#123;</span><br><span class="line">            executorService.submit(() -&gt;&#123;</span><br><span class="line">                IntStream.range(0,50).forEach(j -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);  </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果会出现3个线程的名称，因为提交了多个任务，会有线程的复用。<br>如果使用的是newSingleThreadExecutor()，那么打印结果只会出现一个线程的名称，所有的任务都是由这一个线程去执行。<br>如果使用newCachedThreadPool()，打印结果会出现很多线程的名称。</p>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool()"></a>newCachedThreadPool()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    //最小线程数量是0，最大线程数量是Integer的最大值，AbortPolicy拒绝策略</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SynchronousQueue即同步的队列，插入操作必须等待移除操作的完成才能进行，返回来也是，里边只有一个元素。<br>由于核心线程数是0，因此回往SynchronousQueue添加任务，但是SynchronousQueue是同步的必须立刻执行，<br>因此新提交过来的任务会不断的创建线程去执行。</p>
<h4 id="Executors-newSingleThreadExecutor"><a href="#Executors-newSingleThreadExecutor" class="headerlink" title="Executors.newSingleThreadExecutor()"></a>Executors.newSingleThreadExecutor()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">  //最小和最大线程数量被限制成了1个，AbortPolicy拒绝策略，无界队列</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Executors-newFixedThreadPool-n"><a href="#Executors-newFixedThreadPool-n" class="headerlink" title="Executors.newFixedThreadPool(n)"></a>Executors.newFixedThreadPool(n)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nThreads限制了最小和最大线程数量，AbortPolicy拒绝策略，无界队列</span><br><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工厂方法底层都是调用的ThreadPoolExecutor的构造器。实际使用线程池不推荐使用工厂的方式，因为：</p>
<ul>
<li>这些工厂创建的线程池拒绝策略都是抛出异常</li>
<li>newSingleThreadExecutor、newFixedThreadPool中的任务缓冲队列都是无界的，很容易出现oom异常。</li>
</ul>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>在线程池当中，尽量把偏向锁关闭</p>
<h4 id="自定义ThreadPoolExecutor参数"><a href="#自定义ThreadPoolExecutor参数" class="headerlink" title="自定义ThreadPoolExecutor参数"></a>自定义ThreadPoolExecutor参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService executorService = new ThreadPoolExecutor(3,5,</span><br><span class="line">                0,</span><br><span class="line">                TimeUnit.SECONDS,new LinkedBlockingDeque&lt;&gt;(3),</span><br><span class="line">                new ThreadPoolExecutor.CallerRunsPolicy()</span><br><span class="line">                );</span><br><span class="line">        int number = 9;</span><br><span class="line">        IntStream.range(0,number).forEach(i -&gt;&#123;</span><br><span class="line">            executorService.submit(() -&gt;&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                IntStream.range(0,1).forEach(j -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>number小于等于3的时候，日志最多打印三个线程在执行任务。<br>number大于3小于等于6的时候，日志最多打印三个线程在执行任务。<br>number大于6小于等于8的时候，日志最多打印8个线程在执行任务。<br>number大于8的时候最多会出现8个线程在执行任务，并且可能会出现拒绝执行任务的异常。<br>如果拒绝策略使用DiscardPolicy，那么程序不会抛出异常，但是会有一些任务被静默丢弃。<br>如实拒绝策略使用DiscardOldestPolicy，那么程序也不会抛出异常，但是会将阻塞队列里边的最老的任务丢弃，然后执行当前任务。<br>如果拒绝策略使用CallerRunsPolicy，那么打印结果里边会出现一个main的线程名称，即，使用调用者的线程去执行任务:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-3</span><br><span class="line">pool-1-thread-4</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-5</span><br><span class="line">pool-1-thread-2</span><br><span class="line">main</span><br><span class="line">pool-1-thread-3</span><br><span class="line">pool-1-thread-4</span><br><span class="line">pool-1-thread-1</span><br></pre></td></tr></table></figure>

<h4 id="线程池任务创建与执行任务的核心逻辑"><a href="#线程池任务创建与执行任务的核心逻辑" class="headerlink" title="线程池任务创建与执行任务的核心逻辑"></a>线程池任务创建与执行任务的核心逻辑</h4><p>ThreadPoolExecutor的submit有三种实现方式：</p>
<ul>
<li><T> Future<T> submit(Callable<T> task); &#x2F;&#x2F;Future是线程run方法真正的返回值.</li>
<li><T> Future<T> submit(Runnable task, T result); &#x2F;&#x2F; Future.get()返回的是参数result.</li>
<li>Future&lt;?&gt; submit(Runnable task); &#x2F;&#x2F;Future.get()返回为null.</li>
</ul>
<p>submit方法会调用execute方法去执行任务。<br>对于线程池来说，其提供了execute与submit两种方式来向线程池提交任务。<br>总体来说，submit方法是可以提供execute方法的，因为它既可以接收callable任务，也可以接收Runnable任务。</p>
<p>关于线程池的总体的执行策略：</p>
<ol>
<li>如果线程池中正在执行的线程数 &lt; corePoolSize，那么线程池就会优先选择创建新的线程而非将提交的任务加到阻塞队列中。</li>
<li>如果线程池中正在执行的线程数数 &gt;&#x3D; corePoolSize，那么线程池就会优先选择对提交的任务进行阻塞排队而非创建新的线程。</li>
<li>如果提交的任务无法加入到阻塞队列当中，那么线程池就会创建新的线程；如果创建的线程数超过了maximumPoolSize，那么拒绝策略就会起作用。</li>
</ol>
<p>执行submit过程:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    if (task == null) throw new NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    return ftask;</span><br><span class="line">&#125;</span><br><span class="line">protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123;</span><br><span class="line">    return new FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FutureTask的构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public FutureTask(Runnable runnable, V result) &#123;</span><br><span class="line">    this.callable = Executors.callable(runnable, result);</span><br><span class="line">    this.state = NEW;       // ensure visibility of callable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> Executors.callable(runnable, result)逻辑是对callable创建的封装:<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) &#123;</span><br><span class="line">    if (task == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    return new RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>RunnableAdapter实际上是一个Callable，call方法是实际任务的执行:<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; &#123;</span><br><span class="line">    final Runnable task;</span><br><span class="line">    final T result;</span><br><span class="line">    RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">        this.task = task;</span><br><span class="line">        this.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    public T call() &#123;</span><br><span class="line">        task.run();</span><br><span class="line">        // 等待任务执行完毕(task.run()),然后直接返回result</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 其他的重载的submit方法执行逻辑都是一样的，不管是runnbale或者callable都会转换为callable，只不过参数是Callable的时候不需要RunnableAdapter。<br>newTaskFor返回的是RunnableFuture，RunnableFuture的实现类FutureTask封装了执行和返回的结构的一个集合体:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123;</span><br><span class="line">  java.util.concurrent.FutureTask#FutureTask(java.util.concurrent.Callable&lt;V&gt;)</span><br><span class="line">  java.util.concurrent.FutureTask#FutureTask(java.lang.Runnable, V)</span><br><span class="line">  java.util.concurrent.FutureTask#report</span><br><span class="line">  java.util.concurrent.FutureTask#isCancelled</span><br><span class="line">  java.util.concurrent.FutureTask#isDone</span><br><span class="line">  java.util.concurrent.FutureTask#cancel</span><br><span class="line">  java.util.concurrent.FutureTask#get()</span><br><span class="line">  java.util.concurrent.FutureTask#get(long, java.util.concurrent.TimeUnit)</span><br><span class="line">  java.util.concurrent.FutureTask#done</span><br><span class="line">  java.util.concurrent.FutureTask#set</span><br><span class="line">  java.util.concurrent.FutureTask#setException</span><br><span class="line">  java.util.concurrent.FutureTask#run</span><br><span class="line">  java.util.concurrent.FutureTask#runAndReset</span><br><span class="line">  java.util.concurrent.FutureTask#handlePossibleCancellationInterrupt</span><br><span class="line">  java.util.concurrent.FutureTask#finishCompletion</span><br><span class="line">  java.util.concurrent.FutureTask#awaitDone</span><br><span class="line">  java.util.concurrent.FutureTask#removeWaiter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RunnableFuture是一个可取消的异步的计算，提供了Future的基础的实现，提供了开始、取消、查询、获取运算结构的方法，运算结果只有运算完成之后才能获取，如果运算还没有完成，那么get方法是阻塞，任务一旦计算完成就不能重新开始或者取消，除非计算的时候调用了runAndReset方法。</p>
<h5 id="关于线程池任务的提交"><a href="#关于线程池任务的提交" class="headerlink" title="关于线程池任务的提交"></a>关于线程池任务的提交</h5><ol>
<li>两种提交方式:submit与execute</li>
<li>submit有三种方式，无论是哪种方式，最终都是将传递将来的任务转换为一个callable对象进行处理</li>
<li>当callable对象构造完毕后，最终都会调用Executor提供接口中声明的execute方法进行统一的处理</li>
</ol>
<p>execute()方法是主要的逻辑，它的实现【java.util.concurrent.ThreadPoolExecutor.execute()】。</p>
<p>介绍【java.util.concurrent.ThreadPoolExecutor.execute()】之前先了解下ThreadPoolExecutor的一些成员变量。</p>
<ul>
<li>对于线程池来说，有2个状态需要维护：<ul>
<li>线程池本身的状态</li>
<li>线程池所运行着的线程的数量</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// ctl是一个原子整型变量，表示了线程池本身的状态、线程池所运行着的线程的数量</span><br><span class="line">// 高三位表示【 线程池本身的状态】，低29位表示【线程池所运行着的线程的数量】</span><br><span class="line">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line">private static final int COUNT_BITS = Integer.SIZE - 3;</span><br><span class="line">private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class="line"></span><br><span class="line">// runState is stored in the high-order bits</span><br><span class="line">// 线程池一共有5种状态</span><br><span class="line">private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int STOP       =  1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">// Packing and unpacking ctl</span><br><span class="line">// runStateOf是线程池的状态</span><br><span class="line">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</span><br><span class="line">// workerCountOf是当前线程池工作线程的数量</span><br><span class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</span><br><span class="line">// ctlOf重新计算ctl的值</span><br><span class="line">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<p>线程池的状态:</p>
<ol>
<li>RUNNING: 线程池可以接受新的任务提交，并且还可以正常处理阻塞队列。</li>
<li>SHUTDOWN: 不再接收新的任务提交，不过线程池还可以继续处理阻塞队列中的任务。</li>
<li>STOP：不再接收新的任务，同时还会丢弃阻塞队列中的既有任务，它还会中断正在处理中的任务。SHUTDOWNNOW会将状态置位stop状态。</li>
<li>TIDYING：所有的任务都执行完毕后（同时也涵盖了阻塞队列中的任务），当前线程池的活动的线程数量降为0，将会调用terminated方法。</li>
<li>TERMINATED：线程池的终止状态，当terminated方法执行完毕后，线程池将会处于该状态之下。</li>
</ol>
<p>线程池的状态切换:<br>RUNNING -&gt; SHUTDOWN: 当调用了线程池的SHUTDOWN方法，或者finalize方法被隐式调用后(该方法内部会调用shutdown方法)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void shutdown() &#123;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); // hook for ScheduledThreadPoolExecutor</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void finalize() &#123;</span><br><span class="line">    shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RUNNING&#x2F;SHUTDOWN -&gt; STOP: 当调用了线程池的shutdownNow方法时。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Runnable&gt; shutdownNow() &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        interruptWorkers();</span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    return tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SHUTDOWN -&gt; TIDYING: 在线程池与阻塞队列均变成空时。</p>
<p>STOP -&gt; TIDYING: 在线程池变成空时。</p>
<p>TIDYING -&gt; TERMINATED: 在terminated方法被执行完毕时。</p>
<p>ThreadPoolExecutor.execute()执行逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Executes the given task sometime in the future.  The task</span><br><span class="line">   * may execute in a new thread or in an existing pooled thread.</span><br><span class="line">   * 在将来某个时刻执行给定的任务，任务可能在一个新的线程里边被执行，也可能在已有的线程里边被执行</span><br><span class="line">   * If the task cannot be submitted for execution, either because this</span><br><span class="line">   * executor has been shutdown or because its capacity has been reached,</span><br><span class="line">   * the task is handled by the current &#123;@code RejectedExecutionHandler&#125;.</span><br><span class="line">   * 如果任务无法被提交执行，原因可能是executor已经被关闭，或者阻塞队列容量已经满了，</span><br><span class="line">   * 那么任务就会交给RejectedExecutionHandler处理。</span><br><span class="line">   * @param command the task to execute</span><br><span class="line">   * @throws RejectedExecutionException at discretion of</span><br><span class="line">   *         &#123;@code RejectedExecutionHandler&#125;, if the task</span><br><span class="line">   *         cannot be accepted for execution</span><br><span class="line">   * @throws NullPointerException if &#123;@code command&#125; is null</span><br><span class="line">   */</span><br><span class="line">  public void execute(Runnable command) &#123;</span><br><span class="line">      if (command == null)</span><br><span class="line">          throw new NullPointerException();</span><br><span class="line">      /*</span><br><span class="line">       * Proceed in 3 steps:</span><br><span class="line">       *</span><br><span class="line">       * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="line">       * start a new thread with the given command as its first</span><br><span class="line">       * task.  The call to addWorker atomically checks runState and</span><br><span class="line">       * workerCount, and so prevents false alarms that would add</span><br><span class="line">       * threads when it shouldn&#x27;t, by returning false.</span><br><span class="line">       * 如果线程池运行的线程数如果少于corePoolSize，线程池会尝试创建新的线程，</span><br><span class="line">       * 并且用新的线程去执行给定的任务，对于addWorker会使用原子的方式去调用。</span><br><span class="line">       * 2. If a task can be successfully queued, then we still need</span><br><span class="line">       * to double-check whether we should have added a thread</span><br><span class="line">       * (because existing ones died since last checking) or that</span><br><span class="line">       * the pool shut down since entry into this method. So we</span><br><span class="line">       * recheck state and if necessary roll back the enqueuing if</span><br><span class="line">       * stopped, or start a new thread if there are none.</span><br><span class="line">       * 如果一个任务能够被成功的添加到任务队列中，会尝试双重检查是否已经添加了一个新的线程，</span><br><span class="line">       * 或者线程池被关闭了等，如果不行就会回</span><br><span class="line">       * 滚带入队之前的状态；</span><br><span class="line">       * 3. If we cannot queue task, then we try to add a new</span><br><span class="line">       * thread.  If it fails, we know we are shut down or saturated</span><br><span class="line">       * and so reject the task.</span><br><span class="line">       * 如果不能进行入队操作，那么就会创建新的线程。如果失败，执行拒绝策略</span><br><span class="line">       */</span><br><span class="line">      int c = ctl.get();</span><br><span class="line">      // workerCountOf返回线程池存活的线程的数量，如果小于corePoolSize核心线程数量</span><br><span class="line">      if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">          //创建一个新的线程去执行当前任务</span><br><span class="line">          if (addWorker(command, true))</span><br><span class="line">              //执行成功直接返回</span><br><span class="line">              return;</span><br><span class="line">          //因为线程池可能会把其他线程使用，所以在此获取ctl的值</span><br><span class="line">          c = ctl.get();</span><br><span class="line">      &#125;</span><br><span class="line">      // 线程的线程数大于等于corePoolSize，并且线程池正在运行isRunning=true,</span><br><span class="line">      // 并且任务入队成功：workQueue.offer(command)  = true</span><br><span class="line">      if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        // 重新获取ctl检查</span><br><span class="line">          int recheck = ctl.get();</span><br><span class="line">          //线程池已经关闭并且可以将刚才入队的【workQueue.offer(command)】删除掉成功</span><br><span class="line">          //(回滚操作)</span><br><span class="line">          if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">              // 执行拒绝策略</span><br><span class="line">              reject(command);</span><br><span class="line">          // 线程池正在运行，线程池可用线程数等于0</span><br><span class="line">          else if (workerCountOf(recheck) == 0)</span><br><span class="line">              // 创建新的线程去执行当前任务</span><br><span class="line">              addWorker(null, false);</span><br><span class="line">      &#125;</span><br><span class="line">      // 线程池被关闭，并且创建新的线程失败</span><br><span class="line">      else if (!addWorker(command, false))</span><br><span class="line">          // 拒绝策略</span><br><span class="line">          reject(command);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>addWorker方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Checks if a new worker can be added with respect to current</span><br><span class="line"> * pool state and the given bound (either core or maximum). If so,</span><br><span class="line"> * the worker count is adjusted accordingly, and, if possible, a</span><br><span class="line"> * new worker is created and started, running firstTask as its</span><br><span class="line"> * first task. This method returns false if the pool is stopped or</span><br><span class="line"> * eligible to shut down. It also returns false if the thread</span><br><span class="line"> * factory fails to create a thread when asked.  If the thread</span><br><span class="line"> * creation fails, either due to the thread factory returning</span><br><span class="line"> * null, or due to an exception (typically OutOfMemoryError in</span><br><span class="line"> * Thread.start()), we roll back cleanly.</span><br><span class="line"> * 检查一个新的word而是否能够添加进来，并且还会考虑当前线程池的状态以及边界</span><br><span class="line"> * （核心线程数和最大线程数），如果能够添加成功，那么wordercount就会被调整，新的worker</span><br><span class="line"> * 会被创建和启动，参数firstTask作为worder的第一个任务，如果线程池被停止了那么这个方法返回false，</span><br><span class="line"> * 如果线程工厂无法创建一个新的线程也会返回false，如果线程创建失败，可能是由于线程工厂创建失败，或者</span><br><span class="line"> * 由于一些异常导致，比如线程启动的时候出现OutOfMemoryError，这个时候程序就会进行回滚清理操作</span><br><span class="line"> * @param firstTask the task the new thread should run first (or</span><br><span class="line"> * null if none). Workers are created with an initial first task</span><br><span class="line"> * (in method execute()) to bypass queuing when there are fewer</span><br><span class="line"> * than corePoolSize threads (in which case we always start one),</span><br><span class="line"> * or when the queue is full (in which case we must bypass queue).</span><br><span class="line"> * Initially idle threads are usually created via</span><br><span class="line"> * prestartCoreThread or to replace other dying workers.</span><br><span class="line"> * 新创建的线程应该被执行的任务，worker会被创建出来，并且会有第一个任务(参数firstTask)</span><br><span class="line"> * 当总的线程数小于corePoolSize，会跳过加入阻塞队列的逻辑，会直接执行这个任务，如果阻塞</span><br><span class="line"> * 队列满了，也会绕过队列的加入逻辑，</span><br><span class="line"> * @param core if true use corePoolSize as bound, else</span><br><span class="line"> * maximumPoolSize. (A boolean indicator is used here rather than a</span><br><span class="line"> * value to ensure reads of fresh values after checking other pool</span><br><span class="line"> * state). 如果是true，使用corePoolSize作为边界，如果是false使用maximumPoolSize作为</span><br><span class="line"> * 边界，这个参数决定了线程是怎么创建，任务怎么往阻塞队列里边插入等等逻辑。</span><br><span class="line"> * @return true if successful</span><br><span class="line"> */</span><br><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">    //标签</span><br><span class="line">    retry:</span><br><span class="line">    //外层死循环</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">      //得到状态</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        //线程池运行状态</span><br><span class="line">        int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        // Check if queue empty only if necessary.</span><br><span class="line">        //条件A： 线程池状态是SHUTDOWN、STOP、TIDYING、TERMINATED</span><br><span class="line">        //条件B： 【线程池状态是SHUTDOWN 并且参数firstTask是空，并且任务阻塞不是空的】取反</span><br><span class="line">        if (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == null &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">               //创建失败</span><br><span class="line">            return false;</span><br><span class="line">        // 内存死循环</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            // 当前线程池的线程数量</span><br><span class="line">            int wc = workerCountOf(c);</span><br><span class="line">            // 线程数量大于等于线程数最大能表示的上限数量，或者大于等于上限，返回false，创建失败</span><br><span class="line">            if (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                // 创建失败</span><br><span class="line">                return false;</span><br><span class="line">            //增加线程池线程数量+1成功，退出到外层循环，程序往下走</span><br><span class="line">            if (compareAndIncrementWorkerCount(c))</span><br><span class="line">                break retry;</span><br><span class="line">            // 获取线程池ctl</span><br><span class="line">            c = ctl.get();  // Re-read ctl</span><br><span class="line">            // 线程池状态发生了变化</span><br><span class="line">            if (runStateOf(c) != rs)</span><br><span class="line">                // 外层循环执行，重新执行addWorker方法</span><br><span class="line">                continue retry;</span><br><span class="line">            //CAS失败，即，增加线程池线程数量CAS失败，内层循环执行一遍</span><br><span class="line">            // else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 工作线程是否启动</span><br><span class="line">    boolean workerStarted = false;</span><br><span class="line">    // 工作线程是否添加</span><br><span class="line">    boolean workerAdded = false;</span><br><span class="line">    Worker w = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        // Worker继承了AQS,代表了工作线程</span><br><span class="line">        w = new Worker(firstTask);</span><br><span class="line">        //得到线程对象</span><br><span class="line">        final Thread t = w.thread;</span><br><span class="line">        // 线程工厂创建线程失败</span><br><span class="line">        if (t != null) &#123;</span><br><span class="line">            // 获取到重入锁(排它锁)</span><br><span class="line">            final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">            //加锁</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                // Recheck while holding lock.</span><br><span class="line">                // Back out on ThreadFactory failure or if</span><br><span class="line">                // shut down before lock acquired.</span><br><span class="line">                // 再次检查线程池状态</span><br><span class="line">                int rs = runStateOf(ctl.get());</span><br><span class="line">                // 线程池状态是RUNNING，或者（线程池状态是SHUTDOWN 并且参数firstTask是空）</span><br><span class="line">                if (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</span><br><span class="line">                    //再次判断线程工厂创建的线程是可以启动的，如果不可用，直接抛出异常</span><br><span class="line">                    if (t.isAlive()) // precheck that t is startable</span><br><span class="line">                        throw new IllegalThreadStateException();</span><br><span class="line">                    //将新创建的线程添加到HashSet里边</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    //得到工作线程的数量</span><br><span class="line">                    int s = workers.size();</span><br><span class="line">                    //工作线程的数量大于largestPoolSize</span><br><span class="line">                    if (s &gt; largestPoolSize)</span><br><span class="line">                        //记录曾经最大的线程池的数量</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    // 标记新创建的线程添加成功</span><br><span class="line">                    workerAdded = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">              //解锁</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            //如果工作线程添加成功</span><br><span class="line">            if (workerAdded) &#123;</span><br><span class="line">                //启动工作线程</span><br><span class="line">                t.start();</span><br><span class="line">                //标记工作线程已经启动成功</span><br><span class="line">                workerStarted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      // 如果工作线程没有启动成功</span><br><span class="line">        if (! workerStarted)</span><br><span class="line">            //将线程从工作线程集合里边移除。相当于回滚</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    return workerStarted;</span><br><span class="line">&#125;</span><br><span class="line">private void addWorkerFailed(Worker w) &#123;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (w != null)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        //工作线程数量CAS减1</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        //尝试终止线程池</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Worker的构造器以及worker的主流程：<br>Worker继承了AbstractQueuedSynchronizer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private final class Worker extends AbstractQueuedSynchronizer implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">  Worker(Runnable firstTask) &#123;</span><br><span class="line">      //执行线程之前，线程不能被中断，其实是设置了AQS的state，中断的情况就是项城市的shutdown，</span><br><span class="line">      // stop之类的方法，这类方法在执行的时候会判断state是否大约等于0，小于0的-1不会被中断</span><br><span class="line">      setState(-1); // inhibit interrupts until runWorker</span><br><span class="line">      this.firstTask = firstTask;</span><br><span class="line">      this.thread = getThreadFactory().newThread(this);</span><br><span class="line">  &#125;</span><br><span class="line">  public void run() &#123;</span><br><span class="line">      runWorker(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意， getThreadFactory().newThread(this)传递的是this，也就是worker，当执行thread.start()的时候就会执行worker的run方法。<br>ThreadPoolExecutor当中的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line"> * Main worker run loop.  Repeatedly gets tasks from queue and</span><br><span class="line"> * executes them, while coping with a number of issues:</span><br><span class="line"> * 主要的worker循环，重复不断的从阻塞队列里边获取和执行任务。</span><br><span class="line"> * 1. We may start out with an initial task, in which case we</span><br><span class="line"> * don&#x27;t need to get the first one. Otherwise, as long as pool is</span><br><span class="line"> * running, we get tasks from getTask. If it returns null then the</span><br><span class="line"> * worker exits due to changed pool state or configuration</span><br><span class="line"> * parameters.  Other exits result from exception throws in</span><br><span class="line"> * external code, in which case completedAbruptly holds, which</span><br><span class="line"> * usually leads processWorkerExit to replace this thread.</span><br><span class="line"> *</span><br><span class="line"> * 2. Before running any task, the lock is acquired to prevent</span><br><span class="line"> * other pool interrupts while the task is executing, and then we</span><br><span class="line"> * ensure that unless pool is stopping, this thread does not have</span><br><span class="line"> * its interrupt set.</span><br><span class="line"> *</span><br><span class="line"> * 3. Each task run is preceded by a call to beforeExecute, which</span><br><span class="line"> * might throw an exception, in which case we cause thread to die</span><br><span class="line"> * (breaking loop with completedAbruptly true) without processing</span><br><span class="line"> * the task.</span><br><span class="line"> *</span><br><span class="line"> * 4. Assuming beforeExecute completes normally, we run the task,</span><br><span class="line"> * gathering any of its thrown exceptions to send to afterExecute.</span><br><span class="line"> * We separately handle RuntimeException, Error (both of which the</span><br><span class="line"> * specs guarantee that we trap) and arbitrary Throwables.</span><br><span class="line"> * Because we cannot rethrow Throwables within Runnable.run, we</span><br><span class="line"> * wrap them within Errors on the way out (to the thread&#x27;s</span><br><span class="line"> * UncaughtExceptionHandler).  Any thrown exception also</span><br><span class="line"> * conservatively causes thread to die.</span><br><span class="line"> *</span><br><span class="line"> * 5. After task.run completes, we call afterExecute, which may</span><br><span class="line"> * also throw an exception, which will also cause thread to</span><br><span class="line"> * die. According to JLS Sec 14.20, this exception is the one that</span><br><span class="line"> * will be in effect even if task.run throws.</span><br><span class="line"> *</span><br><span class="line"> * The net effect of the exception mechanics is that afterExecute</span><br><span class="line"> * and the thread&#x27;s UncaughtExceptionHandler have as accurate</span><br><span class="line"> * information as we can provide about any problems encountered by</span><br><span class="line"> * user code.</span><br><span class="line"> *</span><br><span class="line"> * @param w the worker</span><br><span class="line"> */</span><br><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">    //获取到当前线程对象</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    // worker创建后，第一个任务</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    // 任务已经已经暂存，防止下次再次传递进来，造成错乱</span><br><span class="line">    w.firstTask = null;</span><br><span class="line">    // aqs的解锁，将aqs的state设置为0，即，设置线程可以被中断（线程可以被shutdown），实现在Worker的tryRelease</span><br><span class="line">    // 方法里边对state设置为0</span><br><span class="line">    w.unlock(); // allow interrupts</span><br><span class="line">    //完成标记</span><br><span class="line">    boolean completedAbruptly = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        //初始任务不是空，优先执行第一个任务，否则再去阻塞队列拉取任务执行。</span><br><span class="line">        while (task != null || (task = getTask()) != null) &#123;</span><br><span class="line">            // 加锁处理，将aqs的state由0设置为1</span><br><span class="line">            w.lock();</span><br><span class="line">            // If pool is stopping, ensure thread is interrupted;</span><br><span class="line">            // if not, ensure thread is not interrupted.  This</span><br><span class="line">            // requires a recheck in second case to deal with</span><br><span class="line">            // shutdownNow race while clearing interrupt</span><br><span class="line">            // 如果线程池停止了，要确保线程是中断的，</span><br><span class="line">            // 如果线程池不是停止状态，要确保线程没有被中断</span><br><span class="line">            // 这里二次确认shutdownnow导致的停止</span><br><span class="line">            if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            try &#123;</span><br><span class="line">                // 在执行任务之前的一些预先的逻辑，默认空实现，用于继承ThreadPoolExecutor的子类去实现</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //真正执行任务</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Error x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Throwable x) &#123;</span><br><span class="line">                    thrown = x; throw new Error(x);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    //真正的任务执行之后的逻辑，默认空实现，用于继承ThreadPoolExecutor的子类去实现</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // 执行完毕置空，help GC</span><br><span class="line">                task = null;</span><br><span class="line">                //woker成功执行完毕的任务数量，是woker的一个计数器</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                //解锁</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 处理worker的退出</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void processWorkerExit(Worker w, boolean completedAbruptly) &#123;</span><br><span class="line">    // 如果woker处理任务完毕，那么将线程池线程数量减一</span><br><span class="line">    if (completedAbruptly) // If abrupt, then workerCount wasn&#x27;t adjusted</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">    // 得到排它锁</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    //加锁</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 线程池完成的总的任务数</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        //线程从集合当中删除</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      //解锁</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    //尝试终止</span><br><span class="line">    tryTerminate();</span><br><span class="line">    //再次获取线程池状态</span><br><span class="line">    int c = ctl.get();</span><br><span class="line">    //状态是running或者shutdown状态，之后判断是否要创建新的线程去完成一些工作</span><br><span class="line">    if (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        if (!completedAbruptly) &#123;</span><br><span class="line">            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;</span><br><span class="line">            if (min == 0 &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = 1;</span><br><span class="line">            if (workerCountOf(c) &gt;= min)</span><br><span class="line">                return; // replacement not needed</span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h5 id="关于线程池的关闭"><a href="#关于线程池的关闭" class="headerlink" title="关于线程池的关闭"></a>关于线程池的关闭</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">将已经积存的任务执行完毕，不接受新的任务，重复执行这个方法没有任何副作用</span><br><span class="line">public void shutdown() &#123;</span><br><span class="line">    // 获取线程池的排它锁</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    //加锁</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        //权限检查，是否当前线程可以进行一些操作</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        //将线程池状态设置为shutdown状态</span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        // 中断空闲的worker线程</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        //回调函数，默认空实现</span><br><span class="line">        onShutdown(); // hook for ScheduledThreadPoolExecutor</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//无限循环cas设置状态，runStateAtLeast意思是检查运行中的状态至少是targetState这个状态</span><br><span class="line">private void advanceRunState(int targetState) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        if (runStateAtLeast(c, targetState) ||</span><br><span class="line">            ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void interruptIdleWorkers() &#123;</span><br><span class="line">    interruptIdleWorkers(false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void interruptIdleWorkers(boolean onlyOne) &#123;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        for (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            //工作线程没有被中断，并且能获取锁（woker执行run的时候是加锁的，这里能得到锁的都是空闲线程）</span><br><span class="line">            if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                   //执行中断</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; catch (SecurityException ignore) &#123;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    //解锁</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (onlyOne)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final void tryTerminate() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        // 对不能Terminate的线程池状态执行程序返回</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        if (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            return;</span><br><span class="line">        if (workerCountOf(c) != 0) &#123; // Eligible to terminate</span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            //当前是TIDYING状态才能置为terminate</span><br><span class="line">            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, 0));</span><br><span class="line">                    // private final Condition termination = mainLock.newCondition();</span><br><span class="line">                    // 尝试阻塞在调用终止线程池方法的线程，将他们唤醒，其中有一个方法是awaitTermination</span><br><span class="line">                    // awaitTermination阻塞在termination上</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        // else retry on failed CAS</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //</span><br><span class="line">  public List&lt;Runnable&gt; shutdownNow() &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        //状态置位stop</span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        //中断所有线程，无论是否在执行</span><br><span class="line">        interruptWorkers();</span><br><span class="line">        //将阻塞队列里边的任务清空，丢弃，返回</span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    //</span><br><span class="line">    tryTerminate();</span><br><span class="line">    return tasks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void interruptWorkers() &#123;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">      //不区分是否空闲，直接循环工作线程集合，全部中断</span><br><span class="line">        for (Worker w : workers)</span><br><span class="line">            w.interruptIfStarted();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Blocks until all tasks have completed execution after a shutdown request, or the timeout occurs, or the current thread is interrupted, whichever happens first.</span><br><span class="line">//当调用了shutdown请求后，阻塞等待所有的任务完成，或者超时发生返回，或者当前线程被中断返回</span><br><span class="line">public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">    long nanos = unit.toNanos(timeout);</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            if (runStateAtLeast(ctl.get(), TERMINATED))</span><br><span class="line">                return true;</span><br><span class="line">            if (nanos &lt;= 0)</span><br><span class="line">                return false;</span><br><span class="line">            //tryTerminate方法里边 termination.signalAll()会唤醒这里的wait</span><br><span class="line">            nanos = termination.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="等待任务完成"><a href="#等待任务完成" class="headerlink" title="等待任务完成"></a>等待任务完成</h5><p>ThreadPoolExecutor的submit方法通过newTaskFor方法返回一个FutureTask对象，提交任务到线程池之后调用FutureTask的get方法阻塞得到返回值，等待任务的完成，那么怎样才算是任务完成呢，其实state状态取值标志了任务是否完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The run state of this task, initially NEW.  The run state</span><br><span class="line"> * transitions to a terminal state only in methods set,</span><br><span class="line"> * setException, and cancel.  During completion, state may take on</span><br><span class="line"> * transient values of COMPLETING (while outcome is being set) or</span><br><span class="line"> * INTERRUPTING (only while interrupting the runner to satisfy a</span><br><span class="line"> * cancel(true)). Transitions from these intermediate to final</span><br><span class="line"> * states use cheaper ordered/lazy writes because values are unique</span><br><span class="line"> * and cannot be further modified.</span><br><span class="line"> *</span><br><span class="line"> * Possible state transitions:</span><br><span class="line"> * NEW -&gt; COMPLETING -&gt; NORMAL</span><br><span class="line"> * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span><br><span class="line"> * NEW -&gt; CANCELLED</span><br><span class="line"> * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span><br><span class="line"> */</span><br><span class="line">private volatile int state;</span><br><span class="line">private static final int NEW          = 0;</span><br><span class="line">private static final int COMPLETING   = 1;</span><br><span class="line">private static final int NORMAL       = 2;</span><br><span class="line">private static final int EXCEPTIONAL  = 3;</span><br><span class="line">private static final int CANCELLED    = 4;</span><br><span class="line">private static final int INTERRUPTING = 5;</span><br><span class="line">private static final int INTERRUPTED  = 6;</span><br><span class="line"></span><br><span class="line">//FutureTask创建的时候state是NEW</span><br><span class="line">public FutureTask(Runnable runnable, V result) &#123;</span><br><span class="line">    this.callable = Executors.callable(runnable, result);</span><br><span class="line">    this.state = NEW;       // ensure visibility of callable</span><br><span class="line">&#125;</span><br><span class="line">public V get() throws InterruptedException, ExecutionException &#123;</span><br><span class="line">    int s = state;</span><br><span class="line">    //状态是NEW、COMPLETING执行等待</span><br><span class="line">    if (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(false, 0L);</span><br><span class="line">    //report返回任务执行的结果</span><br><span class="line">    return report(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//run方法是对任务执行过程外层抽象逻辑的封装</span><br><span class="line">public void run() &#123;</span><br><span class="line">  //状态校验</span><br><span class="line">    if (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(this, runnerOffset,</span><br><span class="line">                                     null, Thread.currentThread()))</span><br><span class="line">        return;</span><br><span class="line">    try &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        if (c != null &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            boolean ran;</span><br><span class="line">            try &#123;</span><br><span class="line">                //任务执行</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = true;</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                result = null;</span><br><span class="line">                ran = false;</span><br><span class="line">                //设置state为任务执行失败</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            if (ran)</span><br><span class="line">            //设置状态为完成</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // runner must be non-null until state is settled to</span><br><span class="line">        // prevent concurrent calls to run()</span><br><span class="line">        runner = null;</span><br><span class="line">        // state must be re-read after nulling runner to prevent</span><br><span class="line">        // leaked interrupts</span><br><span class="line">        int s = state;</span><br><span class="line">        if (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当我们把一个任务扔到了线程池当中，我们可以通过get方法获取任务的执行结果，倘若我们的线程池满了，会回调拒绝策略，而恰好我们拒绝策略是DiscardPolicy无声丢弃或者DiscardOldestPolicy，DiscardPolicy的rejectedExecution方法是一个空实现，被丢弃的任务(FutureTask)的默认状态是NEW，此时我们调用get方法等待任务返回结果，后果就是get方法永远也不会返回！</strong></p>
<p>因此建议使用带有超时时间的get方法。</p>
<h4 id="forkjoin框架"><a href="#forkjoin框架" class="headerlink" title="forkjoin框架"></a>forkjoin框架</h4><p>ForkJoinPool的主要使用场景比如：<br>一批任务，有的任务很快执行完毕，有的任务会执行的很慢，这样导致了普通的线程池存在部分线程很忙，部分线程很闲，出现了分配不均衡的现象。<br>ForkJoinPool也是间接实现了ExecutorService</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class ForkJoinPool extends AbstractExecutorService &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>forkjoin会对一个大任务进行不断的拆解，拆解的过程就是fork的过程，直到fork的粒度足够小，然后对这些小任务进行执行，最后将执行完毕的小人物的结果进行合并，即，join的过程，最后会合并成一个结果，这个结果就是大任务的结果：<br><img src="/fork-join.png" alt="fork-join.png"></p>
<h5 id="任务窃取"><a href="#任务窃取" class="headerlink" title="任务窃取"></a>任务窃取</h5><p><img src="/fork-join-task-steal.png" alt="fork-join-task-steal.png"></p>
<p>线程池每个线程都有一个任务队列，但是实际情况当中，有些任务比较简单，有些任务比较复杂，他们各自的执行时间长短不同，当一个线程执行完他自己的队列里边的任务的时候，会从其他线程的队列里边窃取任务执行，这里的队列都是双向的队列，两端都可以pop一个任务，当然这个要保证是线程安全的。</p>
<h4 id="源码介绍"><a href="#源码介绍" class="headerlink" title="源码介绍"></a>源码介绍</h4><p>ForkJoinPool构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private ForkJoinPool(int parallelism,</span><br><span class="line">                     ForkJoinWorkerThreadFactory factory,</span><br><span class="line">                     UncaughtExceptionHandler handler,</span><br><span class="line">                     int mode,</span><br><span class="line">                     String workerNamePrefix) &#123;</span><br><span class="line">    this.workerNamePrefix = workerNamePrefix; //线程名字前缀</span><br><span class="line">    this.factory = factory; //类似于线程池里边的线程工厂</span><br><span class="line">    this.ueh = handler;</span><br><span class="line">    this.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">    long np = (long)(-parallelism); // offset ctl counts</span><br><span class="line">    this.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ForkJoinWorkerThreadFactory创建的时候，会创建一个队列:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected ForkJoinWorkerThread(ForkJoinPool pool) &#123;</span><br><span class="line">    // Use a placeholder until a useful name can be set in registerWorker</span><br><span class="line">    super(&quot;aForkJoinWorkerThread&quot;);</span><br><span class="line">    this.pool = pool;</span><br><span class="line">    this.workQueue = pool.registerWorker(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个队列就是线程对应的任务队列。</p>
<h5 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h5><p>ForkJoinTask是forkjoinpool执行的任务的抽象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ForkJoinTask&lt;V&gt; implements Future&lt;V&gt;, Serializable &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RecursiveAction和RecursiveTask都实现了ForkJoinTask，RecursiveAction的compute没有返回值，RecursiveTask的compute方法是有返回值的。<br>在使用ForkJoinPool的时候，任务抽象的时候，如果任务有返回值，那么就是用RecursiveTask，否则使用RecursiveAction。</p>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = new ForkJoinPool();</span><br><span class="line">        MyTask myTask = new MyTask(1,100);</span><br><span class="line">        int  result = forkJoinPool.invoke(myTask);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        forkJoinPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyTask extends RecursiveTask&lt;Integer&gt;&#123;</span><br><span class="line"></span><br><span class="line">    private int limit = 4;</span><br><span class="line">    private int firstIndex;</span><br><span class="line">    private int lastIndex ;</span><br><span class="line">    MyTask(int firstIndex,int lastIndex)&#123;</span><br><span class="line">        this.firstIndex = firstIndex;</span><br><span class="line">        this.lastIndex = lastIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Integer compute() &#123;</span><br><span class="line">        int gap = this.lastIndex - this.firstIndex;</span><br><span class="line">        boolean flag = gap &lt;= this.limit;</span><br><span class="line">        int result = 0;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            for(int i=this.firstIndex;i&lt;=this.lastIndex;++i)&#123;</span><br><span class="line">                result +=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            int middleIndex = (this.firstIndex + this.lastIndex)/2;</span><br><span class="line">            MyTask leftTask = new MyTask(this.firstIndex,middleIndex);</span><br><span class="line">            MyTask rightTask = new MyTask(middleIndex + 1,this.lastIndex);</span><br><span class="line">            invokeAll(leftTask, rightTask);</span><br><span class="line">            result = leftTask.join() + rightTask.join();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果:<br>ForkJoinPool-1-worker-1<br>ForkJoinPool-1-worker-1<br>ForkJoinPool-1-worker-1<br>ForkJoinPool-1-worker-4<br>ForkJoinPool-1-worker-3<br>ForkJoinPool-1-worker-3<br>ForkJoinPool-1-worker-1<br>ForkJoinPool-1-worker-7<br>ForkJoinPool-1-worker-7<br>ForkJoinPool-1-worker-3<br>ForkJoinPool-1-worker-3<br>ForkJoinPool-1-worker-2<br>ForkJoinPool-1-worker-2<br>ForkJoinPool-1-worker-5<br>ForkJoinPool-1-worker-5<br>ForkJoinPool-1-worker-4<br>ForkJoinPool-1-worker-4<br>ForkJoinPool-1-worker-4<br>ForkJoinPool-1-worker-5<br>ForkJoinPool-1-worker-2<br>ForkJoinPool-1-worker-2<br>ForkJoinPool-1-worker-3<br>ForkJoinPool-1-worker-3<br>ForkJoinPool-1-worker-7<br>ForkJoinPool-1-worker-0<br>ForkJoinPool-1-worker-0<br>ForkJoinPool-1-worker-6<br>ForkJoinPool-1-worker-1<br>ForkJoinPool-1-worker-0<br>ForkJoinPool-1-worker-3<br>ForkJoinPool-1-worker-2<br>ForkJoinPool-1-worker-4<br>5050</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>Post author:  </strong>CeaserWang
  </li>
  <li class="post-copyright-link">
      <strong>Post link: </strong>
      <a href="https://ceaser.wang/2020/06/26/Concurrent/concurrency(13)ThreadPool/" title="concurrency(13)ThreadPool">https://ceaser.wang/2020/06/26/Concurrent/concurrency(13)ThreadPool/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/ThreadPool-ForkJoinPool/" rel="tag"><i class="fa fa-tag"></i> ThreadPool ForkJoinPool</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/06/25/spring_boot_and_cloud/spring_boot_cloud(21)distribute_transaction/" rel="prev" title="spring_boot_cloud(21)distribute_transaction">
                  <i class="fa fa-chevron-left"></i> spring_boot_cloud(21)distribute_transaction
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/06/30/Concurrent/concurrency(14)CompletionService/" rel="next" title="concurrency(14)CompletionService">
                  concurrency(14)CompletionService <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2015 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CeaserWang</span>
</div>
  <div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9tdXNlLw==">NexT.Muse</span>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.1/mermaid.min.js","integrity":"sha256-8L3O8tirFUa8Va4NSTAyIbHJeLd6OnlcxgupV9F77e0="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>

  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>

  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"ryAR9bttS7fex1FPEPAylmmJ-gzGzoHsz","app_key":"dYqygoN4Y01Bl38OdRoCHUYn","server_url":null,"security":false}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>



</body>
</html>
