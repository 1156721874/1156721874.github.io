<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1-docker-使用镜像</title>
    <url>/2018/11/18/1-docker-%E4%BD%BF%E7%94%A8%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h1 id="获取docker-镜像"><a href="#获取docker-镜像" class="headerlink" title="获取docker 镜像"></a>获取docker 镜像</h1><h2 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h2><span id="more"></span>
<p>docker hub：<span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbS9leHBsb3JlLw==">https://hub.docker.com/explore/<i class="fa fa-external-link-alt"></i></span><br>  从 Docker 镜像仓库获取镜像的命令是 docker pull：<br>  docker pull [选项] [Docker Registry 地址[:端口号]&#x2F;]仓库名[:标签]<br>  example：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull myregistry.local:5000/testing/test-image</span><br><span class="line">docker pull centos:7</span><br><span class="line">docker pull tdlceaserwang/repository/jdk8DoclerFile:v1</span><br></pre></td></tr></table></figure></p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>  example：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --rm \</span><br><span class="line">ubuntu:16.04 \</span><br><span class="line">bash</span><br></pre></td></tr></table></figure><br>  -it ：这是两个参数，一个是 -i ：交互式操作，一个是 -t 终端。我们这里打算进入<br>  bash 执行一些命令并查看返回结果，因此我们需要交互式终端。<br>  –rm ：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容<br>  器并不会立即删除，除非手动 docker rm 。我们这里只是随便执行个命令，看看结果，<br>  不需要排障和保留结果，因此使用 –rm 可以避免浪费空间。<br>  ubuntu:16.04 ：这是指用 ubuntu:16.04 镜像为基础来启动容器。<br>  bash ：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash</p>
<h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure>

<p>  <img src="/2018-11-18/1-docker-%E4%BD%BF%E7%94%A8%E9%95%9C%E5%83%8F/1-1.png" alt="1-1"><br>  查看镜像、容器、数据卷所占用的空间:<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker system df</span><br></pre></td></tr></table></figure><br>  <img src="/2018-11-18/1-docker-%E4%BD%BF%E7%94%A8%E9%95%9C%E5%83%8F/1-2.png" alt="1-2"></p>
<h2 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h2><p>  定义：镜像既没有仓库名，也没有标签，均为 <none><br>  列出虚悬镜像：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker image ls -f dangling=true</span><br></pre></td></tr></table></figure><br>  删除虚悬镜像(dangling image)：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure></p>
<h2 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h2><p>  为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。所以在使用一段时间后，可<br>  能会看到一些依赖的中间层镜像。默认的 docker image ls 列表中只会显示顶层镜像，如果<br>  希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参:<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker image ls -a</span><br></pre></td></tr></table></figure><br>  ps:删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除.</p>
<h3 id="过滤器参数"><a href="#过滤器参数" class="headerlink" title="过滤器参数"></a>过滤器参数</h3><p>  example:<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker image ls -f since=mongo:3.2</span><br><span class="line"># 想查看某个位置之前的镜像也可以，只需要把 since 换成 before 即可</span><br></pre></td></tr></table></figure></p>
<h2 id="以特定格式显示"><a href="#以特定格式显示" class="headerlink" title="以特定格式显示"></a>以特定格式显示</h2>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker image ls -q</span><br></pre></td></tr></table></figure>
<p>  结果：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">75835a67d134</span><br><span class="line">cae870735e91</span><br></pre></td></tr></table></figure><br>  –filter 配合 -q 产生出指定范围的 ID 列表，然后送给另一个 docker 命令作为参数</p>
<h3 id="Go-的模板语法"><a href="#Go-的模板语法" class="headerlink" title="Go 的模板语法"></a>Go 的模板语法</h3>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker image ls --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>  结果：<br>  75835a67d134: centos<br>  cae870735e91: docker4w&#x2F;nsenter-dockerd</p>
<h2 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h2><p>  docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; …]</p>
<p>  其中， &lt;镜像&gt; 可以是 镜像短 ID 、 镜像长 ID 、 镜像名 或者 镜像摘要</p>
<p>  example：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker image rm 501</span><br><span class="line"># 或者</span><br><span class="line">docker image rm centos</span><br></pre></td></tr></table></figure></p>
<p>  结果：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Untagged: centos:latest</span><br><span class="line">Untagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c</span><br><span class="line">Deleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a</span><br><span class="line">Deleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38</span><br></pre></td></tr></table></figure></p>
<h3 id="Untagged-和-Deleted"><a href="#Untagged-和-Deleted" class="headerlink" title="Untagged 和 Deleted"></a>Untagged 和 Deleted</h3><p>  上边的删除分了Untagged 和 Deleted2步，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。Untagged是删除镜像的标签，当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除，如果某个层其他镜像有依赖，或者某个容器有依赖（不论容器是否运行）都不会删除本层。</p>
<h3 id="用-docker-image-ls-命令来配合"><a href="#用-docker-image-ls-命令来配合" class="headerlink" title="用 docker image ls 命令来配合"></a>用 docker image ls 命令来配合</h3><pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker image rm $(docker image ls -q redis)</span><br><span class="line">docker image rm $(docker image ls -q -f before=mongo:3.2)</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h2><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t nginx:v3 .</span><br></pre></td></tr></table></figure>

<h3 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h3><p>  shell 格式:<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure></p>
<p>  exec 格式: RUN [“可执行文件”, “参数1”, “参数2”] ，这更像是函数调用中的格式</p>
<h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h3><p>  格式：COPY &lt;源路径&gt;… &lt;目标路径&gt;<br>  example：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COPY package.json /usr/src/app/</span><br></pre></td></tr></table></figure><br>  &lt;源路径&gt; 可以是多个，甚至可以是通配符:<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br></pre></td></tr></table></figure><br>  ps:使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等</p>
<h3 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h3><p>  ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能.<br>  比如 &lt;源路径&gt; 可以是一个 URL,这种情况下，Docker 引擎会试图去下载这个链接的文件放到 &lt;目标路径&gt; 去。下载后的文件权限自动设置为 600 ，如果这并不是想要的权限，那么还需要增加额外的一层 RUN 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 RUN 指令进行解压缩。所以不如直接使用 RUN 指令，然后使用 wget 或者 curl 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</p>
<p>  **<br>  如果 &lt;源路径&gt; 为一个 tar 压缩文件的话，压缩格式为 gzip , bzip2 以及 xz 的情况<br>  下， ADD 指令将会自动解压缩这个压缩文件到 &lt;目标路径&gt; 去。<br>  **</p>
<p>  因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用COPY 指令，仅在需要自动解压缩的场合使用 ADD 。</p>
<h3 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h3><p>  格式:<br>  shell 格式： CMD &lt;命令&gt;<br>  exec 格式： CMD [“可执行文件”, “参数1”, “参数2”…]<br>  参数列表格式： CMD [“参数1”, “参数2”…] 。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。<br>  在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此 一定要使用双引号 “ ，而不要使用单引号。<br>  如果使用 shell 格式的话，实际的命令会被包装为 sh -c 的参数的形式进行执行。比如：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMD echo $HOME</span><br></pre></td></tr></table></figure></p>
<p>  在实际执行中，会将其变更为：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</span><br></pre></td></tr></table></figure></p>
<p>  <strong>sh -c：</strong><br>  c string<br>  If the -c option is present, then commands are read from string. If there are arguments after the string, they are assigned to the positional parameters, starting with $0.<br>  翻译一下就是： 如果-c 选项存在，命令就从字符串中读取。如果字符串后有参数，他们将会被分配到参数的位置上，从$0开始。<br>  &#x2F;bin&#x2F;sh -c 命令<br>  可以用shell执行指定的命令<br>  这里<br>  &#x2F;bin&#x2F;sh -c ls<br>  会执行ls命令（列出文件）</p>
<p>  Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。 CMD 指令就是用于指定默认的容器主进程的启动命令的。</p>
<p>  错误事例：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMD service nginx start</span><br></pre></td></tr></table></figure></p>
<p>  CMD service nginx start 会被理解为 CMD [ “sh”, “-c”, “service nginxstart”] ，因此主进程实际上是 sh 。那么当 service nginx start 命令结束后， sh 也就结束了， sh 作为主进程退出了，自然就会令容器退出。</p>
<p>  正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。比如：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure></p>
<h3 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h3><p>  ENTRYPOINT 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。<br>  两种格式：</p>
<pre><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]
ENTRYPOINT command param1 param2（shell中执行）。
</code></pre>
<p>  当指定了 ENTRYPOINT 后， CMD 的含义就发生了改变，不再是直接的运行其命令，而是将<br>  CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</span><br></pre></td></tr></table></figure><br>  ENTRYPOINT和CMD配置，让容器像命令一样使用：</p>
<h4 id="example-A："><a href="#example-A：" class="headerlink" title="example A："></a>example A：</h4><p>  Dockerfile:<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">RUN apt-get update \</span><br><span class="line">&amp;&amp; apt-get install -y curl \</span><br><span class="line">&amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://ip.cn&quot; ]</span><br></pre></td></tr></table></figure><br>  运行：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run myip</span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br><span class="line">$ docker run myip -i</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.8.0</span><br><span class="line">Date: Tue, 22 Nov 2016 05:12:40 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Powered-By: PHP/5.6.24-1~dotdeb+7.1</span><br><span class="line">X-Cache: MISS from cache-2</span><br><span class="line">X-Cache-Lookup: MISS from cache-2:80</span><br><span class="line">X-Cache: MISS from proxy-2_6</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Via: 1.1 cache-2:80, 1.1 proxy-2_6:8006</span><br><span class="line">Connection: keep-alive</span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br></pre></td></tr></table></figure></p>
<h4 id="example-B："><a href="#example-B：" class="headerlink" title="example B："></a>example B：</h4><p>  启动容器之前要做一些准备工作，我们可以写一个脚本，然后ENTRYPOINT 脚本，脚本的参数就是CMD，我们可以在脚本中前边执行初始化，然后在最后执行cmd里边的命令。<br>  example:<br>  redis的镜像：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM alpine:3.4</span><br><span class="line">...</span><br><span class="line">创建redis用户</span><br><span class="line">RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis</span><br><span class="line">...</span><br><span class="line">ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]</span><br><span class="line">EXPOSE 6379</span><br><span class="line">#redis-server会作为docker-entrypoint.sh的参数</span><br><span class="line">CMD [ &quot;redis-server&quot; ]</span><br></pre></td></tr></table></figure></p>
<p>  docker-entrypoint.sh：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"># allow the container to be started with `--user`</span><br><span class="line">#判断CMD的是不是redis-server，是的切换到redis用户，执行第一个参数，即，  CMD [ &quot;redis-server&quot; ]里边的redis-server</span><br><span class="line">if [ &quot;$1&quot; = &#x27;redis-server&#x27; -a &quot;$(id -u)&quot; = &#x27;0&#x27; ]; then</span><br><span class="line">chown -R redis .</span><br><span class="line">exec su-exec redis &quot;$0&quot; &quot;$@&quot;</span><br><span class="line">fi</span><br><span class="line">exec &quot;$@&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h2><p>  格式有两种：</p>
<ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li>
</ul>
<p>  换行、有空格的情况，加引号：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENV VERSION=1.0 DEBUG=on \</span><br><span class="line">NAME=&quot;Happy Feet&quot;</span><br></pre></td></tr></table></figure></p>
<p>  可以使用环境变量的指令：<br>  ADD 、 COPY 、 ENV 、 EXPOSE 、 LABEL 、 USER 、 WORKDIR 、 VOLUME 、 STOPSIGNAL 、 ONBU、ILD 。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENV NODE_VERSION 7.2.0</span><br><span class="line">RUN curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.ta  r.xz&quot; \</span><br><span class="line">&amp;&amp; curl -SLO &quot;https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot; \</span><br><span class="line">&amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \</span><br><span class="line">&amp;&amp; grep &quot; node-v$NODE_VERSION-linux-x64.tar.xz\$&quot; SHASUMS256.txt | sha256sum -c - \</span><br><span class="line">&amp;&amp; tar -xJf &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot; -C /usr/local --strip-components=1 \</span><br><span class="line">&amp;&amp; rm &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot; SHASUMS256.txt.asc SHASUMS256.txt \</span><br><span class="line">&amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs</span><br></pre></td></tr></table></figure>

<h2 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h2><p>  和ENV一样，差别是ARG只能在容器build的时候能用，容器启动之后是不可见的，但是依然会存在容器的历史当中(dcker history)，所以不要ARG保存密码等敏感信息。<br>  ARG一般用来占位，用做默认值写在Dockfile里边。但是ARG可以被–build-arg覆盖，–build-arg里边的参数，不强制要求必须要在Dockerfile里边定义。</p>
<h2 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h2><p>  格式为：</p>
<ul>
<li>VOLUME [“&lt;路径1&gt;”, “&lt;路径2&gt;”…]</li>
<li>VOLUME &lt;路径&gt;</li>
</ul>
<p>  容器运行时，尽量保持容器存储层不发生写操作，对于数据库这类应用，存在动态数据，数据文件不应该写在容器的存储层，而是应该写在juan里边，<br>  比如VOLUME &#x2F;data ，容器运行的时候，任何向&#x2F;data写入的数据都不会存到容器的存储层。<br>  VOLUME可以被覆盖：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -v mydata:/data xxxx</span><br></pre></td></tr></table></figure><br>  在这行命令中，就使用了 mydata 这个命名卷挂载到了 &#x2F;data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。</p>
<h2 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h2><p>  格式为 EXPOSE &lt;端口1&gt; [&lt;端口2&gt;…] 。<br>  EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。<br>  docker run -P 时，会自动随机映射 EXPOSE 的端口,要将 EXPOSE 和在运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。 -p ，是映射宿主端口和<br>  容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明, 容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
<h2 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h2><p>  格式为 WORKDIR &lt;工作目录路径&gt; 。<br>  WORKDIR用来指定工作目录，或者当前目录，指定之后，以后各层的工作目录  都是这个WORKDIR指定的目录，我们知道每个Dockerfile 里边的命令都是一层，层与层之间的内存执行环境是不可见的，他们的执行环境不一样，错误实例：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RUN cd /app</span><br><span class="line">RUN echo &quot;hello&quot; &gt; world.txt</span><br></pre></td></tr></table></figure><br>  第一层  RUN cd &#x2F;app只是在内存中修改一些，当执行RUN echo “hello” &gt; world.txt时，就会找不到world.txt这个文件。第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关<br>  系，自然不可能继承前一层构建过程中的内存变化。<br>  WORKDIR可以指定以后各层都在一个目录下工作。</p>
<h2 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h2><p>  格式： USER &lt;用户名&gt;<br>  USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。 WORKDIR 是改变工作目录， USER 则是改变之后层的执行 RUN , CMD 以及 ENTRYPOINT 这类命令的身份。<br>  比如我们希望执行一个命令使用另外一个已经存在的用户去执行，不要使用 su或者sudo，这写需要很麻烦的配置，我们可以使用gosu；<br>  example：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span><br><span class="line">RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br><span class="line"># 下载 gosu</span><br><span class="line">RUN wget -O /usr/local/bin/gosu &quot;https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64&quot; \</span><br><span class="line">&amp;&amp; chmod +x /usr/local/bin/gosu \</span><br><span class="line">&amp;&amp; gosu nobody true</span><br><span class="line"># 设置 CMD，并以另外的用户执行</span><br><span class="line">CMD [ &quot;exec&quot;, &quot;gosu&quot;, &quot;redis&quot;, &quot;redis-server&quot; ]</span><br><span class="line">USER 指定当前用户</span><br></pre></td></tr></table></figure></p>
<h2 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h2><p>  格式： ONBUILD &lt;其它指令&gt; 。<br>  ONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN , COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。<br>  因此我们可以使用ONBUILD用在基础镜像里边，example：<br>  基础镜像文件A：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM node:slim</span><br><span class="line">RUN mkdir /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">ONBUILD COPY ./package.json /app</span><br><span class="line">ONBUILD RUN [ &quot;npm&quot;, &quot;install&quot; ]</span><br><span class="line">ONBUILD COPY . /app/</span><br><span class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</span><br></pre></td></tr></table></figure><br>  前缀带有ONBUILD的在构建基础镜像A本身的时候，并不会执行，只有在其他 镜像from A的时候，ONBUILD的命令才会执行。<br>  其他镜像可以如些写法：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM my-node</span><br></pre></td></tr></table></figure><br>  只需要一行指令，就可以将当前的一个前端项目启动起来。</p>
<h2 id="多阶段构建"><a href="#多阶段构建" class="headerlink" title="多阶段构建"></a>多阶段构建</h2><p>  在 Docker 17.05 版本之前docker支持多阶段构建, 比如我们要在一个容器中使用go语言的一个软件，我们使用源码编译，首先需要在容器里边安装go的编译器，然后将软件拷贝到容器，执行编译，最后拿到编译结果；编译器和最终编译出来的结果都在一个容器里边，其实我们只需要的是最终的编译结果，中间的编译器是不需要在最终保留的，那么这就可是使用docker的最新的特性—多阶段编译，只需要一个dockerfile，里边可以包含多个from指令，多个 FROM 指令并不是为了生成多根的层关系，最后生成的镜像，仍以最后一条 FROM 为准，之前的 FROM 会被抛弃，那么之前的FROM 又有什么意义呢？<br>  每一条 FROM 指令都是一个构建阶段，多条 FROM 就是多阶段构建，虽然最后生成的镜像只能是最后一个阶段的结果，但是，能够将前置阶段中的文件拷贝到后边的阶段中，这就是多阶段构建的最大意义。<br>  最大的使用场景是将编译环境和运行环境分离，比如，我们需要构建一个Go语言程序，那么就需要用到go命令等编译环境，我们的Dockerfile是这样的：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 编译阶段</span><br><span class="line">FROM golang:1.10.3</span><br><span class="line"></span><br><span class="line">COPY server.go /build/</span><br><span class="line"></span><br><span class="line">WORKDIR /build</span><br><span class="line"></span><br><span class="line">RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 GOARM=6 go build -ldflags &#x27;-w -s&#x27; -o server</span><br><span class="line"></span><br><span class="line"># 运行阶段</span><br><span class="line"> FROM scratch</span><br><span class="line"></span><br><span class="line"># 从编译阶段的中拷贝编译结果到当前镜像中</span><br><span class="line">COPY --from=0 /build/server /</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;/server&quot;]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docer image</tag>
      </tags>
  </entry>
  <entry>
    <title>2-docker-容器</title>
    <url>/2018/11/20/2-docker-%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h2>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br><span class="line">  docker run ubuntu:14.04 /bin/echo &#x27;Hello world&#x27;</span><br><span class="line">  Hello world</span><br><span class="line"></span><br><span class="line">  docker run -t -i ubuntu:14.04 /bin/bash</span><br><span class="line">  root@af8bae53bdd3:/#</span><br></pre></td></tr></table></figure>
<p>  -t:打开终端,让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上<br>  -i:交互式,让容器的标准输入保持打开。在这种模式下，用户可以输入ls、pwd这类命令和os进行交互</p>
<h2 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h2><p>  可以利用 docker container start 命令，直接将一个已经终止的容器启动运行。</p>
<h2 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h2><p>  更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。<br>  此时，可以通过添加 -d 参数来实现。<br>  example:不使用-d：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run ubuntu:17.10 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p>
<p>  使用了 -d 参数运行容器:<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run -d ubuntu:17.10 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br><span class="line">77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a</span><br></pre></td></tr></table></figure><br>  此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用docker logs&#x2F;docker container logs 查看)。<br>  注： 容器是否会长久运行，是和 docker run 指定的命令有关，和 -d 参数无关。<br>  使用 -d 参数启动后会返回一个唯一的 id，也可以通过 docker container ls 命令来查看容<br>  器信息。</p>
<h3 id="docker-container-logs"><a href="#docker-container-logs" class="headerlink" title="docker container logs"></a>docker container logs</h3>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker container logs [container ID or NAMES]</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>

<h2 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h2><p>  docker container stop用来终止一个正在运行的容器，如果容器指定的app终止，那么容器也会立刻终止。<br>  可以使用  docker container ls -a查看到终止的容器。<br>  docker container start：将终止的容器重新运行。<br>  docker container restart：将运行的容器终止，然后再重启。</p>
<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>  使用-d启动容器后，容器会在后台运行，这时候，我们想再次进入容器操作，就需要一些方式，下面介绍2种命令。</p>
<h3 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a>attach 命令</h3>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;docker run -dit  jdk8:v1</span><br><span class="line">bba6e1a848711fd046a4a6d934ac9de0f58736bcade81e42d30ce05aa620ee30</span><br><span class="line">&gt;docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">bba6e1a84871        jdk8:v1             &quot;/bin/bash&quot;         43 seconds ago      Up 40 seconds                           suspicious_blackwell</span><br><span class="line">&gt;docker attach bba</span><br><span class="line">[root@bba6e1a84871 /]# ls /</span><br><span class="line">anaconda-post.log  bin  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure>
<p>  <img src="/2018/11/20/2-docker-%E5%AE%B9%E5%99%A8/2-1.png" alt="2-1"><br>  PS：使用attach退出终端后，容器也会终止，退出。</p>
<h3 id="exec-命令"><a href="#exec-命令" class="headerlink" title="exec 命令"></a>exec 命令</h3><p>  <img src="/2018/11/20/2-docker-%E5%AE%B9%E5%99%A8/2-2.png" alt="2-2"></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;docker run -dit jdk8:v1</span><br><span class="line">15febd290b57ea968d233096e701b8f73bf11ca90db6692da33e185e8a016103</span><br><span class="line"></span><br><span class="line">&gt;docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">15febd290b57        jdk8:v1             &quot;/bin/bash&quot;         12 seconds ago      Up 9 seconds                            goofy_banach</span><br><span class="line">&gt;docker exec -it 15f bash</span><br><span class="line">[root@15febd290b57 /]# ls</span><br><span class="line">anaconda-post.log  bin  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">[root@15febd290b57 /]# exit</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line">&gt;docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED              STATUS              PORTS               NAMES</span><br><span class="line">15febd290b57        jdk8:v1             &quot;/bin/bash&quot;         About a minute ago   Up About a minute                       goofy_banach</span><br></pre></td></tr></table></figure>

<p>  可以看到使用exec进入容器操作，然后退出终端后，容器并没有终止。这个是和attach的主要区别，也是推荐使用的。<br>  docker exec -it 15f bash：bash指的是运行bash，exec要求至少2个参数，一个是容器的id，一个是运行的方式。</p>
<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><pre><code>可以使用 docker container rm 来删除一个处于终止状态的容器。例如
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker container rm trusting_newton</span><br><span class="line">trusting_newton</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="清理所有处于终止状态的容器"><a href="#清理所有处于终止状态的容器" class="headerlink" title="清理所有处于终止状态的容器"></a>清理所有处于终止状态的容器</h2><p>  用 docker container ls -a 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。<br>  <img src="/2018/11/20/2-docker-%E5%AE%B9%E5%99%A8/2-3.png" alt="2-3"><br>  同样的道理也可以清理镜像：<br>  <img src="/2018/11/20/2-docker-%E5%AE%B9%E5%99%A8/2-4.png" alt="2-4"></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>container</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>2019春季杭州面试之路</title>
    <url>/2019/04/20/2019%E6%98%A5%E5%AD%A3%E6%9D%AD%E5%B7%9E%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<h3 id="Rokid"><a href="#Rokid" class="headerlink" title="Rokid"></a>Rokid</h3><span id="more"></span>
<h5 id="智能硬件-2技术面-1hr-2H"><a href="#智能硬件-2技术面-1hr-2H" class="headerlink" title="智能硬件 | 2技术面 + 1hr | 2H"></a>智能硬件 | 2技术面 + 1hr | 2H</h5><h5 id="技术面：-一线开发-leader"><a href="#技术面：-一线开发-leader" class="headerlink" title="技术面：  一线开发 + leader"></a>技术面：  一线开发 + leader</h5><ol>
<li>hashmap和concurrentHashMap <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phbWVpbmdoL2phdmEtaGlnaGVyL2Jsb2IvbWFzdGVyL0phdmElMjA4JUU3JUIzJUJCJUU1JTg4JTk3JUU0JUI5JThCJUU5JTg3JThEJUU2JTk2JUIwJUU4JUFFJUE0JUU4JUFGJTg2SGFzaE1hcC5wZGY=">原理<i class="fa fa-external-link-alt"></i></span>：</li>
<li>多线程模式：wait&#x2F;notify 模型，现场写生产者-消费者问题，线程池的实现原理，几个jdk内置的线程池实现原理，synchronousqueue在newCachedThreadPool里边的作用，<br>  ScheduledThreadPoolExecutor队列用的是什么，队列的实现的数据结构是怎么的(堆)，为什么用这种数据结构；线程的几种状态以及之间怎么切换的。</li>
<li>io三连： buffer结构，和netty的buffer的异同，channel，selector；netty的设计模式<br>( <span class="exturl" data-url="aHR0cHM6Ly8xMTU2NzIxODc0LmdpdGh1Yi5pby8yMDE4LzEwLzA0L25ldHR5JUU2JUJBJTkwJUU3JUEwJTgxJUU1JTg4JTg2JUU2JTlFJTkwLSVFNCVCOSU5RC1SZWFjdG9yJUU2JUE4JUExJUU1JUJDJThGJUU0JUI4JThFTmV0dHklRTclQkIlODQlRTQlQkIlQjYlRTUlQUYlQjklRTYlQUYlOTQlRTUlOEYlOEFBY2NlcHRvciVFNyVCQiU4NCVFNCVCQiVCNiVFNyU5QSU4NCVFNCVCRCU5QyVFNyU5NCVBOCVFNSU4OCU4NiVFNiU5RSU5MC8=">Reactor模型<i class="fa fa-external-link-alt"></i></span> ) ,<br><span class="exturl" data-url="aHR0cHM6Ly8xMTU2NzIxODc0LmdpdGh1Yi5pby8yMDE4LzEwLzA0L25ldHR5JUU2JUJBJTkwJUU3JUEwJTgxJUU1JTg4JTg2JUU2JTlFJTkwLSVFNSU4RCU4MSVFNCVCOCU4My1OZXR0eSVFNyVCQSVCRiVFNyVBOCU4QiVFNiVBOCVBMSVFNSU5RSU4QiVFNiVCNyVCMSVFNSVCQSVBNiVFOCVBNyVBMyVFOCVBRiVCQiVFNCVCOCU4RSVFNiU5RSVCNiVFNiU5RSU4NCVFOCVBRSVCRSVFOCVBRSVBMSVFNSU4RSU5RiVFNSU4OCU5OS8=">netty的线程模型<i class="fa fa-external-link-alt"></i></span>, jdk的nio有什么<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8zZWMxMjBjYTQ2YjI=">bug<i class="fa fa-external-link-alt"></i></span> 怎么解决的？<br> bossGroup和workGroup的作用，编解码器的实现原理,netty书籍推荐：《netty实战》。</li>
<li>场景题：硬件：若干台8G的mem，4core的cpu的机器；然后数据是一些犯罪记录的数据，数据有idcardnum，以及它的犯罪记录，这样的数据大约有100G，对这些数据进行查询或者增加修改等，要求：99.99%的可用性、100万的qps，系统怎么设计？<br>  4.1. 使用redis的cluster集群模式，数据hash到主从复制单元，集群越大，每个主从复制单元支撑到的数据就越少，同时将100万的qps的压力分到到不同的主从复制单元，然后由于是主从复制，能保证非常高的可用性。推荐书籍：《深入分布式缓存+从原理到实践》。</li>
<li>dubbo的原理(铁三角，以及zk的api)。</li>
<li>spring ioc aop（两种代理方式），spring boot的原理、注解、怎么写一个spring框架（这么设计），spring的初始化过程，或者说bean怎么到容器里边的（三个步骤，要看源码才能回答满分）。</li>
<li>讲一下最近做的项目（体现出db的设计，代码上的设计模式，可扩展性等），我主要体现了简单工厂模式和模板模式。</li>
<li>考察netty的channel为什么是线程安全的。《netty实战》</li>
<li>AQS的实现原理</li>
<li>重入锁的实现原理</li>
</ol>
<h5 id="hr："><a href="#hr：" class="headerlink" title="hr："></a>hr：</h5><p>注重面试者对入职的强烈程度，职业生涯规划，技术规划，为什么离职（答不好送命题）。</p>
<h3 id="呆萝卜"><a href="#呆萝卜" class="headerlink" title="呆萝卜"></a>呆萝卜</h3><h5 id="电商-2技术面-1hr-2H"><a href="#电商-2技术面-1hr-2H" class="headerlink" title="电商 | 2技术面 + 1hr | 2H"></a>电商 | 2技术面 + 1hr | 2H</h5><h5 id="技术面：-一线开发-leader-面试的中间件团队。"><a href="#技术面：-一线开发-leader-面试的中间件团队。" class="headerlink" title="技术面： 一线开发 + leader 面试的中间件团队。"></a>技术面： 一线开发 + leader 面试的中间件团队。</h5><ol>
<li>java基础、hashmap一条龙。</li>
<li>dubbo原理一条龙（包括zk的节点类型）。</li>
<li>spring ioc aop一条龙。</li>
<li>spring的事物传播机制（7种）</li>
<li>db的事物隔离级别，以及每个级别存在的问题与解决策略。</li>
<li>beanFactory和FactoryBean的区别。</li>
<li>dubbo负载均衡有哪些算法，详细介绍其中一种算法的实现。</li>
<li>配置中心修好了一个配置，怎么实时的通知到客户端（wb或者客户端轮询），这里当时没有回答好，只说了wb的方式，其实轮询也可以的。</li>
<li>线程池一条龙。问题：只有一个cpu的机器，线程池的参数配置怎么写（2个核心线程数，队列有界，最大线程数为0，拒绝策略不能是caller策略，即遵循的原则不能在new 线程了，<br>  计算密集型和io密集型的配置策略不一样）。</li>
<li>paxos算法实现描述。</li>
<li>oom线上定位常用方式和命令。举例子回答问题。</li>
<li>堆外内存和heapbuffer的区别，堆外内存的释放(<span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMTkvMDIvMTQvdGFsay1hYm91dC1qYXZhLW1hZ2ljLWNsYXNzLXVuc2FmZS5odG1s">参考<i class="fa fa-external-link-alt"></i></span>)</li>
<li>nio的buffer和netty的buffer的区别。</li>
<li>netty的模式和线程模型。</li>
<li>项目介绍。</li>
<li>kafka的重复消费和漏消费问题，kafka高性能原因（顺序读 + page cache预读 + 文件append写，buffer零拷贝，多路复用模型）。推荐：《深入理解kafka核心设计与实践原理》</li>
<li>zk的节点类型有哪些。</li>
<li>mysql的默认引擎（问题好傻）。</li>
</ol>
<h5 id="hr：-1"><a href="#hr：-1" class="headerlink" title="hr："></a>hr：</h5><p>offer</p>
<h3 id="丹鸟物流"><a href="#丹鸟物流" class="headerlink" title="丹鸟物流"></a>丹鸟物流</h3><h5 id="物流-3技术面-1hr-四次面试-阿里系列-偏业务和系统设计"><a href="#物流-3技术面-1hr-四次面试-阿里系列-偏业务和系统设计" class="headerlink" title="物流 | 3技术面 + 1hr | 四次面试 | 阿里系列 | 偏业务和系统设计"></a>物流 | 3技术面 + 1hr | 四次面试 | 阿里系列 | 偏业务和系统设计</h5><h5 id="技术面试：-一线开发-p7"><a href="#技术面试：-一线开发-p7" class="headerlink" title="技术面试： 一线开发 + p7"></a>技术面试： 一线开发 + p7</h5><ol>
<li>hashmap一条龙。</li>
<li>重入锁和sychronized的区别。</li>
<li>spring一条龙。</li>
<li>重入锁的实现原理。</li>
<li>AQS的实现原理。</li>
<li>偏向锁、轻量级锁、重量级锁的过程。</li>
<li>自旋锁解决什么问题。</li>
<li>网站计数器（存在多线程对临界资源方法：cas + voliate 或者 Atomic**）</li>
<li>场景题目： 一张表里边很多数据，每一条数据要进行处理，然后处理完毕修改状态，要求：不能重复处理，不能有遗漏，然后是分布式环境。<br>9.1. 使用kafka： 一个线程是生产者，负载加载数据，从db里边抽数据到kafka里边，一个topic下有N个partition，然后对应有N个consumer，consumer指定分区消费。然后消费者消费的时候实现幂等，kafka也要配置为幂等，然后消费的时候使用kafka的事物，其中消费者消费更新db失败kafka事物要回滚。</li>
<li>dubbo的spi的扩展机制，容器隔离怎么实现，自定义类加载器具体说明。自定义类加载器怎么实现的容器隔离。</li>
<li>paxos算法，zk在dubbo里边的使用方式以及相关api。zk四中节点类型。</li>
<li>项目介绍。</li>
<li>redis 分布式锁实现，zk分布式锁实现。</li>
<li>netty的模式和线程模型。</li>
<li>hadoop的原理，namenode、datanode、secondarynade之间的关系，hdfs。</li>
<li>停车场问题：一个停车场30个车位，2个入口，2个出口，用线程模拟（生产者消费者问题：wait&#x2F;notify模型或者voliate + cas也可以AtomicInteger。</li>
<li>tomcat有哪些设计模式。里边有哪些部分组成，jsp为什么修改之后可以立刻体现在页面上，推荐：《how tomcat work》、《java web技术内幕》。</li>
<li>dubbo几种序列化方式介绍，以及他们之间的优缺点。</li>
</ol>
<h3 id="连连支付"><a href="#连连支付" class="headerlink" title="连连支付"></a>连连支付</h3><h5 id="支付-2技术面-1hr-注重to-c-工作经历。-4-5H"><a href="#支付-2技术面-1hr-注重to-c-工作经历。-4-5H" class="headerlink" title="支付 | 2技术面 + 1hr | 注重to c 工作经历。 | 4.5H"></a>支付 | 2技术面 + 1hr | 注重to c 工作经历。 | 4.5H</h5><h5 id="技术面试：-阿里系面试官，二面面试官很少聊技术，多是团队合作，成员性格，个人和团队的切合度。"><a href="#技术面试：-阿里系面试官，二面面试官很少聊技术，多是团队合作，成员性格，个人和团队的切合度。" class="headerlink" title="技术面试： 阿里系面试官，二面面试官很少聊技术，多是团队合作，成员性格，个人和团队的切合度。"></a>技术面试： 阿里系面试官，二面面试官很少聊技术，多是团队合作，成员性格，个人和团队的切合度。</h5><ol>
<li>dubbo一条龙， 场景：dubbo的生产者出现假死现象（提供者在zk里边是活的，因为它的机器线程是活的，只是负载太大，对外提供服务处理不过来，导致假死），怎么处理这个问题？<br>1.1. 提供者配置使用权重，然后在zk里边配置一个动态权重列表，某个节点失败会让权重减1。减到一定的阈值踢除。</li>
<li>cas存在的问题以及cas的优点，问题怎么解决。</li>
<li>cas怎么解决性能低的问题（借鉴锁细化，分段锁原理）。</li>
<li>分布式限流，redis用当前秒作为key的分布式限流(<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1R3b0RyYWdvbkxha2UvdGRsLXJlZGlzLWFjY2VzcyklRTMlODAlODI=">https://github.com/TwoDragonLake/tdl-redis-access)。<i class="fa fa-external-link-alt"></i></span></li>
<li>令牌通算法限流，令牌通算法出现峰值不均匀问题的解决方式（比如一秒中1&#x2F;10秒的峰值全部打满了，9&#x2F;10的时间都是不可用的或者浪费了怎么解决），回答：把一秒分成10份，对应redis里边的list数据结构，一个list单元就是一个桶，参考sentinel的实现，源码里边有解决方案。</li>
<li>项目介绍，秒杀系统、其他项目体现db设计和设计模式的设计。</li>
<li>netty的实现，线程模型。</li>
<li>mysql的主从复制几种方式，怎么保证数据安全。</li>
<li>说一下spring的bean加载过程，然后自己实现一个spring mvc怎么实现（花了很长时间说完，具体到细节和关键api）。推荐书籍：《spring 技术内幕》。</li>
<li>分库分表要解决那些 <span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvVVRYem1lb3JoS1lON3VuNElTMGpsZw==">问题<i class="fa fa-external-link-alt"></i></span>  （sql解析、sql路由、sql改写、sql执行、结果集合并；动态扩容、分布式事物、分布式id）</li>
<li>二面leader基本没问技术问题，全部问题向团队合作，个人和团队冲突的解决之道（比如系统架构设计和pd业务产生冲突），和pd的配合，怎么学习新的业务，怎么和比你技术level底的人打交道，说一下你的优点和缺点（缺点要化缺点为优点，比如说我喜欢玩，喜欢去夜店蹦迪，很多人说程序员不应该这么搞，然后你说我会让这种东西活跃团队氛围，教你们泡妞。。。）， 技术专家岗位注重技术深度和业务敏感度的掌握。</li>
</ol>
<h5 id="hr：-2"><a href="#hr：-2" class="headerlink" title="hr："></a>hr：</h5><p>注重to c工作经历。</p>
<h3 id="有赞"><a href="#有赞" class="headerlink" title="有赞"></a>有赞</h3><h5 id="乱七八糟的业务-技术面-30min"><a href="#乱七八糟的业务-技术面-30min" class="headerlink" title="乱七八糟的业务 | 技术面 | 30min"></a>乱七八糟的业务 | 技术面 | 30min</h5><h5 id="技术面试：挂掉"><a href="#技术面试：挂掉" class="headerlink" title="技术面试：挂掉"></a>技术面试：挂掉</h5><ol>
<li>hashmap一条龙</li>
<li>项目介绍，秒杀系统使用了乐观锁面试官觉得不OK。</li>
<li>servicemesh 项目介绍，netty线程模型考察。</li>
</ol>
<h3 id="中通云仓"><a href="#中通云仓" class="headerlink" title="中通云仓"></a>中通云仓</h3><h5 id="仓库系统-1技术面-1hr-90min"><a href="#仓库系统-1技术面-1hr-90min" class="headerlink" title="仓库系统 | 1技术面 + 1hr | 90min"></a>仓库系统 | 1技术面 + 1hr | 90min</h5><h5 id="技术面试："><a href="#技术面试：" class="headerlink" title="技术面试："></a>技术面试：</h5><ol>
<li>hashmap一条龙。</li>
<li>kafka幂等实现原理。</li>
<li>分库分表动态扩容怎么解决。</li>
<li>分布式事物怎么解决。</li>
<li>sql优化介绍、公司部门结构怎么加载树形结构，除了递归，使用一条sql搞定。</li>
<li>项目介绍。</li>
<li>线程池一条龙。</li>
<li>voliate特性、java内存模型。</li>
<li>cas原理一条龙。优缺点。</li>
<li>dubbo一条龙。</li>
<li>怎么熟悉一个系统的业务。回答：搞清楚当做职责做的模块在整个业务群里边的作者用，包括但不限于db模型，编码，然后在往上探测业务，和测试、pd交流。</li>
</ol>
<h5 id="hr：-3"><a href="#hr：-3" class="headerlink" title="hr："></a>hr：</h5><p>离职原因、聊了考核绩效，之前团队人数、业务类型。和hr聊的时候要诚实，不要撒谎太厉害。<br>offer</p>
<h3 id="亿伽通"><a href="#亿伽通" class="headerlink" title="亿伽通"></a>亿伽通</h3><h5 id="车联网-1技术面-50min"><a href="#车联网-1技术面-50min" class="headerlink" title="车联网 | 1技术面 | 50min"></a>车联网 | 1技术面 | 50min</h5><h5 id="技术面"><a href="#技术面" class="headerlink" title="技术面"></a>技术面</h5><ol>
<li>lambda表达式考察，常用的list转map，list过滤求之后再求list数量。</li>
<li>2个string类型的List，怎么转换为map，即第一个lsit的值作为map的key，第二个list的值作为map的value，用lambda实现。</li>
<li>项目介绍。</li>
<li>netty特性介绍，项目介绍，使用了netty的那些特性（车联网需要用netty写网关）。</li>
</ol>
<h5 id="hr"><a href="#hr" class="headerlink" title="hr"></a>hr</h5><p>hr觉得我的之前工作的经历不适合他们公司。</p>
<h3 id="e签宝"><a href="#e签宝" class="headerlink" title="e签宝"></a>e签宝</h3><h5 id="企业服务-4技术面-1hr-1-5天-面试官太忙中间等了很长时间"><a href="#企业服务-4技术面-1hr-1-5天-面试官太忙中间等了很长时间" class="headerlink" title="企业服务 | 4技术面 + 1hr | 1.5天(面试官太忙中间等了很长时间)"></a>企业服务 | 4技术面 + 1hr | 1.5天(面试官太忙中间等了很长时间)</h5><h5 id="技术面试：面试的框架组"><a href="#技术面试：面试的框架组" class="headerlink" title="技术面试：面试的框架组"></a>技术面试：面试的框架组</h5><ol>
<li>项目介绍（设计模式，db设计）。</li>
<li>redis数据结构介绍、zset的跳跃表做了哪些优化，优化的目的是什么。</li>
<li>netty的线程模型、大赛项目（service mesh那个大赛项目<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1R3b0RyYWdvbkxha2UvZHViYm8tbWVzaA==">dubbo-mesh<i class="fa fa-external-link-alt"></i></span> ）的介绍、怎么优化的,负载均衡算法介绍。</li>
<li>同步、异步、阻塞、非阻塞的介绍。</li>
<li>map一条龙。</li>
<li>cas和自旋锁，cas在jdk里边是怎么使用的、cas在jdk里边的api是什么，有哪些参数。</li>
<li>三次握手协议、四次分手协议介绍、滑动窗口的作用、滑动窗口怎么减少怎么增加大小的算法，是按半增加还是按半减少等（这个忘记算法过程了，没答上来）。</li>
<li>TCP协议组成部分、网络状态在实际问题定位上的使用（反正是tcp的知识）。【这块是盲区，恶补tcp】。</li>
<li>tomcat的io之前都是阻塞的io，为什么现在都是nio的方式了（说优化，技术升级都是不OK的，感觉考察的是系统设计方面的东西，没答上来）。</li>
<li>lru算法时间复杂度，描述实现，根据事件lru怎么实现（按时间排序），lru有根据访问次数和时间2中方式，如果一个key的访问次数是10W（根据计数lru不会被删除），<br>但是他的时间很少，如果根据时间去lru的话跟定不合适，怎么解决？（答：计数和时间一起参数lru权重[淘汰的权重]的计算）</li>
<li>一致性hash为了解决什么问题？什么场景会使用一致性hash、一致性hash举例介绍算法的实现（画图，举例，我使用简单的mod作为hash函数举例的）。</li>
<li>spring-mvc的架构以及一个请求到达controller之前会经过哪些组件？ aop、ioc起到的作用。</li>
<li>CAP理论、CA、CP、AP的情况举例。</li>
<li>分布式系统如何保证一致性（paxos算法详细介绍），推荐书籍：《从Paxos到zookeeper分布式一致性原理与实践》。</li>
<li>redis的cluster集群模式节点挂掉，其他节点是怎么得到通知的（raft算法，以及每个节点的配置数据结构，里边有2个用于做一致性的版本号）? 《深入分布式缓存+从原理到实践》</li>
<li>函数式接口是什么？ lambda的实现是怎么设计的？ jdk8的stream内部怎么实现的？ forkjoin介绍,任务窃取队列。</li>
<li>缓存雪崩怎么产生的？ 有哪些解决方案？</li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5pbXBvcnRuZXcuY29tLzIzMTUwLmh0bWw=">逃逸分析<i class="fa fa-external-link-alt"></i></span>介绍和举例。</li>
<li>jvm的GC算法，然后知道哪些jvm的参数调优。</li>
</ol>
<h5 id="hr：-4"><a href="#hr：-4" class="headerlink" title="hr："></a>hr：</h5><p>hr，女，穿着暴露，很不好惹，一脸严肃。 我把hr直接怼脸上了。</p>
<h3 id="菜鸟网络"><a href="#菜鸟网络" class="headerlink" title="菜鸟网络"></a>菜鸟网络</h3><h5 id="物流"><a href="#物流" class="headerlink" title="物流 |"></a>物流 |</h5><h5 id="技术面试：-1"><a href="#技术面试：-1" class="headerlink" title="技术面试："></a>技术面试：</h5><ol>
<li>项目介绍。设计模式体现，db设计。</li>
<li>dubbo的序列化方式有哪些？ 各种序列化方式之间的优缺点比较。</li>
<li>cas一条龙。</li>
<li>重入锁一条龙。</li>
<li>aqs一条龙。</li>
<li>map一条龙 ConcurrentHashMap的size是准确的吗？ hashMap和hashTable的区别，hashTable和ConcurrentHashMap的区别。</li>
<li>缓存穿透是怎么发生的，怎么解决（布隆过滤器）。</li>
<li>场景题: 100张购物劵抢购， 100万的qps，要求所有请求在1秒之内返回结果，redis不允许分片，db不允许分片，怎么设计？（面试官要的答案可能是redis单线程执行，面试完毕之后我想了下，单机db肯定撑不住100万qps，<br>那么我可以把db迁移到redis里边去，然后用redis的单线程执行库存扣减，解决多线程并发问题，总的来说没有找到非常OK的解决方案，主要题目限制太厉害。）</li>
<li>dubbo的设计，dubbo一条龙，zk的结构等等。</li>
<li>技术leader面试：项目介绍，遇到那些问题，怎么优化的。优化点的好处是什么。</li>
</ol>
<h5 id="hr-1"><a href="#hr-1" class="headerlink" title="hr"></a>hr</h5><p>hr对工作履历不认可，挂掉。</p>
<h3 id="涂鸦智能"><a href="#涂鸦智能" class="headerlink" title="涂鸦智能"></a>涂鸦智能</h3><h5 id="iot"><a href="#iot" class="headerlink" title="iot"></a>iot</h5><h5 id="技术面试"><a href="#技术面试" class="headerlink" title="技术面试"></a>技术面试</h5><ol>
<li>项目介绍，一条龙。涉及到分库分表，分布式集群设计。</li>
<li>hsf的架构设计（可以引导到dubbo的设计）</li>
<li>spring的设计模式有哪些，aop，代理怎么实现的（注意是spring的代理是怎么实现的，有队源码有走读经历）。</li>
<li>netty的线程模型，channel是不是线程安全的？ 编码器，解码器，粘包拆包问题。</li>
<li>对涂鸦了解多少，iot了解多少？</li>
<li>还有二面</li>
</ol>
<h5 id="hr-2"><a href="#hr-2" class="headerlink" title="hr"></a>hr</h5><p>待定</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里边有的面试的是中间件团队，有的是业务团队，有的是高级开发，有的是技术专家，有 to c，有to b，问的大部分的问题是jdk基础，包括集合、io、nio、多线程、锁、dubbo原理、数据库分库分表、<br>sql优化、索引原理、jvm原理、mq的使用（幂等、事物）和原理、分布式系统设计和理论、分布式锁、redis缓存的使用和原理，除了有赞在技术面挂掉（感觉面试官很着急，水平just so so），其他的企业都能杀到hr一关，做to c的可能排斥之前做to b业务的，不过这些都不是重点，重点是我们对技术的掌握程度，是否扎实，能说能写，随机应变。还有一点是我们和企业都是平等的，该争取的就要争取，面试官不屑一顾我们也没必要压抑自己的<br>感受，你可以反击，hr也是同样的道理。相互尊重、爱， peace &amp; respect &amp; love。感谢龙哥，感谢自己对技术的热爱和坚持，也感谢二龙湖的朋友，乌拉！~~~</p>
<h3 id="书单推荐："><a href="#书单推荐：" class="headerlink" title="书单推荐："></a>书单推荐：</h3><p>《深入分析Java Web技术内幕》、《深入理解Java虚拟机：JVM高级特性与最佳实践（最新第二版）》、《SPRING技术内幕：深入解析SPRING架构与设计原理(第2版)》、《Java并发编程的艺术》<br>《java nio》、《docker从入门到实践》、《netty实战》、《深入分布式缓存+从原理到实践》。</p>
<h3 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h3><p>人生苦短，二龙湖新的革命道路是Google 和 物联网革命！ leetcode、九章算法、英语搞起来，fire in the code！</p>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>3-docker-仓库</title>
    <url>/2018/11/24/3-docker-%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<h2 id="仓库和注册服务器的区别"><a href="#仓库和注册服务器的区别" class="headerlink" title="仓库和注册服务器的区别"></a>仓库和注册服务器的区别</h2><p>  举例说明：</p>
<span id="more"></span>
<p>  tdlceaserwang&#x2F;repository<br>  dl.dockerpool.com&#x2F;ubuntu<br>  tdlceaserwang和dl.dockerpool.com都是注册服务器，repository和ubuntu都是仓库。</p>
<h2 id="Docker-Hub基本操作"><a href="#Docker-Hub基本操作" class="headerlink" title="Docker Hub基本操作"></a>Docker Hub基本操作</h2><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p>  搜索：<br>  docker search  kafka<br>  过滤搜索：  docker search  kafka –filter&#x3D;stars&#x3D;N 【搜索star数量超过N的镜像】<br>  拉取：<br>  docker pull kafka</p>
<h3 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h3><p>  1:&gt;docker tag jdk8:v1 tdlceaserwang&#x2F;jdk8:v1<br>  2:&gt;docker push tdlceaserwang&#x2F;jdk8:v1</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker login</span><br><span class="line">#输入docker的用户id，注意，不是email</span><br><span class="line">#输入密码</span><br><span class="line">&gt;docker tag jdk8:v1 tdlceaserwang/jdk8:v1</span><br><span class="line">&gt;docker push tdlceaserwang/jdk8:v1</span><br></pre></td></tr></table></figure>
<p>  <img src="/2018-11-24/3-docker-%E4%BB%93%E5%BA%93/3-1.png" alt="3-1"><br>  <img src="/2018-11-24/3-docker-%E4%BB%93%E5%BA%93/3-2.png" alt="3-2"></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker hub</tag>
        <tag>Repository</tag>
        <tag>仓库</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayBlockingQueue和LinkedBlockingQueue</title>
    <url>/2018/10/04/ArrayBlockingQueue%E5%92%8CLinkedBlockingQueue/</url>
    <content><![CDATA[<p>ArrayBlockQueue和ArrayBlockQueue属于Java.util.current包下的两个封装的线程安全的队列，主要讨论线程安全和阻塞操作的实现<br>他们之间的关系如下：<br><img src="/2018/10/04/ArrayBlockingQueue%E5%92%8CLinkedBlockingQueue/20161029145814547.png" alt="这里写图片描述"></p>
<span id="more"></span>
<p>[复制图片地址，在新的浏览器器页面查看大图]<br><strong>ArrayBlockingQueue:</strong><br>线程安全和阻塞操作在入队列和取出队列元素都会涉及，先从线程安全进入：<br>注意：ArrayBlockQueue只有一把锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** Main lock guarding all access */</span><br><span class="line">final ReentrantLock lock;</span><br><span class="line">/** Condition for waiting takes */</span><br><span class="line">private final Condition notEmpty;</span><br><span class="line">/** Condition for waiting puts */</span><br><span class="line">private final Condition notFull;</span><br></pre></td></tr></table></figure>
<p>锁的初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">    if (capacity &lt;= 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    this.items = new Object[capacity];</span><br><span class="line">    lock = new ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();//用于取走队列元素</span><br><span class="line">    notFull =  lock.newCondition();//用于元素插入队列</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>take方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Inserts the specified element at the tail of this queue if it is</span><br><span class="line"> * possible to do so immediately without exceeding the queue&#x27;s capacity,</span><br><span class="line"> * returning &#123;@code true&#125; upon success and &#123;@code false&#125; if this queue</span><br><span class="line"> * is full.  This method is generally preferable to method &#123;@link #add&#125;,</span><br><span class="line"> * which can fail to insert an element only by throwing an exception.</span><br><span class="line"> *</span><br><span class="line"> * @throws NullPointerException if the specified element is null</span><br><span class="line"> */</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    //获取锁，使用可重入锁的同步器，cvs操作，非公平锁</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (count == items.length)</span><br><span class="line">            return false;</span><br><span class="line">        else &#123;</span><br><span class="line">            insert(e);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //释放锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>poll方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        return (count == 0) ? null : extract();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看阻塞：<br>Condition拥有类似的操作：await&#x2F;signal。Condition和一个Lock相关，由Lock的newCondition来创建。只有当前线程获取了这把锁，才能调用Condition的await方法来等待通知，否则会抛出异常。</p>
<p>下面来看看put方法就会明白如何使用一个Condition了<br>put操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Inserts the specified element at the tail of this queue, waiting</span><br><span class="line"> * for space to become available if the queue is full.</span><br><span class="line"> *</span><br><span class="line"> * @throws InterruptedException &#123;@inheritDoc&#125;</span><br><span class="line"> * @throws NullPointerException &#123;@inheritDoc&#125;</span><br><span class="line"> */</span><br><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        insert(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>take操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count == 0)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        return extract();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现阻塞的关键就是就是这个notFull的Condition，当队列已满，await方法会阻塞当前线程，并且释放Lock，等待其他线程调用notFull的signal来唤醒这个阻塞的线程。那么这个操作必然会在拿走元素的操作中出现，这样一旦有元素被拿走，阻塞的线程就会被唤醒。</p>
<p>这里有个问题，发出signal的线程肯定拥有这把锁的，因此await方法所在的线程肯定是拿不到这把锁的，await方法不能立刻返回，需要尝试获取锁直到拥有了锁才可以从await方法中返回。</p>
<p>这就是阻塞的实现原理，也是所谓的线程同步。</p>
<p><strong>LinkedBlockingQueue</strong><br>LinkedBlockingQueue使用一个链表来实现，会有一个head和tail分别指向队列的开始和队列的结尾。因此LinkedBlockingQueue会有两把锁，分别控制这两个元素，这样在添加元素和拿走元素的时候就不会有锁的冲突，因此取走元素操作的是head，而添加元素操作的是tail。</p>
<p>offer方法和poll方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Inserts the specified element at the tail of this queue if it is</span><br><span class="line"> * possible to do so immediately without exceeding the queue&#x27;s capacity,</span><br><span class="line"> * returning &#123;@code true&#125; upon success and &#123;@code false&#125; if this queue</span><br><span class="line"> * is full.</span><br><span class="line"> * When using a capacity-restricted queue, this method is generally</span><br><span class="line"> * preferable to method &#123;@link BlockingQueue#add add&#125;, which can fail to</span><br><span class="line"> * insert an element only by throwing an exception.</span><br><span class="line"> *</span><br><span class="line"> * @throws NullPointerException if the specified element is null</span><br><span class="line"> */</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    if (e == null) throw new NullPointerException();</span><br><span class="line">    final AtomicInteger count = this.count;</span><br><span class="line">    if (count.get() == capacity)</span><br><span class="line">        return false;</span><br><span class="line">    int c = -1;</span><br><span class="line">    Node&lt;E&gt; node = new Node(e);</span><br><span class="line">    final ReentrantLock putLock = this.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (count.get() &lt; capacity) &#123;</span><br><span class="line">            enqueue(node);</span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            if (c + 1 &lt; capacity)</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    if (c == 0)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    return c &gt;= 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到offer方法在添加元素时候仅仅涉及到putLock，但是还是会需要takeLock，看看signalNotEmpty代码就知道。而poll方法拿走元素的时候涉及到takeLock，也是会需要putLock。参见signalNotFull()。关于signalNotEmpty会在后面讲阻塞的时候讲到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">    final AtomicInteger count = this.count;</span><br><span class="line">    if (count.get() == 0)</span><br><span class="line">        return null;</span><br><span class="line">    E x = null;</span><br><span class="line">    int c = -1;</span><br><span class="line">    final ReentrantLock takeLock = this.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (count.get() &gt; 0) &#123;</span><br><span class="line">            x = dequeue();</span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            if (c &gt; 1)</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    if (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里顺便说说队列长度的count，因为有两把锁存在，所以如果还是像ArrayBlockingQueue一样使用基本类型的count的话会同时用到两把锁，这样就会很复杂，因此直接使用原子数据类型AtomicInteger来操作count。</p>
<p>LinkedQueue的阻塞<br>一个BlockingQueue会有两个Condition：notFull和notEmpty，LinkedBlockingQueue会有两把锁，因此这两个Condition肯定是由这两个锁分别创建的，takeLock创建notEmpty，putLock创建notFull。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** Lock held by take, poll, etc */</span><br><span class="line">private final ReentrantLock takeLock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">/** Wait queue for waiting takes */</span><br><span class="line">private final Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">/** Lock held by put, offer, etc */</span><br><span class="line">private final ReentrantLock putLock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">/** Wait queue for waiting puts */</span><br><span class="line">private final Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure>

<p>put方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Inserts the specified element at the tail of this queue, waiting if</span><br><span class="line"> * necessary for space to become available.</span><br><span class="line"> *</span><br><span class="line"> * @throws InterruptedException &#123;@inheritDoc&#125;</span><br><span class="line"> * @throws NullPointerException &#123;@inheritDoc&#125;</span><br><span class="line"> */</span><br><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">    if (e == null) throw new NullPointerException();</span><br><span class="line">    // Note: convention in all put/take/etc is to preset local var</span><br><span class="line">    // holding count negative to indicate failure unless set.</span><br><span class="line">    int c = -1;</span><br><span class="line">    Node&lt;E&gt; node = new Node(e);</span><br><span class="line">    final ReentrantLock putLock = this.putLock;</span><br><span class="line">    final AtomicInteger count = this.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        /*</span><br><span class="line">         * Note that count is used in wait guard even though it is</span><br><span class="line">         * not protected by lock. This works because count can</span><br><span class="line">         * only decrease at this point (all other puts are shut</span><br><span class="line">         * out by lock), and we (or some other waiting put) are</span><br><span class="line">         * signalled if it ever changes from capacity. Similarly</span><br><span class="line">         * for all other uses of count in other wait guards.</span><br><span class="line">         */</span><br><span class="line">        while (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(node);</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        if (c + 1 &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    if (c == 0)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实大体逻辑和ArrayBlockingQueue差不多，也会需要通知notEmpty条件，因为notEmpty条件属于takeLock，而调用signal方法需要获取Lock，因此put方法也是用到了另外一个锁：takeLock。这里有一点会不同，按照道理来说put方法是不需要通知notFull条件的，是由由拿走元素的操作来通知的，但是notFull条件属于putLock，而拿走元素时，是用了takeLock，因此这里put方法在拥有putLock的情况通知notFull条件，会让其他添加元素的方法避免过长时间的等待。同理对于take方法来说也通知notEmpty条件。</p>
<p>take 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">    E x;</span><br><span class="line">    int c = -1;</span><br><span class="line">    final AtomicInteger count = this.count;</span><br><span class="line">    final ReentrantLock takeLock = this.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count.get() == 0) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        if (c &gt; 1)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    if (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>remove和contains方法，因为需要操作整个链表，因此需要同时拥有两个锁才能操作。</p>
]]></content>
      <categories>
        <category>Thread</category>
      </categories>
      <tags>
        <tag>ArrayBlockQueue</tag>
      </tags>
  </entry>
  <entry>
    <title>4-docker-数据卷</title>
    <url>/2018/11/24/4-docker-%E6%95%B0%E6%8D%AE%E5%8D%B7/</url>
    <content><![CDATA[<h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>  数据卷 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>
<span id="more"></span>
<ul>
<li>数据卷可以在容器之间共享和重用</li>
<li>对数据卷 的修改会立马生效</li>
<li>对数据卷 的更新，不会影响镜像</li>
<li>数据卷 默认会一直存在，即使容器被删除</li>
</ul>
<h3 id="创建一个数据卷"><a href="#创建一个数据卷" class="headerlink" title="创建一个数据卷"></a>创建一个数据卷</h3>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;docker  volume create volume-1</span><br><span class="line">volume-1</span><br><span class="line"></span><br><span class="line">&gt;docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               volume-1</span><br><span class="line">#查看数据卷的具体信息</span><br><span class="line">&gt;docker volume inspect volume-1</span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">      &quot;CreatedAt&quot;: &quot;2018-11-24T08:25:17Z&quot;,</span><br><span class="line">      &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">      &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">      &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/volume-1/_data&quot;,</span><br><span class="line">      &quot;Name&quot;: &quot;volume-1&quot;,</span><br><span class="line">      &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">      &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h3><p>  docker run 命令的时候，使用 –mount 标记来将 数据卷 挂载到容器里。在一次docker run 中可以挂载多个 数据卷 。<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;docker run -dit --name myjdk8 --mount source=volume-1,target=/webapp jdk8:v1</span><br></pre></td></tr></table></figure></p>
<h3 id="查看容器当中数据卷的具体信息"><a href="#查看容器当中数据卷的具体信息" class="headerlink" title="查看容器当中数据卷的具体信息"></a>查看容器当中数据卷的具体信息</h3>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;docker inspect myjdk8</span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">      &quot;Id&quot;: &quot;c9c346fdf8dcb7d4923d7f07b369e2f07779c14913f42a07b3b9f0accb73dac9&quot;,</span><br><span class="line">      &quot;Created&quot;: &quot;2018-11-24T08:28:50.9454735Z&quot;,</span><br><span class="line">      &quot;Path&quot;: &quot;/bin/bash&quot;,</span><br><span class="line">      &quot;Args&quot;: [],</span><br><span class="line">      &quot;State&quot;: &#123;</span><br><span class="line">          &quot;Status&quot;: &quot;running&quot;,</span><br><span class="line">          &quot;Running&quot;: true,</span><br><span class="line">          &quot;Paused&quot;: false,</span><br><span class="line">          &quot;Restarting&quot;: false,</span><br><span class="line">          &quot;OOMKilled&quot;: false,</span><br><span class="line">          &quot;Dead&quot;: false,</span><br><span class="line">          &quot;Pid&quot;: 3941,</span><br><span class="line">          &quot;ExitCode&quot;: 0,</span><br><span class="line">          &quot;Error&quot;: &quot;&quot;,</span><br><span class="line">          &quot;StartedAt&quot;: &quot;2018-11-24T08:28:53.3865482Z&quot;,</span><br><span class="line">          &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;Image&quot;: &quot;sha256:a70ba00548f32c4d0152cb12e9aafdc419fc5bbb14744780bdfffb11f074ec03&quot;,</span><br><span class="line">      &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/c9c346fdf8dcb7d4923d7f07b369e2f07779c14913f42a07b3b9f0accb73dac9/resolv.conf&quot;,</span><br><span class="line">      &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/c9c346fdf8dcb7d4923d7f07b369e2f07779c14913f42a07b3b9f0accb73dac9/hostname&quot;,</span><br><span class="line">      &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/c9c346fdf8dcb7d4923d7f07b369e2f07779c14913f42a07b3b9f0accb73dac9/hosts&quot;,</span><br><span class="line">      &quot;LogPath&quot;: &quot;/var/lib/docker/containers/c9c346fdf8dcb7d4923d7f07b369e2f07779c14913f42a07b3b9f0accb73dac9/c9c346fdf8dcb7d4923d7f07b369e2f07779c14913f42a07b3b9f0accb73dac9-json.log&quot;,</span><br><span class="line">      &quot;Name&quot;: &quot;/myjdk8&quot;,</span><br><span class="line">      &quot;RestartCount&quot;: 0,</span><br><span class="line">      &quot;Driver&quot;: &quot;overlay2&quot;,</span><br><span class="line">      &quot;Platform&quot;: &quot;linux&quot;,</span><br><span class="line">      &quot;MountLabel&quot;: &quot;&quot;,</span><br><span class="line">      &quot;ProcessLabel&quot;: &quot;&quot;,</span><br><span class="line">      &quot;AppArmorProfile&quot;: &quot;&quot;,</span><br><span class="line">      &quot;ExecIDs&quot;: null,</span><br><span class="line">      &quot;HostConfig&quot;: &#123;</span><br><span class="line">          &quot;Binds&quot;: null,</span><br><span class="line">          &quot;ContainerIDFile&quot;: &quot;&quot;,</span><br><span class="line">          &quot;LogConfig&quot;: &#123;</span><br><span class="line">              &quot;Type&quot;: &quot;json-file&quot;,</span><br><span class="line">              &quot;Config&quot;: &#123;&#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;NetworkMode&quot;: &quot;default&quot;,</span><br><span class="line">          &quot;PortBindings&quot;: &#123;&#125;,</span><br><span class="line">          &quot;RestartPolicy&quot;: &#123;</span><br><span class="line">              &quot;Name&quot;: &quot;no&quot;,</span><br><span class="line">              &quot;MaximumRetryCount&quot;: 0</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;AutoRemove&quot;: false,</span><br><span class="line">          &quot;VolumeDriver&quot;: &quot;&quot;,</span><br><span class="line">          &quot;VolumesFrom&quot;: null,</span><br><span class="line">          &quot;CapAdd&quot;: null,</span><br><span class="line">          &quot;CapDrop&quot;: null,</span><br><span class="line">          &quot;Dns&quot;: [],</span><br><span class="line">          &quot;DnsOptions&quot;: [],</span><br><span class="line">          &quot;DnsSearch&quot;: [],</span><br><span class="line">          &quot;ExtraHosts&quot;: null,</span><br><span class="line">          &quot;GroupAdd&quot;: null,</span><br><span class="line">          &quot;IpcMode&quot;: &quot;shareable&quot;,</span><br><span class="line">          &quot;Cgroup&quot;: &quot;&quot;,</span><br><span class="line">          &quot;Links&quot;: null,</span><br><span class="line">          &quot;OomScoreAdj&quot;: 0,</span><br><span class="line">          &quot;PidMode&quot;: &quot;&quot;,</span><br><span class="line">          &quot;Privileged&quot;: false,</span><br><span class="line">          &quot;PublishAllPorts&quot;: false,</span><br><span class="line">          &quot;ReadonlyRootfs&quot;: false,</span><br><span class="line">          &quot;SecurityOpt&quot;: null,</span><br><span class="line">          &quot;UTSMode&quot;: &quot;&quot;,</span><br><span class="line">          &quot;UsernsMode&quot;: &quot;&quot;,</span><br><span class="line">          &quot;ShmSize&quot;: 67108864,</span><br><span class="line">          &quot;Runtime&quot;: &quot;runc&quot;,</span><br><span class="line">          &quot;ConsoleSize&quot;: [</span><br><span class="line">              50,</span><br><span class="line">              189</span><br><span class="line">          ],</span><br><span class="line">          &quot;Isolation&quot;: &quot;&quot;,</span><br><span class="line">          &quot;CpuShares&quot;: 0,</span><br><span class="line">          &quot;Memory&quot;: 0,</span><br><span class="line">          &quot;NanoCpus&quot;: 0,</span><br><span class="line">          &quot;CgroupParent&quot;: &quot;&quot;,</span><br><span class="line">          &quot;BlkioWeight&quot;: 0,</span><br><span class="line">          &quot;BlkioWeightDevice&quot;: [],</span><br><span class="line">          &quot;BlkioDeviceReadBps&quot;: null,</span><br><span class="line">          &quot;BlkioDeviceWriteBps&quot;: null,</span><br><span class="line">          &quot;BlkioDeviceReadIOps&quot;: null,</span><br><span class="line">          &quot;BlkioDeviceWriteIOps&quot;: null,</span><br><span class="line">          &quot;CpuPeriod&quot;: 0,</span><br><span class="line">          &quot;CpuQuota&quot;: 0,</span><br><span class="line">          &quot;CpuRealtimePeriod&quot;: 0,</span><br><span class="line">          &quot;CpuRealtimeRuntime&quot;: 0,</span><br><span class="line">          &quot;CpusetCpus&quot;: &quot;&quot;,</span><br><span class="line">          &quot;CpusetMems&quot;: &quot;&quot;,</span><br><span class="line">          &quot;Devices&quot;: [],</span><br><span class="line">          &quot;DeviceCgroupRules&quot;: null,</span><br><span class="line">          &quot;DiskQuota&quot;: 0,</span><br><span class="line">          &quot;KernelMemory&quot;: 0,</span><br><span class="line">          &quot;MemoryReservation&quot;: 0,</span><br><span class="line">          &quot;MemorySwap&quot;: 0,</span><br><span class="line">          &quot;MemorySwappiness&quot;: null,</span><br><span class="line">          &quot;OomKillDisable&quot;: false,</span><br><span class="line">          &quot;PidsLimit&quot;: 0,</span><br><span class="line">          &quot;Ulimits&quot;: null,</span><br><span class="line">          &quot;CpuCount&quot;: 0,</span><br><span class="line">          &quot;CpuPercent&quot;: 0,</span><br><span class="line">          &quot;IOMaximumIOps&quot;: 0,</span><br><span class="line">          &quot;IOMaximumBandwidth&quot;: 0,</span><br><span class="line">          &quot;Mounts&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                  &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                  &quot;Source&quot;: &quot;volume-1&quot;,</span><br><span class="line">                  &quot;Target&quot;: &quot;/webapp&quot;</span><br><span class="line">              &#125;</span><br><span class="line">          ],</span><br><span class="line">          &quot;MaskedPaths&quot;: [</span><br><span class="line">              &quot;/proc/acpi&quot;,</span><br><span class="line">              &quot;/proc/kcore&quot;,</span><br><span class="line">              &quot;/proc/keys&quot;,</span><br><span class="line">              &quot;/proc/latency_stats&quot;,</span><br><span class="line">              &quot;/proc/timer_list&quot;,</span><br><span class="line">              &quot;/proc/timer_stats&quot;,</span><br><span class="line">              &quot;/proc/sched_debug&quot;,</span><br><span class="line">              &quot;/proc/scsi&quot;,</span><br><span class="line">              &quot;/sys/firmware&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;ReadonlyPaths&quot;: [</span><br><span class="line">              &quot;/proc/asound&quot;,</span><br><span class="line">              &quot;/proc/bus&quot;,</span><br><span class="line">              &quot;/proc/fs&quot;,</span><br><span class="line">              &quot;/proc/irq&quot;,</span><br><span class="line">              &quot;/proc/sys&quot;,</span><br><span class="line">              &quot;/proc/sysrq-trigger&quot;</span><br><span class="line">          ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;GraphDriver&quot;: &#123;</span><br><span class="line">          &quot;Data&quot;: &#123;</span><br><span class="line">              &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/49a437db0a547c82e213cb31090398d94d64ad11b1dfa7112f1e5f64897fca00-init/diff:/var/lib/docker/overlay2/2796cd7903fb6c509b276acb83505d05b1d685e010dc32557fe6baa06160e0a3/diff:/var/lib/docker/overlay2/15b4eabde2002d7fa67849c36b175b93827b911465b6cc8021e47f467ec2cca3/diff:/var/lib/docker/overlay2/9a004f009ec50069f1f7a8985bf40a256eda15b48402ccbefb6831ae52d2bbb8/diff:/var/lib/docker/overlay2/1d31c352fff2c856f6f208be8c9448ecc30447edcfacb10fd73e4d62ebef989d/diff&quot;,</span><br><span class="line">              &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/49a437db0a547c82e213cb31090398d94d64ad11b1dfa7112f1e5f64897fca00/merged&quot;,</span><br><span class="line">              &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/49a437db0a547c82e213cb31090398d94d64ad11b1dfa7112f1e5f64897fca00/diff&quot;,</span><br><span class="line">              &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/49a437db0a547c82e213cb31090398d94d64ad11b1dfa7112f1e5f64897fca00/work&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;Name&quot;: &quot;overlay2&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;Mounts&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">              &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">              &quot;Name&quot;: &quot;volume-1&quot;,</span><br><span class="line">              &quot;Source&quot;: &quot;/var/lib/docker/volumes/volume-1/_data&quot;,</span><br><span class="line">              &quot;Destination&quot;: &quot;/webapp&quot;,</span><br><span class="line">              &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">              &quot;Mode&quot;: &quot;z&quot;,</span><br><span class="line">              &quot;RW&quot;: true,</span><br><span class="line">              &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">          &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;Config&quot;: &#123;</span><br><span class="line">          &quot;Hostname&quot;: &quot;c9c346fdf8dc&quot;,</span><br><span class="line">          &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">          &quot;User&quot;: &quot;&quot;,</span><br><span class="line">          &quot;AttachStdin&quot;: false,</span><br><span class="line">          &quot;AttachStdout&quot;: false,</span><br><span class="line">          &quot;AttachStderr&quot;: false,</span><br><span class="line">          &quot;Tty&quot;: true,</span><br><span class="line">          &quot;OpenStdin&quot;: true,</span><br><span class="line">          &quot;StdinOnce&quot;: false,</span><br><span class="line">          &quot;Env&quot;: [</span><br><span class="line">              &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/bin:/bin&quot;,</span><br><span class="line">              &quot;JAVA_HOME=/usr/local/jdk1.8.0_151&quot;,</span><br><span class="line">              &quot;MAVEN_HOME=/usr/local/apache-maven-3.6.0&quot;,</span><br><span class="line">              &quot;MAVEN_CONFIG=/root/.m2&quot;,</span><br><span class="line">              &quot;CLASSPATH=/lib/dt.jar:/lib/tools.jar&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;Cmd&quot;: [</span><br><span class="line">              &quot;/bin/bash&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;ArgsEscaped&quot;: true,</span><br><span class="line">          &quot;Image&quot;: &quot;jdk8:v1&quot;,</span><br><span class="line">          &quot;Volumes&quot;: null,</span><br><span class="line">          &quot;WorkingDir&quot;: &quot;&quot;,</span><br><span class="line">          &quot;Entrypoint&quot;: null,</span><br><span class="line">          &quot;OnBuild&quot;: null,</span><br><span class="line">          &quot;Labels&quot;: &#123;</span><br><span class="line">              &quot;org.label-schema.build-date&quot;: &quot;20181006&quot;,</span><br><span class="line">              &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;,</span><br><span class="line">              &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;,</span><br><span class="line">              &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;,</span><br><span class="line">              &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;NetworkSettings&quot;: &#123;</span><br><span class="line">          &quot;Bridge&quot;: &quot;&quot;,</span><br><span class="line">          &quot;SandboxID&quot;: &quot;05a4601c60f48b659a4f5652223ce66518fda32ea775ee03af43bac25d2c2a6b&quot;,</span><br><span class="line">          &quot;HairpinMode&quot;: false,</span><br><span class="line">          &quot;LinkLocalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">          &quot;LinkLocalIPv6PrefixLen&quot;: 0,</span><br><span class="line">          &quot;Ports&quot;: &#123;&#125;,</span><br><span class="line">          &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/05a4601c60f4&quot;,</span><br><span class="line">          &quot;SecondaryIPAddresses&quot;: null,</span><br><span class="line">          &quot;SecondaryIPv6Addresses&quot;: null,</span><br><span class="line">          &quot;EndpointID&quot;: &quot;f24c035e996439590c88b2d0ab3d26cdf32115cdb3d9ec5fa50710cb7ef832d6&quot;,</span><br><span class="line">          &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">          &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">          &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">          &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,</span><br><span class="line">          &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">          &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">          &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">          &quot;Networks&quot;: &#123;</span><br><span class="line">              &quot;bridge&quot;: &#123;</span><br><span class="line">                  &quot;IPAMConfig&quot;: null,</span><br><span class="line">                  &quot;Links&quot;: null,</span><br><span class="line">                  &quot;Aliases&quot;: null,</span><br><span class="line">                  &quot;NetworkID&quot;: &quot;dac87c8ed4bd04308689a40796a465fa0fe175a30e82a0907a40c76405ba7c88&quot;,</span><br><span class="line">                  &quot;EndpointID&quot;: &quot;f24c035e996439590c88b2d0ab3d26cdf32115cdb3d9ec5fa50710cb7ef832d6&quot;,</span><br><span class="line">                  &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">                  &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,</span><br><span class="line">                  &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">                  &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">                  &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">                  &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">                  &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">                  &quot;DriverOpts&quot;: null</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>  数据卷的信息在”Mounts”里边：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">  &#123;</span><br><span class="line">      &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">      &quot;Source&quot;: &quot;volume-1&quot;,</span><br><span class="line">      &quot;Target&quot;: &quot;/webapp&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h3 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h3>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;docker volume rm volume-1</span><br><span class="line">#如果数据卷 volume-1别其他容器引用，则是无法删除的，并且删除的时候会提示：</span><br><span class="line"># Error response from daemon: remove volume-1: volume is in use - [c9c346fdf8dcb7d4923d7f07b369e2f07779c14913f42a07b3b9f0accb73dac9]</span><br><span class="line">#需要先把容器删除</span><br></pre></td></tr></table></figure>

<p>  数据卷设计的是用来存放数据的，并不会随着容器的删除而删除，有点类似于Linux里边的mount操作，如果想在删除容器的时候顺带删除数据卷，可以使用docker rm -v。</p>
<p>  无主的数据卷可能会占据很多空间，要清理请使用以下命令：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;docker volume prune</span><br></pre></td></tr></table></figure>

<h2 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h2><h3 id="挂载一个主机目录作为数据卷"><a href="#挂载一个主机目录作为数据卷" class="headerlink" title="挂载一个主机目录作为数据卷"></a>挂载一个主机目录作为数据卷</h3><p>  加载主机的 E:\Study\dockerWorkspace\volumes\volume1 目录到容器的 &#x2F;opt&#x2F;webapp 目录,此功能可以在测试的时候发挥作用，比如我们可以在source下边添加文件，依次来判定容器是否工作。<br>  PS： –mount 参数时如果本地目录不存在，Docker 会报错<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;docker run -dit --name myjdk8 --mount type=bind,source=E:\Study\dockerWorkspace\volumes\volume1,target=/webapp jdk8:v1</span><br><span class="line">#查看容器里边的挂载目录的信息</span><br><span class="line">&gt;&gt;docker inspect myjdk8</span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">      &quot;Id&quot;: &quot;c28039a147a1ae4210e6cdf5491a56bb9dae25ca11c6ae2e91c9f55075d1ba5c&quot;,</span><br><span class="line">      &quot;Created&quot;: &quot;2018-11-24T08:55:43.3658908Z&quot;,</span><br><span class="line">      &quot;Path&quot;: &quot;/bin/bash&quot;,</span><br><span class="line">      &quot;Args&quot;: [],</span><br><span class="line">      &quot;State&quot;: &#123;</span><br><span class="line">          &quot;Status&quot;: &quot;running&quot;,</span><br><span class="line">          &quot;Running&quot;: true,</span><br><span class="line">          &quot;Paused&quot;: false,</span><br><span class="line">          &quot;Restarting&quot;: false,</span><br><span class="line">          &quot;OOMKilled&quot;: false,</span><br><span class="line">          &quot;Dead&quot;: false,</span><br><span class="line">          &quot;Pid&quot;: 4170,</span><br><span class="line">          &quot;ExitCode&quot;: 0,</span><br><span class="line">          &quot;Error&quot;: &quot;&quot;,</span><br><span class="line">          &quot;StartedAt&quot;: &quot;2018-11-24T08:55:45.2437582Z&quot;,</span><br><span class="line">          &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;Image&quot;: &quot;sha256:a70ba00548f32c4d0152cb12e9aafdc419fc5bbb14744780bdfffb11f074ec03&quot;,</span><br><span class="line">      &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/c28039a147a1ae4210e6cdf5491a56bb9dae25ca11c6ae2e91c9f55075d1ba5c/resolv.conf&quot;,</span><br><span class="line">      &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/c28039a147a1ae4210e6cdf5491a56bb9dae25ca11c6ae2e91c9f55075d1ba5c/hostname&quot;,</span><br><span class="line">      &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/c28039a147a1ae4210e6cdf5491a56bb9dae25ca11c6ae2e91c9f55075d1ba5c/hosts&quot;,</span><br><span class="line">      &quot;LogPath&quot;: &quot;/var/lib/docker/containers/c28039a147a1ae4210e6cdf5491a56bb9dae25ca11c6ae2e91c9f55075d1ba5c/c28039a147a1ae4210e6cdf5491a56bb9dae25ca11c6ae2e91c9f55075d1ba5c-json.log&quot;,</span><br><span class="line">      &quot;Name&quot;: &quot;/myjdk8&quot;,</span><br><span class="line">      &quot;RestartCount&quot;: 0,</span><br><span class="line">      &quot;Driver&quot;: &quot;overlay2&quot;,</span><br><span class="line">      &quot;Platform&quot;: &quot;linux&quot;,</span><br><span class="line">      &quot;MountLabel&quot;: &quot;&quot;,</span><br><span class="line">      &quot;ProcessLabel&quot;: &quot;&quot;,</span><br><span class="line">      &quot;AppArmorProfile&quot;: &quot;&quot;,</span><br><span class="line">      &quot;ExecIDs&quot;: null,</span><br><span class="line">      &quot;HostConfig&quot;: &#123;</span><br><span class="line">          &quot;Binds&quot;: null,</span><br><span class="line">          &quot;ContainerIDFile&quot;: &quot;&quot;,</span><br><span class="line">          &quot;LogConfig&quot;: &#123;</span><br><span class="line">              &quot;Type&quot;: &quot;json-file&quot;,</span><br><span class="line">              &quot;Config&quot;: &#123;&#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;NetworkMode&quot;: &quot;default&quot;,</span><br><span class="line">          &quot;PortBindings&quot;: &#123;&#125;,</span><br><span class="line">          &quot;RestartPolicy&quot;: &#123;</span><br><span class="line">              &quot;Name&quot;: &quot;no&quot;,</span><br><span class="line">              &quot;MaximumRetryCount&quot;: 0</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;AutoRemove&quot;: false,</span><br><span class="line">          &quot;VolumeDriver&quot;: &quot;&quot;,</span><br><span class="line">          &quot;VolumesFrom&quot;: null,</span><br><span class="line">          &quot;CapAdd&quot;: null,</span><br><span class="line">          &quot;CapDrop&quot;: null,</span><br><span class="line">          &quot;Dns&quot;: [],</span><br><span class="line">          &quot;DnsOptions&quot;: [],</span><br><span class="line">          &quot;DnsSearch&quot;: [],</span><br><span class="line">          &quot;ExtraHosts&quot;: null,</span><br><span class="line">          &quot;GroupAdd&quot;: null,</span><br><span class="line">          &quot;IpcMode&quot;: &quot;shareable&quot;,</span><br><span class="line">          &quot;Cgroup&quot;: &quot;&quot;,</span><br><span class="line">          &quot;Links&quot;: null,</span><br><span class="line">          &quot;OomScoreAdj&quot;: 0,</span><br><span class="line">          &quot;PidMode&quot;: &quot;&quot;,</span><br><span class="line">          &quot;Privileged&quot;: false,</span><br><span class="line">          &quot;PublishAllPorts&quot;: false,</span><br><span class="line">          &quot;ReadonlyRootfs&quot;: false,</span><br><span class="line">          &quot;SecurityOpt&quot;: null,</span><br><span class="line">          &quot;UTSMode&quot;: &quot;&quot;,</span><br><span class="line">          &quot;UsernsMode&quot;: &quot;&quot;,</span><br><span class="line">          &quot;ShmSize&quot;: 67108864,</span><br><span class="line">          &quot;Runtime&quot;: &quot;runc&quot;,</span><br><span class="line">          &quot;ConsoleSize&quot;: [</span><br><span class="line">              50,</span><br><span class="line">              189</span><br><span class="line">          ],</span><br><span class="line">          &quot;Isolation&quot;: &quot;&quot;,</span><br><span class="line">          &quot;CpuShares&quot;: 0,</span><br><span class="line">          &quot;Memory&quot;: 0,</span><br><span class="line">          &quot;NanoCpus&quot;: 0,</span><br><span class="line">          &quot;CgroupParent&quot;: &quot;&quot;,</span><br><span class="line">          &quot;BlkioWeight&quot;: 0,</span><br><span class="line">          &quot;BlkioWeightDevice&quot;: [],</span><br><span class="line">          &quot;BlkioDeviceReadBps&quot;: null,</span><br><span class="line">          &quot;BlkioDeviceWriteBps&quot;: null,</span><br><span class="line">          &quot;BlkioDeviceReadIOps&quot;: null,</span><br><span class="line">          &quot;BlkioDeviceWriteIOps&quot;: null,</span><br><span class="line">          &quot;CpuPeriod&quot;: 0,</span><br><span class="line">          &quot;CpuQuota&quot;: 0,</span><br><span class="line">          &quot;CpuRealtimePeriod&quot;: 0,</span><br><span class="line">          &quot;CpuRealtimeRuntime&quot;: 0,</span><br><span class="line">          &quot;CpusetCpus&quot;: &quot;&quot;,</span><br><span class="line">          &quot;CpusetMems&quot;: &quot;&quot;,</span><br><span class="line">          &quot;Devices&quot;: [],</span><br><span class="line">          &quot;DeviceCgroupRules&quot;: null,</span><br><span class="line">          &quot;DiskQuota&quot;: 0,</span><br><span class="line">          &quot;KernelMemory&quot;: 0,</span><br><span class="line">          &quot;MemoryReservation&quot;: 0,</span><br><span class="line">          &quot;MemorySwap&quot;: 0,</span><br><span class="line">          &quot;MemorySwappiness&quot;: null,</span><br><span class="line">          &quot;OomKillDisable&quot;: false,</span><br><span class="line">          &quot;PidsLimit&quot;: 0,</span><br><span class="line">          &quot;Ulimits&quot;: null,</span><br><span class="line">          &quot;CpuCount&quot;: 0,</span><br><span class="line">          &quot;CpuPercent&quot;: 0,</span><br><span class="line">          &quot;IOMaximumIOps&quot;: 0,</span><br><span class="line">          &quot;IOMaximumBandwidth&quot;: 0,</span><br><span class="line">          &quot;Mounts&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                  &quot;Type&quot;: &quot;bind&quot;,</span><br><span class="line">                  &quot;Source&quot;: &quot;/host_mnt/e/Study/dockerWorkspace/volumes/volume1&quot;,</span><br><span class="line">                  &quot;Target&quot;: &quot;/webapp&quot;</span><br><span class="line">              &#125;</span><br><span class="line">          ],</span><br><span class="line">          &quot;MaskedPaths&quot;: [</span><br><span class="line">              &quot;/proc/acpi&quot;,</span><br><span class="line">              &quot;/proc/kcore&quot;,</span><br><span class="line">              &quot;/proc/keys&quot;,</span><br><span class="line">              &quot;/proc/latency_stats&quot;,</span><br><span class="line">              &quot;/proc/timer_list&quot;,</span><br><span class="line">              &quot;/proc/timer_stats&quot;,</span><br><span class="line">              &quot;/proc/sched_debug&quot;,</span><br><span class="line">              &quot;/proc/scsi&quot;,</span><br><span class="line">              &quot;/sys/firmware&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;ReadonlyPaths&quot;: [</span><br><span class="line">              &quot;/proc/asound&quot;,</span><br><span class="line">              &quot;/proc/bus&quot;,</span><br><span class="line">              &quot;/proc/fs&quot;,</span><br><span class="line">              &quot;/proc/irq&quot;,</span><br><span class="line">              &quot;/proc/sys&quot;,</span><br><span class="line">              &quot;/proc/sysrq-trigger&quot;</span><br><span class="line">          ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;GraphDriver&quot;: &#123;</span><br><span class="line">          &quot;Data&quot;: &#123;</span><br><span class="line">              &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/2a1d010cd96bb1307be40e1b5e23a0b2f9ecbbcb124b4b8abfba963a0b37bf72-init/diff:/var/lib/docker/overlay2/2796cd7903fb6c509b276acb83505d05b1d685e010dc32557fe6baa06160e0a3/diff:/var/lib/docker/overlay2/15b4eabde2002d7fa67849c36b175b93827b911465b6cc8021e47f467ec2cca3/diff:/var/lib/docker/overlay2/9a004f009ec50069f1f7a8985bf40a256eda15b48402ccbefb6831ae52d2bbb8/diff:/var/lib/docker/overlay2/1d31c352fff2c856f6f208be8c9448ecc30447edcfacb10fd73e4d62ebef989d/diff&quot;,</span><br><span class="line">              &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/2a1d010cd96bb1307be40e1b5e23a0b2f9ecbbcb124b4b8abfba963a0b37bf72/merged&quot;,</span><br><span class="line">              &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/2a1d010cd96bb1307be40e1b5e23a0b2f9ecbbcb124b4b8abfba963a0b37bf72/diff&quot;,</span><br><span class="line">              &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/2a1d010cd96bb1307be40e1b5e23a0b2f9ecbbcb124b4b8abfba963a0b37bf72/work&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;Name&quot;: &quot;overlay2&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;Mounts&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">              &quot;Type&quot;: &quot;bind&quot;,</span><br><span class="line">              &quot;Source&quot;: &quot;/host_mnt/e/Study/dockerWorkspace/volumes/volume1&quot;,</span><br><span class="line">              &quot;Destination&quot;: &quot;/webapp&quot;,</span><br><span class="line">              &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">              &quot;RW&quot;: true,</span><br><span class="line">              &quot;Propagation&quot;: &quot;rprivate&quot;</span><br><span class="line">          &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;Config&quot;: &#123;</span><br><span class="line">          &quot;Hostname&quot;: &quot;c28039a147a1&quot;,</span><br><span class="line">          &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">          &quot;User&quot;: &quot;&quot;,</span><br><span class="line">          &quot;AttachStdin&quot;: false,</span><br><span class="line">          &quot;AttachStdout&quot;: false,</span><br><span class="line">          &quot;AttachStderr&quot;: false,</span><br><span class="line">          &quot;Tty&quot;: true,</span><br><span class="line">          &quot;OpenStdin&quot;: true,</span><br><span class="line">          &quot;StdinOnce&quot;: false,</span><br><span class="line">          &quot;Env&quot;: [</span><br><span class="line">              &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/bin:/bin&quot;,</span><br><span class="line">              &quot;JAVA_HOME=/usr/local/jdk1.8.0_151&quot;,</span><br><span class="line">              &quot;MAVEN_HOME=/usr/local/apache-maven-3.6.0&quot;,</span><br><span class="line">              &quot;MAVEN_CONFIG=/root/.m2&quot;,</span><br><span class="line">              &quot;CLASSPATH=/lib/dt.jar:/lib/tools.jar&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;Cmd&quot;: [</span><br><span class="line">              &quot;/bin/bash&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;ArgsEscaped&quot;: true,</span><br><span class="line">          &quot;Image&quot;: &quot;jdk8:v1&quot;,</span><br><span class="line">          &quot;Volumes&quot;: null,</span><br><span class="line">          &quot;WorkingDir&quot;: &quot;&quot;,</span><br><span class="line">          &quot;Entrypoint&quot;: null,</span><br><span class="line">          &quot;OnBuild&quot;: null,</span><br><span class="line">          &quot;Labels&quot;: &#123;</span><br><span class="line">              &quot;org.label-schema.build-date&quot;: &quot;20181006&quot;,</span><br><span class="line">              &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;,</span><br><span class="line">              &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;,</span><br><span class="line">              &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;,</span><br><span class="line">              &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;NetworkSettings&quot;: &#123;</span><br><span class="line">          &quot;Bridge&quot;: &quot;&quot;,</span><br><span class="line">          &quot;SandboxID&quot;: &quot;d20c63fb42c257b9e1313b637d80d8c2841f4bec9d54c5941e2381a6f537b106&quot;,</span><br><span class="line">          &quot;HairpinMode&quot;: false,</span><br><span class="line">          &quot;LinkLocalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">          &quot;LinkLocalIPv6PrefixLen&quot;: 0,</span><br><span class="line">          &quot;Ports&quot;: &#123;&#125;,</span><br><span class="line">          &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/d20c63fb42c2&quot;,</span><br><span class="line">          &quot;SecondaryIPAddresses&quot;: null,</span><br><span class="line">          &quot;SecondaryIPv6Addresses&quot;: null,</span><br><span class="line">          &quot;EndpointID&quot;: &quot;89f640f036d7de25ad93e120e7352da9c99f254e82a4384972c43c6803f6c713&quot;,</span><br><span class="line">          &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">          &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">          &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">          &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,</span><br><span class="line">          &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">          &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">          &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">          &quot;Networks&quot;: &#123;</span><br><span class="line">              &quot;bridge&quot;: &#123;</span><br><span class="line">                  &quot;IPAMConfig&quot;: null,</span><br><span class="line">                  &quot;Links&quot;: null,</span><br><span class="line">                  &quot;Aliases&quot;: null,</span><br><span class="line">                  &quot;NetworkID&quot;: &quot;dac87c8ed4bd04308689a40796a465fa0fe175a30e82a0907a40c76405ba7c88&quot;,</span><br><span class="line">                  &quot;EndpointID&quot;: &quot;89f640f036d7de25ad93e120e7352da9c99f254e82a4384972c43c6803f6c713&quot;,</span><br><span class="line">                  &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">                  &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,</span><br><span class="line">                  &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">                  &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">                  &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">                  &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">                  &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,</span><br><span class="line">                  &quot;DriverOpts&quot;: null</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>  挂载信息：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;bind&quot;,</span><br><span class="line">        &quot;Source&quot;: &quot;/host_mnt/e/Study/dockerWorkspace/volumes/volume1&quot;,</span><br><span class="line">        &quot;Destination&quot;: &quot;/webapp&quot;,</span><br><span class="line">        &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">        &quot;RW&quot;: true,</span><br><span class="line">        &quot;Propagation&quot;: &quot;rprivate&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>  Docker 挂载主机目录的默认权限是 读写 ，用户也可以通过增加 readonly 指定为 只读 。<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -dit --name myjdk8 --mount type=bind,source=E:\Study\dockerWorkspace\volumes\volume1,target=/webapp readonly jdk8:v1</span><br></pre></td></tr></table></figure><br>  此时如果向&#x2F;webapp写操作，都会异常。</p>
<h2 id="挂载一个本地主机文件作为数据卷"><a href="#挂载一个本地主机文件作为数据卷" class="headerlink" title="挂载一个本地主机文件作为数据卷"></a>挂载一个本地主机文件作为数据卷</h2><p>  –mount 标记也可以从主机挂载单个文件到容器中</p>
<h3 id="记录在容器输入过的命令"><a href="#记录在容器输入过的命令" class="headerlink" title="记录在容器输入过的命令"></a>记录在容器输入过的命令</h3>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;docker run -dit --name myjdk8 --mount type=bind,source=E:\Study\dockerWorkspace\volumes\volume1\.bash_history,target=/root/.bash_history jdk8:v1</span><br><span class="line">d2bc7b21ca877bf952246bf147e29d9bc81a0b4769e1be3dca2cb49a30f20bec</span><br><span class="line">#这样就可以记录在容器输入过的命令了。</span><br><span class="line">&gt;docker exec -it  d2b bash</span><br><span class="line">[root@d2bc7b21ca87 /]# pwd</span><br><span class="line">/</span><br><span class="line">[root@d2bc7b21ca87 /]# cd /root</span><br><span class="line">[root@d2bc7b21ca87 ~]# ls</span><br><span class="line">anaconda-ks.cfg</span><br><span class="line">[root@d2bc7b21ca87 ~]# more .bash_history</span><br><span class="line">[root@d2bc7b21ca87 ~]# ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">   19 pts/1    00:00:00 bash</span><br><span class="line">   37 pts/1    00:00:00 ps</span><br><span class="line">[root@d2bc7b21ca87 ~]# top</span><br><span class="line">top - 09:10:52 up  3:36,  0 users,  load average: 0.23, 0.06, 0.02</span><br><span class="line">Tasks:   3 total,   1 running,   2 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.2 us,  0.0 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  2027756 total,    95516 free,   355696 used,  1576544 buff/cache</span><br><span class="line">KiB Swap:  1048572 total,  1048572 free,        0 used.  1478204 avail Mem</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">    1 root      20   0   11832   2820   2544 S   0.0  0.1   0:00.05 bash</span><br><span class="line">   19 root      20   0   11832   2992   2616 S   0.0  0.1   0:00.03 bash</span><br><span class="line">   38 root      20   0   56176   3848   3296 R   0.0  0.2   0:00.00 top</span><br><span class="line">   [root@d2bc7b21ca87 ~]# ll</span><br><span class="line"> total 4</span><br><span class="line"> -rw------- 1 root root 3415 Oct  6 19:15 anaconda-ks.cfg</span><br><span class="line"> [root@d2bc7b21ca87 ~]# java -c</span><br><span class="line"> Unrecognized option: -c</span><br><span class="line"> Error: Could not create the Java Virtual Machine.</span><br><span class="line"> Error: A fatal exception has occurred. Program will exit.</span><br><span class="line"> [root@d2bc7b21ca87 ~]# java -v</span><br><span class="line"> Unrecognized option: -v</span><br><span class="line"> Error: Could not create the Java Virtual Machine.</span><br><span class="line"> Error: A fatal exception has occurred. Program will exit.</span><br><span class="line"> [root@d2bc7b21ca87 ~]# java -v</span><br><span class="line"> Unrecognized option: -v</span><br><span class="line"> Error: Could not create the Java Virtual Machine.</span><br><span class="line"> Error: A fatal exception has occurred. Program will exit.</span><br><span class="line"> [root@d2bc7b21ca87 ~]# java -v</span><br><span class="line"> Unrecognized option: -v</span><br><span class="line"> Error: Could not create the Java Virtual Machine.</span><br><span class="line"> Error: A fatal exception has occurred. Program will exit.</span><br><span class="line"> [root@d2bc7b21ca87 ~]# java -version</span><br><span class="line"> java version &quot;1.8.0_151&quot;</span><br><span class="line"> Java(TM) SE Runtime Environment (build 1.8.0_151-b12)</span><br><span class="line"> Java HotSpot(TM) 64-Bit Server VM (build 25.151-b12, mixed mode)</span><br></pre></td></tr></table></figure>

<p>  我们在容器里边敲了很多命令，<br>  那么此时我们可以到宿主机的E:\Study\dockerWorkspace\volumes\volume1.bash_history里边看一下，<br>  我们敲得命令的记录：<br>  <img src="/2018-11-24/4-docker-%E6%95%B0%E6%8D%AE%E5%8D%B7/4-2.png" alt="4-2"></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>volume</tag>
        <tag>数据卷</tag>
        <tag>挂载主机目录</tag>
      </tags>
  </entry>
  <entry>
    <title>CopyOnWriteArrayList和CopyOnWriteArraySet</title>
    <url>/2018/10/04/CopyOnWriteArrayList%E5%92%8CCopyOnWriteArraySet/</url>
    <content><![CDATA[<p>CopyOnWriteArrayList和CopyOnWriteArraySet应用场合一般 是在读多写少的情况，比如黑名单，他们之间的区别就是list和set的区别，但是在实现上CopyOnWriteArraySet使用CopyOnWriteArrayList来实现的，就像set使用了hashmap，treeset使用treemap，下面先看CopyOnWriteArrayList的添加操作.</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Inserts the specified element at the specified position in this</span><br><span class="line"> * list. Shifts the element currently at that position (if any) and</span><br><span class="line"> * any subsequent elements to the right (adds one to their indices).</span><br><span class="line"> *</span><br><span class="line"> * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</span><br><span class="line"> */</span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    //加锁，CopyOnWriteArrayList是线程安全的</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        int len = elements.length;</span><br><span class="line">        if (index &gt; len || index &lt; 0)</span><br><span class="line">            throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+</span><br><span class="line">                                                &quot;, Size: &quot;+len);</span><br><span class="line">        Object[] newElements;</span><br><span class="line">        int numMoved = len - index;</span><br><span class="line">        //如果位移实在列表的尾部，那么直接复制数组，，使用Arrays.copyOf()</span><br><span class="line">        if (numMoved == 0)</span><br><span class="line">            newElements = Arrays.copyOf(elements, len + 1);</span><br><span class="line">        else &#123;</span><br><span class="line">        //否则，以index为中心点，把原始数组分成2段，index左边一段，右边一段，index放要插入的数据元素，放进新的数组newElements。</span><br><span class="line">            newElements = new Object[len + 1];</span><br><span class="line">            System.arraycopy(elements, 0, newElements, 0, index);</span><br><span class="line">            System.arraycopy(elements, index, newElements, index + 1,</span><br><span class="line">                             numMoved);</span><br><span class="line">        &#125;</span><br><span class="line">        newElements[index] = element;</span><br><span class="line">        //覆盖原来的数组，原来的数组失去引用，被jvm回收</span><br><span class="line">        setArray(newElements);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">     //解锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看remove方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Removes the first occurrence of the specified element from this list,</span><br><span class="line"> * if it is present.  If this list does not contain the element, it is</span><br><span class="line"> * unchanged.  More formally, removes the element with the lowest index</span><br><span class="line"> * &lt;tt&gt;i&lt;/tt&gt; such that</span><br><span class="line"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;</span><br><span class="line"> * (if such an element exists).  Returns &lt;tt&gt;true&lt;/tt&gt; if this list</span><br><span class="line"> * contained the specified element (or equivalently, if this list</span><br><span class="line"> * changed as a result of the call).</span><br><span class="line"> *</span><br><span class="line"> * @param o element to be removed from this list, if present</span><br><span class="line"> * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element</span><br><span class="line"> */</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    //加锁，</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        int len = elements.length;</span><br><span class="line">        if (len != 0) &#123;</span><br><span class="line">            // Copy while searching for element to remove</span><br><span class="line">            // This wins in the normal case of element being present</span><br><span class="line">            int newlen = len - 1;</span><br><span class="line">            Object[] newElements = new Object[newlen];</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; newlen; ++i) &#123;</span><br><span class="line">                if (eq(o, elements[i])) &#123;</span><br><span class="line">                    // found one;  copy remaining and exit</span><br><span class="line">                    //找到要删除的元素，然后将元素后面的数据复制到新的数组里边</span><br><span class="line">                    for (int k = i + 1; k &lt; len; ++k)</span><br><span class="line">                        newElements[k-1] = elements[k];</span><br><span class="line">                    setArray(newElements);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else</span><br><span class="line">                    //不是删除数据，直接进入新的数组</span><br><span class="line">                    newElements[i] = elements[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // special handling for last cell</span><br><span class="line">            //最后一个元素的单独处理</span><br><span class="line">            if (eq(o, elements[newlen])) &#123;</span><br><span class="line">                setArray(newElements);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">    //解锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看CopyOnWriteArraySet<br>内部维护了一个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private final CopyOnWriteArrayList&lt;E&gt; al;</span><br></pre></td></tr></table></figure>

<p>因为CopyOnWriteArraySet元素不能重复，所以CopyOnWriteArraySet的add用的是CopyOnWriteArrayList的addIfAbsent，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    return al.addIfAbsent(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除操作用的是CopyOnWriteArrayList的remove</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    return al.remove(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Thread</category>
      </categories>
      <tags>
        <tag>CopyOnWriteArrayList</tag>
        <tag>CopyOnWriteArraySet</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK_ElasticSearch-Logstash-Kibana搭建实时日志分析平台</title>
    <url>/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cDovL215Lm9zY2hpbmEubmV0L2l0YmxvZy9ibG9nLzU0NzI1MA==">http://my.oschina.net/itblog/blog/547250<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2JhaWR1LmJsb2cuNTFjdG8uY29tLzcxOTM4LzE2NzY3OTg=">http://baidu.blog.51cto.com/71938/1676798<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<p>1、ELK由ElasticSearch、Logstash和Kiabana三个开源工具组成。官方网站：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9wcm9kdWN0cw==">https://www.elastic.co/products<i class="fa fa-external-link-alt"></i></span><br>•	Elasticsearch是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。<br>•	Logstash是一个完全开源的工具，他可以对你的日志进行收集、过滤，并将其存储供以后使用（如，搜索）。<br>•	Kibana 也是一个开源和免费的工具，它Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志。<br><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802213017295.png" alt="这里写图片描述"><br><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802213047641.png" alt="这里写图片描述"><br><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802213111001.png" alt="这里写图片描述"><br><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802213129470.png" alt="这里写图片描述"><br>•	画了一个ELK工作的原理图：<br><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802213154905.png" alt="这里写图片描述"><br>•	如图：Logstash收集AppServer产生的Log，并存放到ElasticSearch集群中，而Kibana则从ES集群中查询数据生成图表，再返回给Browser。<br>2、环境：<br>Linux:<br><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802213232331.png" alt="这里写图片描述"><br>Elasticsearch：elasticsearch-2.3.4.tar.gz<br>Logstash：logstash-2.3.4.tar.gz<br>Kibana：kibana-4.5.2-linux-x64.tar.gz<br>Jdk：jdk-8u91-linux-x64.tar.gz<br>3、jdk的安装：<br> mkdir -p &#x2F;usr&#x2F;local&#x2F;java&#x2F;<br> tar -zxvf jdk-8u91-linux-x64.tar.gz -C &#x2F;usr&#x2F;local&#x2F;java&#x2F;<br> vim &#x2F;etc&#x2F;profile<br>加入：<br>JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_91<br>PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH<br>CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar<br>export JAVA_HOME<br>export PATH<br>export CLASSPATH<br><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802213301269.png" alt="这里写图片描述"><br>执行：<br> . &#x2F;etc&#x2F;profile #生效配置<br> java -version<br>4、安装配置Elasticsearch<br>4.1、安装配置Elasticsearch<br> tar -zxvf elasticsearch-2.3.4.tar.gz<br> cd elasticsearch-2.3.4<br>然后编辑ES的配置文件：<br>vim config&#x2F;elasticsearch.yml<br>修改以下配置项：<br>cluster.name: wen<br>node.name: node-1<br>path.data: &#x2F;path&#x2F;to&#x2F;data<br>path.logs: &#x2F;path&#x2F;to&#x2F;logs<br>当前hostname或IP，这里使用ip<br>network.host: 10.10.20.210<br>http.port: 9200<br><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802213420880.png" alt="这里写图片描述"><br>4.2、启动elasticsearch<br> .&#x2F;bin&#x2F;elasticsearch<br>报错：<br><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802213451131.png" alt="这里写图片描述"><br>不能使用root用户启动elasticsearch<br><strong>解决方法</strong>: <span class="exturl" data-url="aHR0cDovL215Lm9zY2hpbmEubmV0L3RvcGVhZ2xlL2Jsb2cvNTkxNDUxP2Zyb21lcnI9bXpPcjJxelo=">http://my.oschina.net/topeagle/blog/591451?fromerr=mzOr2qzZ<i class="fa fa-external-link-alt"></i></span><br>将&#x2F;data&#x2F;soft&#x2F;ch&#x2F;elasticsearch-2.3.4&#x2F;所属用户和组改为另外一个非root账户:<br>4.2.1、创建esgp组<br> groupadd esgp<br>4.2.2、创建用户es 添加到esgp组设置用户的密码为es123<br> useradd es -g esgp -p es123<br>4.2.3、更改elasticsearch-2.3.4文件夹及内部文件的所属用户及组为es:esgp<br> chown -R es:esgp  elasticsearch-2.3.4</p>
<p><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802213623063.png" alt="这里写图片描述"><br>4.2.4、切换到es用户<br> su es<br>4.2.5、启动elasticsearch<br> .&#x2F;elasticsearch-2.3.4&#x2F;bin&#x2F;elasticsearch<br><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802213649711.png" alt="这里写图片描述"><br>修改&#x2F;path&#x2F;to&#x2F;logs&#x2F;和&#x2F;path&#x2F;to&#x2F;data&#x2F;的权限：设置&#x2F;path的用户为es,组为esgp<br> su root<br> chown -R es:esgp &#x2F;path<br><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802213724884.png" alt="这里写图片描述"><br>再启动elasticsearch<br><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802213745415.png" alt="这里写图片描述"><br>使用ctrl+C停止。当然，也可以使用<strong>后台进程</strong>的方式启动ES：<br> .&#x2F;elasticsearch-2.3.4&#x2F;bin&#x2F;elasticsearch –d<br>或者<br>.&#x2F;elasticsearch-2.3.4&#x2F;bin&#x2F;elasticsearch &amp;<br><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802213826158.png" alt="这里写图片描述"><br>4.2.6、可以打开页面10.10.20.210:920，将会看到以下内容<br><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802213847346.png" alt="这里写图片描述"><br><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802213902002.png" alt="这里写图片描述"><br>5、安装elasticsearch的插件：elasticsearch-head<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21vYnovZWxhc3RpY3NlYXJjaC1oZWFk">https://github.com/mobz/elasticsearch-head<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVseV8yL2FydGljbGUvZGV0YWlscy8yNDQ4MTkzNQ==">http://blog.csdn.net/july_2/article/details/24481935<i class="fa fa-external-link-alt"></i></span><br>5.1、插件安装方法1：<br>5.1.1.#.&#x2F;elasticsearch-2.3.4&#x2F;bin&#x2F;plugin -install mobz&#x2F;elasticsearch-head<br>5.1.2.运行es<br>5.1.3.打开<br><span class="exturl" data-url="aHR0cDovLzEwLjEwLjIwLjIxMDo5MjAwL19wbHVnaW4vaGVhZC8=">http://10.10.20.210:9200/_plugin/head/<i class="fa fa-external-link-alt"></i></span></p>
<p>5.2、插件安装方法2：<br>5.2.1.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21vYnovZWxhc3RpY3NlYXJjaC1oZWFkJUU0JUI4JThCJUU4JUJEJUJEemlw">https://github.com/mobz/elasticsearch-head下载zip<i class="fa fa-external-link-alt"></i></span> 解压<br><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802213940605.png" alt="这里写图片描述"><br>5.2.2.建立elasticsearch-2.3.4&#x2F;plugins&#x2F;head&#x2F;_site文件<br> mkdir -p .&#x2F;elasticsearch-2.3.4&#x2F;plugins&#x2F;head&#x2F;_site<br>5.2.3.将解压后的<code>elasticsearch-head-master</code>文件夹下的文件copy到<code>_site</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su root  #切换到root用户</span><br><span class="line">unzip elasticsearch-head-master.zip   #解压</span><br><span class="line">cp -r /data/soft/ch/elasticsearch-head-master/* /data/soft/ch/elasticsearch-2.3.4/plugins/head/\_site/</span><br></pre></td></tr></table></figure>
<p> <img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802214101488.png" alt="这里写图片描述"><br> 5.2.4.运行es<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> su es  #切换到es用户</span><br><span class="line">/data/soft/ch/elasticsearch-2.3.4/bin/elasticsearch</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802214136624.png" alt="这里写图片描述"><br>会报错，如上，<strong>拷贝plugin-descriptor.properties文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp /data/soft/ch/elasticsearch-2.3.4/plugins/head/\_site/plugin-descriptor.properties /data/soft/ch/elasticsearch-2.3.4/plugins/head/</span><br></pre></td></tr></table></figure>
<p>再启动elasticsearch<br>5.2.5.打开<span class="exturl" data-url="aHR0cDovLzEwLjEwLjIwLjIxMDo5MjAwLyU2MF9wbHVnaW4lNjAvaGVhZC8=">http://10.10.20.210:9200/`_plugin`/head/<i class="fa fa-external-link-alt"></i></span><br><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802214222770.png" alt="这里写图片描述"><br>6、安装logstash-2.3.4.tar.gz</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf logstash-2.3.4.tar.gz</span><br><span class="line">cd logstash-2.3.4</span><br><span class="line">mkdir config</span><br><span class="line">touch file_to_es.conf   #创建file_to_es.conf文件</span><br></pre></td></tr></table></figure>
<p> <img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802214324330.png" alt="这里写图片描述"><br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim file_to_es.conf</span><br></pre></td></tr></table></figure><br>输入内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> #For detail structure of this file</span><br><span class="line"> #Set: https://www.elastic.co/guide/en/logstash/current/configuration-file-structure.html</span><br><span class="line">input &#123;</span><br><span class="line">  # For detail config for file as input,</span><br><span class="line">  # See: https://www.elastic.co/guide/en/logstash/current/plugins-inputs-file.html</span><br><span class="line">  file&#123;</span><br><span class="line">    path =&gt; &quot;/data/java/apache-tomcat-ware/logs/catalina.out&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  # For detail config for log4j as input,</span><br><span class="line">  # See: https://www.elastic.co/guide/en/logstash/current/plugins-inputs-log4j.html</span><br><span class="line">  #log4j &#123;</span><br><span class="line">  #  mode =&gt; &quot;server&quot;</span><br><span class="line">  #  host =&gt; &quot;10.10.20.210&quot;</span><br><span class="line">  #  port =&gt; 4567</span><br><span class="line">  #&#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  #Only matched data are send to output.</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  # For detail config for elasticsearch as output,</span><br><span class="line">  # See: https://www.elastic.co/guide/en/logstash/current/plugins-outputs-elasticsearch.html</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    action =&gt; &quot;index&quot;          #The operation on ES</span><br><span class="line">    hosts  =&gt; &quot;10.10.20.210:9200&quot;   #ElasticSearch host, can be array.</span><br><span class="line">    index  =&gt; &quot;ware-manager-dev&quot;         #The index to write data to.</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动logstash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./logstash-2.3.4/bin/logstash agent -f ./logstash-2.3.4/config/file_to_es.conf</span><br></pre></td></tr></table></figure>
<p><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802214412190.png" alt="这里写图片描述"><br>后台启动（加上&amp;）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./logstash-2.3.4/bin/logstash agent -f ./logstash-2.3.4/config/file_to_es.conf &amp;</span><br></pre></td></tr></table></figure>
<p> <img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802214441287.png" alt="这里写图片描述"><br> 查看进程<br> <img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802214507600" alt="这里写图片描述"><br> 可以在<span class="exturl" data-url="aHR0cDovLzEwLjEwLjIwLjIxMDo5MjAwLyU2MF9wbHVnaW4lNjAvaGVhZC8lRTQlQjglQUQlRTclOUMlOEIlRTUlODglQjAlRTglODclQUElRTUlOEElQTglRTUlODglOUIlRTUlQkIlQkElRTQlQkElODZ3YXJlLW1hbmFnZXItZGV2JUU4JUJGJTk5JUU0JUI4JUFBJUU3JUI0JUEyJUU1JUJDJTk1JUVGJUJDJThDJUU5JTg3JThDJUU5JTlEJUEyJUU0JUJGJTlEJUU1JUFEJTk4JUU3JTlBJTg0JUU2JTk4JUFGd2FyZS1tYW5hZ2VyJUU4JUJGJTk5JUU0JUI4JUFBJUU5JUExJUI5JUU3JTlCJUFFJUU3JTlBJTg0JUU2JTk3JUE1JUU1JUJGJTk3">http://10.10.20.210:9200/`_plugin`/head/中看到自动创建了ware-manager-dev这个索引，里面保存的是ware-manager这个项目的日志<i class="fa fa-external-link-alt"></i></span><br> <img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802214535116.png" alt="这里写图片描述"><br> <img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802214605958.png" alt="这里写图片描述"><br> <strong>注意：如果在同一个服务器对不同的文件，设置不同的索引，那么可以增加配置文件然后制定配置文件启动即可</strong><br> <img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802214633881.png" alt="这里写图片描述"><br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ./logstash-2.3.4/bin/logstash agent -f ./logstash-2.3.4/config/order_to_es.conf &amp;</span><br><span class="line">#./logstash-2.3.4/bin/logstash agent -f ./logstash-2.3.4/config/ware_to_es.conf &amp;</span><br></pre></td></tr></table></figure><br> <img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802214710163.png" alt="这里写图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">order_to_es.conf的内容：</span><br><span class="line"># For detail structure of this file</span><br><span class="line"># Set: https://www.elastic.co/guide/en/logstash/current/configuration-file-structure.html</span><br><span class="line">input &#123;</span><br><span class="line">  file&#123;</span><br><span class="line">    path =&gt; &quot;/data/applogs/**order**/wrapper.*.log&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  # For detail config for log4j as input,</span><br><span class="line">  # See: https://www.elastic.co/guide/en/logstash/current/plugins-inputs-log4j.html</span><br><span class="line">  #log4j &#123;</span><br><span class="line">  #  mode =&gt; &quot;server&quot;</span><br><span class="line">  #  host =&gt; &quot;10.10.20.206&quot;</span><br><span class="line">  #  port =&gt; 4567</span><br><span class="line">  #&#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  #Only matched data are send to output.</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  # For detail config for elasticsearch as output,</span><br><span class="line">  # See: https://www.elastic.co/guide/en/logstash/current/plugins-outputs-elasticsearch.html</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    action =&gt; &quot;index&quot;          #The operation on ES</span><br><span class="line">    hosts  =&gt; &quot;10.10.20.206:9200&quot;   #ElasticSearch host, can be array.</span><br><span class="line">    index  =&gt; &quot;**order-server-test**&quot;         #The index to write data to.</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ware_to_es.conf的内容：</span><br><span class="line"># For detail structure of this file</span><br><span class="line"># Set: https://www.elastic.co/guide/en/logstash/current/configuration-file-structure.html</span><br><span class="line">input &#123;</span><br><span class="line">  file&#123;</span><br><span class="line">    path =&gt; &quot;/data/applogs/**ware**/wrapper.*.log&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  # For detail config for log4j as input,</span><br><span class="line">  # See: https://www.elastic.co/guide/en/logstash/current/plugins-inputs-log4j.html</span><br><span class="line">  #log4j &#123;</span><br><span class="line">  #  mode =&gt; &quot;server&quot;</span><br><span class="line">  #  host =&gt; &quot;10.10.20.206&quot;</span><br><span class="line">  #  port =&gt; 4567</span><br><span class="line">  #&#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  #Only matched data are send to output.</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  # For detail config for elasticsearch as output,</span><br><span class="line">  # See: https://www.elastic.co/guide/en/logstash/current/plugins-outputs-elasticsearch.html</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    action =&gt; &quot;index&quot;          #The operation on ES</span><br><span class="line">    hosts  =&gt; &quot;10.10.20.206:9200&quot;   #ElasticSearch host, can be array.</span><br><span class="line">    index  =&gt; &quot;**ware-server-test**&quot;         #The index to write data to.</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>7、安装kibana</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf kibana-4.5.2-linux-x64.tar.gz</span><br><span class="line"> cd kibana-4.5.2-linux-x64</span><br><span class="line"> vim config/kibana.yml</span><br></pre></td></tr></table></figure>
<p>修改内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server.port: 5601</span><br><span class="line">server.host: &quot;10.10.20.210&quot;</span><br><span class="line">elasticsearch.url: &quot;http://10.10.20.210:9200&quot;</span><br><span class="line">kibana.index: &quot;.kibana&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802214827148.png" alt="这里写图片描述"><br>注意：其中server.host是安装kibana服务的地址<br>elasticsearch.url为elasticsearch安装的地址<br>启动kibana</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/data/soft/ch/kibana-4.5.2-linux-x64/bin/kibana</span><br></pre></td></tr></table></figure>
<p><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802214853540.png" alt="这里写图片描述"><br>可以通过<span class="exturl" data-url="aHR0cDovLzEwLjEwLjIwLjIwNjo1NjAx6K6/6Zeu5Yiw44CC">http://10.10.20.206:5601访问到。<i class="fa fa-external-link-alt"></i></span><br><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802214914320.png" alt="这里写图片描述"><br>也可以后台启动kibana(<strong>加上&amp;</strong>)<br> &#x2F;data&#x2F;soft&#x2F;ch&#x2F;kibana-4.5.2-linux-x64&#x2F;bin&#x2F;kibana <strong>&amp;</strong><br> <img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802214949057.png" alt="这里写图片描述"><br> 注意：这时加上了&amp;虽然执行了后台启动，但是还是有日志打印出来，使用ctrl+c可以退出。<br>但是如果直接关闭了Xshell,这时服务也会停止，访问<span class="exturl" data-url="aHR0cDovLzEwLjEwLjIwLjIwNjo1NjAx5bCx5aSx6LSl5LqG44CC">http://10.10.20.206:5601就失败了。<i class="fa fa-external-link-alt"></i></span></p>
<p><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802215013510.png" alt="这里写图片描述"><br>解决方法：<br>执行了&#x2F;data&#x2F;soft&#x2F;ch&#x2F;kibana-4.5.2-linux-x64&#x2F;bin&#x2F;kibana &amp;命令后，不使用ctrl+c去退出日志，<br>而是使用exit;这样即使关闭了Xshell窗口服务也不会挂了。<br><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802215039664.png" alt="这里写图片描述"><br>配置kibana：<br><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802215105746.png" alt="这里写图片描述"><br>这时在elasticsearch中多了一个kibana的索引<br><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802215128024.png" alt="这里写图片描述"><br>为了后续使用Kibana，需要配置至少一个Index名字或者Pattern，它用于在分析时确定ES中的Index。这里我输入之前配置的Index 名字ware-manager-dev，Kibana会自动加载该Index下doc的field，并自动选择合适的field用于图标中的时间字段：<br><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802215154747.png" alt="这里写图片描述"><br>点击Discover查看日志<br><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802215216545.png" alt="这里写图片描述"><br>设置只查看message信息:<br><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802215240915.png" alt="这里写图片描述"><br><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802215302619.png" alt="这里写图片描述"><br>设置自动刷新：<br><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802215327187.png" alt="这里写图片描述"><br><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802215349000.png" alt="这里写图片描述"><br><img src="/2018/09/28/ELK-ElasticSearch-Logstash-Kibana%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/20160802215405228.png" alt="这里写图片描述"><br>更多配置请查看：<br><span class="exturl" data-url="aHR0cDovL215Lm9zY2hpbmEubmV0L2l0YmxvZy9ibG9nLzU0NzI1MA==">http://my.oschina.net/itblog/blog/547250<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>kibana</tag>
        <tag>logstash</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC简易实现</title>
    <url>/2018/10/13/RPC%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>RpcFramework:</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package rpc;</span><br><span class="line"></span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * RpcFramework</span><br><span class="line"> *</span><br><span class="line"> * @author ceaserWang</span><br><span class="line"> */</span><br><span class="line">public class RpcFramework &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 暴露服务</span><br><span class="line">     *</span><br><span class="line">     * @param service 服务实现</span><br><span class="line">     * @param port 服务端口</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static void export(final Object service, int port) throws Exception &#123;</span><br><span class="line">        if (service == null)</span><br><span class="line">            throw new IllegalArgumentException(&quot;service instance == null&quot;);</span><br><span class="line">        if (port &lt;= 0 || port &gt; 65535)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Invalid port &quot; + port);</span><br><span class="line">        System.out.println(&quot;Export service &quot; + service.getClass().getName() + &quot; on port &quot; + port);</span><br><span class="line">        ServerSocket server = new ServerSocket(port);</span><br><span class="line">        for(;;) &#123;</span><br><span class="line">        	System.out.println(&quot;export&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">            	//阻塞，等到数据传输</span><br><span class="line">                final Socket socket = server.accept();</span><br><span class="line">                new Thread(new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                ObjectInputStream input = new ObjectInputStream(socket.getInputStream());</span><br><span class="line">                                try &#123;</span><br><span class="line">                                    String methodName = input.readUTF();</span><br><span class="line">                                    Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[])input.readObject();</span><br><span class="line">                                    Object[] arguments = (Object[])input.readObject();</span><br><span class="line">                                    ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());</span><br><span class="line">                                    try &#123;</span><br><span class="line">                                        Method method = service.getClass().getMethod(methodName, parameterTypes);</span><br><span class="line">                                        Object result = method.invoke(service, arguments);</span><br><span class="line">                                        output.writeObject(result);</span><br><span class="line">                                    &#125; catch (Throwable t) &#123;</span><br><span class="line">                                        output.writeObject(t);</span><br><span class="line">                                    &#125; finally &#123;</span><br><span class="line">                                        output.close();</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125; finally &#123;</span><br><span class="line">                                    input.close();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; finally &#123;</span><br><span class="line">                                socket.close();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; catch (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 引用服务</span><br><span class="line">     *</span><br><span class="line">     * @param &lt;T&gt; 接口泛型</span><br><span class="line">     * @param interfaceClass 接口类型</span><br><span class="line">     * @param host 服务器主机名</span><br><span class="line">     * @param port 服务器端口</span><br><span class="line">     * @return 远程服务</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public static &lt;T&gt; T refer(final Class&lt;T&gt; interfaceClass, final String host, final int port) throws Exception &#123;</span><br><span class="line">        if (interfaceClass == null)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Interface class == null&quot;);</span><br><span class="line">        if (! interfaceClass.isInterface())</span><br><span class="line">            throw new IllegalArgumentException(&quot;The &quot; + interfaceClass.getName() + &quot; must be interface class!&quot;);</span><br><span class="line">        if (host == null || host.length() == 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Host == null!&quot;);</span><br><span class="line">        if (port &lt;= 0 || port &gt; 65535)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Invalid port &quot; + port);</span><br><span class="line">        System.out.println(&quot;Get remote service &quot; + interfaceClass.getName() + &quot; from server &quot; + host + &quot;:&quot; + port);</span><br><span class="line">        return (T) Proxy.newProxyInstance(interfaceClass.getClassLoader(), new Class&lt;?&gt;[] &#123;interfaceClass&#125;, new InvocationHandler() &#123;</span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] arguments) throws Throwable &#123;</span><br><span class="line">                Socket socket = new Socket(host, port);</span><br><span class="line">                try &#123;</span><br><span class="line">                    ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());</span><br><span class="line">                    try &#123;</span><br><span class="line">                        output.writeUTF(method.getName());</span><br><span class="line">                        output.writeObject(method.getParameterTypes());</span><br><span class="line">                        output.writeObject(arguments);</span><br><span class="line">                        ObjectInputStream input = new ObjectInputStream(socket.getInputStream());</span><br><span class="line">                        try &#123;</span><br><span class="line">                            Object result = input.readObject();</span><br><span class="line">                            if (result instanceof Throwable) &#123;</span><br><span class="line">                                throw (Throwable) result;</span><br><span class="line">                            &#125;</span><br><span class="line">                            return result;</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                            input.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        output.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>RpcProvider:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package rpc;</span><br><span class="line"></span><br><span class="line">import rpc.impl.HelloServiceImpl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * RpcProvider</span><br><span class="line"> *</span><br><span class="line"> * @author ceaserWang</span><br><span class="line"> */</span><br><span class="line">public class RpcProvider &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        HelloService service = new HelloServiceImpl();</span><br><span class="line">        RpcFramework.export(service, 1234);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>RpcConsumer:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * CodeLib 上午11:39:55</span><br><span class="line"> * All right reserved.</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">package rpc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * RpcConsumer</span><br><span class="line"> *</span><br><span class="line"> * @author ceaserWang</span><br><span class="line"> */</span><br><span class="line">public class RpcConsumer &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		HelloService service = RpcFramework.refer(HelloService.class,</span><br><span class="line">				&quot;127.0.0.1&quot;, 1234);</span><br><span class="line">		for (int i = 0; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">			String hello = service.hello(&quot;World&quot; + i);</span><br><span class="line">			System.out.println(hello);</span><br><span class="line">			Thread.sleep(1000);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>HelloService:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package rpc;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * @author ceaserWang</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public interface HelloService &#123;</span><br><span class="line">	String hello(String name);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>HelloServiceImpl:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* CodeLib 上午11:38:11</span><br><span class="line">* All right reserved.</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line">package rpc.impl;</span><br><span class="line"></span><br><span class="line">import rpc.HelloService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * HelloServiceImpl</span><br><span class="line"> *</span><br><span class="line"> * @author ceaserWang</span><br><span class="line"> */</span><br><span class="line">public class HelloServiceImpl implements HelloService &#123;</span><br><span class="line"></span><br><span class="line">    public String hello(String name) &#123;</span><br><span class="line">        return &quot;Hello &quot; + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>io</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 在Centos7下配置开机自启动</title>
    <url>/2018/10/04/Redis-%E5%9C%A8Centos7%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p>来源：<span class="exturl" data-url="aHR0cDovL3d3dy5qaWFuc2h1LmNvbS9wLzIwYjc2MWFlOTkzYw==">http://www.jianshu.com/p/20b761ae993c<i class="fa fa-external-link-alt"></i></span><br>设置Redis开机启动需要如下几个步骤：</p>
<span id="more"></span>

<p>编写配置脚本 [ vim &#x2F;etc&#x2F;init.d&#x2F;redis ]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">#</span><br><span class="line"># Simple Redis init.d script conceived to work on Linux systems</span><br><span class="line"># as it does use of the /proc filesystem.</span><br><span class="line">#chkconfig: 2345 80 90</span><br><span class="line">#description:auto_run</span><br><span class="line">REDISPORT=6379</span><br><span class="line">EXEC=/usr/local/bin/redis/src/redis-server</span><br><span class="line">CLIEXEC=/usr/local/bin/redis/src/redis-cli</span><br><span class="line"></span><br><span class="line">PIDFILE=/var/run/redis_$&#123;REDISPORT&#125;.pid</span><br><span class="line">CONF=&quot;/usr/local/bin/redis/redis.conf&quot;</span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">    start)</span><br><span class="line">        if [ -f $PIDFILE ]</span><br><span class="line">        then</span><br><span class="line">                echo &quot;$PIDFILE exists, process is already running or crashed&quot;</span><br><span class="line">        else</span><br><span class="line">                echo &quot;Starting Redis server...&quot;</span><br><span class="line">                $EXEC $CONF</span><br><span class="line">        fi</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        if [ ! -f $PIDFILE ]</span><br><span class="line">        then</span><br><span class="line">                echo &quot;$PIDFILE does not exist, process is not running&quot;</span><br><span class="line">        else</span><br><span class="line">                PID=$(cat $PIDFILE)</span><br><span class="line">                echo &quot;Stopping ...&quot;</span><br><span class="line">                $CLIEXEC -p $REDISPORT shutdown</span><br><span class="line">                while [ -x /proc/$&#123;PID&#125; ]</span><br><span class="line">                do</span><br><span class="line">                    echo &quot;Waiting for Redis to shutdown ...&quot;</span><br><span class="line">                    sleep 1</span><br><span class="line">                done</span><br><span class="line">                echo &quot;Redis stopped&quot;</span><br><span class="line">        fi</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        echo &quot;Please use start or stop as first argument&quot;</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>修改redis.conf,打开后台运行选项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># By default Redis does not run as a daemon. Use &#x27;yes&#x27; if you need it.</span><br><span class="line"># Note that Redis will write a pid file in /var/run/redis.pid when daemonized.</span><br><span class="line">daemonize yes</span><br></pre></td></tr></table></figure>

<p>修改文件执行权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x /etc/init.d/redis</span><br></pre></td></tr></table></figure>

<p>设置开机启动</p>
<h1 id="尝试启动或停止-redis"><a href="#尝试启动或停止-redis" class="headerlink" title="尝试启动或停止 redis"></a>尝试启动或停止 redis</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service redis start</span><br><span class="line">service redis stop</span><br></pre></td></tr></table></figure>

<h1 id="开启服务自启动"><a href="#开启服务自启动" class="headerlink" title="开启服务自启动"></a>开启服务自启动</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chkconfig redis on</span><br></pre></td></tr></table></figure>

<p>5.异常处理<br>A. 执行 [ service redis start ] 提示服务不支持 chkconfig，在开机脚本前添加如下内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#chkconfig: 2345 80 90</span><br><span class="line">#description:auto_run</span><br></pre></td></tr></table></figure>

<p>B. 如果在Windows下编辑的开机脚本，由于Windows中的换行符为CRLF, 而Unix(或Linux)换行符为LF，会导致开机脚本执行报错,把脚本通过notepad++转化为Unix格式。</p>
<p>作者：_LiuWei<br>链接：<span class="exturl" data-url="aHR0cDovL3d3dy5qaWFuc2h1LmNvbS9wLzIwYjc2MWFlOTkzYw==">http://www.jianshu.com/p/20b761ae993c<i class="fa fa-external-link-alt"></i></span><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis 启动脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>SPRING技术内幕-笔记（七）WEB环境中的springMVC</title>
    <url>/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89WEB%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84springMVC/</url>
    <content><![CDATA[<p><strong>7.1Tomcat的web.XML对springMVC 的描述</strong>：<br><img src="/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89WEB%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84springMVC/20150610221403198.png" alt="这里写图片描述"></p>
<span id="more"></span>
<p>dispatcherServlet定义了对应的URL的映射，context-param制定了bean的定义文件的路径，contextLoaderListener作为简历IOC容器的入口，加载IOC容器到servletContext中，即上下文。</p>
<p><strong>7.2上下文在？WEB容器中的启动</strong><br>在WEB容器中启动spring应用的过程：<br><img src="/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89WEB%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84springMVC/20150610222104616.png" alt="这里写图片描述"></p>
<p>ContextLoaderListener是一个监听器应为实现了servletAPI的ServletContextListener，就有了contextInitialized，contextDestroyed，而IOC容器的载入过程是由ContextLoaderListener的基类ContextLoader完成的：<br>他们关系：<br><img src="/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89WEB%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84springMVC/20150610222828706.png" alt="这里写图片描述"></p>
<p><strong>7.3WEB容器中的上下文设置</strong></p>
<p>WebApplicationContext的上下文设置：<br><img src="/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89WEB%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84springMVC/20150610223037173.png" alt="这里写图片描述"></p>
<p>在这个体系中XMLWebAppliocationContext初始化过程中建立了IOC容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class XmlWebApplicationContext extends AbstractRefreshableWebApplicationContext &#123;</span><br><span class="line"></span><br><span class="line">	/** Default config location for the root context */</span><br><span class="line">	//bean定义文件定义为常量</span><br><span class="line">	public static final String DEFAULT_CONFIG_LOCATION = &quot;/WEB-INF/applicationContext.xml&quot;;</span><br><span class="line"></span><br><span class="line">	/** Default prefix for building a config location for a namespace */</span><br><span class="line">	  //配置文件父级路径</span><br><span class="line">	public static final String DEFAULT_CONFIG_LOCATION_PREFIX = &quot;/WEB-INF/&quot;;</span><br><span class="line"></span><br><span class="line">	/** Default suffix for building a config location for a namespace */</span><br><span class="line">	//配置文件默认的后缀名是.XML</span><br><span class="line">	public static final String DEFAULT_CONFIG_LOCATION_SUFFIX = &quot;.xml&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Loads the bean definitions via an XmlBeanDefinitionReader.</span><br><span class="line">	 * @see org.springframework.beans.factory.xml.XmlBeanDefinitionReader</span><br><span class="line">	 * @see #initBeanDefinitionReader</span><br><span class="line">	 * @see #loadBeanDefinitions</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;</span><br><span class="line">		// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span><br><span class="line">		 //使用XmlBeanDefinitionReader进行BeanDefination的解析</span><br><span class="line">		XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">		// Configure the bean definition reader with this context&#x27;s</span><br><span class="line">		// resource loading environment.</span><br><span class="line">		beanDefinitionReader.setEnvironment(this.getEnvironment());</span><br><span class="line">		//因为XmlWebApplicationContext 是defaultResourceLoader的子类，因此传入this</span><br><span class="line">		beanDefinitionReader.setResourceLoader(this);</span><br><span class="line">		beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</span><br><span class="line"></span><br><span class="line">		// Allow a subclass to provide custom initialization of the reader,</span><br><span class="line">		// then proceed with actually loading the bean definitions.</span><br><span class="line">		//允许子类为reader配置自定的初始化过程</span><br><span class="line">		initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">		//使用定义好的XmlBeanDefinitionReader载入BeanDefinition</span><br><span class="line">		loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>loadBeanDefinitions方法代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//有多个beanDefination定义要逐个载入</span><br><span class="line">	protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws IOException &#123;</span><br><span class="line">		String[] configLocations = getConfigLocations();</span><br><span class="line">		if (configLocations != null) &#123;</span><br><span class="line">			for (String configLocation : configLocations) &#123;</span><br><span class="line">				reader.loadBeanDefinitions(configLocation);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>得到Resource的路径默认是“&#x2F;WEB-INF&#x2F;applicationContext.xml”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected String[] getDefaultConfigLocations() &#123;</span><br><span class="line">	if (getNamespace() != null) &#123;</span><br><span class="line">		return new String[] &#123;DEFAULT_CONFIG_LOCATION_PREFIX + getNamespace() + DEFAULT_CONFIG_LOCATION_SUFFIX&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		return new String[] &#123;DEFAULT_CONFIG_LOCATION&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ContextLoaderListener的contextInitialized初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void contextInitialized(ServletContextEvent event) &#123;</span><br><span class="line">	this.contextLoader = createContextLoader();</span><br><span class="line">	if (this.contextLoader == null) &#123;</span><br><span class="line">		this.contextLoader = this;</span><br><span class="line">	&#125;</span><br><span class="line">	this.contextLoader.initWebApplicationContext(event.getServletContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再到他的基类ContextLoader中WEB容器的加载过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public WebApplicationContext initWebApplicationContext(ServletContext servletContext) &#123;</span><br><span class="line">//如果已经加载会抛出异常</span><br><span class="line">		if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) &#123;</span><br><span class="line">			throw new IllegalStateException(</span><br><span class="line">					&quot;Cannot initialize context because there is already a root application context present - &quot; +</span><br><span class="line">					&quot;check whether you have multiple ContextLoader* definitions in your web.xml!&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Log logger = LogFactory.getLog(ContextLoader.class);</span><br><span class="line">		servletContext.log(&quot;Initializing Spring root WebApplicationContext&quot;);</span><br><span class="line">		if (logger.isInfoEnabled()) &#123;</span><br><span class="line">			logger.info(&quot;Root WebApplicationContext: initialization started&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		long startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			// Store context in local instance variable, to guarantee that</span><br><span class="line">			// it is available on ServletContext shutdown.</span><br><span class="line">			if (this.context == null) &#123;</span><br><span class="line">			  // 创建上下文</span><br><span class="line">				this.context = createWebApplicationContext(servletContext);</span><br><span class="line">			&#125;</span><br><span class="line">			if (this.context instanceof ConfigurableWebApplicationContext) &#123;</span><br><span class="line">				configureAndRefreshWebApplicationContext((ConfigurableWebApplicationContext)this.context, servletContext);</span><br><span class="line">			&#125;</span><br><span class="line">			 //将创建好的上下文放在servletContext中</span><br><span class="line">			servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);</span><br><span class="line"></span><br><span class="line">			ClassLoader ccl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">			if (ccl == ContextLoader.class.getClassLoader()) &#123;</span><br><span class="line">				currentContext = this.context;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (ccl != null) &#123;</span><br><span class="line">				currentContextPerThread.put(ccl, this.context);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Published root WebApplicationContext as ServletContext attribute with name [&quot; +</span><br><span class="line">						WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + &quot;]&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			if (logger.isInfoEnabled()) &#123;</span><br><span class="line">				long elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">				logger.info(&quot;Root WebApplicationContext: initialization completed in &quot; + elapsedTime + &quot; ms&quot;);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			return this.context;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (RuntimeException ex) &#123;</span><br><span class="line">			logger.error(&quot;Context initialization failed&quot;, ex);</span><br><span class="line">			servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Error err) &#123;</span><br><span class="line">			logger.error(&quot;Context initialization failed&quot;, err);</span><br><span class="line">			servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);</span><br><span class="line">			throw err;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>createWebApplicationContext(servletContext)即实例化上下文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected WebApplicationContext createWebApplicationContext(ServletContext sc) &#123;</span><br><span class="line">//探查将那个类在WEB容器中作为IOC容器</span><br><span class="line">	Class&lt;?&gt; contextClass = determineContextClass(sc);</span><br><span class="line">	if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line">		throw new ApplicationContextException(&quot;Custom context class [&quot; + contextClass.getName() +</span><br><span class="line">				&quot;] is not of type [&quot; + ConfigurableWebApplicationContext.class.getName() + &quot;]&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	 //实例化IOC 容器</span><br><span class="line">	ConfigurableWebApplicationContext wac =</span><br><span class="line">			(ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">	return wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认是WebApplicationContext作为容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Class&lt;?&gt; determineContextClass(ServletContext servletContext) &#123;</span><br><span class="line">//CONTEXT_CLASS_PARAM是WEB.xml的配置参数</span><br><span class="line">	String contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM);</span><br><span class="line">	if (contextClassName != null) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			return ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader());</span><br><span class="line">		&#125;</span><br><span class="line">		catch (ClassNotFoundException ex) &#123;</span><br><span class="line">			throw new ApplicationContextException(</span><br><span class="line">					&quot;Failed to load custom context class [&quot; + contextClassName + &quot;]&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">	//默认是WebApplicationContext</span><br><span class="line">		contextClassName = defaultStrategies.getProperty(WebApplicationContext.class.getName());</span><br><span class="line">		try &#123;</span><br><span class="line">			return ClassUtils.forName(contextClassName, ContextLoader.class.getClassLoader());</span><br><span class="line">		&#125;</span><br><span class="line">		catch (ClassNotFoundException ex) &#123;</span><br><span class="line">			throw new ApplicationContextException(</span><br><span class="line">					&quot;Failed to load default context class [&quot; + contextClassName + &quot;]&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>configureAndRefreshWebApplicationContext方法接着设置IOC的各个参数，随后通过refresh启动容器的初始化，refresh参考前边的 FileSystemXmlApplicationContext的IOC的初始化过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) &#123;</span><br><span class="line">	if (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class="line">		// The application context id is still set to its original default value</span><br><span class="line">		// -&gt; assign a more useful id based on available information</span><br><span class="line">		String idParam = sc.getInitParameter(CONTEXT_ID_PARAM);</span><br><span class="line">		if (idParam != null) &#123;</span><br><span class="line">			wac.setId(idParam);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			// Generate default id...</span><br><span class="line">			if (sc.getMajorVersion() == 2 &amp;&amp; sc.getMinorVersion() &lt; 5) &#123;</span><br><span class="line">				// Servlet &lt;= 2.4: resort to name specified in web.xml, if any.</span><br><span class="line">				wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class="line">						ObjectUtils.getDisplayString(sc.getServletContextName()));</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class="line">						ObjectUtils.getDisplayString(sc.getContextPath()));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Determine parent for root web application context, if any.</span><br><span class="line">	ApplicationContext parent = loadParentContext(sc);</span><br><span class="line">     //设置双亲上下文</span><br><span class="line">	wac.setParent(parent);</span><br><span class="line">	 //设置servletcontext以及配置文件的位置参数</span><br><span class="line">	wac.setServletContext(sc);</span><br><span class="line">	String initParameter = sc.getInitParameter(CONFIG_LOCATION_PARAM);</span><br><span class="line">	if (initParameter != null) &#123;</span><br><span class="line">		wac.setConfigLocation(initParameter);</span><br><span class="line">	&#125;</span><br><span class="line">	customizeContext(sc, wac);</span><br><span class="line">	//调用refresh初始化IOC容器</span><br><span class="line">	wac.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SPRING技术内幕-笔记（九）SpringMVC视图的呈现</title>
    <url>/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89SpringMVC%E8%A7%86%E5%9B%BE%E7%9A%84%E5%91%88%E7%8E%B0/</url>
    <content><![CDATA[<p><strong>9.1 DispatcherServlet视图呈现的设计</strong><br>衔接上一章DisPatcherServlet的doDispatch,执行完handler之后得到ModelAndView对象，然后视图的展现交给了render方法：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">	// Determine locale for request and apply it to the response.</span><br><span class="line">	Locale locale = this.localeResolver.resolveLocale(request);</span><br><span class="line">	response.setLocale(locale);</span><br><span class="line"></span><br><span class="line">	View view;</span><br><span class="line">	if (mv.isReference()) &#123;</span><br><span class="line">		// We need to resolve the view name.</span><br><span class="line">		 //如果配置了String类型的view名字，那么就解析出来</span><br><span class="line">		view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);</span><br><span class="line">		if (view == null) &#123;</span><br><span class="line">			throw new ServletException(</span><br><span class="line">					&quot;Could not resolve view with name &#x27;&quot; + mv.getViewName() + &quot;&#x27; in servlet with name &#x27;&quot; +</span><br><span class="line">							getServletName() + &quot;&#x27;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		// No need to lookup: the ModelAndView object contains the actual View object.</span><br><span class="line">		//视图对象已经在ModelAndView 对象里边，直接拿来用</span><br><span class="line">		view = mv.getView();</span><br><span class="line">		if (view == null) &#123;</span><br><span class="line">			throw new ServletException(&quot;ModelAndView [&quot; + mv + &quot;] neither contains a view name nor a &quot; +</span><br><span class="line">					&quot;View object in servlet with name &#x27;&quot; + getServletName() + &quot;&#x27;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Delegate to the View object for rendering.</span><br><span class="line">	if (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(&quot;Rendering view [&quot; + view + &quot;] in DispatcherServlet with name &#x27;&quot; + getServletName() + &quot;&#x27;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	//不同的视图类型调用各自的render方法</span><br><span class="line">	view.render(mv.getModelInternal(), request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面解析根据名字解析视图的方法resolveViewName：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected View resolveViewName(String viewName, Map&lt;String, Object&gt; model, Locale locale,</span><br><span class="line">		HttpServletRequest request) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	for (ViewResolver viewResolver : this.viewResolvers) &#123;</span><br><span class="line">		View view = viewResolver.resolveViewName(viewName, locale);</span><br><span class="line">		if (view != null) &#123;</span><br><span class="line">			return view;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>viewResolver.resolveViewName(viewName, locale)可以看子类BeanNameViewResolver的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public View resolveViewName(String viewName, Locale locale) throws BeansException &#123;</span><br><span class="line">	ApplicationContext context = getApplicationContext();</span><br><span class="line">	if (!context.containsBean(viewName)) &#123;</span><br><span class="line">		// Allow for ViewResolver chaining.</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	return (View) context.getBean(viewName, View.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出直接是从山下取出来的。<br>回到各种视图的解析SPringMVC有各种视图的支持，PDF，JSTL，等等，使用了第三方框架，从而让视图丰富多彩。<br>这是SPring的视图类型结构图：</p>
<p><img src="/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89SpringMVC%E8%A7%86%E5%9B%BE%E7%9A%84%E5%91%88%E7%8E%B0/20150624212800016.png" alt="这里写图片描述"></p>
<p><strong>9.2JSP视图的实现</strong></p>
<p>在jsp中可以使用JSTL表达式来丰富jsp页面，在springmvc中需要Jstlview来作为view对象。<br>Jstlview没有实现render方法，其使用了基类的render方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">	if (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(&quot;Rendering view with name &#x27;&quot; + this.beanName + &quot;&#x27; with model &quot; + model +</span><br><span class="line">			&quot; and static attributes &quot; + this.staticAttributes);</span><br><span class="line">	&#125;</span><br><span class="line">	//将所有的数据放到一个Map里边</span><br><span class="line">	Map&lt;String, Object&gt; mergedModel = createMergedOutputModel(model, request, response);</span><br><span class="line"></span><br><span class="line">	prepareResponse(request, response);</span><br><span class="line">	//展现模型数据到对应视图的方法</span><br><span class="line">	renderMergedOutputModel(mergedModel, request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> renderMergedOutputModel使用的是模板方法，在InternalResourceView中，InternalResourceView也是Jstlview的基类，代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void renderMergedOutputModel(</span><br><span class="line">		Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	// Determine which request handle to expose to the RequestDispatcher.</span><br><span class="line">	//判断将那个请求的处理交给RequestDispatcher</span><br><span class="line">	HttpServletRequest requestToExpose = getRequestToExpose(request);</span><br><span class="line"></span><br><span class="line">	// Expose the model object as request attributes.</span><br><span class="line">	//对数据进行处理，放到servletcontext中</span><br><span class="line">	exposeModelAsRequestAttributes(model, requestToExpose);</span><br><span class="line"></span><br><span class="line">	// Expose helpers as request attributes, if any.</span><br><span class="line">	exposeHelpers(requestToExpose);</span><br><span class="line"></span><br><span class="line">	// Determine the path for the request dispatcher.</span><br><span class="line">	//得到InternalResourceView定义的内部资源路径</span><br><span class="line">	String dispatcherPath = prepareForRendering(requestToExpose, response);</span><br><span class="line"></span><br><span class="line">	// Obtain a RequestDispatcher for the target resource (typically a JSP).</span><br><span class="line">	 //把请求转发到前面获取的资源路径中去</span><br><span class="line">	RequestDispatcher rd = getRequestDispatcher(requestToExpose, dispatcherPath);</span><br><span class="line">	if (rd == null) &#123;</span><br><span class="line">		throw new ServletException(&quot;Could not get RequestDispatcher for [&quot; + getUrl() +</span><br><span class="line">				&quot;]: Check that the corresponding file exists within your web application archive!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// If already included or response already committed, perform include, else forward.</span><br><span class="line">	if (useInclude(requestToExpose, response)) &#123;</span><br><span class="line">		response.setContentType(getContentType());</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Including resource [&quot; + getUrl() + &quot;] in InternalResourceView &#x27;&quot; + getBeanName() + &quot;&#x27;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		rd.include(requestToExpose, response);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	else &#123;</span><br><span class="line">		// Note: The forwarded resource is supposed to determine the content type itself.</span><br><span class="line">		//转发请求到之前内部定义好的资源上去，比如jsp页面，jsp页面的展现是有容器负责，在这种情况下，view只是起到转发  </span><br><span class="line">		//请求的作用</span><br><span class="line">		exposeForwardRequestAttributes(requestToExpose);</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Forwarding to resource [&quot; + getUrl() + &quot;] in InternalResourceView &#x27;&quot; + getBeanName() + &quot;&#x27;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		rd.forward(requestToExpose, response);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>exposeModelAsRequestAttributes(model, requestToExpose)方法是处理数据的关键，在AbstractView中他把ModelAndView中的数据以及其他请求的数据放到HttpServletRequest中去，这样就能在页面得到这些值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void exposeModelAsRequestAttributes(Map&lt;String, Object&gt; model, HttpServletRequest request) throws Exception &#123;</span><br><span class="line">	for (Map.Entry&lt;String, Object&gt; entry : model.entrySet()) &#123;</span><br><span class="line">		String modelName = entry.getKey();</span><br><span class="line">		Object modelValue = entry.getValue();</span><br><span class="line">		if (modelValue != null) &#123;</span><br><span class="line">			request.setAttribute(modelName, modelValue);</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Added model object &#x27;&quot; + modelName + &quot;&#x27; of type [&quot; + modelValue.getClass().getName() +</span><br><span class="line">						&quot;] to request in view with name &#x27;&quot; + getBeanName() + &quot;&#x27;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			request.removeAttribute(modelName);</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Removed model object &#x27;&quot; + modelName +</span><br><span class="line">						&quot;&#x27; from request in view with name &#x27;&quot; + getBeanName() + &quot;&#x27;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exposeHelpers包含所有关于 jstl的相关处理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void exposeHelpers(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">	if (this.messageSource != null) &#123;</span><br><span class="line">		JstlUtils.exposeLocalizationContext(request, this.messageSource);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		JstlUtils.exposeLocalizationContext(new RequestContext(request, getServletContext()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到转发路径后InternalResourceView进行重定向，那么这个路径的获得如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected String prepareForRendering(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">		throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	String path = getUrl();</span><br><span class="line">	if (this.preventDispatchLoop) &#123;</span><br><span class="line">	//从request中获取URL路径</span><br><span class="line">		String uri = request.getRequestURI();</span><br><span class="line">		if (path.startsWith(&quot;/&quot;) ? uri.equals(path) : uri.equals(StringUtils.applyRelativePath(uri, path))) &#123;</span><br><span class="line">			throw new ServletException(&quot;Circular view path [&quot; + path + &quot;]: would dispatch back &quot; +</span><br><span class="line">					&quot;to the current handler URL [&quot; + uri + &quot;] again. Check your ViewResolver setup! &quot; +</span><br><span class="line">					&quot;(Hint: This may be the result of an unspecified view, due to default view name generation.)&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到路径然后进行转发。</p>
<p><strong>9.3 ExcelView的实现</strong><br>实现类AbstractExcelView,springMvc使用了Apache开源的POI完成对excel的创建<br>主要实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final void renderMergedOutputModel(</span><br><span class="line">		Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	HSSFWorkbook workbook;</span><br><span class="line">	if (this.url != null) &#123;</span><br><span class="line">	//使用一游模板创建HSSFWorkbook 对象，模板来自URL</span><br><span class="line">		workbook = getTemplateSource(this.url, request);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">	//直接New</span><br><span class="line">		workbook = new HSSFWorkbook();</span><br><span class="line">		logger.debug(&quot;Created Excel Workbook from scratch&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">       //此方法留给应用重写，完成根据去填充这张表格</span><br><span class="line">	buildExcelDocument(model, workbook, request, response);</span><br><span class="line"></span><br><span class="line">	// Set the content type.</span><br><span class="line">	response.setContentType(getContentType());</span><br><span class="line"></span><br><span class="line">	// Should we set the content length here?</span><br><span class="line">	// response.setContentLength(workbook.getBytes().length);</span><br><span class="line"></span><br><span class="line">	// Flush byte array to servlet output stream.</span><br><span class="line">	//输出到页面展现</span><br><span class="line">	ServletOutputStream out = response.getOutputStream();</span><br><span class="line">	workbook.write(out);</span><br><span class="line">	out.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从已有的文件创建	workbook对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected HSSFWorkbook getTemplateSource(String url, HttpServletRequest request) throws Exception &#123;</span><br><span class="line">		LocalizedResourceHelper helper = new LocalizedResourceHelper(getApplicationContext());</span><br><span class="line">		Locale userLocale = RequestContextUtils.getLocale(request);</span><br><span class="line">		Resource inputFile = helper.findLocalizedResource(url, EXTENSION, userLocale);</span><br><span class="line"></span><br><span class="line">		// Create the Excel document from the source.</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Loading Excel workbook from &quot; + inputFile);</span><br><span class="line">		&#125;</span><br><span class="line">		//创建excel文本对象</span><br><span class="line">		POIFSFileSystem fs = new POIFSFileSystem(inputFile.getInputStream());</span><br><span class="line">		return new HSSFWorkbook(fs);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>一下是一个举例解释对AbstractExcelView的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void testExcelWithTemplateAndLanguage() throws Exception &#123;</span><br><span class="line">	request.setAttribute(DispatcherServlet.LOCALE_RESOLVER_ATTRIBUTE,</span><br><span class="line">			newDummyLocaleResolver(&quot;de&quot;, &quot;&quot;));</span><br><span class="line"></span><br><span class="line">	AbstractExcelView excelView = new AbstractExcelView() &#123;</span><br><span class="line">	 //实现基类的buildExcelDocument</span><br><span class="line">		protected void buildExcelDocument(Map model, HSSFWorkbook wb,</span><br><span class="line">				HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">				throws Exception &#123;</span><br><span class="line">			HSSFSheet sheet = wb.getSheet(&quot;Sheet1&quot;);</span><br><span class="line"></span><br><span class="line">			// test all possible permutation of row or column not existing</span><br><span class="line">			HSSFCell cell = getCell(sheet, 2, 4);</span><br><span class="line">			cell.setCellValue(&quot;Test Value&quot;);</span><br><span class="line">			cell = getCell(sheet, 2, 3);</span><br><span class="line">			setText(cell, &quot;Test Value&quot;);</span><br><span class="line">			cell = getCell(sheet, 3, 4);</span><br><span class="line">			setText(cell, &quot;Test Value&quot;);</span><br><span class="line">			cell = getCell(sheet, 2, 4);</span><br><span class="line">			setText(cell, &quot;Test Value&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	excelView.setApplicationContext(webAppCtx);</span><br><span class="line">	excelView.setUrl(&quot;template&quot;);</span><br><span class="line">	//手动调用render，触发视图的呈现</span><br><span class="line">	excelView.render(new HashMap(), request, response);</span><br><span class="line"></span><br><span class="line">	POIFSFileSystem poiFs = new POIFSFileSystem(new ByteArrayInputStream(response.getContentAsByteArray()));</span><br><span class="line">	HSSFWorkbook wb = new HSSFWorkbook(poiFs);</span><br><span class="line">	HSSFSheet sheet = wb.getSheet(&quot;Sheet1&quot;);</span><br><span class="line">	HSSFRow row = sheet.getRow(0);</span><br><span class="line">	HSSFCell cell = row.getCell((short) 0);</span><br><span class="line">	assertEquals(&quot;Test Template auf Deutsch&quot;, cell.getStringCellValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>9.4 PDF视图的实现</strong></p>
<p>实现类AbstractPdfView，主要的工程springMVC使用了itext：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final void renderMergedOutputModel(</span><br><span class="line">		Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	// IE workaround: write into byte array first.</span><br><span class="line">	ByteArrayOutputStream baos = createTemporaryOutputStream();</span><br><span class="line"></span><br><span class="line">	// Apply preferences and build metadata.</span><br><span class="line">	//创建itext与PDF文件操作相关联的对象</span><br><span class="line">	Document document = newDocument();</span><br><span class="line">	PdfWriter writer = newWriter(document, baos);</span><br><span class="line">	prepareWriter(model, writer, request);</span><br><span class="line">	buildPdfMetadata(model, document, request);</span><br><span class="line"></span><br><span class="line">	// Build PDF document.</span><br><span class="line">	//根据应用业务构建对象，填充内容，buildPdfDocument有子类去实现</span><br><span class="line">	document.open();</span><br><span class="line">	buildPdfDocument(model, document, writer, request, response);</span><br><span class="line">	document.close();</span><br><span class="line"></span><br><span class="line">	// Flush to HTTP response.</span><br><span class="line">	writeToResponse(response, baos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SpringMvc提供的测试数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void testPdf() throws Exception &#123;</span><br><span class="line">	final String text = &quot;this should be in the PDF&quot;;</span><br><span class="line">	MockHttpServletRequest request = new MockHttpServletRequest();</span><br><span class="line">	MockHttpServletResponse response = new MockHttpServletResponse();</span><br><span class="line"></span><br><span class="line">	AbstractPdfView pdfView = new AbstractPdfView() &#123;</span><br><span class="line">		protected void buildPdfDocument(Map model, Document document, PdfWriter writer,</span><br><span class="line">				HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">			document.add(new Paragraph(text));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	pdfView.render(new HashMap(), request, response);</span><br><span class="line">	byte[] pdfContent = response.getContentAsByteArray();</span><br><span class="line">	assertEquals(&quot;correct response content type&quot;, &quot;application/pdf&quot;, response.getContentType());</span><br><span class="line">	assertEquals(&quot;correct response content length&quot;, pdfContent.length, response.getContentLength());</span><br><span class="line"></span><br><span class="line">	// rebuild iText document for comparison</span><br><span class="line">	Document document = new Document(PageSize.A4);</span><br><span class="line">	ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">	PdfWriter writer = PdfWriter.getInstance(document, baos);</span><br><span class="line">	writer.setViewerPreferences(PdfWriter.AllowPrinting | PdfWriter.PageLayoutSinglePage);</span><br><span class="line">	document.open();</span><br><span class="line">	document.add(new Paragraph(text));</span><br><span class="line">	document.close();</span><br><span class="line">	byte[] baosContent = baos.toByteArray();</span><br><span class="line">	assertEquals(&quot;correct size&quot;, pdfContent.length, baosContent.length);</span><br><span class="line"></span><br><span class="line">	int diffCount = 0;</span><br><span class="line">	for (int i = 0; i &lt; pdfContent.length; i++) &#123;</span><br><span class="line">		if (pdfContent[i] != baosContent[i]) &#123;</span><br><span class="line">			diffCount++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	assertTrue(&quot;difference only in encryption&quot;, diffCount &lt; 70);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SPRING技术内幕-笔记（八）SpringMVC的设计与实现</title>
    <url>/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89SpringMVC%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>8.1SPringMVC设置概览<br>在web.xml文件里边配置的DispatcherServlet是web请求的入口，它的处理过程如下：<br><img src="/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89SpringMVC%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/20150613213240218.png" alt="这里写图片描述"></p>
<span id="more"></span>

<p>DispatcherServlet的任务有2个：<br>一个是 初始化部分，由initservletBean()启动，通过initWebApplicationContext方法最终调用DispatcherSevlet的initStrategies方法，在这个过程中DispatcherServlet对MVC模块的其他部分进行初始化，比如HandlerMapping、Viewresolver等，另一个是对HTTP请求进行响应，作为一个servlet,WEB容器会调用servlet的都跟他()和dopost()方法，在这个方法的调用封装了doDispatcher。</p>
<p>在FrameworkServlet的initWebApplicationContext()方法中主要是设置当前上下文的父级上下文<br>HttpServletBean完成初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final void init() throws ServletException &#123;</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Initializing servlet &#x27;&quot; + getServletName() + &quot;&#x27;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Set bean properties from init parameters.</span><br><span class="line">		//获得servlet的初始化参数，即WEB.XML的配置</span><br><span class="line">		try &#123;</span><br><span class="line">			PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);</span><br><span class="line">			BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);</span><br><span class="line">			ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());</span><br><span class="line">			bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, this.environment));</span><br><span class="line">			initBeanWrapper(bw);</span><br><span class="line">			bw.setPropertyValues(pvs, true);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BeansException ex) &#123;</span><br><span class="line">			logger.error(&quot;Failed to set bean properties on servlet &#x27;&quot; + getServletName() + &quot;&#x27;&quot;, ex);</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Let subclasses do whatever initialization they like.</span><br><span class="line">		//调用子类（FrameworkServlet）完成具体的初始化</span><br><span class="line">		initServletBean();</span><br><span class="line"></span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Servlet &#x27;&quot; + getServletName() + &quot;&#x27; configured successfully&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>具体的初始化在FrameworkServlet完成;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final void initServletBean() throws ServletException &#123;</span><br><span class="line">	getServletContext().log(&quot;Initializing Spring FrameworkServlet &#x27;&quot; + getServletName() + &quot;&#x27;&quot;);</span><br><span class="line">	if (this.logger.isInfoEnabled()) &#123;</span><br><span class="line">		this.logger.info(&quot;FrameworkServlet &#x27;&quot; + getServletName() + &quot;&#x27;: initialization started&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	long startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">	try &#123;</span><br><span class="line">	//初始化上下文</span><br><span class="line">		this.webApplicationContext = initWebApplicationContext();</span><br><span class="line">		initFrameworkServlet();</span><br><span class="line">	&#125;</span><br><span class="line">	catch (ServletException ex) &#123;</span><br><span class="line">		this.logger.error(&quot;Context initialization failed&quot;, ex);</span><br><span class="line">		throw ex;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (RuntimeException ex) &#123;</span><br><span class="line">		this.logger.error(&quot;Context initialization failed&quot;, ex);</span><br><span class="line">		throw ex;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (this.logger.isInfoEnabled()) &#123;</span><br><span class="line">		long elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">		this.logger.info(&quot;FrameworkServlet &#x27;&quot; + getServletName() + &quot;&#x27;: initialization completed in &quot; +</span><br><span class="line">				elapsedTime + &quot; ms&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置上下文：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected WebApplicationContext initWebApplicationContext() &#123;</span><br><span class="line">		WebApplicationContext rootContext =</span><br><span class="line">				//使用WebApplicationContextUtils得到根山下文。这个根上下文是保存在servletContext中</span><br><span class="line">				//得到之后将其作为当前上下文的根上下文</span><br><span class="line">				WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">		WebApplicationContext wac = null;</span><br><span class="line"></span><br><span class="line">		if (this.webApplicationContext != null) &#123;</span><br><span class="line">			// A context instance was injected at construction time -&gt; use it</span><br><span class="line">			wac = this.webApplicationContext;</span><br><span class="line">			if (wac instanceof ConfigurableWebApplicationContext) &#123;</span><br><span class="line">				ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line">				if (!cwac.isActive()) &#123;</span><br><span class="line">					// The context has not yet been refreshed -&gt; provide services such as</span><br><span class="line">					// setting the parent context, setting the application context id, etc</span><br><span class="line">					if (cwac.getParent() == null) &#123;</span><br><span class="line">						// The context instance was injected without an explicit parent -&gt; set</span><br><span class="line">						// the root application context (if any; may be null) as the parent</span><br><span class="line">						cwac.setParent(rootContext);</span><br><span class="line">					&#125;</span><br><span class="line">					//设置bean配置的信息，调用refresh()完成IOC容器的最终初始化</span><br><span class="line">					configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (wac == null) &#123;</span><br><span class="line">			// No context instance was injected at construction time -&gt; see if one</span><br><span class="line">			// has been registered in the servlet context. If one exists, it is assumed</span><br><span class="line">			// that the parent context (if any) has already been set and that the</span><br><span class="line">			// user has performed any initialization such as setting the context id</span><br><span class="line">			wac = findWebApplicationContext();</span><br><span class="line">		&#125;</span><br><span class="line">		if (wac == null) &#123;</span><br><span class="line">			// No context instance is defined for this servlet -&gt; create a local one</span><br><span class="line">			wac = createWebApplicationContext(rootContext);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!this.refreshEventReceived) &#123;</span><br><span class="line">			// Either the context is not a ConfigurableApplicationContext with refresh</span><br><span class="line">			// support or the context injected at construction time had already been</span><br><span class="line">			// refreshed -&gt; trigger initial onRefresh manually here.</span><br><span class="line">			onRefresh(wac);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (this.publishContext) &#123;</span><br><span class="line">			// Publish the context as a servlet context attribute.</span><br><span class="line">			String attrName = getServletContextAttributeName();</span><br><span class="line">			//将当前建立的上下文保存咋servletcontext中（attrName=&quot;FrameworkServlet..CONTEXT.&quot;+servletname）</span><br><span class="line">			getServletContext().setAttribute(attrName, wac);</span><br><span class="line">			if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">				this.logger.debug(&quot;Published WebApplicationContext of servlet &#x27;&quot; + getServletName() +</span><br><span class="line">						&quot;&#x27; as ServletContext attribute with name [&quot; + attrName + &quot;]&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return wac;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>根上下文是WebApplication以ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE的名字设置在servletContext中的。然后被DispatcherServlet得到使用，可以通过getBean的方式<br>这个上下文，在FrameworkServlet的createWebApplicationContext得到，根据默认配置使用的也是XmlWebApplicationContext，实例化之后设置bean配置文件的路径，左后调研refresh完成最终初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	protected WebApplicationContext createWebApplicationContext(ApplicationContext parent) &#123;</span><br><span class="line">		Class&lt;?&gt; contextClass = getContextClass();</span><br><span class="line">		if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">			this.logger.debug(&quot;Servlet with name &#x27;&quot; + getServletName() +</span><br><span class="line">					&quot;&#x27; will try to create custom WebApplicationContext context of class &#x27;&quot; +</span><br><span class="line">					contextClass.getName() + &quot;&#x27;&quot; + &quot;, using parent context [&quot; + parent + &quot;]&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line">			throw new ApplicationContextException(</span><br><span class="line">					&quot;Fatal initialization error in servlet with name &#x27;&quot; + getServletName() +</span><br><span class="line">					&quot;&#x27;: custom WebApplicationContext class [&quot; + contextClass.getName() +</span><br><span class="line">					&quot;] is not of type ConfigurableWebApplicationContext&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		//使用XmlWebApplicationContext作为IOC容器</span><br><span class="line">		**ConfigurableWebApplicationContext wac =</span><br><span class="line">				(ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);**</span><br><span class="line"></span><br><span class="line">		wac.setParent(parent);</span><br><span class="line">		wac.setConfigLocation(getContextConfigLocation());</span><br><span class="line"></span><br><span class="line">//调用refresh完成IOC的初始化</span><br><span class="line">		configureAndRefreshWebApplicationContext(wac);</span><br><span class="line"></span><br><span class="line">		return wac;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在SpringMvcDispatcher的初始化过程中，以对 HandlerMapping的初始化调用作为触发点，了解SPringMVC木块初始化的方法调用关系，在这个调用关系最初是由HttpservletBean的init方法触发的，这个HttpservletBean是 Httpservlet的子类。接着会在HttpservletBean的子类 FrameWorkServlet中对IOC容器完成初始化，这个初始化方法中，会调用DispatcherServlet的initStrategies方法，这个initStrategies方法中，启动整个SpringMVC框架的初始化。<br>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Initialize the strategy objects that this servlet uses.</span><br><span class="line"> * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.</span><br><span class="line"> */</span><br><span class="line">protected void initStrategies(ApplicationContext context) &#123;</span><br><span class="line">	initMultipartResolver(context);</span><br><span class="line">	initLocaleResolver(context);</span><br><span class="line">	initThemeResolver(context);</span><br><span class="line">	**initHandlerMappings(context);**</span><br><span class="line">	initHandlerAdapters(context);</span><br><span class="line">	initHandlerExceptionResolvers(context);</span><br><span class="line">	initRequestToViewNameTranslator(context);</span><br><span class="line">	initViewResolvers(context);</span><br><span class="line">	initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>initHandlerMappings中mapping关系的作用是为http请求找到相应的controller控制器，从而利用这些控制器controller去完成设计好的数据处理工作。handlermapping完成对mvc中国controller的定义和配置，只不过在web这个特定的应用环境中这些控制器是与具体的http请求对应的。<br>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Initialize the HandlerMappings used by this class.</span><br><span class="line"> * &lt;p&gt;If no HandlerMapping beans are defined in the BeanFactory for this namespace,</span><br><span class="line"> * we default to BeanNameUrlHandlerMapping.</span><br><span class="line"> */</span><br><span class="line">private void initHandlerMappings(ApplicationContext context) &#123;</span><br><span class="line">	this.handlerMappings = null;</span><br><span class="line"></span><br><span class="line">	if (this.detectAllHandlerMappings) &#123;</span><br><span class="line">		// Find all HandlerMappings in the ApplicationContext, including ancestor contexts.</span><br><span class="line">		 //取到所有的handlermapping，可以从当前容器里边取，也可以从父级容器里边取值，</span><br><span class="line">		 //detectAllHandlerMappings默认为true，即从所有的容器里边取</span><br><span class="line">		Map&lt;String, HandlerMapping&gt; matchingBeans =</span><br><span class="line">				BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false);</span><br><span class="line">		if (!matchingBeans.isEmpty()) &#123;</span><br><span class="line">			this.handlerMappings = new ArrayList&lt;HandlerMapping&gt;(matchingBeans.values());</span><br><span class="line">			// We keep HandlerMappings in sorted order.</span><br><span class="line">			OrderComparator.sort(this.handlerMappings);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">		 //通过getbean的方式从容器取值</span><br><span class="line">			HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);</span><br><span class="line">			this.handlerMappings = Collections.singletonList(hm);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">			// Ignore, we&#x27;ll add a default HandlerMapping later.</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Ensure we have at least one HandlerMapping, by registering</span><br><span class="line">	// a default HandlerMapping if no other mappings are found.</span><br><span class="line">	if (this.handlerMappings == null) &#123;</span><br><span class="line">	//如果没有取到，就用默认的handlerMappings 默认配置在DispatcherServlet.properties中。</span><br><span class="line">		this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;No HandlerMappings found in servlet &#x27;&quot; + getServletName() + &quot;&#x27;: using default&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>8.2、MVC处理http分发请求</strong></p>
<p>  <strong>1、handlerMapping 的配置和设计原理：</strong><br><img src="/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89SpringMVC%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/20150622193305255.png" alt="这里写图片描述"></p>
<p>以SimpleUrlHandlerMapping的分析handlerMapping的设计与实现<br>接口HandlerMapping的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface HandlerMapping &#123;</span><br><span class="line"></span><br><span class="line">	String PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.pathWithinHandlerMapping&quot;;</span><br><span class="line"></span><br><span class="line">	String BEST_MATCHING_PATTERN_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.bestMatchingPattern&quot;;</span><br><span class="line"></span><br><span class="line">	String INTROSPECT_TYPE_LEVEL_MAPPING = HandlerMapping.class.getName() + &quot;.introspectTypeLevelMapping&quot;;</span><br><span class="line"></span><br><span class="line">	String URI_TEMPLATE_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.uriTemplateVariables&quot;;</span><br><span class="line"></span><br><span class="line">	String PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE = HandlerMapping.class.getName() + &quot;.producibleMediaTypes&quot;;</span><br><span class="line">    //调用getHandler实际上返回的是一个handlerExceptionChain，这是典型的command的模式的使用，这个</span><br><span class="line">    //HandlerExecutionChain不但持有handler本身，还包括了处理这个http请求的拦截器</span><br><span class="line">    //handler就是http请求对应的controller</span><br><span class="line">	HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>HandlerExecutionChain 的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class HandlerExecutionChain &#123;</span><br><span class="line"></span><br><span class="line">	private final Object handler;</span><br><span class="line">	private HandlerInterceptor[] interceptors;</span><br><span class="line">	private List&lt;HandlerInterceptor&gt; interceptorList;</span><br><span class="line">	public HandlerExecutionChain(Object handler) &#123;</span><br><span class="line">		this(handler, null);</span><br><span class="line">	&#125;</span><br><span class="line">	public HandlerExecutionChain(Object handler, HandlerInterceptor[] interceptors) &#123;</span><br><span class="line">		if (handler instanceof HandlerExecutionChain) &#123;</span><br><span class="line">			HandlerExecutionChain originalChain = (HandlerExecutionChain) handler;</span><br><span class="line">			this.handler = originalChain.getHandler();</span><br><span class="line">			this.interceptorList = new ArrayList&lt;HandlerInterceptor&gt;();</span><br><span class="line">			CollectionUtils.mergeArrayIntoCollection(originalChain.getInterceptors(),     </span><br><span class="line">			this.interceptorList);</span><br><span class="line">			CollectionUtils.mergeArrayIntoCollection(interceptors, this.interceptorList);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			this.handler = handler;</span><br><span class="line">			this.interceptors = interceptors;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public Object getHandler() &#123;</span><br><span class="line">		return this.handler;</span><br><span class="line">	&#125;</span><br><span class="line">	public void addInterceptor(HandlerInterceptor interceptor) &#123;</span><br><span class="line">		initInterceptorList();</span><br><span class="line">		this.interceptorList.add(interceptor);</span><br><span class="line">	&#125;</span><br><span class="line">	public void addInterceptors(HandlerInterceptor[] interceptors) &#123;</span><br><span class="line">		if (interceptors != null) &#123;</span><br><span class="line">			initInterceptorList();</span><br><span class="line">			this.interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	private void initInterceptorList() &#123;</span><br><span class="line">		if (this.interceptorList == null) &#123;</span><br><span class="line">			this.interceptorList = new ArrayList&lt;HandlerInterceptor&gt;();</span><br><span class="line">		&#125;</span><br><span class="line">		if (this.interceptors != null) &#123;</span><br><span class="line">			this.interceptorList.addAll(Arrays.asList(this.interceptors));</span><br><span class="line">			this.interceptors = null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public HandlerInterceptor[] getInterceptors() &#123;</span><br><span class="line">		if (this.interceptors == null &amp;&amp; this.interceptorList != null) &#123;</span><br><span class="line">			this.interceptors = this.interceptorList.toArray(new HandlerInterceptor[this.interceptorList.size()]);</span><br><span class="line">		&#125;</span><br><span class="line">		return this.interceptors;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		if (this.handler == null) &#123;</span><br><span class="line">			return &quot;HandlerExecutionChain with no handler&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		StringBuilder sb = new StringBuilder();</span><br><span class="line">		sb.append(&quot;HandlerExecutionChain with handler [&quot;).append(this.handler).append(&quot;]&quot;);</span><br><span class="line">		if (!CollectionUtils.isEmpty(this.interceptorList)) &#123;</span><br><span class="line">			sb.append(&quot; and &quot;).append(this.interceptorList.size()).append(&quot; interceptor&quot;);</span><br><span class="line">			if (this.interceptorList.size() &gt; 1) &#123;</span><br><span class="line">				sb.append(&quot;s&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>HandlerExecutionChain 中的handler和interceptors需要在定义HandlerMapping的时候配置好，这牵涉到一个bean的注册过程，接下来分析SimpleUrlHandlerMapping的注册过程:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void initApplicationContext() throws BeansException &#123;</span><br><span class="line">	super.initApplicationContext();</span><br><span class="line">	registerHandlers(this.urlMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void registerHandlers(Map&lt;String, Object&gt; urlMap) throws BeansException &#123;</span><br><span class="line">	if (urlMap.isEmpty()) &#123;</span><br><span class="line">		logger.warn(&quot;Neither &#x27;urlMap&#x27; nor &#x27;mappings&#x27; set on SimpleUrlHandlerMapping&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		for (Map.Entry&lt;String, Object&gt; entry : urlMap.entrySet()) &#123;</span><br><span class="line">			String url = entry.getKey();</span><br><span class="line">			Object handler = entry.getValue();</span><br><span class="line">			// Prepend with slash if not already present.</span><br><span class="line">			if (!url.startsWith(&quot;/&quot;)) &#123;</span><br><span class="line">				url = &quot;/&quot; + url;</span><br><span class="line">			&#125;</span><br><span class="line">			// Remove whitespace from handler bean name.</span><br><span class="line">			if (handler instanceof String) &#123;</span><br><span class="line">				handler = ((String) handler).trim();</span><br><span class="line">			&#125;</span><br><span class="line">			registerHandler(url, handler);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SimpleUrlHandlerMapping的基类AbstractUrlHandlerMapping完成registerHandler方法的实现:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException &#123;</span><br><span class="line">	Assert.notNull(urlPath, &quot;URL path must not be null&quot;);</span><br><span class="line">	Assert.notNull(handler, &quot;Handler object must not be null&quot;);</span><br><span class="line">	Object resolvedHandler = handler;</span><br><span class="line"></span><br><span class="line">	// Eagerly resolve handler if referencing singleton via name.</span><br><span class="line">	//直接用bean的名字映射，那就直接从容器中获取handler</span><br><span class="line">	if (!this.lazyInitHandlers &amp;&amp; handler instanceof String) &#123;</span><br><span class="line">		String handlerName = (String) handler;</span><br><span class="line">		if (getApplicationContext().isSingleton(handlerName)) &#123;</span><br><span class="line">			resolvedHandler = getApplicationContext().getBean(handlerName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Object mappedHandler = this.handlerMap.get(urlPath);</span><br><span class="line">	if (mappedHandler != null) &#123;</span><br><span class="line">		if (mappedHandler != resolvedHandler) &#123;</span><br><span class="line">			throw new IllegalStateException(</span><br><span class="line">					&quot;Cannot map &quot; + getHandlerDescription(handler) + &quot; to URL path [&quot; + urlPath +</span><br><span class="line">					&quot;]: There is already &quot; + getHandlerDescription(mappedHandler) + &quot; mapped.&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">	//处理URL是“/”的映射，把这个“ /”映射的controller设置到rootHandler中</span><br><span class="line">		if (urlPath.equals(&quot;/&quot;)) &#123;</span><br><span class="line">			if (logger.isInfoEnabled()) &#123;</span><br><span class="line">				logger.info(&quot;Root mapping to &quot; + getHandlerDescription(handler));</span><br><span class="line">			&#125;</span><br><span class="line">			setRootHandler(resolvedHandler);</span><br><span class="line">		&#125;</span><br><span class="line">		else if (urlPath.equals(&quot;/*&quot;)) &#123;</span><br><span class="line">		//处理“/*”的url，将“/*”映射的controller设置到DefaultHandler中去。</span><br><span class="line">			if (logger.isInfoEnabled()) &#123;</span><br><span class="line">				logger.info(&quot;Default mapping to &quot; + getHandlerDescription(handler));</span><br><span class="line">			&#125;</span><br><span class="line">			setDefaultHandler(resolvedHandler);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">		//处理正常的、URL映射，将URL和controller分别设置为key和value</span><br><span class="line">	//这个handlerMap是一个LinkedHashMap</span><br><span class="line">			this.handlerMap.put(urlPath, resolvedHandler);</span><br><span class="line">			if (logger.isInfoEnabled()) &#123;</span><br><span class="line">				logger.info(&quot;Mapped URL path [&quot; + urlPath + &quot;] onto &quot; + getHandlerDescription(handler));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、 使用handlerMapping完成请求的映射处理</strong><br>SimpleHandlerMapping的接口方法getHandler，会根据初始化时得到的映射关系生产DispatcherServlet需要的HandlerExecutionChain。AbstractHandlerMapping的getHandler:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">	Object handler = getHandlerInternal(request);</span><br><span class="line">	if (handler == null) &#123;</span><br><span class="line">	//通过默认的Handler  ,“/”</span><br><span class="line">		handler = getDefaultHandler();</span><br><span class="line">	&#125;</span><br><span class="line">	if (handler == null) &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	// Bean name or resolved handler?</span><br><span class="line">	if (handler instanceof String) &#123;</span><br><span class="line">	//通过bean的名字得到handler</span><br><span class="line">		String handlerName = (String) handler;</span><br><span class="line">		handler = getApplicationContext().getBean(handlerName);</span><br><span class="line">	&#125;</span><br><span class="line">	//把handler封装成getHandlerExecutionChain并且加上拦截器</span><br><span class="line">	return getHandlerExecutionChain(handler, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getHandlerExecutionChain的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) &#123;</span><br><span class="line">	HandlerExecutionChain chain =</span><br><span class="line">		(handler instanceof HandlerExecutionChain) ?</span><br><span class="line">			(HandlerExecutionChain) handler : new HandlerExecutionChain(handler);</span><br><span class="line"></span><br><span class="line">	chain.addInterceptors(getAdaptedInterceptors());</span><br><span class="line"></span><br><span class="line">	String lookupPath = urlPathHelper.getLookupPathForRequest(request);</span><br><span class="line">	for (MappedInterceptor mappedInterceptor : mappedInterceptors) &#123;</span><br><span class="line">		if (mappedInterceptor.matches(lookupPath, pathMatcher)) &#123;</span><br><span class="line">			chain.addInterceptor(mappedInterceptor.getInterceptor());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取得handler的具体过程在getHandlerInternal方法中，根据http请求作为参数，得到URL并根据URL到uurlMapping中获得handler，具体实现再起子类AbstractUrlHandlerMapping中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Object getHandlerInternal(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">//根据http得到URL，通过URL与handler进行匹配，得到handler，如果你找不到就返回null，期间调用默认的handler会被使用</span><br><span class="line">	String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">	//lookHandler根据URL路径启动在handlerMapping中对handler的检索，并最终返回handler对象</span><br><span class="line">	Object handler = lookupHandler(lookupPath, request);</span><br><span class="line">	if (handler == null) &#123;</span><br><span class="line">		// We need to care for the default handler directly, since we need to</span><br><span class="line">		// expose the PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE for it as well.</span><br><span class="line">		Object rawHandler = null;</span><br><span class="line">		//对默认的handler的处理</span><br><span class="line">		if (&quot;/&quot;.equals(lookupPath)) &#123;</span><br><span class="line">			rawHandler = getRootHandler();</span><br><span class="line">		&#125;</span><br><span class="line">		if (rawHandler == null) &#123;</span><br><span class="line">			rawHandler = getDefaultHandler();</span><br><span class="line">		&#125;</span><br><span class="line">		if (rawHandler != null) &#123;</span><br><span class="line">			// Bean name or resolved handler?</span><br><span class="line">			if (rawHandler instanceof String) &#123;</span><br><span class="line">				String handlerName = (String) rawHandler;</span><br><span class="line">				rawHandler = getApplicationContext().getBean(handlerName);</span><br><span class="line">			&#125;</span><br><span class="line">			validateHandler(rawHandler, request);</span><br><span class="line">			handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, null);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (handler != null &amp;&amp; logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(&quot;Mapping [&quot; + lookupPath + &quot;] to &quot; + handler);</span><br><span class="line">	&#125;</span><br><span class="line">	else if (handler == null &amp;&amp; logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(&quot;No handler mapping found for [&quot; + lookupPath + &quot;]&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、springmvc对http请求的分发处理</strong></p>
<p>回到dispatcherServlet这个servlet担负了自有容器的建立与请求分发处理，所有的请求都会走都service方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			String requestUri = urlPathHelper.getRequestUri(request);</span><br><span class="line">			logger.debug(&quot;DispatcherServlet with name &#x27;&quot; + getServletName() + &quot;&#x27; processing &quot; + request.getMethod() +</span><br><span class="line">					&quot; request for [&quot; + requestUri + &quot;]&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Keep a snapshot of the request attributes in case of an include,</span><br><span class="line">		// to be able to restore the original attributes after the include.</span><br><span class="line">		Map&lt;String, Object&gt; attributesSnapshot = null;</span><br><span class="line">		if (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">			logger.debug(&quot;Taking snapshot of request attributes before include&quot;);</span><br><span class="line">			attributesSnapshot = new HashMap&lt;String, Object&gt;();</span><br><span class="line">			Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line">			while (attrNames.hasMoreElements()) &#123;</span><br><span class="line">				String attrName = (String) attrNames.nextElement();</span><br><span class="line">				if (this.cleanupAfterInclude || attrName.startsWith(&quot;org.springframework.web.servlet&quot;)) &#123;</span><br><span class="line">					attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Make framework objects available to handlers and view objects.</span><br><span class="line">		//http请求参数快照处理</span><br><span class="line">		request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">		request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);</span><br><span class="line">		request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);</span><br><span class="line">		request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line"></span><br><span class="line">		FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line">		if (inputFlashMap != null) &#123;</span><br><span class="line">			request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">		&#125;</span><br><span class="line">		request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());</span><br><span class="line">		request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">		 //请求分发的主要处理方法</span><br><span class="line">			doDispatch(request, response);</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			// Restore the original attribute snapshot, in case of an include.</span><br><span class="line">			if (attributesSnapshot != null) &#123;</span><br><span class="line">				restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>doDispatch的实现（典型的command模式的应用）：<br>Dodispatcher协同模型和控制器的过程：</p>
<p><img src="/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89SpringMVC%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/20150622213746614.png" alt="这里写图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">		HttpServletRequest processedRequest = request;</span><br><span class="line">		HandlerExecutionChain mappedHandler = null;</span><br><span class="line">		int interceptorIndex = -1;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">		 //ModelAndView 持有handler处理请求的结果</span><br><span class="line">			ModelAndView mv;</span><br><span class="line">			boolean errorView = false;</span><br><span class="line"></span><br><span class="line">			try &#123;</span><br><span class="line">				processedRequest = checkMultipart(request);</span><br><span class="line"></span><br><span class="line">				// Determine handler for the current request.</span><br><span class="line">				//根据请求得到对应的handler，handler的注册以及gethandler的实现</span><br><span class="line">				mappedHandler = getHandler(processedRequest, false);</span><br><span class="line">				if (mappedHandler == null || mappedHandler.getHandler() == null) &#123;</span><br><span class="line">					noHandlerFound(processedRequest, response);</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// Determine handler adapter for the current request.</span><br><span class="line">				//执行handler之前检查handler的合法性，是不是按spring的要求编写的handler</span><br><span class="line">				HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">                // Process last-modified header, if supported by the handler.</span><br><span class="line">				String method = request.getMethod();</span><br><span class="line">				boolean isGet = &quot;GET&quot;.equals(method);</span><br><span class="line">				if (isGet || &quot;HEAD&quot;.equals(method)) &#123;</span><br><span class="line">					long lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">					if (logger.isDebugEnabled()) &#123;</span><br><span class="line">						String requestUri = urlPathHelper.getRequestUri(request);</span><br><span class="line">						logger.debug(&quot;Last-Modified value for [&quot; + requestUri + &quot;] is: &quot; + lastModified);</span><br><span class="line">					&#125;</span><br><span class="line">					if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">						return;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// Apply preHandle methods of registered interceptors.</span><br><span class="line">				//调用handler的拦截器，从HandlerExecutionchain中取得Interceptor进行处理。</span><br><span class="line">				HandlerInterceptor[] interceptors = mappedHandler.getInterceptors();</span><br><span class="line">				if (interceptors != null) &#123;</span><br><span class="line">					for (int i = 0; i &lt; interceptors.length; i++) &#123;</span><br><span class="line">						HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">						if (!interceptor.preHandle(processedRequest, response, mappedHandler.getHandler())) &#123;</span><br><span class="line">							triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, null);</span><br><span class="line">							return;</span><br><span class="line">						&#125;</span><br><span class="line">						interceptorIndex = i;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// Actually invoke the handler.</span><br><span class="line">				//通过调用handleAdapter的handler方法，实际触发对controller的handleRequest方法的调用。</span><br><span class="line">				mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">				// Do we need view name translation?</span><br><span class="line">				//判断是否需要视图名的翻译与转换</span><br><span class="line">				if (mv != null &amp;&amp; !mv.hasView()) &#123;</span><br><span class="line">					mv.setViewName(getDefaultViewName(request));</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// Apply postHandle methods of registered interceptors.</span><br><span class="line">				if (interceptors != null) &#123;</span><br><span class="line">					for (int i = interceptors.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">						HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">						interceptor.postHandle(processedRequest, response, mappedHandler.getHandler(), mv);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			catch (ModelAndViewDefiningException ex) &#123;</span><br><span class="line">				logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, ex);</span><br><span class="line">				mv = ex.getModelAndView();</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Exception ex) &#123;</span><br><span class="line">				Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);</span><br><span class="line">				mv = processHandlerException(processedRequest, response, handler, ex);</span><br><span class="line">				errorView = (mv != null);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Did the handler return a view to render?</span><br><span class="line">			//使用视图对modelAndView数据的展现</span><br><span class="line">			if (mv != null &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">				render(mv, processedRequest, response);</span><br><span class="line">				if (errorView) &#123;</span><br><span class="line">					WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				if (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(&quot;Null ModelAndView returned to DispatcherServlet with name &#x27;&quot; + getServletName() +</span><br><span class="line">							&quot;&#x27;: assuming HandlerAdapter completed request handling&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Trigger after-completion for successful outcome.</span><br><span class="line">			triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, null);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		catch (Exception ex) &#123;</span><br><span class="line">			// Trigger after-completion for thrown exception.</span><br><span class="line">			triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, ex);</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Error err) &#123;</span><br><span class="line">			ServletException ex = new NestedServletException(&quot;Handler processing failed&quot;, err);</span><br><span class="line">			// Trigger after-completion for thrown exception.</span><br><span class="line">			triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, ex);</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		finally &#123;</span><br><span class="line">			// Clean up any resources used by a multipart request.</span><br><span class="line">			if (processedRequest != request) &#123;</span><br><span class="line">				cleanupMultipart(processedRequest);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面看看dispatcherservler是怎么得到handler的:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">//从handlerMappings得到handler与前面的初始化对接上</span><br><span class="line">	for (HandlerMapping hm : this.handlerMappings) &#123;</span><br><span class="line">		if (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(</span><br><span class="line">					&quot;Testing handler map [&quot; + hm + &quot;] in DispatcherServlet with name &#x27;&quot; + getServletName() + &quot;&#x27;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		 //与前面的分析对接，前面分析的simpleUrlhandlerMapping的基类getHandler得</span><br><span class="line">		 //HandlerExecutionChain</span><br><span class="line">		HandlerExecutionChain handler = hm.getHandler(request);</span><br><span class="line">		if (handler != null) &#123;</span><br><span class="line">			return handler;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过handler对业务逻辑处理后将返回的数据封装为ModelAndView交给视图类处理，处理的入口方法是doDispatch的render方法。至此到handler的调用，业务数据的处理完毕。</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SPRING技术内幕-笔记（十一）spring事物处理的设计与实现</title>
    <url>/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89spring%E4%BA%8B%E7%89%A9%E5%A4%84%E7%90%86%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p><strong>11.1事物的创建</strong><br>TransactionInterceptor的invoke的回调过程中会使用createTransactionIfNecessary，这个方法在其基类TransactionAspectSupport中实现，期间会使用AbstractPlatformTransactionManager调用getTransaction(txAttr)，这个过程要对不同情况进行处理，得到TransactionStatus，然后塞进TransactionInfo中，最后将TransactionInfo与当前线程绑定，TransactionInfo穿插在整个事物处理过程中。<br>createTransactionIfNecessary的调用时序图：</p>
<span id="more"></span>
<p><img src="/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89spring%E4%BA%8B%E7%89%A9%E5%A4%84%E7%90%86%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/20150716102610570.png" alt="这里写图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected TransactionInfo createTransactionIfNecessary(</span><br><span class="line">		PlatformTransactionManager tm, TransactionAttribute txAttr, final String joinpointIdentification) &#123;</span><br><span class="line"></span><br><span class="line">	// If no name specified, apply method identification as transaction name.</span><br><span class="line">	//如果没有配置事物属性，就用方法名作为事物的名字</span><br><span class="line">	if (txAttr != null &amp;&amp; txAttr.getName() == null) &#123;</span><br><span class="line">		txAttr = new DelegatingTransactionAttribute(txAttr) &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public String getName() &#123;</span><br><span class="line">				return joinpointIdentification;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">       //TransactionStatus 封装了事物执行的状态信息</span><br><span class="line">       TransactionStatus status = null;</span><br><span class="line">	if (txAttr != null) &#123;</span><br><span class="line">		if (tm != null) &#123;</span><br><span class="line">		//使用定义好的事物属性创建事物，返回事物的状态和 事物本身，由事物处理器去完成，事物处理器重写getTransaction</span><br><span class="line">		 //方法.</span><br><span class="line">			status = tm.getTransaction(txAttr);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Skipping transactional joinpoint [&quot; + joinpointIdentification +</span><br><span class="line">						&quot;] because no transaction manager has been configured&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//准备TransactionInfo，TransactionInfo封装了事物的配置信息以及TransactionStatus</span><br><span class="line">	return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>prepareTransactionInfo代码清单:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected TransactionInfo prepareTransactionInfo(PlatformTransactionManager tm,</span><br><span class="line">		TransactionAttribute txAttr, String joinpointIdentification, TransactionStatus status) &#123;</span><br><span class="line">       //创建新的TransactionInfo</span><br><span class="line">	TransactionInfo txInfo = new TransactionInfo(tm, txAttr, joinpointIdentification);</span><br><span class="line">	if (txAttr != null) &#123;</span><br><span class="line">		// We need a transaction for this method</span><br><span class="line">		if (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(&quot;Getting transaction for [&quot; + txInfo.getJoinpointIdentification() + &quot;]&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		// The transaction manager will flag an error if an incompatible tx already exists</span><br><span class="line">		//为TransactionInfo 设置TransactionStatus，这个TransactionStatus比较重要，内含了事物创建过程的信息，</span><br><span class="line">		//比如Transaction是由TransactionStatus持有的</span><br><span class="line">		txInfo.newTransactionStatus(status);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		// The TransactionInfo.hasTransaction() method will return</span><br><span class="line">		// false. We created it only to preserve the integrity of</span><br><span class="line">		// the ThreadLocal stack maintained in this class.</span><br><span class="line">		if (logger.isTraceEnabled())</span><br><span class="line">			logger.trace(&quot;Don&#x27;t need to create transaction for [&quot; + joinpointIdentification +</span><br><span class="line">					&quot;]: This method isn&#x27;t transactional.&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// We always bind the TransactionInfo to the thread, even if we didn&#x27;t create</span><br><span class="line">	// a new transaction here. This guarantees that the TransactionInfo stack</span><br><span class="line">       //将当前的TransactionInfo 与当前线程绑定，TransactionInfo 内部用一个含量持有以前的TransactionInfo ，这样</span><br><span class="line">       //就会有一系列的TransactionInfo ，虽然不会创建新的事物，但是总会简历新的TransactionInfo 。</span><br><span class="line">	txInfo.bindToThread();</span><br><span class="line">	return txInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是AbstractPlatformTransactionManager得getTransaction，此方法提供了事物处理流程的一个模板。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException &#123;</span><br><span class="line">//doGetTransaction由事物处理器完成，比如datasourcetransactionmanager</span><br><span class="line">	Object transaction = doGetTransaction();</span><br><span class="line"></span><br><span class="line">	// Cache debug flag to avoid repeated checks.</span><br><span class="line">	//缓存标志，防止重复检查</span><br><span class="line">	boolean debugEnabled = logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">	if (definition == null) &#123;</span><br><span class="line">		// Use defaults if no transaction definition given.</span><br><span class="line">		//使用默认事物处理属性，默认的配置如下:</span><br><span class="line">		//	private int propagationBehavior = PROPAGATION_REQUIRED;</span><br><span class="line">		//	private int isolationLevel = ISOLATION_DEFAULT;</span><br><span class="line">		//	private int timeout = TIMEOUT_DEFAULT;</span><br><span class="line">		//	private boolean readOnly = false;</span><br><span class="line">		definition = new DefaultTransactionDefinition();</span><br><span class="line">	&#125;</span><br><span class="line">       //判断当前事物是否已经存在,如果已经存在事物，那么需要根据事物属性中定义的事物传播性配置来处理事物的</span><br><span class="line">       //产生.</span><br><span class="line">	if (isExistingTransaction(transaction)) &#123;</span><br><span class="line">		// Existing transaction found -&gt; check propagation behavior to find out how to behave.</span><br><span class="line">		//如果当前线程存，那么在检查事物处理行为,将已经存在的事物进行处理，结果封装在</span><br><span class="line">		//TransactionState中。</span><br><span class="line">		return handleExistingTransaction(definition, transaction, debugEnabled);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Check definition settings for new transaction.</span><br><span class="line">	//检查事物中timeout的设置是否合理</span><br><span class="line">	if (definition.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">		throw new InvalidTimeoutException(&quot;Invalid transaction timeout&quot;, definition.getTimeout());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// No existing transaction found -&gt; check propagation behavior to find out how to proceed.</span><br><span class="line"></span><br><span class="line">	if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">		throw new IllegalTransactionStateException(</span><br><span class="line">				&quot;No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">//当前没有存在的事物，那么根据配置的事物属性的事物传播行为处理，比如PROPAGATION_REQUIRED，</span><br><span class="line">	//PROPAGATION_REQUIRES_NEW，PROPAGATION_NESTED</span><br><span class="line">	else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">			definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">	    definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">		SuspendedResourcesHolder suspendedResources = suspend(null);</span><br><span class="line">		if (debugEnabled) &#123;</span><br><span class="line">			logger.debug(&quot;Creating new transaction with name [&quot; + definition.getName() + &quot;]: &quot; + definition);</span><br><span class="line">		&#125;</span><br><span class="line">		try &#123;</span><br><span class="line">			boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">		//要返回的TransactionStatus，封装事物处理情况，getTransactionSynchronization()默认为</span><br><span class="line">		//SYNCHRONIZATION_ALWAYS，所以newSynchronization为true</span><br><span class="line">			DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">					definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">			//创建事物的调用，由具体的事物处理器来完成。</span><br><span class="line">			doBegin(transaction, definition);</span><br><span class="line">			prepareSynchronization(status, definition);</span><br><span class="line">			return status;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (RuntimeException ex) &#123;</span><br><span class="line">			resume(null, suspendedResources);</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Error err) &#123;</span><br><span class="line">			resume(null, suspendedResources);</span><br><span class="line">			throw err;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		// Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.</span><br><span class="line">		boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">		//设置事物为空，创建新的事物状态对象，没有transaction。</span><br><span class="line">		return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractPlatformTransactionManager创建事物的过程可以看到TransactionStatus的创建过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected DefaultTransactionStatus newTransactionStatus(</span><br><span class="line">		TransactionDefinition definition, Object transaction, boolean newTransaction,</span><br><span class="line">		boolean newSynchronization, boolean debug, Object suspendedResources) &#123;</span><br><span class="line">       //判断是不是新的事物，如果是新的事物，需要放到当前线程中去，</span><br><span class="line">       //AbstractPlatformTransactionManager维护了一系列的threadLocal变量来保持事物的属性，比如并</span><br><span class="line">       //事物并发事物隔离级别，是否有活跃的事物。</span><br><span class="line">	boolean actualNewSynchronization = newSynchronization &amp;&amp;</span><br><span class="line">			!TransactionSynchronizationManager.isSynchronizationActive();</span><br><span class="line">			//使用DefaultTransactionStatus返回</span><br><span class="line">	return new DefaultTransactionStatus(</span><br><span class="line">			transaction, newTransaction, actualNewSynchronization,</span><br><span class="line">			definition.isReadOnly(), debug, suspendedResources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所谓创建，首先是把创建工作较给具体的事物处理器来完成，比如dataSourceTransactionManager，把创建的事物对象哎TransactionStatus中保存，然后把其他事物的属性和线程ThreadLocal绑定。<br>对于线程中已经存在事物，会涉及事物传播属性的具体处理。处理逻辑在AbstractPlatformTransactionManager的handleExistingTransaction方法中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private TransactionStatus handleExistingTransaction(</span><br><span class="line">			TransactionDefinition definition, Object transaction, boolean debugEnabled)</span><br><span class="line">			throws TransactionException &#123;</span><br><span class="line">//如果当前线程已有事物存在且当前事物的传播属性是PROPAGATION_NEVER，那么抛出异常，这种无法处理</span><br><span class="line">		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) &#123;</span><br><span class="line">			throw new IllegalTransactionStateException(</span><br><span class="line">					&quot;Existing transaction found for transaction marked with propagation &#x27;never&#x27;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">         //如果当前线程存在事物并且当前事物传播属性是PROPAGATION_NOT_SUPPORTED，那么将事物挂起</span><br><span class="line">		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) &#123;</span><br><span class="line">			if (debugEnabled) &#123;</span><br><span class="line">				logger.debug(&quot;Suspending current transaction&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			Object suspendedResources = suspend(transaction);</span><br><span class="line">			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">			//此时Transaction为null意味着事物方法不需要在事物环境中执行，同事挂起的事物记录到TransactionStatus当中</span><br><span class="line">			//包含ThreadLocal对事物信息的记录</span><br><span class="line">			return prepareTransactionStatus(</span><br><span class="line">					definition, null, false, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">		&#125;</span><br><span class="line">//如果当前事物的传播属性是PROPAGATION_REQUIRES_NEW，那么将当前线程中已有的事物挂起，与创建事物不同的是，此处需要将已有</span><br><span class="line">//事物挂起，而新建不需要这步操作</span><br><span class="line">		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123;</span><br><span class="line">			if (debugEnabled) &#123;</span><br><span class="line">				logger.debug(&quot;Suspending current transaction, creating new transaction with name [&quot; +</span><br><span class="line">						definition.getName() + &quot;]&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			SuspendedResourcesHolder suspendedResources = suspend(transaction);</span><br><span class="line">			try &#123;</span><br><span class="line">				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">				DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">				doBegin(transaction, definition);</span><br><span class="line">				prepareSynchronization(status, definition);</span><br><span class="line">				return status;</span><br><span class="line">			&#125;</span><br><span class="line">			catch (RuntimeException beginEx) &#123;</span><br><span class="line">				resumeAfterBeginException(transaction, suspendedResources, beginEx);</span><br><span class="line">				throw beginEx;</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Error beginErr) &#123;</span><br><span class="line">				resumeAfterBeginException(transaction, suspendedResources, beginErr);</span><br><span class="line">				throw beginErr;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	//嵌套事物的创建</span><br><span class="line">		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">			if (!isNestedTransactionAllowed()) &#123;</span><br><span class="line">				throw new NestedTransactionNotSupportedException(</span><br><span class="line">						&quot;Transaction manager does not allow nested transactions by default - &quot; +</span><br><span class="line">						&quot;specify &#x27;nestedTransactionAllowed&#x27; property with value &#x27;true&#x27;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			if (debugEnabled) &#123;</span><br><span class="line">				logger.debug(&quot;Creating nested transaction with name [&quot; + definition.getName() + &quot;]&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			if (useSavepointForNestedTransaction()) &#123;</span><br><span class="line">				// Create savepoint within existing Spring-managed transaction,</span><br><span class="line">				// through the SavepointManager API implemented by TransactionStatus.</span><br><span class="line">				// Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.</span><br><span class="line">				//在spring事物处理中，创建事物保存点</span><br><span class="line">				DefaultTransactionStatus status =</span><br><span class="line">						prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null);</span><br><span class="line">				status.createAndHoldSavepoint();</span><br><span class="line">				return status;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				// Nested transaction through nested begin and commit/rollback calls.</span><br><span class="line">				// Usually only for JTA: Spring synchronization might get activated here</span><br><span class="line">				// in case of a pre-existing JTA transaction.</span><br><span class="line">				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">				DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">						definition, transaction, true, newSynchronization, debugEnabled, null);</span><br><span class="line">				doBegin(transaction, definition);</span><br><span class="line">				prepareSynchronization(status, definition);</span><br><span class="line">				return status;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED.</span><br><span class="line">		if (debugEnabled) &#123;</span><br><span class="line">			logger.debug(&quot;Participating in existing transaction&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		//判断当前事物方法中的事物配置与已有事物的属性配置是否一致，如果不一致则不执行事物的方法并且抛出异常</span><br><span class="line">		if (isValidateExistingTransaction()) &#123;</span><br><span class="line">			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) &#123;</span><br><span class="line">				Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();</span><br><span class="line">				if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) &#123;</span><br><span class="line">					Constants isoConstants = DefaultTransactionDefinition.constants;</span><br><span class="line">					throw new IllegalTransactionStateException(&quot;Participating transaction with definition [&quot; +</span><br><span class="line">							definition + &quot;] specifies isolation level which is incompatible with existing transaction: &quot; +</span><br><span class="line">							(currentIsolationLevel != null ?</span><br><span class="line">									isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :</span><br><span class="line">									&quot;(unknown)&quot;));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if (!definition.isReadOnly()) &#123;</span><br><span class="line">				if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) &#123;</span><br><span class="line">					throw new IllegalTransactionStateException(&quot;Participating transaction with definition [&quot; +</span><br><span class="line">							definition + &quot;] is not marked as read-only but existing transaction is&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//返回TransactionStatus，参数newTransaction为false，表示不是使用新的事物</span><br><span class="line">		boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">		return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>11.2事物的挂起</strong><br>事物的挂起牵扯到当前线程与事物处理信息的保存：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final SuspendedResourcesHolder suspend(Object transaction) throws TransactionException &#123;</span><br><span class="line">	if (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span><br><span class="line">		List&lt;TransactionSynchronization&gt; suspendedSynchronizations = doSuspendSynchronization();</span><br><span class="line">		try &#123;</span><br><span class="line">			Object suspendedResources = null;</span><br><span class="line">			if (transaction != null) &#123;</span><br><span class="line">			//把挂起的事物交给具体的事物处理器去完成，如果事物处理器不支持事物挂起，就会抛出异常</span><br><span class="line">				suspendedResources = doSuspend(transaction);</span><br><span class="line">			&#125;</span><br><span class="line">			//设置事物处理状态信息，放到线程中去，并且重置线程中的相关的threadlocal变量</span><br><span class="line">			String name = TransactionSynchronizationManager.getCurrentTransactionName();</span><br><span class="line">			TransactionSynchronizationManager.setCurrentTransactionName(null);</span><br><span class="line">			boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();</span><br><span class="line">			TransactionSynchronizationManager.setCurrentTransactionReadOnly(false);</span><br><span class="line">			Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();</span><br><span class="line">			TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null);</span><br><span class="line">			boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive();</span><br><span class="line">			TransactionSynchronizationManager.setActualTransactionActive(false);</span><br><span class="line">			return new SuspendedResourcesHolder(</span><br><span class="line">					suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (RuntimeException ex) &#123;</span><br><span class="line">			// doSuspend failed - original transaction is still active...</span><br><span class="line">			doResumeSynchronization(suspendedSynchronizations);</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Error err) &#123;</span><br><span class="line">			// doSuspend failed - original transaction is still active...</span><br><span class="line">			//doSuspend方法失败，但是原先的事物依然存在</span><br><span class="line">			doResumeSynchronization(suspendedSynchronizations);</span><br><span class="line">			throw err;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (transaction != null) &#123;</span><br><span class="line">		// Transaction active but no synchronization active.</span><br><span class="line">		Object suspendedResources = doSuspend(transaction);</span><br><span class="line">		return new SuspendedResourcesHolder(suspendedResources);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		// Neither transaction nor synchronization active.</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>11.3  事务的提交</strong><br>commitTransactionAfterReturning方法通过直接调用事物处理器来完成事物的提交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void commitTransactionAfterReturning(TransactionInfo txInfo) &#123;</span><br><span class="line">	if (txInfo != null &amp;&amp; txInfo.hasTransaction()) &#123;</span><br><span class="line">		if (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(&quot;Completing transaction for [&quot; + txInfo.getJoinpointIdentification() + &quot;]&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		//txInfo是TransactionInfo ，调用事物处理器的commit方法</span><br><span class="line">		txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractPlatformTransactionManager的commit方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	public final void commit(TransactionStatus status) throws TransactionException &#123;</span><br><span class="line">	//status.isCompleted()表示事务已经结束</span><br><span class="line">		if (status.isCompleted()) &#123;</span><br><span class="line">			throw new IllegalTransactionStateException(</span><br><span class="line">					&quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">//事务处理过程中出现异常，则进行回滚</span><br><span class="line">		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;</span><br><span class="line">		if (defStatus.isLocalRollbackOnly()) &#123;</span><br><span class="line">			if (defStatus.isDebug()) &#123;</span><br><span class="line">				logger.debug(&quot;Transactional code has requested rollback&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			processRollback(defStatus);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		if (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) &#123;</span><br><span class="line">			if (defStatus.isDebug()) &#123;</span><br><span class="line">				logger.debug(&quot;Global transaction is marked as rollback-only but transactional code requested commit&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		//处理回滚</span><br><span class="line">			processRollback(defStatus);</span><br><span class="line">			// Throw UnexpectedRollbackException only at outermost transaction boundary</span><br><span class="line">			// or if explicitly asked to.</span><br><span class="line">			if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">				throw new UnexpectedRollbackException(</span><br><span class="line">						&quot;Transaction rolled back because it has been marked as rollback-only&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">//最后调事务</span><br><span class="line">		processCommit(defStatus);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>处理事务的提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void processCommit(DefaultTransactionStatus status) throws TransactionException &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		boolean beforeCompletionInvoked = false;</span><br><span class="line">		try &#123;</span><br><span class="line">		// 事务的提交准备操作由具体的事物处理器完成</span><br><span class="line">			prepareForCommit(status);</span><br><span class="line">			triggerBeforeCommit(status);</span><br><span class="line">			triggerBeforeCompletion(status);</span><br><span class="line">			beforeCompletionInvoked = true;</span><br><span class="line">			boolean globalRollbackOnly = false;</span><br><span class="line">			if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">				globalRollbackOnly = status.isGlobalRollbackOnly();</span><br><span class="line">			&#125;</span><br><span class="line">			//嵌套事物的处理</span><br><span class="line">			if (status.hasSavepoint()) &#123;</span><br><span class="line">				if (status.isDebug()) &#123;</span><br><span class="line">					logger.debug(&quot;Releasing transaction savepoint&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				status.releaseHeldSavepoint();</span><br><span class="line">			&#125;</span><br><span class="line">			 //如果当前持有的事务是新建立的事物那么由具体的事务处理器完成提交，否则由已存在的事务完成提交</span><br><span class="line">			else if (status.isNewTransaction()) &#123;</span><br><span class="line">				if (status.isDebug()) &#123;</span><br><span class="line">					logger.debug(&quot;Initiating transaction commit&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				 //由具体的事务处理器完成提交</span><br><span class="line">				doCommit(status);</span><br><span class="line">			&#125;</span><br><span class="line">			// Throw UnexpectedRollbackException if we have a global rollback-only</span><br><span class="line">			// marker but still didn&#x27;t get a corresponding exception from commit.</span><br><span class="line">			if (globalRollbackOnly) &#123;</span><br><span class="line">				throw new UnexpectedRollbackException(</span><br><span class="line">						&quot;Transaction silently rolled back because it has been marked as rollback-only&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (UnexpectedRollbackException ex) &#123;</span><br><span class="line">			// can only be caused by doCommit</span><br><span class="line">			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (TransactionException ex) &#123;</span><br><span class="line">			// can only be caused by doCommit</span><br><span class="line">			if (isRollbackOnCommitFailure()) &#123;</span><br><span class="line">				doRollbackOnCommitException(status, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line">			&#125;</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (RuntimeException ex) &#123;</span><br><span class="line">			if (!beforeCompletionInvoked) &#123;</span><br><span class="line">				triggerBeforeCompletion(status);</span><br><span class="line">			&#125;</span><br><span class="line">			doRollbackOnCommitException(status, ex);</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Error err) &#123;</span><br><span class="line">			if (!beforeCompletionInvoked) &#123;</span><br><span class="line">				triggerBeforeCompletion(status);</span><br><span class="line">			&#125;</span><br><span class="line">			doRollbackOnCommitException(status, err);</span><br><span class="line">			throw err;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Trigger afterCommit callbacks, with an exception thrown there</span><br><span class="line">		// propagated to callers but the transaction still considered as committed.</span><br><span class="line">		try &#123;</span><br><span class="line">		//触发triggerAfterCommit回滚</span><br><span class="line">			triggerAfterCommit(status);</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	finally &#123;</span><br><span class="line">		cleanupAfterCompletion(status);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>11.4事务的回滚</strong><br>回滚和提交比较类似:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void processRollback(DefaultTransactionStatus status) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				triggerBeforeCompletion(status);</span><br><span class="line">				//嵌套事务的回滚</span><br><span class="line">				if (status.hasSavepoint()) &#123;</span><br><span class="line">					if (status.isDebug()) &#123;</span><br><span class="line">						logger.debug(&quot;Rolling back transaction to savepoint&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">					status.rollbackToHeldSavepoint();</span><br><span class="line">				&#125;</span><br><span class="line">				 //新建事务的回滚</span><br><span class="line">				else if (status.isNewTransaction()) &#123;</span><br><span class="line">					if (status.isDebug()) &#123;</span><br><span class="line">						logger.debug(&quot;Initiating transaction rollback&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">					doRollback(status);</span><br><span class="line">				&#125;</span><br><span class="line">				//如果当前事务调用方法中，没有新建事务的回滚方法</span><br><span class="line">				else if (status.hasTransaction()) &#123;</span><br><span class="line">					if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) &#123;</span><br><span class="line">						if (status.isDebug()) &#123;</span><br><span class="line">							logger.debug(&quot;Participating transaction failed - marking existing transaction as rollback-only&quot;);</span><br><span class="line">						&#125;</span><br><span class="line">						doSetRollbackOnly(status);</span><br><span class="line">					&#125;//由线程的前一个事物来处理，当前不做任何操作</span><br><span class="line">					else &#123;</span><br><span class="line">						if (status.isDebug()) &#123;</span><br><span class="line">							logger.debug(&quot;Participating transaction failed - letting transaction originator decide on rollback&quot;);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					logger.debug(&quot;Should roll back transaction but cannot - no transaction available&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			catch (RuntimeException ex) &#123;</span><br><span class="line">				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line">				throw ex;</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Error err) &#123;</span><br><span class="line">				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line">				throw err;</span><br><span class="line">			&#125;</span><br><span class="line">			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			cleanupAfterCompletion(status);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>到此事务的处理新建，挂起，提交、回滚完成，下一步说一下具体的事物处理器对事物的处理过程。</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SPRING技术内幕-笔记（十二）spring驱动ibatis的设计与实现</title>
    <url>/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89spring%E9%A9%B1%E5%8A%A8ibatis%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p><strong>12.1设计原理</strong><br>对ibatis的使用相对来说比较简单，在spring的封装中，有几个基本过程，首先需要创建sqlmapclient，这个sqlmapclient类似于在hibernate中的session，对于它的创建，在spring中设计sqlmapclientfactorybean，通过这个factorybean；哎读取sqlmapclient的配置和具体创建。在配置和创建好sqlmapclient之后，在spring中同样为sqlmapclient的使用封装了sqlmapclienttemplate，他同样作为一个模板，封装了通过sqlmapclient完成的主要操作。</p>
<span id="more"></span>
<p><strong>12.2创建sqlmapclient</strong><br>在springIOC容器中，ibatis实例通常通过sqlmapclientfactorybean来设置，在sqlmapfactorybean中完成sqlmapclient的创建，sqlmapclient是用户使用ibatis操作数据库的主要类，这个创建过程包括一些对sqlmapclient的配置过程（比如对数据源打他source的配置），以及对参数的配置，宰割创建过程是在afterpropertiesset中完成，他在依赖注入完成以后被ioc容器回调。<br>IOC调用回顾：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd)</span><br><span class="line">		throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">	boolean isInitializingBean = (bean instanceof InitializingBean);</span><br><span class="line">	if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))) &#123;</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Invoking afterPropertiesSet() on bean with name &#x27;&quot; + beanName + &quot;&#x27;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		if (System.getSecurityManager() != null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line">					public Object run() throws Exception &#123;</span><br><span class="line">						((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">						return null;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;, getAccessControlContext());</span><br><span class="line">			&#125;</span><br><span class="line">			catch (PrivilegedActionException pae) &#123;</span><br><span class="line">				throw pae.getException();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;				</span><br><span class="line">		else &#123;</span><br><span class="line">		//对bean注入之后进行初始化</span><br><span class="line">			((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (mbd != null) &#123;</span><br><span class="line">		String initMethodName = mbd.getInitMethodName();</span><br><span class="line">		if (initMethodName != null &amp;&amp; !(isInitializingBean &amp;&amp; &quot;afterPropertiesSet&quot;.equals(initMethodName)) &amp;&amp;</span><br><span class="line">				!mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">			invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SqlMapClientFactoryBean的getObject以及afterPropertiesSet方法：<br>    public SqlMapClient getObject() {<br>        return this.sqlMapClient;<br>    }</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">	if (this.lobHandler != null) &#123;</span><br><span class="line">		// Make given LobHandler available for SqlMapClient configuration.</span><br><span class="line">		// Do early because because mapping resource might refer to custom types.</span><br><span class="line">		configTimeLobHandlerHolder.set(this.lobHandler);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	try &#123;</span><br><span class="line">	//开始创建sqlMapClient</span><br><span class="line">		this.sqlMapClient = buildSqlMapClient(this.configLocations, this.mappingLocations, this.sqlMapClientProperties);</span><br><span class="line"></span><br><span class="line">		// Tell the SqlMapClient to use the given DataSource, if any.</span><br><span class="line">		//为sqlMapClient 设置数据源</span><br><span class="line">		if (this.dataSource != null) &#123;</span><br><span class="line">			TransactionConfig transactionConfig = (TransactionConfig) this.transactionConfigClass.newInstance();</span><br><span class="line">			DataSource dataSourceToUse = this.dataSource;</span><br><span class="line">			if (this.useTransactionAwareDataSource &amp;&amp; !(this.dataSource instanceof TransactionAwareDataSourceProxy)) &#123;</span><br><span class="line">				dataSourceToUse = new TransactionAwareDataSourceProxy(this.dataSource);</span><br><span class="line">			&#125;</span><br><span class="line">			transactionConfig.setDataSource(dataSourceToUse);</span><br><span class="line">			transactionConfig.initialize(this.transactionConfigProperties);</span><br><span class="line">			applyTransactionConfig(this.sqlMapClient, transactionConfig);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	finally &#123;</span><br><span class="line">		if (this.lobHandler != null) &#123;</span><br><span class="line">			// Reset LobHandler holder.</span><br><span class="line">			configTimeLobHandlerHolder.remove();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>buildSqlMapClient方法的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	protected SqlMapClient buildSqlMapClient(</span><br><span class="line">			Resource[] configLocations, Resource[] mappingLocations, Properties properties)</span><br><span class="line">			throws IOException &#123;</span><br><span class="line"></span><br><span class="line">		if (ObjectUtils.isEmpty(configLocations)) &#123;</span><br><span class="line">			throw new IllegalArgumentException(&quot;At least 1 &#x27;configLocation&#x27; entry is required&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		SqlMapClient client = null;</span><br><span class="line">		//对应对数据源以及数据源附属参数的设置</span><br><span class="line">		SqlMapConfigParser configParser = new SqlMapConfigParser();</span><br><span class="line">		for (Resource configLocation : configLocations) &#123;</span><br><span class="line">			InputStream is = configLocation.getInputStream();</span><br><span class="line">			try &#123;</span><br><span class="line">				client = configParser.parse(is, properties);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (RuntimeException ex) &#123;</span><br><span class="line">				throw new NestedIOException(&quot;Failed to parse config resource: &quot; + configLocation, ex.getCause());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">//对映射文件的初始化。</span><br><span class="line">		if (mappingLocations != null) &#123;</span><br><span class="line">			SqlMapParser mapParser = SqlMapParserFactory.createSqlMapParser(configParser);</span><br><span class="line">			for (Resource mappingLocation : mappingLocations) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					mapParser.parse(mappingLocation.getInputStream());</span><br><span class="line">				&#125;</span><br><span class="line">				catch (NodeletException ex) &#123;</span><br><span class="line">					throw new NestedIOException(&quot;Failed to parse mapping resource: &quot; + mappingLocation, ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return client;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>12.3 sqlmapclienttemplate的实现</strong></p>
<p>sqlmapclienttemplate封装了对ibatis的操作，其继承关系如下：<br><img src="/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89spring%E9%A9%B1%E5%8A%A8ibatis%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/20150726132920921.png" alt="这里写图片描述"></p>
<p>sqlmapclienttemplate是一个核心，这个类持有一个sqlmapclient，这个类是ibatis的类，是直接使用ibatis时调用的，它提供了使用ibatis的API，类似于hibernate的session，同时，sqlmapclientdaosupport中持有一个salmapclienttemplate，尽管对ibatis的操作是由sqlmapclienttemplate来完成，但应用可以通过扩展sqlmapclientdaosupport来对ibatis进行操作。spring封装ibatis操作基本上封装在sqlmapclienttemplate的设计和实现中。其设计时序图：<br><img src="/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89spring%E9%A9%B1%E5%8A%A8ibatis%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/20150726142033632.png" alt="这里写图片描述"></p>
<p>在这个时序过程中，template会从sqlmapclient中得到session和datasource，并进行一系列的初始化过程，然后回调sqlmapclientcallback的doinsqlmapclient方法执行具体的动作，最后释放数据库连接和关闭session。<br>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">	 * Execute the given data access action on a SqlMapExecutor.</span><br><span class="line">	 * @param action callback object that specifies the data access action</span><br><span class="line">	 * @return a result object returned by the action, or &lt;code&gt;null&lt;/code&gt;</span><br><span class="line">	 * @throws DataAccessException in case of SQL Maps errors</span><br><span class="line">	 */</span><br><span class="line">	 //使用SqlMapExecutor完成数据的操作</span><br><span class="line">	public &lt;T&gt; T execute(SqlMapClientCallback&lt;T&gt; action) throws DataAccessException &#123;</span><br><span class="line">		Assert.notNull(action, &quot;Callback object must not be null&quot;);</span><br><span class="line">		Assert.notNull(this.sqlMapClient, &quot;No SqlMapClient specified&quot;);</span><br><span class="line"></span><br><span class="line">		// We always need to use a SqlMapSession, as we need to pass a Spring-managed</span><br><span class="line">		// Connection (potentially transactional) in. This shouldn&#x27;t be necessary if</span><br><span class="line">		// we run against a TransactionAwareDataSourceProxy underneath, but unfortunately</span><br><span class="line">		// we still need it to make iBATIS batch execution work properly: If iBATIS</span><br><span class="line">		// doesn&#x27;t recognize an existing transaction, it automatically executes the</span><br><span class="line">		// batch for every single statement...</span><br><span class="line">         //通过sqlMapClient完成sqlmapsession</span><br><span class="line">		SqlMapSession session = this.sqlMapClient.openSession();</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Opened SqlMapSession [&quot; + session + &quot;] for iBATIS operation&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		Connection ibatisCon = null;</span><br><span class="line">        //得到数据源</span><br><span class="line">		try &#123;</span><br><span class="line">			Connection springCon = null;</span><br><span class="line">			DataSource dataSource = getDataSource();</span><br><span class="line">			boolean transactionAware = (dataSource instanceof TransactionAwareDataSourceProxy);</span><br><span class="line"></span><br><span class="line">			// Obtain JDBC Connection to operate on...</span><br><span class="line">			try &#123;</span><br><span class="line">				ibatisCon = session.getCurrentConnection();</span><br><span class="line">				if (ibatisCon == null) &#123;</span><br><span class="line">				//此处将要获取connection，如果已经在spring的事物管理之下，数据源直接拿过来使用，否则就是用</span><br><span class="line">				//DataSourceUtils生成一个connection，并将得到的connnection放在spring的事物管理之下。</span><br><span class="line">					springCon = (transactionAware ?</span><br><span class="line">							dataSource.getConnection() : DataSourceUtils.doGetConnection(dataSource));</span><br><span class="line">					session.setUserConnection(springCon);</span><br><span class="line">					if (logger.isDebugEnabled()) &#123;</span><br><span class="line">						logger.debug(&quot;Obtained JDBC Connection [&quot; + springCon + &quot;] for iBATIS operation&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					if (logger.isDebugEnabled()) &#123;</span><br><span class="line">						logger.debug(&quot;Reusing JDBC Connection [&quot; + ibatisCon + &quot;] for iBATIS operation&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			catch (SQLException ex) &#123;</span><br><span class="line">				throw new CannotGetJdbcConnectionException(&quot;Could not get JDBC Connection&quot;, ex);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Execute given callback...</span><br><span class="line">			try &#123;</span><br><span class="line">			 //执行SqlMapClientCallback的回调函数</span><br><span class="line">				return action.doInSqlMapClient(session);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (SQLException ex) &#123;</span><br><span class="line">				throw getExceptionTranslator().translate(&quot;SqlMapClient operation&quot;, null, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			finally &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					if (springCon != null) &#123;</span><br><span class="line">						if (transactionAware) &#123;</span><br><span class="line">							springCon.close();</span><br><span class="line">						&#125;</span><br><span class="line">						else &#123;</span><br><span class="line">							DataSourceUtils.doReleaseConnection(springCon, dataSource);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				catch (Throwable ex) &#123;</span><br><span class="line">					logger.debug(&quot;Could not close JDBC Connection&quot;, ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Processing finished - potentially session still to be closed.</span><br><span class="line">		&#125;</span><br><span class="line">		//释放datasource</span><br><span class="line">		finally &#123;</span><br><span class="line">			// Only close SqlMapSession if we know we&#x27;ve actually opened it</span><br><span class="line">			// at the present level.</span><br><span class="line">			if (ibatisCon == null) &#123;</span><br><span class="line">				session.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>sqlmapclienttemplate的其他方法也是调用exector方法提供回调函数实现的。<br>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object queryForObject(final String statementName, final Object parameterObject)</span><br><span class="line">		throws DataAccessException &#123;</span><br><span class="line"></span><br><span class="line">	return execute(new SqlMapClientCallback&lt;Object&gt;() &#123;</span><br><span class="line">		public Object doInSqlMapClient(SqlMapExecutor executor) throws SQLException &#123;</span><br><span class="line">			return executor.queryForObject(statementName, parameterObject);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于datasource的关闭以及事物的绑定都已经做好了封装。</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SPRING技术内幕-笔记（十）spring声明式事物处理</title>
    <url>/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89spring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E7%89%A9%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p><strong>10.1事物处理拦截器的配置</strong><br>首先看一下建立事物处理对象的时序图：<br><img src="/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89spring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E7%89%A9%E5%A4%84%E7%90%86/20150714170841112.png" alt="这里写图片描述"></p>
<span id="more"></span>

<p>首先从TransactionProxyFactoryBean 的createMainInterceptor()方法开始：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//TransactionInterceptor 封装了AOP的事物处理的实现，通过依赖注入设置进来</span><br><span class="line">	private final TransactionInterceptor transactionInterceptor = new TransactionInterceptor();</span><br><span class="line"></span><br><span class="line">	private Pointcut pointcut;</span><br><span class="line">		public void setTransactionAttributes(Properties transactionAttributes) &#123;</span><br><span class="line">		this.transactionInterceptor.setTransactionAttributes(transactionAttributes);</span><br><span class="line">	&#125;</span><br><span class="line">//通过依赖注入的PlatformTransactionManager</span><br><span class="line">		public void setTransactionManager(PlatformTransactionManager transactionManager) &#123;</span><br><span class="line">		this.transactionInterceptor.setTransactionManager(transactionManager);</span><br><span class="line">	&#125;</span><br><span class="line">//创建SPringAOP处理的advisor</span><br><span class="line">	protected Object createMainInterceptor() &#123;</span><br><span class="line">		this.transactionInterceptor.afterPropertiesSet();</span><br><span class="line">		if (this.pointcut != null) &#123;</span><br><span class="line">		//使用默认的DefaultPointcutAdvisor作为默认的通知器，并设置拦截器</span><br><span class="line">			return new DefaultPointcutAdvisor(this.pointcut, this.transactionInterceptor);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			// Rely on default pointcut.如果没有配置pointcut 就用TransactionAttributeSourceAdvisor作为通知器，并设置transactionInterceptor为拦截器</span><br><span class="line">			return new TransactionAttributeSourceAdvisor(this.transactionInterceptor);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是createMainInterceptor()是在bean完成依赖注入的时候通过InitializingBean方法调用的。<br>TransactionProxyFactoryBean继承了AbstractSingletonProxyFactoryBean，而AbstractSingletonProxyFactoryBean实现了InitializingBean，于是就会重写InitializingBean的afterPropertiesSet()方法，这个方法实例化了一个proxyFactory，建立起 SPringAOP的应用，在这里，会为这个proxyfactory设置通知，目标对象，并最终返回proxy代理对象 。<br>AbstractSingletonProxyFactoryBean的afterPropertiesSet方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void afterPropertiesSet() &#123;</span><br><span class="line">		if (this.target == null) &#123;</span><br><span class="line">			throw new IllegalArgumentException(&quot;Property &#x27;target&#x27; is required&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		if (this.target instanceof String) &#123;</span><br><span class="line">			throw new IllegalArgumentException(&quot;&#x27;target&#x27; needs to be a bean reference, not a bean name as value&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		if (this.proxyClassLoader == null) &#123;</span><br><span class="line">			this.proxyClassLoader = ClassUtils.getDefaultClassLoader();</span><br><span class="line">		&#125;</span><br><span class="line">		//TransactionProxyFactoryBean使用ProxyFactory 完成AOP的年基本功能，ProxyFactory 提供代理对象，并将transactionInterceptor设置为target的拦截器</span><br><span class="line">		ProxyFactory proxyFactory = new ProxyFactory();</span><br><span class="line"></span><br><span class="line">		if (this.preInterceptors != null) &#123;</span><br><span class="line">			for (Object interceptor : this.preInterceptors) &#123;</span><br><span class="line">				proxyFactory.addAdvisor(this.advisorAdapterRegistry.wrap(interceptor));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Add the main interceptor (typically an Advisor).</span><br><span class="line">		spring加入通知器的地方，可以加入2种通知器，分别是DefaultPointcutAdvisor、TransactionAttributeSourceAdvisor，Proxyfactory的基类，ADvisedSupport中，维护了一个用来持有advice的linkedList，通过对这个list的增删改等操作，用来管理配置给Proxyfactory的通知器</span><br><span class="line">		proxyFactory.addAdvisor(this.advisorAdapterRegistry.wrap(createMainInterceptor()));</span><br><span class="line"></span><br><span class="line">		if (this.postInterceptors != null) &#123;</span><br><span class="line">			for (Object interceptor : this.postInterceptors) &#123;</span><br><span class="line">				proxyFactory.addAdvisor(this.advisorAdapterRegistry.wrap(interceptor));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		proxyFactory.copyFrom(this);</span><br><span class="line"> //创建AOP的目标源</span><br><span class="line">		TargetSource targetSource = createTargetSource(this.target);</span><br><span class="line">		proxyFactory.setTargetSource(targetSource);</span><br><span class="line"></span><br><span class="line">		if (this.proxyInterfaces != null) &#123;</span><br><span class="line">		//设置使用哪个接口作为代理</span><br><span class="line">			proxyFactory.setInterfaces(this.proxyInterfaces);</span><br><span class="line">		&#125;</span><br><span class="line">		else if (!isProxyTargetClass()) &#123;</span><br><span class="line">			// Rely on AOP infrastructure to tell us what interfaces to proxy.</span><br><span class="line">			proxyFactory.setInterfaces(</span><br><span class="line">					ClassUtils.getAllInterfacesForClass(targetSource.getTargetClass(), this.proxyClassLoader));</span><br><span class="line">		&#125;</span><br><span class="line">//设置代理对象</span><br><span class="line">		this.proxy = proxyFactory.getProxy(this.proxyClassLoader);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">//至于怎创建的代理对象要到proxyFactory看看：</span><br><span class="line">	public Object getProxy(ClassLoader classLoader) &#123;</span><br><span class="line">		return createAopProxy().getProxy(classLoader);</span><br><span class="line">	&#125;</span><br><span class="line">	createAopProxy（）在其基类ProxyCreatorSupport中实现</span><br><span class="line">createAopProxy():</span><br><span class="line">	protected final synchronized AopProxy createAopProxy() &#123;</span><br><span class="line">		if (!this.active) &#123;</span><br><span class="line">			activate();</span><br><span class="line">		&#125;</span><br><span class="line">		//使用 DefaultAopProxyfactory来创建AopProxy对象，proxyFactory本身是ProxyConfig的子类，所以使用this</span><br><span class="line">		return getAopProxyFactory().createAopProxy(this);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><strong>10.2事物处理配置的读入</strong><br>在AOP配置完成的基础上，从TransactionAttributeSourceAdvisor的实现为入口，了解具体的事物配置属性是如何读取的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Interceptor使用之前介绍的transactionInterceptor</span><br><span class="line">	private TransactionInterceptor transactionInterceptor;</span><br><span class="line">//对于pointcut ，使用其内部类TransactionAttributeSourcePointcut，</span><br><span class="line">	private final TransactionAttributeSourcePointcut pointcut = new TransactionAttributeSourcePointcut() &#123;</span><br><span class="line">		@Override</span><br><span class="line">		//使用transactionInterceptor得到事物配置的属性，在对proxy的方法进行调用时，会用到这些属性</span><br><span class="line">		protected TransactionAttributeSource getTransactionAttributeSource() &#123;</span><br><span class="line">			return (transactionInterceptor != null ? transactionInterceptor.getTransactionAttributeSource() : null);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<p>TransactionAttributeSourcePointcut这个切点实现了StaticMethodMatcherPointcut，有一个matches(Method method, Class targetClass)函数，在此函数中调用getTransactionAttributeSource得到配置属性，并且判断是否当前方法被拦截：<br>TransactionAttributeSourcePointcut的matches</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean matches(Method method, Class targetClass) &#123;</span><br><span class="line">//调用transactionInterceptor的getTransactionAttributeSource()，见TransactionAttributeSourcePointcut 得内部类TransactionAttributeSourcePointcut的匿名实现。</span><br><span class="line">	TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">	//判断是否是被拦截的方法</span><br><span class="line">	return (tas == null || tas.getTransactionAttribute(method, targetClass) != null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个TransactionAttributeSource是在完成依赖注入的时候配置的，在transactionInterceptor的基类TransactionAspectSupport中注入实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void setTransactionAttributes(Properties transactionAttributes) &#123;</span><br><span class="line">//实际使用的是NameMatchTransactionAttributeSource，然后将事物配置属性设置到     </span><br><span class="line">//NameMatchTransactionAttributeSource。</span><br><span class="line">	NameMatchTransactionAttributeSource tas = new NameMatchTransactionAttributeSource();</span><br><span class="line">	tas.setProperties(transactionAttributes);</span><br><span class="line">	this.transactionAttributeSource = tas;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到读取和匹配事物配置属性的是NameMatchTransactionAttributeSource ，这个类将transactionAttributes通过调用setProperties方法把调用的方法名为key，放到namemap中，在应用调用目标方法的时候，因为目标方法已经被TransactionProxyFactoryBean代理，所以TransactionProxyFactoryBean需要判断这个调用方法是否是事物方法，这个判断的实现是通过NameMatchTransactionAttributeSource 中能否为这个调用返回事物属性来完成的，具体的实现是这样的：首先，以调用方法名为索引在namemap中查找相应的事物处理属性值，如果能够找到，那么就说明该调用方法和事物方法是直接对应的，如果你找不到，就用正则表达式的方式模糊匹配。意味着，可以使用通配符的方式指定要拦截的方法。返回的属性封装在TransactionAttribute 中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> //配置事物属性的方法</span><br><span class="line">	public void setProperties(Properties transactionAttributes) &#123;</span><br><span class="line">		TransactionAttributeEditor tae = new TransactionAttributeEditor();</span><br><span class="line">		Enumeration propNames = transactionAttributes.propertyNames();</span><br><span class="line">		while (propNames.hasMoreElements()) &#123;</span><br><span class="line">			String methodName = (String) propNames.nextElement();</span><br><span class="line">			String value = transactionAttributes.getProperty(methodName);</span><br><span class="line">			tae.setAsText(value);</span><br><span class="line">			TransactionAttribute attr = (TransactionAttribute) tae.getValue();</span><br><span class="line">			addTransactionalMethod(methodName, attr);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">//将被拦截的方法的名字为key，配置的属性为value放入到nameMap中去。</span><br><span class="line">	public void addTransactionalMethod(String methodName, TransactionAttribute attr) &#123;</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Adding transactional method [&quot; + methodName + &quot;] with attribute [&quot; + attr + &quot;]&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		this.nameMap.put(methodName, attr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">//根据方法名字活模式取配置的事物属性</span><br><span class="line">	public TransactionAttribute getTransactionAttribute(Method method, Class&lt;?&gt; targetClass) &#123;</span><br><span class="line">		// look for direct name match</span><br><span class="line">		String methodName = method.getName();</span><br><span class="line">		//以名字为key</span><br><span class="line">		TransactionAttribute attr = this.nameMap.get(methodName);</span><br><span class="line"></span><br><span class="line">		if (attr == null) &#123;</span><br><span class="line">			// Look for most specific name match.</span><br><span class="line">			String bestNameMatch = null;</span><br><span class="line">			for (String mappedName : this.nameMap.keySet()) &#123;</span><br><span class="line">			//isMatch使用模糊或者通配符的方式匹配</span><br><span class="line">				if (isMatch(methodName, mappedName) &amp;&amp;</span><br><span class="line">						(bestNameMatch == null || bestNameMatch.length() &lt;= mappedName.length())) &#123;</span><br><span class="line">					attr = this.nameMap.get(mappedName);</span><br><span class="line">					bestNameMatch = mappedName;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">//返回取得的属性值</span><br><span class="line">		return attr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>10.3事物处理拦截器的设计与实现<br>TransactionProxyFactoryBean代理得到代理对象，通过调用getObject()得到，对目标方法的调用，TransactionProxyFactoryBean不会直接调用而是经过拦截器的拦截：<br>getObject方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object getObject() &#123;</span><br><span class="line">	if (this.proxy == null) &#123;</span><br><span class="line">		throw new FactoryBeanNotInitializedException();</span><br><span class="line">	&#125;</span><br><span class="line">	 //proxy已经配置好事物拦截器配置</span><br><span class="line">	return this.proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对AOP代理起到作用，是用到TransactionInterceptor的回调方法，invoke方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	public Object invoke(final MethodInvocation invocation) throws Throwable &#123;</span><br><span class="line">		// Work out the target class: may be &lt;code&gt;null&lt;/code&gt;.</span><br><span class="line">		// The TransactionAttributeSource should be passed the target class</span><br><span class="line">		// as well as the method, which may be from an interface.</span><br><span class="line">		 //目标对象</span><br><span class="line">		Class&lt;?&gt; targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);</span><br><span class="line"></span><br><span class="line">		// If the transaction attribute is null, the method is non-transactional.</span><br><span class="line">		//取得事物的配置属性，通过TransactionAttributeSource得到</span><br><span class="line">		final TransactionAttribute txAttr =</span><br><span class="line">				getTransactionAttributeSource().getTransactionAttribute(invocation.getMethod(), targetClass);</span><br><span class="line">//根据TransactionProxyFactoryBean的配置信息获取具体的事物处理器</span><br><span class="line">		final PlatformTransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line">		final String joinpointIdentification = methodIdentification(invocation.getMethod(), targetClass);</span><br><span class="line"></span><br><span class="line">// 这里获取不同的PlatformTransactionManager ，因为回调方式不同，CallbackPreferringPlatformTransactionManager的需要回调函数实现事物的回调与提交，而非CallbackPreferringPlatformTransactionManager不需要，DatasourceTransactionManager就不是CallbackPreferringPlatformTransactionManager</span><br><span class="line">		if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">			// Standard transaction demarcation with getTransaction and commit/rollback calls.</span><br><span class="line">			 //创建事物，并且把创建过程得到的信息放到TransactionInfo 中去，TransactionInfo 是封装事物状态的类</span><br><span class="line">			TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">			Object retVal = null;</span><br><span class="line">			try &#123;</span><br><span class="line">				// This is an around advice: Invoke the next interceptor in the chain.</span><br><span class="line">				// This will normally result in a target object being invoked.</span><br><span class="line">				//继续走拦截器链，知道目标方法被调用。</span><br><span class="line">				retVal = invocation.proceed();</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Throwable ex) &#123;</span><br><span class="line">				// target invocation exception</span><br><span class="line">				//如果调用过程出现异常需要根据具体情况判断是提交或者回滚。</span><br><span class="line">				completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">				throw ex;</span><br><span class="line">			&#125;</span><br><span class="line">			finally &#123;</span><br><span class="line">			 //把线程绑定的TransactionInfo 置为oldTransactionInfo</span><br><span class="line">				cleanupTransactionInfo(txInfo);</span><br><span class="line">			&#125;</span><br><span class="line">			 //使用事物处理器对事物进行提交</span><br><span class="line">			commitTransactionAfterReturning(txInfo);</span><br><span class="line">			return retVal;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		else &#123;</span><br><span class="line">			// It&#x27;s a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.</span><br><span class="line">			//使用回调的方式</span><br><span class="line">			try &#123;</span><br><span class="line">				Object result = ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr,</span><br><span class="line">						new TransactionCallback&lt;Object&gt;() &#123;</span><br><span class="line">							public Object doInTransaction(TransactionStatus status) &#123;</span><br><span class="line">								TransactionInfo txInfo = prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">								try &#123;</span><br><span class="line">									return invocation.proceed();</span><br><span class="line">								&#125;</span><br><span class="line">								catch (Throwable ex) &#123;</span><br><span class="line">									if (txAttr.rollbackOn(ex)) &#123;</span><br><span class="line">										// A RuntimeException: will lead to a rollback.</span><br><span class="line">										//导致事物回滚</span><br><span class="line">										if (ex instanceof RuntimeException) &#123;</span><br><span class="line">											throw (RuntimeException) ex;</span><br><span class="line">										&#125;</span><br><span class="line">										else &#123;</span><br><span class="line">											throw new ThrowableHolderException(ex);</span><br><span class="line">										&#125;</span><br><span class="line">									&#125;</span><br><span class="line">									else &#123;</span><br><span class="line">										// A normal return value: will lead to a commit.</span><br><span class="line">										//正常的处理，进行事物提交</span><br><span class="line">										return new ThrowableHolder(ex);</span><br><span class="line">									&#125;</span><br><span class="line">								&#125;</span><br><span class="line">								finally &#123;</span><br><span class="line">									cleanupTransactionInfo(txInfo);</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;);</span><br><span class="line"></span><br><span class="line">				// Check result: It might indicate a Throwable to rethrow.</span><br><span class="line">				if (result instanceof ThrowableHolder) &#123;</span><br><span class="line">					throw ((ThrowableHolder) result).getThrowable();</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					return result;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			catch (ThrowableHolderException ex) &#123;</span><br><span class="line">				throw ex.getCause();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>事物提交时序图：<br><img src="/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95-%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89spring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E7%89%A9%E5%A4%84%E7%90%86/20150715155836118.png" alt="这里写图片描述"><br>invoke方法是AOP和spring事物处理的桥梁，接下来就是事物处理的实现。</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title> SPRING技术内幕：深入解析SPRING架构与设计原理(第2版)-笔记（三）AOP概念</title>
    <url>/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90SPRING%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86-%E7%AC%AC2%E7%89%88-%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89AOP%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>advice：<br><img src="/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90SPRING%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86-%E7%AC%AC2%E7%89%88-%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89AOP%E6%A6%82%E5%BF%B5/20150519214932869.png" alt="这里写图片描述"></p>
<span id="more"></span>
<p><img src="/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90SPRING%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86-%E7%AC%AC2%E7%89%88-%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89AOP%E6%A6%82%E5%BF%B5/20150519215014802.png" alt="这里写图片描述"></p>
<p><img src="/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90SPRING%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86-%E7%AC%AC2%E7%89%88-%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89AOP%E6%A6%82%E5%BF%B5/20150519215006717.png" alt="这里写图片描述"><br>【pointcut】—判定哪些切面需要增强：<br><img src="/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90SPRING%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86-%E7%AC%AC2%E7%89%88-%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89AOP%E6%A6%82%E5%BF%B5/20150519215116765.png" alt="这里写图片描述"><br>【advisor】定义那个通知在那个关注点使用它：<br><img src="/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90SPRING%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86-%E7%AC%AC2%E7%89%88-%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89AOP%E6%A6%82%E5%BF%B5/20150519215148620.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SPRING技术内幕：深入解析SPRING架构与设计原理(第2版)-笔记（一）IOC解析</title>
    <url>/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90SPRING%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86-%E7%AC%AC2%E7%89%88-%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89IOC%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>开始之前先说一下Beanfactory的结构原理：</p>
<p><img src="/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90SPRING%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86-%E7%AC%AC2%E7%89%88-%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89IOC%E8%A7%A3%E6%9E%90/20150610213912663.png" alt="这里写图片描述"></p>
<span id="more"></span>

<p>下图是springIOC解析的整个过程：<br><img src="/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90SPRING%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86-%E7%AC%AC2%E7%89%88-%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89IOC%E8%A7%A3%E6%9E%90/20150518222648397" alt="这里写图片描述"><img src="/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90SPRING%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86-%E7%AC%AC2%E7%89%88-%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89IOC%E8%A7%A3%E6%9E%90/20150518222843084.png" alt="这里写图片描述"><img src="/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90SPRING%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86-%E7%AC%AC2%E7%89%88-%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89IOC%E8%A7%A3%E6%9E%90/20150518223322309.png" alt="这里写图片描述"></p>
<p>IOC容器分为3个步骤：<br>1、定位<br>(1)Resource resource &#x3D; resourceLoader.getResource(location);<br>int loadCount &#x3D; loadBeanDefinitions(resource);<br>(2)loadBeanDefinitions委派为子类XmlBeanDefinitionReader的重写方法<br>(3)定位：在方法loadBeanDefinitions(String location, Set<Resource> actualResources)中语句：<br>Resource resource &#x3D; resourceLoader.getResource(location)，resourceLoader调用其实现类DefaultResourceLoader的getResource(String location)方法的getResourceByPath(location)定位加载资源，getResourceByPath(location)在FileSystemXmlApplicationContext已经重写，即，调用的FileSystemXmlApplicationContext的实现方法。这也解释了FileSystemXmlApplicationContext有一个getResourceByPath方法的原因（委派机制）。<br>2、载入<br>主要实现类：<br>BeanDefinitionParserDelegate.parseBeanDefinitionElement(<br>            Element ele, String beanName, BeanDefinition containingBean):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">	 * Parse the bean definition itself, without regard to name or aliases. May return</span><br><span class="line">	 * &lt;code&gt;null&lt;/code&gt; if problems occured during the parse of the bean definition.</span><br><span class="line">	 */</span><br><span class="line">	public AbstractBeanDefinition parseBeanDefinitionElement(</span><br><span class="line">			Element ele, String beanName, BeanDefinition containingBean) &#123;</span><br><span class="line"></span><br><span class="line">		this.parseState.push(new BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">		String className = null;</span><br><span class="line">		if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">			className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			String parent = null;</span><br><span class="line">			if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">				parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">			&#125;</span><br><span class="line">			AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">			parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">			bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">			parseMetaElements(ele, bd);</span><br><span class="line">			parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">			parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"></span><br><span class="line">			parseConstructorArgElements(ele, bd);</span><br><span class="line">			parsePropertyElements(ele, bd);</span><br><span class="line">			parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">			bd.setResource(this.readerContext.getResource());</span><br><span class="line">			bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">			return bd;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (ClassNotFoundException ex) &#123;</span><br><span class="line">			error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (NoClassDefFoundError err) &#123;</span><br><span class="line">			error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			this.parseState.pop();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>3、注册<br>主要实现类：<br>DefaultListableBeanFactory.registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//---------------------------------------------------------------------</span><br><span class="line">	// Implementation of BeanDefinitionRegistry interface</span><br><span class="line">	//---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">	public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</span><br><span class="line">			throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">		Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);</span><br><span class="line">		Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);</span><br><span class="line"></span><br><span class="line">		if (beanDefinition instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">			&#125;</span><br><span class="line">			catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">				throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">						&quot;Validation of bean definition failed&quot;, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		synchronized (this.beanDefinitionMap) &#123;</span><br><span class="line">			Object oldBeanDefinition = this.beanDefinitionMap.get(beanName);</span><br><span class="line">			if (oldBeanDefinition != null) &#123;</span><br><span class="line">				if (!this.allowBeanDefinitionOverriding) &#123;</span><br><span class="line">					throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">							&quot;Cannot register bean definition [&quot; + beanDefinition + &quot;] for bean &#x27;&quot; + beanName +</span><br><span class="line">							&quot;&#x27;: There is already [&quot; + oldBeanDefinition + &quot;] bound.&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					if (this.logger.isInfoEnabled()) &#123;</span><br><span class="line">						this.logger.info(&quot;Overriding bean definition for bean &#x27;&quot; + beanName +</span><br><span class="line">								&quot;&#x27;: replacing [&quot; + oldBeanDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				this.beanDefinitionNames.add(beanName);</span><br><span class="line">				this.frozenBeanDefinitionNames = null;</span><br><span class="line">			&#125;</span><br><span class="line">			this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line"></span><br><span class="line">			resetBeanDefinition(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SPRING技术内幕：深入解析SPRING架构与设计原理(第2版)-笔记（二）IOC注入</title>
    <url>/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90SPRING%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86-%E7%AC%AC2%E7%89%88-%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89IOC%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<p>IOC注入过程：<br><img src="/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90SPRING%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86-%E7%AC%AC2%E7%89%88-%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89IOC%E6%B3%A8%E5%85%A5/20150519213644221.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title> SPRING技术内幕：深入解析SPRING架构与设计原理(第2版)-笔记（五）(3)AOPProxy的生成过程</title>
    <url>/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90SPRING%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86-%E7%AC%AC2%E7%89%88-%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89-3-AOPProxy%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>AOPProxy的生成过程：<br><img src="/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90SPRING%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86-%E7%AC%AC2%E7%89%88-%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89-3-AOPProxy%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B/20150519215814452.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SPRING技术内幕：深入解析SPRING架构与设计原理(第2版)-笔记（六）AOP拦截器调用的实现</title>
    <url>/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90SPRING%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86-%E7%AC%AC2%E7%89%88-%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89AOP%E6%8B%A6%E6%88%AA%E5%99%A8%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p><strong>JdkDynamicAopProxy</strong><br>JdkDynamicAopProxy代理对象的回调：<br>JdkDynamicAopProxy通过ReflectiveMethodInvocation完成拦截器链的调用，</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">	 * Implementation of &lt;code&gt;InvocationHandler.invoke&lt;/code&gt;.</span><br><span class="line">	 * &lt;p&gt;Callers will see exactly the exception thrown by the target,</span><br><span class="line">	 * unless a hook method throws an exception.</span><br><span class="line">	 */</span><br><span class="line">	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">		MethodInvocation invocation;</span><br><span class="line">		Object oldProxy = null;</span><br><span class="line">		boolean setProxyContext = false;</span><br><span class="line">		TargetSource targetSource = this.advised.targetSource;</span><br><span class="line"></span><br><span class="line">		Class targetClass = null;</span><br><span class="line">		Object target = null;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">				// The target does not implement the equals(Object) method itself.</span><br><span class="line">				return equals(args[0]);</span><br><span class="line">			&#125;</span><br><span class="line">			if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">				// The target does not implement the hashCode() method itself.</span><br><span class="line">				return hashCode();</span><br><span class="line">			&#125;</span><br><span class="line">			if (!this.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">					method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">				// Service invocations on ProxyConfig with the proxy config...没有拦截器直接调用目标对象的方法</span><br><span class="line">				return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Object retVal;</span><br><span class="line"></span><br><span class="line">			if (this.advised.exposeProxy) &#123;</span><br><span class="line">				// Make invocation available if necessary.</span><br><span class="line">				oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">				setProxyContext = true;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// May be null. Get as late as possible to minimize the time we &quot;own&quot; the target,</span><br><span class="line">			// in case it comes from a pool.</span><br><span class="line">			/*targetSource.getTarget()可以从一个对象池或者对象工厂获得，target可以配置成热部署，可以随时切换目标对   </span><br><span class="line">			*象，配置的时候可以将HotSwappableTargetSource作为ProxyFactoryBean的target属性即可。</span><br><span class="line">		    */</span><br><span class="line">			target = targetSource.getTarget();</span><br><span class="line">			if (target != null) &#123;</span><br><span class="line">				targetClass = target.getClass();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Get the interception chain for this method.</span><br><span class="line">			List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">			// Check whether we have any advice. If we don&#x27;t, we can fallback on direct</span><br><span class="line">			// reflective invocation of the target, and avoid creating a MethodInvocation.</span><br><span class="line">			if (chain.isEmpty()) &#123;</span><br><span class="line">				// We can skip creating a MethodInvocation: just invoke the target directly</span><br><span class="line">				// Note that the final invoker must be an InvokerInterceptor so we know it does</span><br><span class="line">				// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span><br><span class="line">				retVal = AopUtils.invokeJoinpointUsingReflection(target, method, args);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				// We need to create a method invocation...</span><br><span class="line">				invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">				// Proceed to the joinpoint through the interceptor chain.</span><br><span class="line">				retVal = invocation.proceed();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Massage return value if necessary.</span><br><span class="line">			if (retVal != null &amp;&amp; retVal == target &amp;&amp; method.getReturnType().isInstance(proxy) &amp;&amp;</span><br><span class="line">					!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">				// Special case: it returned &quot;this&quot; and the return type of the method</span><br><span class="line">				// is type-compatible. Note that we can&#x27;t help if the target sets</span><br><span class="line">				// a reference to itself in another returned object.</span><br><span class="line">				retVal = proxy;</span><br><span class="line">			&#125;</span><br><span class="line">			return retVal;</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			if (target != null &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">				// Must have come from TargetSource.</span><br><span class="line">				targetSource.releaseTarget(target);</span><br><span class="line">			&#125;</span><br><span class="line">			if (setProxyContext) &#123;</span><br><span class="line">				// Restore old proxy.</span><br><span class="line">				AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Cglib2AopProxy</strong><br>Cglib2AopProxy的intercept的回调：<br>其使用内部类DynamicAdvisedInterceptor 的intercept方法回调实现，使用CglibMethodInvocation完成拦截器链的调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * General purpose AOP callback. Used when the target is dynamic or when the</span><br><span class="line"> * proxy is not frozen.</span><br><span class="line"> */</span><br><span class="line">private static class DynamicAdvisedInterceptor implements MethodInterceptor, Serializable &#123;</span><br><span class="line"></span><br><span class="line">	private AdvisedSupport advised;</span><br><span class="line"></span><br><span class="line">	public DynamicAdvisedInterceptor(AdvisedSupport advised) &#123;</span><br><span class="line">		this.advised = advised;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">		Object oldProxy = null;</span><br><span class="line">		boolean setProxyContext = false;</span><br><span class="line">		Class targetClass = null;</span><br><span class="line">		Object target = null;</span><br><span class="line">		try &#123;</span><br><span class="line">			if (this.advised.exposeProxy) &#123;</span><br><span class="line">				// Make invocation available if necessary.</span><br><span class="line">				oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">				setProxyContext = true;</span><br><span class="line">			&#125;</span><br><span class="line">			// May be &lt;code&gt;null&lt;/code&gt;. Get as late as possible to minimize the time we</span><br><span class="line">			// &quot;own&quot; the target, in case it comes from a pool.</span><br><span class="line">			target = getTarget();</span><br><span class="line">			if (target != null) &#123;</span><br><span class="line">				targetClass = target.getClass();</span><br><span class="line">			&#125;</span><br><span class="line">			List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">			Object retVal;</span><br><span class="line">			// Check whether we only have one InvokerInterceptor: that is,</span><br><span class="line">			// no real advice, but just reflective invocation of the target.</span><br><span class="line">			if (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">				// We can skip creating a MethodInvocation: just invoke the target directly.</span><br><span class="line">				// Note that the final invoker must be an InvokerInterceptor, so we know</span><br><span class="line">				// it does nothing but a reflective operation on the target, and no hot</span><br><span class="line">				// swapping or fancy proxying.没有AOP通知配置，直接调用target对象的方法</span><br><span class="line">				retVal = methodProxy.invoke(target, args);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				// We need to create a method invocation...</span><br><span class="line">				retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br><span class="line">			&#125;</span><br><span class="line">			retVal = massageReturnTypeIfNecessary(proxy, target, method, retVal);</span><br><span class="line">			return retVal;</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			if (target != null) &#123;</span><br><span class="line">				releaseTarget(target);</span><br><span class="line">			&#125;</span><br><span class="line">			if (setProxyContext) &#123;</span><br><span class="line">				// Restore old proxy.</span><br><span class="line">				AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public boolean equals(Object other) &#123;</span><br><span class="line">		return (this == other ||</span><br><span class="line">				(other instanceof DynamicAdvisedInterceptor &amp;&amp;</span><br><span class="line">						this.advised.equals(((DynamicAdvisedInterceptor) other).advised)));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * CGLIB uses this to drive proxy creation.</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public int hashCode() &#123;</span><br><span class="line">		return this.advised.hashCode();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	protected Object getTarget() throws Exception &#123;</span><br><span class="line">		return this.advised.getTargetSource().getTarget();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	protected void releaseTarget(Object target) throws Exception &#123;</span><br><span class="line">		this.advised.getTargetSource().releaseTarget(target);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>目标对象方法的调用</strong><br>JdkDynamicAopProxy目标对象方法的调用是通过AopUtils的invokeJoinpointUsingReflection方法实现的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	/**</span><br><span class="line">	 * Invoke the given target via reflection, as part of an AOP method invocation.</span><br><span class="line">	 * @param target the target object</span><br><span class="line">	 * @param method the method to invoke</span><br><span class="line">	 * @param args the arguments for the method</span><br><span class="line">	 * @return the invocation result, if any</span><br><span class="line">	 * @throws Throwable if thrown by the target method</span><br><span class="line">	 * @throws org.springframework.aop.AopInvocationException in case of a reflection error</span><br><span class="line">	 */</span><br><span class="line">	public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args)</span><br><span class="line">			throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">		// Use reflection to invoke the method.</span><br><span class="line">		try &#123;</span><br><span class="line">			ReflectionUtils.makeAccessible(method);</span><br><span class="line">			return method.invoke(target, args);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (InvocationTargetException ex) &#123;</span><br><span class="line">			// Invoked method threw a checked exception.</span><br><span class="line">			// We must rethrow it. The client won&#x27;t see the interceptor.</span><br><span class="line">			throw ex.getTargetException();</span><br><span class="line">		&#125;</span><br><span class="line">		catch (IllegalArgumentException ex) &#123;</span><br><span class="line">			throw new AopInvocationException(&quot;AOP configuration seems to be invalid: tried calling method [&quot; +</span><br><span class="line">					method + &quot;] on target [&quot; + target + &quot;]&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (IllegalAccessException ex) &#123;</span><br><span class="line">			throw new AopInvocationException(&quot;Could not access method [&quot; + method + &quot;]&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>拦截器链的调用</strong></p>
<p>不论是JdkDynamicAopProxy还是Cglib2AopProxy归根到底是通过ReflectiveMethodInvocation的proceed方法调用拦截器链的，<br><img src="/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90SPRING%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86-%E7%AC%AC2%E7%89%88-%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89AOP%E6%8B%A6%E6%88%AA%E5%99%A8%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/20150521220420283.png" alt="这里写图片描述"><br>advised（class：AdvisedSupport  ）持有拦截器链，getInterceptorsAndDynamicInterceptionAdvice方法的实现在其基类AdvisedSupport中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Determine a list of &#123;@link org.aopalliance.intercept.MethodInterceptor&#125; objects</span><br><span class="line"> * for the given method, based on this configuration.</span><br><span class="line"> * @param method the proxied method</span><br><span class="line"> * @param targetClass the target class</span><br><span class="line"> * @return List of MethodInterceptors (may also include InterceptorAndDynamicMethodMatchers)</span><br><span class="line"> */</span><br><span class="line">public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(Method method, Class targetClass) &#123;</span><br><span class="line">	MethodCacheKey cacheKey = new MethodCacheKey(method);</span><br><span class="line">	List&lt;Object&gt; cached = this.methodCache.get(cacheKey);</span><br><span class="line">	if (cached == null) &#123;</span><br><span class="line">		cached = this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(</span><br><span class="line">				this, method, targetClass);</span><br><span class="line">		this.methodCache.put(cacheKey, cached);</span><br><span class="line">	&#125;</span><br><span class="line">	return cached;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工厂advisorChainFactory（impl:DefaultAdvisorChainFactory）完成拦截器链的获取过程，其中的AdvisorAdapterRegistry是完成ProxyFactoryBean从XML文件张得到的拦截器的注册工作，主要是放到之前设置好的List集合里边。list中的拦截器被JdkDynamicAopProxy的invoke或者Cglib2AopProxy的intercep对象使用得到拦截器。<br>DefaultAdvisorChainFactory的getInterceptorsAndDynamicInterceptionAdvice方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(</span><br><span class="line">		Advised config, Method method, Class targetClass) &#123;</span><br><span class="line"></span><br><span class="line">	// This is somewhat tricky... we have to process introductions first,</span><br><span class="line">	// but we need to preserve order in the ultimate list.</span><br><span class="line">	List&lt;Object&gt; interceptorList = new ArrayList&lt;Object&gt;(config.getAdvisors().length);</span><br><span class="line">	boolean hasIntroductions = hasMatchingIntroductions(config, targetClass);</span><br><span class="line">	AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();</span><br><span class="line">	for (Advisor advisor : config.getAdvisors()) &#123;</span><br><span class="line">		if (advisor instanceof PointcutAdvisor) &#123;</span><br><span class="line">			// Add it conditionally.</span><br><span class="line">			PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;</span><br><span class="line">			if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">				MethodInterceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">				MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();</span><br><span class="line">				if (MethodMatchers.matches(mm, method, targetClass, hasIntroductions)) &#123;</span><br><span class="line">					if (mm.isRuntime()) &#123;</span><br><span class="line">						// Creating a new object instance in the getInterceptors() method</span><br><span class="line">						// isn&#x27;t a problem as we normally cache created chains.</span><br><span class="line">						for (MethodInterceptor interceptor : interceptors) &#123;</span><br><span class="line">							interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm));</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					else &#123;</span><br><span class="line">						interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (advisor instanceof IntroductionAdvisor) &#123;</span><br><span class="line">			IntroductionAdvisor ia = (IntroductionAdvisor) advisor;</span><br><span class="line">			if (config.isPreFiltered() || ia.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">				Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">				interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">			interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return interceptorList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上advisor通知其是在adviosrSupport得到并初始化的，再其子类ProxyFactoryBean中的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">	 * Create the advisor (interceptor) chain. Aadvisors that are sourced</span><br><span class="line">	 * from a BeanFactory will be refreshed each time a new prototype instance</span><br><span class="line">	 * is added. Interceptors added programmatically through the factory API</span><br><span class="line">	 * are unaffected by such changes.</span><br><span class="line">	 */</span><br><span class="line">	private synchronized void initializeAdvisorChain() throws AopConfigException, BeansException &#123;</span><br><span class="line">		if (this.advisorChainInitialized) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!ObjectUtils.isEmpty(this.interceptorNames)) &#123;</span><br><span class="line">			if (this.beanFactory == null) &#123;</span><br><span class="line">				throw new IllegalStateException(&quot;No BeanFactory available anymore (probably due to serialization) &quot; +</span><br><span class="line">						&quot;- cannot resolve interceptor names &quot; + Arrays.asList(this.interceptorNames));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Globals can&#x27;t be last unless we specified a targetSource using the property...</span><br><span class="line">			if (this.interceptorNames[this.interceptorNames.length - 1].endsWith(GLOBAL_SUFFIX) &amp;&amp;</span><br><span class="line">					this.targetName == null &amp;&amp; this.targetSource == EMPTY_TARGET_SOURCE) &#123;</span><br><span class="line">				throw new AopConfigException(&quot;Target required after globals&quot;);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Materialize interceptor chain from bean names.</span><br><span class="line">			for (String name : this.interceptorNames) &#123;</span><br><span class="line">				if (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(&quot;Configuring advisor or advice &#x27;&quot; + name + &quot;&#x27;&quot;);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				if (name.endsWith(GLOBAL_SUFFIX)) &#123;</span><br><span class="line">					if (!(this.beanFactory instanceof ListableBeanFactory)) &#123;</span><br><span class="line">						throw new AopConfigException(</span><br><span class="line">								&quot;Can only use global advisors or interceptors with a ListableBeanFactory&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">					addGlobalAdvisor((ListableBeanFactory) this.beanFactory,</span><br><span class="line">							name.substring(0, name.length() - GLOBAL_SUFFIX.length()));</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				else &#123;</span><br><span class="line">					// If we get here, we need to add a named interceptor.</span><br><span class="line">					// We must check if it&#x27;s a singleton or prototype.</span><br><span class="line">					Object advice;</span><br><span class="line">					if (this.singleton || this.beanFactory.isSingleton(name)) &#123;</span><br><span class="line">						// Add the real Advisor/Advice to the chain.</span><br><span class="line">						advice = this.beanFactory.getBean(name);</span><br><span class="line">					&#125;</span><br><span class="line">					else &#123;</span><br><span class="line">						// It&#x27;s a prototype Advice or Advisor: replace with a prototype.</span><br><span class="line">						// Avoid unnecessary creation of prototype bean just for advisor chain initialization.</span><br><span class="line">						advice = new PrototypePlaceholderAdvisor(name);</span><br><span class="line">					&#125;</span><br><span class="line">					addAdvisorOnChainCreation(advice, name);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		this.advisorChainInitialized = true;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>已配置在XML中的advisor是通过IOC容器（DefaultListableBeanFactory）的getbean得到的。</p>
<p><strong>advice通知的实现</strong><br>上边DefaultAdvisorChainFactory的getInterceptorsAndDynamicInterceptionAdvice得到拦截器链的时候，使用了一个注册器（AdvisorAdapterRegistry registry &#x3D; GlobalAdvisorAdapterRegistry.getInstance();），这个registry包含了很多AOP的主要核心实现，这是个单件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Singleton to publish a shared DefaultAdvisorAdapterRegistry instance.</span><br><span class="line"> *</span><br><span class="line"> * @author Rod Johnson</span><br><span class="line"> * @author Juergen Hoeller</span><br><span class="line"> * @see DefaultAdvisorAdapterRegistry</span><br><span class="line"> */</span><br><span class="line">public abstract class GlobalAdvisorAdapterRegistry &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Keep track of a single instance so we can return it to classes that request it.</span><br><span class="line">	 */</span><br><span class="line">	private static final AdvisorAdapterRegistry instance = new DefaultAdvisorAdapterRegistry();</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Return the singleton DefaultAdvisorAdapterRegistry instance.</span><br><span class="line">	 */</span><br><span class="line">	public static AdvisorAdapterRegistry getInstance() &#123;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DefaultAdvisorAdapterRegistry中设置了一个adapters成员变量，放的是一系列AdvisorAdapter适配器，spring的advice对应的是一个适配器，这些是适配器的作用是：一是调用adapter的support方法，通过这个方法来判断取得的advice属于什么类型的advice通知，从而根据不同的advice类型来注册不同的adviceinterceptor，也就是前面看到的哪些拦截器；第二，这些adviceinterceptor都是springAOP框架设计好的，是为了实现不同的advice功能提供服务，有了这些adviceinterceptor，就可以方便使用由spring提供的各种不同advice来设计AOP应用，也就是说，正是这些adviceinterceptor最终实现了advice通知在AOPProxy代理对象中的织入功能。<br>advisorAdaptor接口中类的设计层次与关系：<br><img src="/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90SPRING%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86-%E7%AC%AC2%E7%89%88-%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89AOP%E6%8B%A6%E6%88%AA%E5%99%A8%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/20150524144221973.png" alt="这里写图片描述"><br>DefaultAdvisorAdapterRegistry代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultAdvisorAdapterRegistry implements AdvisorAdapterRegistry, Serializable &#123;</span><br><span class="line"></span><br><span class="line">	private final List&lt;AdvisorAdapter&gt; adapters = new ArrayList&lt;AdvisorAdapter&gt;(3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Create a new DefaultAdvisorAdapterRegistry, registering well-known adapters.</span><br><span class="line">	 */</span><br><span class="line">	public DefaultAdvisorAdapterRegistry() &#123;</span><br><span class="line">		registerAdvisorAdapter(new MethodBeforeAdviceAdapter());</span><br><span class="line">		registerAdvisorAdapter(new AfterReturningAdviceAdapter());</span><br><span class="line">		registerAdvisorAdapter(new ThrowsAdviceAdapter());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	public Advisor wrap(Object adviceObject) throws UnknownAdviceTypeException &#123;</span><br><span class="line">		if (adviceObject instanceof Advisor) &#123;</span><br><span class="line">			return (Advisor) adviceObject;</span><br><span class="line">		&#125;</span><br><span class="line">		if (!(adviceObject instanceof Advice)) &#123;</span><br><span class="line">			throw new UnknownAdviceTypeException(adviceObject);</span><br><span class="line">		&#125;</span><br><span class="line">		Advice advice = (Advice) adviceObject;</span><br><span class="line">		if (advice instanceof MethodInterceptor) &#123;</span><br><span class="line">			// So well-known it doesn&#x27;t even need an adapter.</span><br><span class="line">			return new DefaultPointcutAdvisor(advice);</span><br><span class="line">		&#125;</span><br><span class="line">		for (AdvisorAdapter adapter : this.adapters) &#123;</span><br><span class="line">			// Check that it is supported.</span><br><span class="line">			if (adapter.supportsAdvice(advice)) &#123;</span><br><span class="line">				return new DefaultPointcutAdvisor(advice);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		throw new UnknownAdviceTypeException(advice);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException &#123;</span><br><span class="line">		List&lt;MethodInterceptor&gt; interceptors = new ArrayList&lt;MethodInterceptor&gt;(3);</span><br><span class="line">		Advice advice = advisor.getAdvice();</span><br><span class="line">		if (advice instanceof MethodInterceptor) &#123;</span><br><span class="line">			interceptors.add((MethodInterceptor) advice);</span><br><span class="line">		&#125;</span><br><span class="line">		for (AdvisorAdapter adapter : this.adapters) &#123;</span><br><span class="line">			if (adapter.supportsAdvice(advice)) &#123;</span><br><span class="line">			//调用adapter的support方法，通过这个方法来判断取得的advice属于什么类型的advice通知，从而根据不同的advice</span><br><span class="line">			//类型来注册不同的adviceinterceptor</span><br><span class="line">				interceptors.add(adapter.getInterceptor(advisor));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (interceptors.isEmpty()) &#123;</span><br><span class="line">			throw new UnknownAdviceTypeException(advisor.getAdvice());</span><br><span class="line">		&#125;</span><br><span class="line">		return interceptors.toArray(new MethodInterceptor[interceptors.size()]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void registerAdvisorAdapter(AdvisorAdapter adapter) &#123;</span><br><span class="line">		this.adapters.add(adapter);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>拿MethodBeforeAdviceAdapter来举例，其源代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable &#123;</span><br><span class="line"></span><br><span class="line">	public boolean supportsAdvice(Advice advice) &#123;</span><br><span class="line">		return (advice instanceof MethodBeforeAdvice);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public MethodInterceptor getInterceptor(Advisor advisor) &#123;</span><br><span class="line">		MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();</span><br><span class="line">		return new MethodBeforeAdviceInterceptor(advice);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码可以看到supportsAdvice方法是判断是不是Advice 是不是MethodBeforeAdvice类型的，如果是就会在上边的DefaultAdvisorAdapterRegistry 的getInterceptors方法调用其getInterceptor方法返回一个MethodBeforeAdviceInterceptor，这个就是拦截器链里边放的interceptor，<br>其代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MethodBeforeAdviceInterceptor implements MethodInterceptor, Serializable &#123;</span><br><span class="line"></span><br><span class="line">	private MethodBeforeAdvice advice;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Create a new MethodBeforeAdviceInterceptor for the given advice.</span><br><span class="line">	 * @param advice the MethodBeforeAdvice to wrap</span><br><span class="line">	 */</span><br><span class="line">	public MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) &#123;</span><br><span class="line">		Assert.notNull(advice, &quot;Advice must not be null&quot;);</span><br><span class="line">		this.advice = advice;</span><br><span class="line">	&#125;</span><br><span class="line">//这个invoke方法是把拦截器的回调方法，会在代理对象的方法被调用时触发回调</span><br><span class="line">	public Object invoke(MethodInvocation mi) throws Throwable &#123;</span><br><span class="line">		this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );</span><br><span class="line">		return mi.proceed();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MethodBeforeAdviceInterceptor 封装了advice，可以在methodbeforeadviceinterceptor设计的invoke回调方法中，看到首先触发了advice的before回调，然后才是methodInvocation的process方法调用，看到这里，就已经和前面在reflectmethodInvocation的process分析中联系起来了，回忆一下，在AOpProxy代理对象触发ReflectiveMethodInvocation的process方法中，在取得拦截器以后，启动对拦截器invoke方法的调用，按照AOP的配置规则，reflectiveMethodInvocation触发的拦截器invoke方法，最会以根据不同的advice类型，触发spring对不同advice的拦截器封装，比如对MethodBeforAdvice。最终会触发MethodBeforAdviceInterceptor方法。在MethodBeforAdviceInterceptor方法中，会先调用advice的before方法，这就是MethodBeforAdvice所需要的对象的增强效果，在方法之前完成通知增强。AfterReturningAdviceAdapter、ThrowsAdviceAdapter按照同样的原理进行。</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SPRING技术内幕：深入解析SPRING架构与设计原理(第2版)-笔记（四）AOP设计与实现</title>
    <url>/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90SPRING%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86-%E7%AC%AC2%E7%89%88-%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89AOP%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>proxyConfig是一个数据基类，这个数据基类为proxyFactoryBean这样的子类提供配置属性，在另一个基类advisesupport的实现中，封装了AOP对通知和通知其的相关操作，这些操作对于不同AOP的代理对象的生成都是一样的，但对于具体的AOP代理对象的创建，advisedSupport把它交给他的子类们去完成，对于proxyCreatorsupport,可以将它看成是其子类创建AOP代理对象的一个辅助类。aspectJProxyBean起到集成Spring和AspectJ的作用；对于使用SpringAOP的应用，ProxyFactoryBean和ProxyFactory都提供了AOP功能的封装，只是使用ProxyFactory,可以在IOC容器中完成声明式配置，而使用ProxyFactory，则需要编程式的使用spring AOP<br><img src="/2018/09/28/SPRING%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95%EF%BC%9A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90SPRING%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86-%E7%AC%AC2%E7%89%88-%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89AOP%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/20150519215523554.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal可能引起的内存泄露</title>
    <url>/2018/10/04/ThreadLocal%E5%8F%AF%E8%83%BD%E5%BC%95%E8%B5%B7%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/</url>
    <content><![CDATA[<p>Threadlocal里面使用了一个存在弱引用的map,当释放掉threadlocal的强引用以后,map里面的value却没有被回收.而这块value永远不会被访问到了。 所以存在着内存泄露. 最好的做法是将调用threadlocal的remove方法。<br>　 在threadlocal的生命周期中,都存在这些引用. 看下图: 实线代表强引用,虚线代表弱引用：</p>
<span id="more"></span>
<p>　　<br><img src="/2018/10/04/ThreadLocal%E5%8F%AF%E8%83%BD%E5%BC%95%E8%B5%B7%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/20160820211419288.png" alt="这里写图片描述"><br>　　<br>每个thread中都存在一个map, map的类型是ThreadLocal.ThreadLocalMap. Map中的key为一个threadlocal实例. 这个Map的确使用了弱引用,不过弱引用只是针对key. 每个key都弱引用指向threadlocal. 当把threadlocal实例置为null以后,没有任何强引用指向threadlocal实例,所以threadlocal将会被gc回收. 但是,我们的value却不能回收,因为存在一条从current thread连接过来的强引用. 只有当前thread结束以后, current thread就不会存在栈中,强引用断开, Current Thread, Map, value将全部被GC回收.</p>
<p>　　<br>所以得出一个结论就是只要这个线程对象被gc回收，就不会出现内存泄露，但在threadLocal设为null和线程结束这段时间不会被回收的，就发生了我们认为的内存泄露。其实这是一个对概念理解的不一致，也没什么好争论的。最要命的是线程对象不被回收的情况，这就发生了真正意义上的内存泄露。比如使用线程池的时候，线程结束是不会销毁的，会再次使用的。就可能出现内存泄露。　　</p>
<p>　　<br>PS.Java为了最小化减少内存泄露的可能性和影响，在ThreadLocal的get,set的时候都会清除线程Map里所有key为null的value。所以最怕的情况就是，threadLocal对象设null了，开始发生“内存泄露”，然后使用线程池，这个线程结束，线程放回线程池中不销毁，这个线程一直不被使用，或者分配使用了又不再调用get,set方法，那么这个期间就会发生真正的内存泄露。</p>
]]></content>
      <categories>
        <category>Thread</category>
      </categories>
      <tags>
        <tag>ThreadLocal Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>git(一)-git入门，版本库初始化以及常用命令操作</title>
    <url>/2018/10/04/git-%E4%B8%80-git%E5%85%A5%E9%97%A8%EF%BC%8C%E7%89%88%E6%9C%AC%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p><strong>初始化版本库</strong><br>第一步：git的安装，到官网下载即可（<span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS8lRUYlQkMlODlXaW5kb3dzJUU0JUI4JThCJUU1JTgyJUJCJUU3JTkzJTlDJUU1JUJDJThGJUU1JUFFJTg5JUU4JUEzJTg1JUVGJUJDJThDJUU1JUFFJTg5JUU4JUEzJTg1JUU1JUFFJThDJUU2JUFGJTk1JUU0JUJDJTlBJUU3JTk0JTlGJUU2JTg4JTkwZ2l0">https://git-scm.com/）Windows下傻瓜式安装，安装完毕会生成git<i class="fa fa-external-link-alt"></i></span> shell客户端，这个客户端在Windows下是一个模拟Linux的窗口，支持大部分的Linux的命令操作：<br>第二部：创建一个目录，然后进入目录，将此文件夹下作为项目的root，然后执行：git init 初始化版本库：</p>
<span id="more"></span>
<p><img src="/2018/10/04/git-%E4%B8%80-git%E5%85%A5%E9%97%A8%EF%BC%8C%E7%89%88%E6%9C%AC%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/20170625214336490.png" alt="这里写图片描述"></p>
<p>初始化之后在文件夹下的所有操作都会纳入到版本库的管理，此时需要说明一下git的三种状态：<br><img src="/2018/10/04/git-%E4%B8%80-git%E5%85%A5%E9%97%A8%EF%BC%8C%E7%89%88%E6%9C%AC%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/20170626194227609.png" alt="这里写图片描述"></p>
<p>已修改：文件修改之后的状态<br>已暂存：文件add到暂存区的状态<br>已提交：文件提交到远程版本库的状态</p>
<p><strong>git常用命令简要：</strong></p>
<ul>
<li>获得版本库<ul>
<li>git init</li>
<li>git clone</li>
</ul>
</li>
<li>版本管理<ul>
<li>git add   将文件存放道暂存区</li>
<li>git commit  将暂存区文件提交到远程版本库</li>
<li>git rm  删除文件，剥离版本库的管理</li>
</ul>
</li>
<li>查看信息<ul>
<li>git help  帮助</li>
<li>git log    查看提交日志</li>
<li>git diff   比较文件的差别。可以是已修改的状态的文件和暂存区文件的差别，也可以是暂存区和远程版本库的文件的差别</li>
</ul>
</li>
<li>远程协作<br>- git pull  把远程版本库的文件拉取到本地<br>- git push 将本地版本库的文件推送到远程</li>
</ul>
<p> git版本库的所有信息都在mygit的.git文件夹下边，如果我们删除此文件夹，那区别就是进入mygit这个目录的时候命令不会有诸如”(master)”这样的提示性的标示。<br> <img src="/2018/10/04/git-%E4%B8%80-git%E5%85%A5%E9%97%A8%EF%BC%8C%E7%89%88%E6%9C%AC%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/20170626200449220.png" alt="这里写图片描述"></p>
<p>.git目录下边的文件保存了当前版本库的所有信息，一般不要手动修改，只能通过命令去修改：<br><img src="/2018/10/04/git-%E4%B8%80-git%E5%85%A5%E9%97%A8%EF%BC%8C%E7%89%88%E6%9C%AC%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/20170626200825133.png" alt="这里写图片描述">  </p>
<p>新建一个文件：<br><img src="/2018/10/04/git-%E4%B8%80-git%E5%85%A5%E9%97%A8%EF%BC%8C%E7%89%88%E6%9C%AC%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/20170626201302870.png" alt="这里写图片描述"></p>
<p>新建一个文件之后当前工作区发生来了变化，那么怎么查看当前工作区的状态呢？</p>
<p><strong>查看工作区状态:</strong><br>git status 命令<br><img src="/2018/10/04/git-%E4%B8%80-git%E5%85%A5%E9%97%A8%EF%BC%8C%E7%89%88%E6%9C%AC%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/20170626201506577.png" alt="这里写图片描述"><br>很明显文件的状态是未追踪的状态（untracked），文件处理修改状态。</p>
<p><strong>将已修改的文件加入到暂存区：</strong><br>git add test.txt   将文件添加到暂存区当中。</p>
<p>add完毕之后再去查看版本库状态：<br><img src="/2018/10/04/git-%E4%B8%80-git%E5%85%A5%E9%97%A8%EF%BC%8C%E7%89%88%E6%9C%AC%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/20170626202259387.png" alt="这里写图片描述"><br>可以看到红色提示 new file  :  test.txt 意思是对于暂存区是一个新的文件，等待提交。<br>除了提示这是个新的文件之外，还有一句：use “git rm –cached <file>…” to unstage)意思是我们可以将某个文件会退到已修改状态，即，从暂存区删除：<br><img src="/2018/10/04/git-%E4%B8%80-git%E5%85%A5%E9%97%A8%EF%BC%8C%E7%89%88%E6%9C%AC%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/20170626202954258.png" alt="这里写图片描述"><br>取消之后再去git status 就会回到文件刚刚创建的时候一样的状态。同样的道理我们再次git add  test.txt  进去到暂存区恢复刚才的状态，接着我们下边的内容。</p>
<p><strong>文件的提交（commit）:</strong><br>文件添加到暂存区之后接下来我们对文件进行提交到远程版本库:<br>git commit<br>当我们输入完命令回车之后会出现一个编辑器：<br><img src="/2018/10/04/git-%E4%B8%80-git%E5%85%A5%E9%97%A8%EF%BC%8C%E7%89%88%E6%9C%AC%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/20170626203719854.png" alt="这里写图片描述"><br>其中注释说明的意思是：当前提交需要添加提交说明，如果输入空内容忽略本次提交。我们什么也没有输入然后保存退出,出现：<br><img src="/2018/10/04/git-%E4%B8%80-git%E5%85%A5%E9%97%A8%EF%BC%8C%E7%89%88%E6%9C%AC%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/20170626203917225.png" alt="这里写图片描述"></p>
<p> Aborting commit due to empty commit message. 意思是由于本次提交没有添加说明，当前提交被取消终止，这一点和svn有很大的不同，svn可以不添加提交说明也可以提交成功，而git是不允许的。<br>我们添加提交说明，然后保存退出：<br><img src="/2018/10/04/git-%E4%B8%80-git%E5%85%A5%E9%97%A8%EF%BC%8C%E7%89%88%E6%9C%AC%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/20170626204250307.png" alt="这里写图片描述"></p>
<p>此时出现提交成功的提示：<br><img src="/2018/10/04/git-%E4%B8%80-git%E5%85%A5%E9%97%A8%EF%BC%8C%E7%89%88%E6%9C%AC%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/20170626204346823.png" alt="这里写图片描述"><br>create mode 100644 test.txt  即创建模式。此时再去查看git status：<br><img src="/2018/10/04/git-%E4%B8%80-git%E5%85%A5%E9%97%A8%EF%BC%8C%E7%89%88%E6%9C%AC%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/20170626204845295.png" alt="这里写图片描述"><br>意思是没有任何可以提交的文件。</p>
<p><strong>查看提交历史：</strong><br>    git log<br>    查看当前版本库的提交历史：<br>    <img src="/2018/10/04/git-%E4%B8%80-git%E5%85%A5%E9%97%A8%EF%BC%8C%E7%89%88%E6%9C%AC%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/20170626205356824.png" alt="这里写图片描述"><br>commit a0e67a4d3d6aa80d140e97d002828ec60911b8ff 这个提交id是一个摘要值，通过sha1计算出来的，sha1和MD5很相似，都是不可逆的。<br>author是提交人，date是提交的时间。<br>接下来我们要修改下名字和邮箱，对于user.email和user.name有三种方式可以设置：</p>
<ul>
<li>&#x2F;etc&#x2F;gitconfig （针对于整个OS,不常用）  git config –system</li>
<li>~&#x2F;.gitconfig(很常用)                      git config –global</li>
<li>针对于特定项目的 位于当前项目的  .git&#x2F;config文件中。 git config –local<br> 我们针对于第二种和第三种情况进行说明：<br>  <strong>git config –global</strong><br> 首先进入.git目录查看 config文件内容：<br> git config命令一些参数：<br><img src="/2018/10/04/git-%E4%B8%80-git%E5%85%A5%E9%97%A8%EF%BC%8C%E7%89%88%E6%9C%AC%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/20170626210947905.png" alt="这里写图片描述"><br>config文件内容：<br> <img src="/2018/10/04/git-%E4%B8%80-git%E5%85%A5%E9%97%A8%EF%BC%8C%E7%89%88%E6%9C%AC%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/20170626210740993.png" alt="这里写图片描述"><br>紧接着：<br>git config –local user.name ‘CeaserWang’<br>git config –local user.email ‘<span class="exturl" data-url="bWFpbHRvOiYjeDc4OyYjeDc4OyYjMTIwOyYjeDQwOyYjMTIwOyYjeDc4OyYjeDc4OyYjNDY7JiN4NjM7JiMxMTE7JiMxMDk7">&#x78;&#x78;&#120;&#x40;&#120;&#x78;&#x78;&#46;&#x63;&#111;&#109;<i class="fa fa-external-link-alt"></i></span>‘<br>进行配置用户和邮箱，此时我们可以展示一下:<br>git config user.name<br>git config user.email<br>同时再次查看config文件会发现user.name和user.email都存在了。<br><img src="/2018/10/04/git-%E4%B8%80-git%E5%85%A5%E9%97%A8%EF%BC%8C%E7%89%88%E6%9C%AC%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/20170626211439173.png" alt="这里写图片描述"><br>或者 git config –list查看所有配置参数<br>git config –local user.name ‘CeaserWang’<br>git config –local user.email ‘<span class="exturl" data-url="bWFpbHRvOiYjeDc4OyYjeDc4OyYjMTIwOyYjeDQwOyYjeDc4OyYjMTIwOyYjMTIwOyYjeDJlOyYjeDYzOyYjeDZmOyYjMTA5Ow==">&#x78;&#x78;&#120;&#x40;&#x78;&#120;&#120;&#x2e;&#x63;&#x6f;&#109;<i class="fa fa-external-link-alt"></i></span>‘ 这些命令也可以用来修改，再说一下删除：<br>git config –local  –unset  user.name<br><img src="/2018/10/04/git-%E4%B8%80-git%E5%85%A5%E9%97%A8%EF%BC%8C%E7%89%88%E6%9C%AC%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/20170626212216912.png" alt="这里写图片描述"><br>接下我们回到mygit根目录，修改下test.txt文件，然后git staus 查看状态：<br><img src="/2018/10/04/git-%E4%B8%80-git%E5%85%A5%E9%97%A8%EF%BC%8C%E7%89%88%E6%9C%AC%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/20170626212952735.png" alt="这里写图片描述"><br>这时提示信息又发生一些变化。<br> modified:   test.txt意思是已经修改了。<br> (use “git checkout – <file>…” to discard changes in working directory 意识是 使用git checkout – <file>命令丢弃刚才的修改。<br>  首先我们的文件修改之后加入了一行文字（welcome）然后状态是modified状态，此时我们使用git checkout 命令回退刚才的修改：<br><img src="/2018/10/04/git-%E4%B8%80-git%E5%85%A5%E9%97%A8%EF%BC%8C%E7%89%88%E6%9C%AC%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/20170626213638727.png" alt="这里写图片描述"><br>  会发现刚下的修改会取消了，状态回到愿原来的状态。这个命令要小心一点，因为文件没有放到版本库里边，真的丢弃了就找不回来了。</li>
</ul>
<p>另外git commit的提交说明可以直接：git commmit -m ‘提交说明’<br>提交日志时间是按照倒序的排列：<br><img src="/2018/10/04/git-%E4%B8%80-git%E5%85%A5%E9%97%A8%EF%BC%8C%E7%89%88%E6%9C%AC%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/20170626220111432.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>git init</tag>
      </tags>
  </entry>
  <entry>
    <title>git(七)-远程与github</title>
    <url>/2018/10/04/git-%E4%B8%83-%E8%BF%9C%E7%A8%8B%E4%B8%8Egithub/</url>
    <content><![CDATA[<p>本地创建一个新的仓库，然后在github也创建一个新的仓库。<br>此时需要在本地关联github的远程仓库的url地址之后，将本地仓库提交到github。</p>
<span id="more"></span>
<p>命令：<br>一、https的方式<br>git remote add origin <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3VzZXIvZ2l0cmVzcG9yeS5naXQ=">https://github.com/user/gitrespory.git<i class="fa fa-external-link-alt"></i></span><br>git push -u origin master</p>
<p>二、ssh的方式<br>ssh的方式需要在本地机器生成公钥和私钥，然后将公钥设置到github的远程仓库，设置方式：<br><img src="/2018/10/04/git-%E4%B8%83-%E8%BF%9C%E7%A8%8B%E4%B8%8Egithub/20170730201503950.png" alt="这里写图片描述"></p>
<p>然后执行：<br>git remote add origin <span class="exturl" data-url="bWFpbHRvOiYjeDY3OyYjeDY5OyYjMTE2OyYjNjQ7JiN4Njc7JiN4Njk7JiN4NzQ7JiMxMDQ7JiN4NzU7JiN4NjI7JiN4MmU7JiM5OTsmIzExMTsmIzEwOTs=">&#x67;&#x69;&#116;&#64;&#x67;&#x69;&#x74;&#104;&#x75;&#x62;&#x2e;&#99;&#111;&#109;<i class="fa fa-external-link-alt"></i></span>:1156721874&#x2F;CrazyCode.git<br>git push -u origin master<br>输入用户名和密码之后即可建立关联，此后所有的提交的push都会提交到github的远程仓库。</p>
<p>查看远程仓库信息：<br>git remote show<br>查看远程某个版本库详情：<br>git remote show origin<br>查看所有分支，会显示远程分支：<br>git branch -a<br>查看所有分支以及最近提交情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch -av</span><br><span class="line">  dev    080a6d7 delete</span><br><span class="line">* master a4ed124 commit</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>git clone：<br>将远程仓库克隆岛本地：<br>git clone <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9wcm90b2J1Zi5naXQ=">https://github.com/google/protobuf.git<i class="fa fa-external-link-alt"></i></span><br>克隆到目录myprotobuf下<br>git clone <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9wcm90b2J1Zi5naXQ=">https://github.com/google/protobuf.git<i class="fa fa-external-link-alt"></i></span> myprotobuf</p>
<p>git add . 和 git add *的区别：<br>git add .  ： 将当前目录的修改以及新增的文件放进暂存区，同时考虑”.gitignore”文件的配置<br>git add * ：将当前目录的修改以及新增的文件放进暂存区，不考虑”.gitignore”文件的配置</p>
<p>git add的三个作用：<br>1、将未追踪的文件纳入到缓存区。<br>2、将已追踪但是又修改的文件纳入到缓存区。<br>3、标示冲突的文件被解决掉。</p>
<p>git pull操作组成：<br>git pull &#x3D; git fetch + git merge</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>远程</tag>
      </tags>
  </entry>
  <entry>
    <title>git(三)-.gitignore和分支</title>
    <url>/2018/10/04/git-%E4%B8%89-gitignore%E5%92%8C%E5%88%86%E6%94%AF/</url>
    <content><![CDATA[<p>一：.gitignore<br>.gitignore文件的作用是界定那些文件不纳入版本库的管理，比如ide的工作文件，临时文件，等等。</p>
<span id="more"></span>
<p><img src="/2018/10/04/git-%E4%B8%89-gitignore%E5%92%8C%E5%88%86%E6%94%AF/20170710213342759.png" alt="这里写图片描述"></p>
<p><img src="/2018/10/04/git-%E4%B8%89-gitignore%E5%92%8C%E5%88%86%E6%94%AF/20170710215003710.png" alt="这里写图片描述"><br>另外：<br>&#x2F;<em>.txt表示根目录下所有txt文件被忽略，但是 子集目录不会忽略<br>&#x2F;**&#x2F;</em>.txt：表示根目录下以及子目录的所有txt文件都被忽略</p>
<p>二：分支<br><img src="/2018/10/04/git-%E4%B8%89-gitignore%E5%92%8C%E5%88%86%E6%94%AF/20170710221747993.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>gitignore</tag>
        <tag>branch</tag>
        <tag>分支</tag>
      </tags>
  </entry>
  <entry>
    <title>git(九)-git refspec以及git别名</title>
    <url>/2018/10/04/git-%E4%B9%9D-git-refspec%E4%BB%A5%E5%8F%8Agit%E5%88%AB%E5%90%8D/</url>
    <content><![CDATA[<p><strong>别名：</strong><br>我们在使用git命令的时候，有些命令使用的非常频繁，因此我们可以使用别名减少拼写，例如：</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global alias.br branch</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/04/git-%E4%B9%9D-git-refspec%E4%BB%A5%E5%8F%8Agit%E5%88%AB%E5%90%8D/20170801193146297.png" alt="这里写图片描述"><br>别名配置在~&#x2F;.gitconfig（用户目录）里边</p>
<p><strong>refspec：</strong><br>新建三个分支：dev、test、master：<br>然后切换到dev，将devpush到远程仓库出现如下问题：<br><img src="/2018/10/04/git-%E4%B9%9D-git-refspec%E4%BB%A5%E5%8F%8Agit%E5%88%AB%E5%90%8D/20170801194728281.png" alt="这里写图片描述"><br>原因：<br>表面意思是远程分支没有dev这个分支，命令提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push --set-upstream origin dev</span><br></pre></td></tr></table></figure>
<p>引导我们将当前分支关联到远程的dev，同时新建一个远程的dev分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push --set-upstream origin dev</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/1156721874/mygit.git</span><br><span class="line"> * [new branch]      dev -&gt; dev</span><br><span class="line">Branch dev set up to track remote branch dev from origin.</span><br></pre></td></tr></table></figure>
<p>PS：git push –set-upstream origin dev和git push  -u origin dev效果是一致的。<br>提示本地的分支和远程的分支进行了对应，接下来即可push操作:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push</span><br><span class="line">Everything up-to-date</span><br></pre></td></tr></table></figure>
<p>然后我们去github的页面可以看到出现我们的dev分支。<br><img src="/2018/10/04/git-%E4%B9%9D-git-refspec%E4%BB%A5%E5%8F%8Agit%E5%88%AB%E5%90%8D/20170801195813246.png" alt="这里写图片描述"><br>通过命令我们可以看到多出来一个远程分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch  -av</span><br><span class="line">* dev                   b76e551 modify</span><br><span class="line">  master                b76e551 modify</span><br><span class="line">  test                  b76e551 modify</span><br><span class="line">  remotes/origin/dev    b76e551 modify</span><br><span class="line">  remotes/origin/master b76e551 modify</span><br></pre></td></tr></table></figure>
<p>此时如果另一个开发者执行git pull就可以将dev分支拉回到他的本地，名字是remote&#x2F;origin&#x2F;dev,但是这个只是一个远程分支的景象，<br>执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure>
<p>PS：git checkout -b dev origin&#x2F;dev和git checkout –track  origin&#x2F;test效果一致。<br>即可新建一个和远程镜像一致的dev分支。</p>
<p><strong>删除远程分支：</strong><br>第一种方式<br>首先说一下git push的完整写法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin src:desc</span><br></pre></td></tr></table></figure>
<p>src是本地分支的名字，desc是远程分支的名字，因为他们的名字一样因此可以直接git push。<br>所以我们要删除一个远程分支可以将一个空的分支推送到远程，就是删除操作：<br>删除dev远程分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin  :dev</span><br></pre></td></tr></table></figure>

<p>第二种方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin --delete develop</span><br></pre></td></tr></table></figure>

<p>有些时候我们在本地的分支叫dev，而在远程分支的名字叫dev2，那么我们怎么处理呢？<br>写法：<br>git push –set-upstream origin dev:dev2</p>
<p>在推送的时候使用push的全写：git push origin dev:dev2，即显式指定远程分支的名字。</p>
<p>重命名远程分支：<br>只有一种方式，就是先删除远程分支，然后在本地重命名再提交到远程分支，即先删除后新增。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>refspec以及git别名</tag>
      </tags>
  </entry>
  <entry>
    <title>git(二)-git添加-删除-修改与日志</title>
    <url>/2018/10/04/git-%E4%BA%8C-git%E6%B7%BB%E5%8A%A0-%E5%88%A0%E9%99%A4-%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>题外话：<br>echo ‘hello world’ &gt;　test2.txt</p>
<span id="more"></span>
<p>如果此命令敲错了，想跳到开头快捷键：ctrl+A，跳到命令结尾：ctrl+E</p>
<p><strong>删除操作</strong><br><em>第一种删除(git rm )：</em><br>我们新建一个test.txt文件提交到远程版本库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Administrator@CeaserWang MINGW64 /e/Study/mygit (master)</span><br><span class="line">$ ls</span><br><span class="line">test.txt  test2.txt</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/mygit (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>
<p>然后我们删除test.txt<br><img src="/2018/10/04/git-%E4%BA%8C-git%E6%B7%BB%E5%8A%A0-%E5%88%A0%E9%99%A4-%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%97%A5%E5%BF%97/20170628211149639.png" alt="这里写图片描述"><br>并且ls查看目录当前目录test2.txt已经不存在了，证明删除成功。</p>
<p> 此时我们要撤销删除：<br> <img src="/2018/10/04/git-%E4%BA%8C-git%E6%B7%BB%E5%8A%A0-%E5%88%A0%E9%99%A4-%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%97%A5%E5%BF%97/20170628212228337.png" alt="这里写图片描述"></p>
<p>我们把test2删除：<br><img src="/2018/10/04/git-%E4%BA%8C-git%E6%B7%BB%E5%8A%A0-%E5%88%A0%E9%99%A4-%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%97%A5%E5%BF%97/20170628212759004.png" alt="这里写图片描述"></p>
<p>git rm完成2件事情：<br>1、将被删除的文件放到暂存区，因此 git  reset  HEAD   file 是将文件从暂存区放回已修改区。<br>2、删除一个文件（一个删除操作） 那么 git checkout – file 是将删除操作回退。</p>
<p><em>第二种删除(直接使用操作系统的rm)：</em><br>还是新建文件test.txt<br><img src="/2018/10/04/git-%E4%BA%8C-git%E6%B7%BB%E5%8A%A0-%E5%88%A0%E9%99%A4-%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%97%A5%E5%BF%97/20170628213030357.png" alt="这里写图片描述">  </p>
<p>然后我们使用操作系统的rm删除命令 ，然后接着我们要恢复test2：<br><img src="/2018/10/04/git-%E4%BA%8C-git%E6%B7%BB%E5%8A%A0-%E5%88%A0%E9%99%A4-%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%97%A5%E5%BF%97/20170628214736956.png" alt="这里写图片描述">  </p>
<p>rm操作只做了一件事情：<br>执行了删除操作，被删除的文件并没有纳入到暂存区当中。此时是commit是非法的，因为暂存区不存在此文件，<br>那么要想回退只用git checkout – file就能撤销删除操作。</p>
<p><strong>重命名</strong><br>第一种git rm a b<br><img src="/2018/10/04/git-%E4%BA%8C-git%E6%B7%BB%E5%8A%A0-%E5%88%A0%E9%99%A4-%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%97%A5%E5%BF%97/20170628223000054.png" alt="这里写图片描述"></p>
<p><img src="/2018/10/04/git-%E4%BA%8C-git%E6%B7%BB%E5%8A%A0-%E5%88%A0%E9%99%A4-%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%97%A5%E5%BF%97/20170628223537610.png" alt="这里写图片描述">  </p>
<p>第二种 mv a b<br><img src="/2018/10/04/git-%E4%BA%8C-git%E6%B7%BB%E5%8A%A0-%E5%88%A0%E9%99%A4-%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%97%A5%E5%BF%97/20170628224553518.png" alt="这里写图片描述"></p>
<p><strong>修改提交日志</strong><br>我们进行了一次提交，但是提交日志不小心写错了：<br><img src="/2018/10/04/git-%E4%BA%8C-git%E6%B7%BB%E5%8A%A0-%E5%88%A0%E9%99%A4-%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%97%A5%E5%BF%97/20170628225329525.png" alt="这里写图片描述"></p>
<p>修复：</p>
<p>git commit –amend -m ‘修正的提交消息’  即 将原来的提交消息覆盖掉。<br><img src="/2018/10/04/git-%E4%BA%8C-git%E6%B7%BB%E5%8A%A0-%E5%88%A0%E9%99%A4-%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%97%A5%E5%BF%97/20170628225522634.png" alt="这里写图片描述"></p>
<p>git log参数:<br>git log -3 查看最近的三条<br>git log pretty&#x3D;oneline：<br><img src="/2018/10/04/git-%E4%BA%8C-git%E6%B7%BB%E5%8A%A0-%E5%88%A0%E9%99%A4-%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%97%A5%E5%BF%97/20170628230022202.png" alt="这里写图片描述"><br>git log –pretty&#x3D;&#x3D;format:”%h - %an, %ar :%ｓ”<br><img src="/2018/10/04/git-%E4%BA%8C-git%E6%B7%BB%E5%8A%A0-%E5%88%A0%E9%99%A4-%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%97%A5%E5%BF%97/20170628230312893.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>删除</tag>
        <tag>修改</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>git(五)-checkout进阶与stash</title>
    <url>/2018/10/04/git-%E4%BA%94-checkout%E8%BF%9B%E9%98%B6%E4%B8%8Estash/</url>
    <content><![CDATA[<p><strong>git checkout – test.txt原理：</strong><br>作用：<strong>丢弃掉相对于暂存区最后一个添加的文件内容所做的变更。</strong></p>
<span id="more"></span>
<p>实际操作：<br><img src="/2018/10/04/git-%E4%BA%94-checkout%E8%BF%9B%E9%98%B6%E4%B8%8Estash/20170730130722488.png" alt="这里写图片描述"></p>
<p>范围：针对于工作区</p>
<p><strong>git reset HEAD test.txt作用：</strong><br>将之前添加到暂存区（stage index）的内容从暂存区移除到工作区。<br>实际操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   test.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/mygit (master)</span><br><span class="line">$ git reset HEAD test.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       test.txt</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/mygit (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>git checkout 2424324 作用：<br><img src="/2018/10/04/git-%E4%BA%94-checkout%E8%BF%9B%E9%98%B6%E4%B8%8Estash/20170730134220453.png" alt="这里写图片描述"><br><strong>重点内容</strong><br>上面我们生成一个游离分支，接下来做一下修改在其上。<br><img src="/2018/10/04/git-%E4%BA%94-checkout%E8%BF%9B%E9%98%B6%E4%B8%8Estash/20170730142812736.png" alt="这里写图片描述"></p>
<p>整个过程：<br><img src="/2018/10/04/git-%E4%BA%94-checkout%E8%BF%9B%E9%98%B6%E4%B8%8Estash/20170730142855766.png" alt="这里写图片描述">  </p>
<p><strong>分支改名：</strong><br>git branch -m master master2</p>
<p><strong>stash命令：</strong><br>• 保存现场<br>• git stash<br>• git stash save ‘name XXX ’<br>• git stash list<br>• 恢复现场<br>• git stash apply（stash内容并不不删除，需要通过git stash drop<br>stash@{0}⼿手动删除）<br>• git stash pop（恢复的同时也将stash内容删除）<br>• git stash apply stash@{0}<br>git stash drop stash@{0} 删除保存的记录</p>
<p>实际操作:<br>我们在master分支创建新的分支dev，然后在master分支修改文件并且进行一次提交，接着切换到dev分支，在dev分支修改也进行一次提交，此时如果再次执行切换到master分支会出错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">error: Your local changes to the following files would be overwritten by checkout:</span><br><span class="line">        test.txt</span><br><span class="line">Please commit your changes or stash them before you switch branches.</span><br><span class="line">Aborting</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这在我们的日常开发中非常常见，从主干拉了2个分支A和B，开发者者在A分支开发了一半，但是紧接着要转到B分支进行开发，但是A分支的代码是不能提交的，因为没有开发完毕，才是就需要暂存A分支的内容，下次回到A的时候从暂存中恢复出来。<br><img src="/2018/10/04/git-%E4%BA%94-checkout%E8%BF%9B%E9%98%B6%E4%B8%8Estash/20170730150702916.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>checkout</tag>
        <tag>stash</tag>
      </tags>
  </entry>
  <entry>
    <title>git(八)-远程分支、别名、gitk与git gui</title>
    <url>/2018/10/04/git-%E5%85%AB-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E3%80%81%E5%88%AB%E5%90%8D%E3%80%81gitk%E4%B8%8Egit-gui/</url>
    <content><![CDATA[<p>gitk<br>在命令模式输入gitk弹出git窗口页面;</p>
<span id="more"></span>
<p><img src="/2018/10/04/git-%E5%85%AB-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E3%80%81%E5%88%AB%E5%90%8D%E3%80%81gitk%E4%B8%8Egit-gui/20170731213836111.png" alt="这里写图片描述"></p>
<p>git gui<br>命令模式输入git gui弹出窗口页面：<br><img src="/2018/10/04/git-%E5%85%AB-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E3%80%81%E5%88%AB%E5%90%8D%E3%80%81gitk%E4%B8%8Egit-gui/20170731213933679.png" alt="这里写图片描述">  </p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>gitk git-gui</tag>
        <tag>别名</tag>
        <tag>gitk</tag>
        <tag>git-gui</tag>
        <tag>远程分支</tag>
      </tags>
  </entry>
  <entry>
    <title>git(六)-标签与diff</title>
    <url>/2018/10/04/git-%E5%85%AD-%E6%A0%87%E7%AD%BE%E4%B8%8Ediff/</url>
    <content><![CDATA[<p>新建标签，标签有两种：轻量量级标签（lightweight）与带有附注标签<br>（annotated）</p>
<span id="more"></span>
<p>• 创建⼀一个轻量量级标签<br>• git tag v1.0.1<br>• 创建⼀一个带有附注的标签<br>• git tag -a v1.0.2 -m ‘release version’<br>• 删除标签<br>• git tag -d tag_name</p>
<p>操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Administrator@CeaserWang MINGW64 /e/Study/mygit (dev)</span><br><span class="line">$ git tag v1.0</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/mygit (dev)</span><br><span class="line">$ git tag</span><br><span class="line">v1.0</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/mygit (dev)</span><br><span class="line">$ git tag -a v1.2 -m &#x27;v1.2 released&#x27;</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/mygit (dev)</span><br><span class="line">$ git tag</span><br><span class="line">v1.0</span><br><span class="line">v1.2</span><br></pre></td></tr></table></figure>

<p>查找：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git tag -l &#x27;v1.0&#x27;</span><br><span class="line">v1.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>删除：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Administrator@CeaserWang MINGW64 /e/Study/mygit (dev)</span><br><span class="line">$ git tag -d v1.0</span><br><span class="line">Deleted tag &#x27;v1.0&#x27; (was 080a6d7)</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/mygit (dev)</span><br><span class="line">$ git tag</span><br><span class="line">v1.2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>标签不依赖特定的分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Administrator@CeaserWang MINGW64 /e/Study/mygit (dev)</span><br><span class="line">$ git tag</span><br><span class="line">v1.2</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/mygit (dev)</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/mygit (master)</span><br><span class="line">$ git tag</span><br><span class="line">v1.2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>git blame命令：</strong></p>
<p>blame的作用是查看文件的修改是哪个作者操作的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git blame test.txt</span><br><span class="line">1806ac5e (ceaser 2017-07-30 11:57:14 +0800 1) first commit</span><br><span class="line">1806ac5e (ceaser 2017-07-30 11:57:14 +0800 2) second commit</span><br><span class="line">25db944e (ceaser 2017-07-30 11:57:56 +0800 3) third commit</span><br><span class="line">821425dc (ceaser 2017-07-30 11:58:26 +0800 4) fourth commit</span><br><span class="line">9b95dda7 (ceaser 2017-07-30 14:53:25 +0800 5) hello java</span><br><span class="line">9b95dda7 (ceaser 2017-07-30 14:53:25 +0800 6) hello node</span><br></pre></td></tr></table></figure>

<p><strong>git  diff命令：</strong><br>diff比较的是暂存区和工作区的内容的不同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/test.txt b/test.txt</span><br><span class="line">index 4151b86..e304045 100644</span><br><span class="line">--- a/test.txt  //暂存区文件</span><br><span class="line">+++ b/test.txt  //工作区文件</span><br><span class="line">@@ -4,3 +4,4 @@ third commit</span><br><span class="line"> fourth commit</span><br><span class="line"> hello java</span><br><span class="line"> hello node</span><br><span class="line">+hello python  //工作区比暂存区多了一行</span><br></pre></td></tr></table></figure>
<p>git diff HEAD 比较的是最新的提交和工作区的差别，ＨＥＡＤ可以换成某一个提交ｉｄ</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git diff HEAD</span><br><span class="line">diff --git a/test.txt b/test.txt</span><br><span class="line">index e304045..d18bc0f 100644</span><br><span class="line">--- a/test.txt</span><br><span class="line">+++ b/test.txt</span><br><span class="line">@@ -2,6 +2,3 @@ first commit</span><br><span class="line"> second commit</span><br><span class="line"> third commit</span><br><span class="line"> fourth commit</span><br><span class="line">-hello java</span><br><span class="line">-hello node</span><br><span class="line">-hello python</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　<br>git diff  –cached commit_id 比较的最新的提交和暂存区的差别。<br><img src="/2018/10/04/git-%E5%85%AD-%E6%A0%87%E7%AD%BE%E4%B8%8Ediff/20170730170532741.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>标签</tag>
        <tag>diff</tag>
      </tags>
  </entry>
  <entry>
    <title>git(十)-git refspec以及远程标签</title>
    <url>/2018/10/04/git-%E5%8D%81-git-refspec%E4%BB%A5%E5%8F%8A%E8%BF%9C%E7%A8%8B%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<p>HEAD标记：HEAD文件是一个指向你当前所在分支的引用标示符，该文件内部并不包含SHA-1值，而是指向另外一个引用的指针。<br><img src="/2018/10/04/git-%E5%8D%81-git-refspec%E4%BB%A5%E5%8F%8A%E8%BF%9C%E7%A8%8B%E6%A0%87%E7%AD%BE/20170801210357580.png" alt="这里写图片描述"></p>
<span id="more"></span>

<p>当执行git commit命令时，git会创建一个commit对象，并且将这个commit对象的parent指针设置为HEAD所指向的引用的ＳＨＡ－１值。<br>另外凡是只要修改了ＨＥＡＤ的ｇｉｔ操作都会计入reflog。<br>实际上我们可以通过底层命令symbolic-ref来实现对HEAD文件的修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Administrator@CeaserWang MINGW64 /e/Study/mygit (dev)</span><br><span class="line">$ git symbolic-ref HEAD</span><br><span class="line">refs/heads/dev</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/mygit (dev)</span><br><span class="line">$ git symbolic-ref HEAD refs/heads/test</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/mygit (test)</span><br><span class="line">$</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其他形式不按照准则的会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git symbolic-ref HEAD askj/ajkaj/ll</span><br><span class="line">fatal: Refusing to point HEAD outside of refs/</span><br></pre></td></tr></table></figure>

<p><strong>标签：</strong><br>创建标签：<br><img src="/2018/10/04/git-%E5%8D%81-git-refspec%E4%BB%A5%E5%8F%8A%E8%BF%9C%E7%A8%8B%E6%A0%87%E7%AD%BE/20170801212627322.png" alt="这里写图片描述">  </p>
<p><strong>git show v1.0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git show v1.0</span><br><span class="line">commit b76e5510bdde8e3e0209b16037865eeecca890ff (HEAD -&gt; test, tag: v2.0, tag: v1.0, origin/test, origin/master, origin/dev, master, dev)</span><br><span class="line">Author: ceaserwang &lt;ceaserwang@outlook.com&gt;</span><br><span class="line">Date:   Tue Aug 1 19:44:50 2017 +0800</span><br><span class="line"></span><br><span class="line">    modify</span><br><span class="line"></span><br><span class="line">diff --git a/test.txt b/test.txt</span><br><span class="line">index c46f196..dfdd12d 100644</span><br><span class="line">--- a/test.txt</span><br><span class="line">+++ b/test.txt</span><br><span class="line">@@ -1,2 +1,3 @@</span><br><span class="line"> hello java</span><br><span class="line"> hello python</span><br><span class="line">+hello C++</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>git show v2.0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git show v2.0</span><br><span class="line">tag v2.0</span><br><span class="line">Tagger: ceaserwang &lt;ceaserwang@outlook.com&gt;</span><br><span class="line">Date:   Tue Aug 1 21:25:52 2017 +0800</span><br><span class="line"></span><br><span class="line">v2.0released</span><br><span class="line"></span><br><span class="line">commit b76e5510bdde8e3e0209b16037865eeecca890ff (HEAD -&gt; test, tag: v2.0, tag: v1.0, origin/test, origin/master, origin/dev, master, dev)</span><br><span class="line">Author: ceaserwang &lt;ceaserwang@outlook.com&gt;</span><br><span class="line">Date:   Tue Aug 1 19:44:50 2017 +0800</span><br><span class="line"></span><br><span class="line">    modify</span><br><span class="line"></span><br><span class="line">diff --git a/test.txt b/test.txt</span><br><span class="line">index c46f196..dfdd12d 100644</span><br><span class="line">--- a/test.txt</span><br><span class="line">+++ b/test.txt</span><br><span class="line">@@ -1,2 +1,3 @@</span><br><span class="line"> hello java</span><br><span class="line"> hello python</span><br><span class="line">+hello C++</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>git show v2.0  显示的详细明显比v1.0多。</p>
<p>将标签推送到远程：<br>git push的时候默认不会将标签也推送到远程，需要执行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin v1.0</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/1156721874/mygit.git</span><br><span class="line"> * [new tag]         v1.0 -&gt; v1.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在github上面可以看到提交的标签:<br><img src="/2018/10/04/git-%E5%8D%81-git-refspec%E4%BB%A5%E5%8F%8A%E8%BF%9C%E7%A8%8B%E6%A0%87%E7%AD%BE/20170801213504510.png" alt="这里写图片描述"></p>
<p>将所有本地未推送的标签推送到远程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Counting objects: 5, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (5/5), done.</span><br><span class="line">Writing objects: 100% (5/5), 349 bytes | 0 bytes/s, done.</span><br><span class="line">Total 5 (delta 4), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (4/4), done.</span><br><span class="line">To https://github.com/1156721874/mygit.git</span><br><span class="line"> * [new tag]         v1.0 -&gt; v1.0</span><br><span class="line"> * [new tag]         v2.0 -&gt; v2.0</span><br><span class="line"> * [new tag]         v3.0 -&gt; v3.0</span><br><span class="line"> * [new tag]         v4.0 -&gt; v4.0</span><br><span class="line"> * [new tag]         v5.0 -&gt; v5.0</span><br><span class="line"> * [new tag]         v6.0 -&gt; v6.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时另外一个开发者执行git pull将会把所有的标签拉取下来。<br>PS：标签和每一次提交时一一对应的，提交的id是一个SHA-1值，不便于记忆，tag是对这次提交的一个别名，可以这么理解。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>refspec</tag>
        <tag>远程标签</tag>
      </tags>
  </entry>
  <entry>
    <title>git(十一)-git远程分支底层剖析</title>
    <url>/2018/10/04/git-%E5%8D%81%E4%B8%80-git%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<p>标签的删除：<br>git push origin :refs&#x2F;tags&#x2F;v1.0</p>
<span id="more"></span>
<p>git push origin –delete tag v5.0<br>删除本地标签：<br>git tag -d v1.0<br>标签推送的完整的写法：<br>git push origin refs&#x2F;tags&#x2F;v1.0:refs&#x2F;tags&#x2F;v1.0</p>
<p>单独从远程拉取某个标签：<br>git fetch origin tag v1.0</p>
<p>游离的分支可以通过git remote prune origin删除掉，所谓的游离分支指的是：开发者A执行git push origin –delete dev删除一个远程分支，然后开发者B执行git pull的时候，B所在的分支dev就是游离的。</p>
<p>在缺省情况下，refspec会被git remote add命令所自动生成，git会获取远端上refs&#x2F;heads下的所有引用，并将它们写到本地的refs&#x2F;remote&#x2F;origin目录下，所以，如果远端上有一个master分支，你在本地就可以通过下面几种方式访问它们的历史记录：<br>git log origin&#x2F;master<br>git log remotes&#x2F;origin&#x2F;master<br>git log refs&#x2F;remotes&#x2F;origin&#x2F;master</p>
<p>将远程的master分支拉取到本地对应myaster：<br>git fetch origin master:refs&#x2F;remotes&#x2F;origin&#x2F;mymaster</p>
<p>在.git目录下进入config文件：<br><img src="/2018/10/04/git-%E5%8D%81%E4%B8%80-git%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90/20170801224506574.png" alt="这里写图片描述"><br>可以看到本地和远程的对应关系。<br>在.git&#x2F;refs&#x2F;下边有三个目录：<br>heads&#x2F;  remotes&#x2F;  tags&#x2F;<br>分别是本地的指针、远程的分支指针，以及标签的指针，指向的都是当前分支指向的提交id：<br><img src="/2018/10/04/git-%E5%8D%81%E4%B8%80-git%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90/20170801224804261.png" alt="这里写图片描述"></p>
<p> 标签里边的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Administrator@CeaserWang MINGW64 /e/Study/mygit/.git/refs/tags (GIT_DIR!)</span><br><span class="line">$ cat v1.0</span><br><span class="line">b76e5510bdde8e3e0209b16037865eeecca890ff</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/mygit/.git/refs/tags (GIT_DIR!)</span><br><span class="line">$ cat v2.0</span><br><span class="line">0b1af7c771e8de24167e97caf7af6448d33370c4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果是轻量级标签，里边的id是commitid，如果是带有注释的标签，里边的id是tag自身的id，这个id指向其所对应的commitid，因为带有注释的标签除了存储指向commitid之外，还要存储注释。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>远程分支</tag>
      </tags>
  </entry>
  <entry>
    <title>git(十七) git rebase 实战</title>
    <url>/2018/10/04/git-%E5%8D%81%E4%B8%83-git-rebase-%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p>我们新建三个分支分别是master、dev、test,之后在dev分支的test.txt文件新建2个提交，在test分支的test.txt文件新建2个提交。<br>切换到test分支，然后执行git rebase dev 我们要将dev分支的提交应用到test分支：</p>
<span id="more"></span>
<p><img src="/2018/10/04/git-%E5%8D%81%E4%B8%83-git-rebase-%E5%AE%9E%E6%88%98/20170805204123755.png" alt="这里写图片描述"><br>然后在test分支执行git rebase dev</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test)</span><br><span class="line">$ git rebase dev</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: [test branch] add -test1- in text.txt //将test的第一次提交应用到dev的最后一个节点</span><br><span class="line">error: Failed to merge in the changes.</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">M       test.txt</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging test.txt</span><br><span class="line">CONFLICT (content): Merge conflict in test.txt</span><br><span class="line">Patch failed at 0001 [test branch] add -test1- in text.txt</span><br><span class="line">The copy of the patch that failed is found in: .git/rebase-apply/patch</span><br><span class="line"></span><br><span class="line">When you have resolved this problem, run &quot;git rebase --continue&quot;.</span><br><span class="line">If you prefer to skip this patch, run &quot;git rebase --skip&quot; instead.</span><br><span class="line">To check out the original branch and stop rebasing, run &quot;git rebase --abort&quot;.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test|REBASE 1/2)</span><br><span class="line">$ cat test.txt</span><br><span class="line">master1</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">dev1</span><br><span class="line">dev2</span><br><span class="line">=======</span><br><span class="line">test1</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; [test branch] add -test1- in text.txt</span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test|REBASE 1/2)</span><br><span class="line">$ git status</span><br><span class="line">rebase in progress; onto f28df0d</span><br><span class="line">You are currently rebasing branch &#x27;test&#x27; on &#x27;f28df0d&#x27;.//对dev 的&#x27;f28df0d&#x27;应用补丁。</span><br><span class="line">  (fix conflicts and then run &quot;git rebase --continue&quot;)</span><br><span class="line">  (use &quot;git rebase --skip&quot; to skip this patch)//使用dev的补丁，废弃test的修改。</span><br><span class="line">  (use &quot;git rebase --abort&quot; to check out the original branch)//终止rebase过程</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line"></span><br><span class="line">        both modified:   test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>git rebase –abort的意思是终止当前rebase的操作，回到原始状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test|REBASE 1/2)</span><br><span class="line">$ git rebase --abort</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test)</span><br><span class="line">$ cat test.txt</span><br><span class="line">master1</span><br><span class="line">test1</span><br><span class="line">test2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>刚才演示了abort的效果，我们重新rebase回到rebase状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test)</span><br><span class="line">$ git rebase dev</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: [test branch] add  a line  in test.txt</span><br><span class="line">error: Failed to merge in the changes.</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">M       test.txt</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging test.txt</span><br><span class="line">CONFLICT (content): Merge conflict in test.txt</span><br><span class="line">Patch failed at 0001 [test branch] add  a line  in test.txt</span><br><span class="line">The copy of the patch that failed is found in: .git/rebase-apply/patch</span><br><span class="line"></span><br><span class="line">When you have resolved this problem, run &quot;git rebase --continue&quot;.</span><br><span class="line">If you prefer to skip this patch, run &quot;git rebase --skip&quot; instead.</span><br><span class="line">To check out the original branch and stop rebasing, run &quot;git rebase --abort&quot;.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test|REBASE 1/2)</span><br><span class="line">$ cat test.txt</span><br><span class="line">master1</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">dev1</span><br><span class="line">dev2</span><br><span class="line">=======</span><br><span class="line">test1</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; [test branch] add  a line  in test.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>test.txt文件里边的冲突部分是dev分支的“dev1 dev2”2行和test分支的“test1”， 即以dev的2次提交为基准，那么如果执行git rebase –skip所做的操作是：<br>丢弃test的第一次提交的修改，保留dev的修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test|REBASE 1/2)</span><br><span class="line">$ git rebase --skip</span><br><span class="line">Applying: [test branch] add -test2- in text.txt //应用test的第二次提交。</span><br><span class="line">error: Failed to merge in the changes.</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">M       test.txt</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging test.txt</span><br><span class="line">CONFLICT (content): Merge conflict in test.txt</span><br><span class="line">Patch failed at 0002 [test branch] add -test2- in text.txt</span><br><span class="line">The copy of the patch that failed is found in: .git/rebase-apply/patch</span><br><span class="line"></span><br><span class="line">When you have resolved this problem, run &quot;git rebase --continue&quot;.</span><br><span class="line">If you prefer to skip this patch, run &quot;git rebase --skip&quot; instead.</span><br><span class="line">To check out the original branch and stop rebasing, run &quot;git rebase --abort&quot;.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test|REBASE 2/2)</span><br><span class="line">$ cat test.txt</span><br><span class="line">master1</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">dev1</span><br><span class="line">dev2</span><br><span class="line">=======</span><br><span class="line">test1</span><br><span class="line">test2 //test2出现。</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; [test branch] add -test2- in text.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此时如果我们再次执行git rebase –skip 就会将test的第二次提交丢弃，保留dev的修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test|REBASE 2/2)</span><br><span class="line">$ git rebase --skip</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test)</span><br><span class="line">$ cat test.txt</span><br><span class="line">master1</span><br><span class="line">dev1</span><br><span class="line">dev2</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test)</span><br><span class="line">$</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到保留的2次的dev出现在文件里边，即“dev1 “和”dev2”这2次提交。<br>同时我们看一下git log：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test)</span><br><span class="line">$ git log</span><br><span class="line">commit f28df0d2c6fcb11d34e7551d5bb9b337aa46b259 (HEAD -&gt; test, dev)</span><br><span class="line">Author: ceaser &lt;ceaserwang@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 5 20:38:36 2017 +0800</span><br><span class="line"></span><br><span class="line">    [dev  branch] add -dev2- in test.txt</span><br><span class="line"></span><br><span class="line">commit 9ad27e0c99795978f259af4d2e17b99b77448f91</span><br><span class="line">Author: ceaser &lt;ceaserwang@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 5 20:38:22 2017 +0800</span><br><span class="line"></span><br><span class="line">    [dev  branch] add -dev1- in test.txt</span><br><span class="line"></span><br><span class="line">commit 72d9d551a336c1db8976a8d1f595f4d9dbd5569b (master)</span><br><span class="line">Author: ceaser &lt;ceaserwang@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 5 19:55:40 2017 +0800</span><br><span class="line"></span><br><span class="line">    master branch add file test.txt with master1 content</span><br><span class="line"></span><br><span class="line">commit 62046ccba0fea0b8e922697312632972edc8f0f8</span><br><span class="line">Author: ceaser &lt;ceaserwang@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 5 19:48:49 2017 +0800</span><br><span class="line"></span><br><span class="line">    master branch add file test.txt with line master1 commtent</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>里边有dev的2次提交的commit id验证了我们所说的。<br>此时我们切换到dev分支，演示出现冲突的一种情况，上边我们演示的是丢弃test的提交，那么我们接下来演示不丢弃test的提交，切换到dev的时候我们 git merge test，进行的是fast forward：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test)</span><br><span class="line">$  git checkout dev</span><br><span class="line">Switched to branch &#x27;dev&#x27;</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (dev)</span><br><span class="line">$ git merge test</span><br><span class="line">Already up-to-date.</span><br></pre></td></tr></table></figure>
<p>我们增加dev3和dev4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (dev)</span><br><span class="line">$ cat test.txt</span><br><span class="line">master1</span><br><span class="line">dev1</span><br><span class="line">dev2</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (dev)</span><br><span class="line">$ echo &#x27;dev3&#x27; &gt;&gt; test.txt</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (dev)</span><br><span class="line">$ git add test.txt</span><br><span class="line">warning: LF will be replaced by CRLF in test.txt.</span><br><span class="line">The file will have its original line endings in your working directory.</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (dev)</span><br><span class="line">$ git commit -m &#x27;[dev branch] add -dev3- in test.txt&#x27;</span><br><span class="line">[dev f018dc6] [dev branch] add -dev3- in test.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (dev)</span><br><span class="line">$ echo &#x27;dev4&#x27; &gt;&gt; test.txt</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (dev)</span><br><span class="line">$ git add test.txt</span><br><span class="line">warning: LF will be replaced by CRLF in test.txt.</span><br><span class="line">The file will have its original line endings in your working directory.</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (dev)</span><br><span class="line">$ git commit -m &#x27;[dev branch] add -dev4- in test.txt&#x27;</span><br><span class="line">[dev 3d74c2e] [dev branch] add -dev4- in test.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (dev)</span><br><span class="line">$ cat test.txt</span><br><span class="line">master1</span><br><span class="line">dev1</span><br><span class="line">dev2</span><br><span class="line">dev3</span><br><span class="line">dev4</span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (dev)</span><br><span class="line">$ git log -3</span><br><span class="line">commit 3d74c2ee12b7556cdbd576eb9f6fd9795898ddf6 (HEAD -&gt; dev)</span><br><span class="line">Author: ceaser &lt;ceaserwang@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 5 21:08:39 2017 +0800</span><br><span class="line"></span><br><span class="line">    [dev branch] add -dev4- in test.txt</span><br><span class="line"></span><br><span class="line">commit f018dc6f17d1a9b7c835e43064b695dd4b74e8df</span><br><span class="line">Author: ceaser &lt;ceaserwang@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 5 21:08:23 2017 +0800</span><br><span class="line"></span><br><span class="line">    [dev branch] add -dev3- in test.txt</span><br><span class="line"></span><br><span class="line">commit f28df0d2c6fcb11d34e7551d5bb9b337aa46b259 (test)</span><br><span class="line">Author: ceaser &lt;ceaserwang@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 5 20:38:36 2017 +0800</span><br><span class="line"></span><br><span class="line">    [dev  branch] add -dev2- in test.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>切换到test分支增加test3 和test4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test)</span><br><span class="line">$ cat test.txt</span><br><span class="line">master1</span><br><span class="line">dev1</span><br><span class="line">dev2</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test)</span><br><span class="line">$ echo &#x27;test3&#x27; &gt;&gt; test.txt</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test)</span><br><span class="line">$ git add test.txt</span><br><span class="line">warning: LF will be replaced by CRLF in test.txt.</span><br><span class="line">The file will have its original line endings in your working directory.</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test)</span><br><span class="line">$ git commit -m &#x27;[test branch] add -test3- in test.txt&#x27;</span><br><span class="line">[test 17794bd] [test branch] add -test3- in test.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test)</span><br><span class="line">$ echo &#x27;test4&#x27; &gt;&gt; test.txt</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test)</span><br><span class="line">$ git add test.txt</span><br><span class="line">warning: LF will be replaced by CRLF in test.txt.</span><br><span class="line">The file will have its original line endings in your working directory.</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test)</span><br><span class="line">$ git commit -m &#x27;[test branch] add -test4- in test.txt&#x27;</span><br><span class="line">[test d5a085e] [test branch] add -test4- in test.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test)</span><br><span class="line">$ git log -3</span><br><span class="line">commit d5a085e27b6f25f354c3292078d0069a3605eeaa (HEAD -&gt; test)</span><br><span class="line">Author: ceaser &lt;ceaserwang@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 5 21:12:56 2017 +0800</span><br><span class="line"></span><br><span class="line">    [test branch] add -test4- in test.txt</span><br><span class="line"></span><br><span class="line">commit 17794bda63b337577ad0da88826c28ef2b17ba67</span><br><span class="line">Author: ceaser &lt;ceaserwang@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 5 21:12:43 2017 +0800</span><br><span class="line"></span><br><span class="line">    [test branch] add -test3- in test.txt</span><br><span class="line"></span><br><span class="line">commit f28df0d2c6fcb11d34e7551d5bb9b337aa46b259</span><br><span class="line">Author: ceaser &lt;ceaserwang@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 5 20:38:36 2017 +0800</span><br><span class="line"></span><br><span class="line">    [dev  branch] add -dev2- in test.txt</span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test)</span><br><span class="line">$ cat test.txt</span><br><span class="line">master1</span><br><span class="line">dev1</span><br><span class="line">dev2</span><br><span class="line">test3</span><br><span class="line">test4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>test分支下执行git rebase dev:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test)</span><br><span class="line">$ git rebase dev</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: [test branch] add -test3- in test.txt</span><br><span class="line">error: Failed to merge in the changes.</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">M       test.txt</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging test.txt</span><br><span class="line">CONFLICT (content): Merge conflict in test.txt</span><br><span class="line">Patch failed at 0001 [test branch] add -test3- in test.txt</span><br><span class="line">The copy of the patch that failed is found in: .git/rebase-apply/patch</span><br><span class="line"></span><br><span class="line">When you have resolved this problem, run &quot;git rebase --continue&quot;.</span><br><span class="line">If you prefer to skip this patch, run &quot;git rebase --skip&quot; instead.</span><br><span class="line">To check out the original branch and stop rebasing, run &quot;git rebase --abort&quot;.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test|REBASE 1/2)</span><br><span class="line">$ cat test.txt</span><br><span class="line">master1</span><br><span class="line">dev1</span><br><span class="line">dev2</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">dev3</span><br><span class="line">dev4</span><br><span class="line">=======</span><br><span class="line">test3</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; [test branch] add -test3- in test.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此时出现的冲突我们先保留test3：<br>vi test.txt 删除456行：<br><img src="/2018/10/04/git-%E5%8D%81%E4%B8%83-git-rebase-%E5%AE%9E%E6%88%98/20170805211736486.png" alt="这里写图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat test.txt</span><br><span class="line">master1</span><br><span class="line">dev1</span><br><span class="line">dev2</span><br><span class="line">test3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行git rebase –continue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test|REBASE 1/2)</span><br><span class="line">$ git add test.txt</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test|REBASE 1/2)</span><br><span class="line">$ git rebase --continue</span><br><span class="line">Applying: [test branch] add -test3- in test.txt</span><br><span class="line">Applying: [test branch] add -test4- in test.txt</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test) //回到test</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>执行之后出现：<br>Applying: [test branch] add -test3- in test.txt<br>Applying: [test branch] add -test4- in test.txt<br>我们保留了test3的提交，test4就是比test3多了一次提交，直接就成功了。</p>
<p>查看文件只保留了test的提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$  cat test.txt</span><br><span class="line">master1</span><br><span class="line">dev1</span><br><span class="line">dev2</span><br><span class="line">test3</span><br><span class="line">test4</span><br></pre></td></tr></table></figure>
<p>test的日志：<br><img src="/2018/10/04/git-%E5%8D%81%E4%B8%83-git-rebase-%E5%AE%9E%E6%88%98/20170805212448530.png" alt="这里写图片描述"></p>
<p>如果我们在dev分支执行merge test会执行fast forward：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (test)</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch &#x27;dev&#x27;</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_rebase (dev)</span><br><span class="line">$ git merge test</span><br><span class="line">Updating 3d74c2e..9dcfcec</span><br><span class="line">Fast-forward</span><br><span class="line"> test.txt | 4 ++--</span><br><span class="line"> 1 file changed, 2 insertions(+), 2 deletions(-)</span><br></pre></td></tr></table></figure>
<p>我们用gitk看一下提交历史：<br>他的整个提交历史是一条直线<br><img src="/2018/10/04/git-%E5%8D%81%E4%B8%83-git-rebase-%E5%AE%9E%E6%88%98/20170805213018895.png" alt="这里写图片描述"><br>总的来说rebase的操作是将分叉的情况形成一条直线，但是会修改git的提交历史。</p>
<p>将test的提交应用到dev：<br>1、git checkout test<br>2、git rebase dev 以dev为基准将test的提交进行回放，挨个的应用到dev上去，然后test的那些提交就会废弃。<br>等价于git merge dev</p>
<p>git merge 和git rebase区别：<br>merge不会修改提交历史，rebase会修改提交历史。<br>rebase只应用于本地没有提交的代码，如果应用到已经提交到远程的分支不要应用，不然会非常的麻烦，get merge可以应用于远程分支。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>rebase</tag>
      </tags>
  </entry>
  <entry>
    <title>git(十三)-git裸库与submodule</title>
    <url>/2018/10/04/git-%E5%8D%81%E4%B8%89-git%E8%A3%B8%E5%BA%93%E4%B8%8Esubmodule/</url>
    <content><![CDATA[<p><strong>创建裸库：</strong><br>girl init –bare</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git init --bare</span><br><span class="line">Initialized empty Git repository in E:/Study/git_bare/</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/git_bare (BARE:master)</span><br><span class="line">$ ll -a</span><br><span class="line">total 19</span><br><span class="line">drwxr-xr-x 1 Administrator 197121   0 8月   2 20:52 ./</span><br><span class="line">drwxr-xr-x 1 Administrator 197121   0 8月   2 20:51 ../</span><br><span class="line">-rw-r--r-- 1 Administrator 197121 104 8月   2 20:52 config</span><br><span class="line">-rw-r--r-- 1 Administrator 197121  73 8月   2 20:52 description</span><br><span class="line">-rw-r--r-- 1 Administrator 197121  23 8月   2 20:52 HEAD</span><br><span class="line">drwxr-xr-x 1 Administrator 197121   0 8月   2 20:52 hooks/</span><br><span class="line">drwxr-xr-x 1 Administrator 197121   0 8月   2 20:52 info/</span><br><span class="line">drwxr-xr-x 1 Administrator 197121   0 8月   2 20:52 objects/</span><br><span class="line">drwxr-xr-x 1 Administrator 197121   0 8月   2 20:52 refs/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到裸库没有工作区，直接就是之前非裸库的.git下边的内容。</p>
<p><strong>submodule：</strong><br>用于在开发过程中一个模块依赖于另外一个模块的情况。<br>比如A模块需要使用B模块的代码，我们之前可以这样做，将B的代码打包成jar文件，然后上床到nexus之类的远端服务仓库，然后在其他开发者的机器上再maven upload下来，我们看到的B的只是class文件，这样没有问题，大部分也在使用这种模式，但是当B模块需要频繁的修改时，这就显得不合适了，需要频繁的上传下载，我们可以使用git子模块的方式submodule，A项目是一个git仓库，我们在A仓库里边在建立一个仓库B，注意A里边的B是B的源代码。</p>
<p>准备2个仓库，即2个项目：<br>子仓库：<br><img src="/2018/10/04/git-%E5%8D%81%E4%B8%89-git%E8%A3%B8%E5%BA%93%E4%B8%8Esubmodule/20170802211927985.png" alt="这里写图片描述"><br>父仓库：<br><img src="/2018/10/04/git-%E5%8D%81%E4%B8%89-git%E8%A3%B8%E5%BA%93%E4%B8%8Esubmodule/20170802212123602.png" alt="这里写图片描述"></p>
<p><strong>将子仓库纳入到父仓库：</strong><br>git submodule add <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzExNTY3MjE4NzQvY2hpbGQuZ2l0">https://github.com/1156721874/child.git<i class="fa fa-external-link-alt"></i></span> mymodule<br>mymodule必须是一个不存在的目录，否则git会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git submodule add https://github.com/1156721874/child.git mymodule</span><br><span class="line">Cloning into &#x27;E:/Study/mygit/mymodule&#x27;...</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">warning: LF will be replaced by CRLF in .gitmodules.</span><br><span class="line">The file will have its original line endings in your working directory.</span><br></pre></td></tr></table></figure>
<p>子模块出现在mygit中：<br><img src="/2018/10/04/git-%E5%8D%81%E4%B8%89-git%E8%A3%B8%E5%BA%93%E4%B8%8Esubmodule/20170802212522296.png" alt="这里写图片描述">；<br>当前mygit多出来mudule的配置文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ll -a</span><br><span class="line">total 19</span><br><span class="line">drwxr-xr-x 1 Administrator 197121  0 8月   2 21:23 ./</span><br><span class="line">drwxr-xr-x 1 Administrator 197121  0 8月   2 21:12 ../</span><br><span class="line">drwxr-xr-x 1 Administrator 197121  0 8月   2 21:23 .git/</span><br><span class="line">-rw-r--r-- 1 Administrator 197121 87 8月   2 21:23 .gitmodules</span><br><span class="line">drwxr-xr-x 1 Administrator 197121  0 8月   2 21:23 mymodule/</span><br><span class="line">-rw-r--r-- 1 Administrator 197121 54 7月  31 20:57 README.md</span><br><span class="line">-rw-r--r-- 1 Administrator 197121 44 8月   2 20:04 test.txt</span><br></pre></td></tr></table></figure>
<p>接下来我们在mygit里边将版本库提交到远程，然后在远程可以看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">warning: LF will be replaced by CRLF in .gitmodules.</span><br><span class="line">The file will have its original line endings in your working directory.</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/mygit (master)</span><br><span class="line">$ git commit -m &#x27;commit mymodule&#x27;</span><br><span class="line">[master 9f82bed] commit mymodule</span><br><span class="line"> 2 files changed, 4 insertions(+)</span><br><span class="line"> create mode 100644 .gitmodules</span><br><span class="line"> create mode 160000 mymodule</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/mygit (master)</span><br><span class="line">$ git push</span><br><span class="line">Counting objects: 3, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (3/3), done.</span><br><span class="line">Writing objects: 100% (3/3), 415 bytes | 0 bytes/s, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/1156721874/mygit.git</span><br><span class="line">   8004460..9f82bed  master -&gt; master</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/04/git-%E5%8D%81%E4%B8%89-git%E8%A3%B8%E5%BA%93%E4%B8%8Esubmodule/20170802213041221.png" alt="这里写图片描述">  </p>
<p>我们验证下在child下添加一个文件在mygit仓库的mymodule同步出现：<br><img src="/2018/10/04/git-%E5%8D%81%E4%B8%89-git%E8%A3%B8%E5%BA%93%E4%B8%8Esubmodule/20170802213719567.png" alt="这里写图片描述"></p>
<p>如果我们引用了很多的子模块我们是不是需要进入每一个子模块执行git pull呢？这样做显然是麻烦的，所以git提供了批量的方式：<br>git submodule foreach git pull</p>
<p>命令很明显，就是每个仓库执行git pull</p>
<p>这时候如果另外一个开发者加入进来，需要执行clone mygit操作：<br><img src="/2018/10/04/git-%E5%8D%81%E4%B8%89-git%E8%A3%B8%E5%BA%93%E4%B8%8Esubmodule/20170802215333635.png" alt="这里写图片描述"></p>
<p>我们虽然讲父级模块克隆下来，但是内容是空的，需要使用【 git submodule init】初始化子模块，然后【 git submodule update –recursive<br>】递归更新子模块内容。</p>
<p>其实我跟在座的读者兜了一个圈子，哈哈，我们完全可以使用一条命令将所有的子模块下载下来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git submodule add https://github.com/1156721874/child.git mymodule --recursive</span><br></pre></td></tr></table></figure>
<p>克隆的时候加上参数 –recursive即可。</p>
<p>此时在父级模块mygit里边的.git目录下出现modules文件件，进入modules是一个完整的仓库的配合格局：<br><img src="/2018/10/04/git-%E5%8D%81%E4%B8%89-git%E8%A3%B8%E5%BA%93%E4%B8%8Esubmodule/20170802220455849.png" alt="这里写图片描述"></p>
<p>mymodule的删除，git没有提供直接的命令删除submodule，但是我们可以使用一系列命令组合完成删除：<br><img src="/2018/10/04/git-%E5%8D%81%E4%B8%89-git%E8%A3%B8%E5%BA%93%E4%B8%8Esubmodule/20170802221743396.png" alt="这里写图片描述"><br>即：<br>第一： git rm –cached mymodule&#x2F; 删除暂存区文件<br>第二：rm -rf mymodule&#x2F; 删除工作区文件<br>第三：提交删除：<br>第四：推送到远程仓库：<br>第五：抓状态恢复正常。</p>
<p>远程仓库的当然也会删除掉：<br><img src="/2018/10/04/git-%E5%8D%81%E4%B8%89-git%E8%A3%B8%E5%BA%93%E4%B8%8Esubmodule/20170802222005477.png" alt="这里写图片描述"></p>
<p>最后说一下这种submodule的项目管理方式和jar嵌入的方式的不同点就是，jar包的形式是子模块很少发生代码的变化，而submodule的方式是用在依赖的子模块变动非常大的情况。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>裸库</tag>
        <tag>submodule</tag>
      </tags>
  </entry>
  <entry>
    <title>git(十二)-git gc</title>
    <url>/2018/10/04/git-%E5%8D%81%E4%BA%8C-git-gc/</url>
    <content><![CDATA[<p>在执行git gc之前我们看一下.git目录的一些信息：<br>refs目录下边有三个文件夹：</p>
<span id="more"></span>
<p><img src="/2018/10/04/git-%E5%8D%81%E4%BA%8C-git-gc/20170802195110448.png" alt="这里写图片描述"><br>此三个文件夹下边都存在一些本地、远程分支的信息，以及标签的 信息。</p>
<p>执行git gc：<br>执行完毕之后，heads、remotes、tags下边的内容消失，git并不是删除了这些信息，而是存放在 .git&#x2F;packed-refs文件里边，即进行了压缩。<br><img src="/2018/10/04/git-%E5%8D%81%E4%BA%8C-git-gc/20170802195304125.png" alt="这里写图片描述"><br>通过里边的内容我们还可以验证带有注释标签的一些信息，v1.0只有一个id指向的就是一个commitid，而带有注释的v2.0有两个id第一id是其本身，第二个是指向的commitid，可以看到id前边有个“^”符号。</p>
<p>此时我们如果在进行一次提交和推送，那么又会在.git&#x2F;refs&#x2F;下边出现新的内容记录git的信息：<br><img src="/2018/10/04/git-%E5%8D%81%E4%BA%8C-git-gc/20170802200643650.png" alt="这里写图片描述"><br>如图我们对test.txt进行了提交，在.git&#x2F;refs&#x2F;heads和.git&#x2F;refs&#x2F;remotes下边出现了新的内容，而不是放在.git&#x2F;packed-refs文件里边。</p>
<p>此外git gc还会对每次提交的文件进行压缩，我们知道git和svn的区别就是git是全量记录文件的提交，而svn是记录变化量，既然git 记录的是全量的文件，那是不是会很大，占用空间，并且是怎么存放的呢？<br>其实所有的提交文件记录都在.git&#x2F;objects&#x2F;里边：<br><img src="/2018/10/04/git-%E5%8D%81%E4%BA%8C-git-gc/20170802202341094.png" alt="这里写图片描述"><br>执行git gc之后文件都会&#x3D;消失，转而放在pack目录下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git gc</span><br><span class="line">Counting objects: 18, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (10/10), done.</span><br><span class="line">Writing objects: 100% (18/18), done.</span><br><span class="line">Total 18 (delta 4), reused 15 (delta 4)</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/mygit (master)</span><br><span class="line">$ ls .git/objects/</span><br><span class="line">info/  pack/</span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/mygit (master)</span><br><span class="line">$ ls .git/objects/pack/</span><br><span class="line">pack-94d0a6b4da258363c6f774e525a8615469b64e03.idx  pack-94d0a6b4da258363c6f774e525a8615469b64e03.pack</span><br></pre></td></tr></table></figure>

<p>复习：<br>将一个文件从暂存区删除，但是保存在工作区：<br>git rm –cached test.txt<br>重命名文件：<br>git mv  test.txt test2.txt &#x3D; git rm test.txt  + git add  test2.txt<br>重命名远程仓库：<br>git remote rename origin origin2<br>删除远程仓库:<br>git remote rm origin</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>gitgc</tag>
      </tags>
  </entry>
  <entry>
    <title>git(十五)-git cherry-pick</title>
    <url>/2018/10/04/git-%E5%8D%81%E4%BA%94-git-cherry-pick/</url>
    <content><![CDATA[<p>cherry-pick：现在有哦2个分支和dev和master，我们在dev下边进行了2此提交，我们这个时候发现这个2个提交不应该发生在dev分支，应该在master分支进行，于是我们把dev当前修改的内容的文件被备份到其他的地方存储，然后将dev回退到之前没有修改的状态，紧接着切换到master分支，将备份的文件覆盖master上对应的文件，完成修正，这种方法能解决问题，但是效率太低了，并且容易出现问题。此时我们可以使用cherry-pick将这2次提交应用到master分支。<br>演示：</p>
<span id="more"></span>
<p>在dev分支做2次提交<br><img src="/2018/10/04/git-%E5%8D%81%E4%BA%94-git-cherry-pick/20170805121857928.png" alt="这里写图片描述"></p>
<p>出线2次提交的id：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dministrator@CeaserWang MINGW64 /e/Study/child (dev)</span><br><span class="line">$ git log -3</span><br><span class="line">commit db37ad8478eea03a8315fc74bd6f9e16d71b6e43 (HEAD -&gt; dev)</span><br><span class="line">Author: zhangsan &lt;zhangsan@git.com&gt;</span><br><span class="line">Date:   Sat Aug 5 12:16:11 2017 +0800</span><br><span class="line"></span><br><span class="line">    add line2</span><br><span class="line"></span><br><span class="line">commit f46e43054c20537fbecbc0502223015a61eef957</span><br><span class="line">Author: zhangsan &lt;zhangsan@git.com&gt;</span><br><span class="line">Date:   Sat Aug 5 12:15:34 2017 +0800</span><br><span class="line"></span><br><span class="line">    add line 1</span><br><span class="line"></span><br><span class="line">commit 4a510291d57a857337d567a43401e3b636da0a0c (origin/master, master)</span><br><span class="line">Author: zhangsan &lt;zhangsan@git.com&gt;</span><br><span class="line">Date:   Sat Aug 5 11:48:40 2017 +0800</span><br><span class="line"></span><br><span class="line">    add child4 and child5</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 此时返现分支搞错了，不应该在dev下边做这2次提交，应该是在master下做，解决方式：</p>
<p>在master使用 git cherry-pick 《dev提交id》</p>
<p> <img src="/2018/10/04/git-%E5%8D%81%E4%BA%94-git-cherry-pick/20170805122325346.png" alt="这里写图片描述"><br>我们能否直接 git cherry-pick   db37ad8478eea03a8315fc74bd6f9e16d71b6e43  这个id呢？做个试验，在dev新增2个提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit 6525f476721e83d0254a785b1d3b8a44d3ad2400 (HEAD -&gt; dev)</span><br><span class="line">Author: zhangsan &lt;zhangsan@git.com&gt;</span><br><span class="line">Date:   Sat Aug 5 13:18:54 2017 +0800</span><br><span class="line"></span><br><span class="line">    add 2 lines</span><br><span class="line"></span><br><span class="line">commit db37ad8478eea03a8315fc74bd6f9e16d71b6e43</span><br><span class="line">Author: zhangsan &lt;zhangsan@git.com&gt;</span><br><span class="line">Date:   Sat Aug 5 12:16:11 2017 +0800</span><br><span class="line"></span><br><span class="line">    add line2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后切换到master分支，我们直接 git cherry-pick 6525f476721e83d0254a785b1d3b8a44d3ad2400 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> git cherry-pick 6525f476721e83d0254a785b1d3b8a44d3ad2400</span><br><span class="line">[master 27ffd95] add 2 lines</span><br><span class="line"> Date: Sat Aug 5 13:18:54 2017 +0800</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/child (master)</span><br><span class="line">$ cat line.txt</span><br><span class="line">line 1</span><br><span class="line">line2</span><br><span class="line"> line 4</span><br><span class="line"> line 5</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到可以直接跨commit id 进行操作。</p>
<p>还有一个遗留问题：<br>dev分支需要还原到初始状态，<br>初始状态所在位置：<br><img src="/2018/10/04/git-%E5%8D%81%E4%BA%94-git-cherry-pick/20170805133311617.png" alt="这里写图片描述"><br>1、 git checkout aa261fee67458af84f3406d4f132232ca3c8825b</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout aa261fee67458af84f3406d4f132232ca3c8825b</span><br><span class="line">Note: checking out &#x27;aa261fee67458af84f3406d4f132232ca3c8825b&#x27;.</span><br><span class="line"></span><br><span class="line">You are in &#x27;detached HEAD&#x27; state. You can look around, make experimental</span><br><span class="line">changes and commit them, and you can discard any commits you make in this</span><br><span class="line">state without impacting any branches by performing another checkout.</span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line">do so (now or later) by using -b with the checkout command again. Example:</span><br><span class="line"></span><br><span class="line">  git checkout -b &lt;new-branch-name&gt;</span><br><span class="line"></span><br><span class="line">HEAD is now at aa261fe... add welcome in hello.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、 git branch -D dev<br>3、 git checkout -b dev</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>cherry-pack</tag>
      </tags>
  </entry>
  <entry>
    <title>git(十六) git rebase 原理深度剖析</title>
    <url>/2018/10/04/git-%E5%8D%81%E5%85%AD-git-rebase-%E5%8E%9F%E7%90%86%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<p>rebase：变基，意即改变分支的根基<br>从某种程度来说，rebase和merge可以完成类似的工作，不过2者的工作方式有显著的差异。</p>
<span id="more"></span>
<p><strong>我们先从merge切入看看merge和rebase的差异。</strong><br><img src="/2018/10/04/git-%E5%8D%81%E5%85%AD-git-rebase-%E5%8E%9F%E7%90%86%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/20170805173058949.png" alt="这里写图片描述"></p>
<p>merge的2个节点origin和mywork都有公共的祖先c2：<br><img src="/2018/10/04/git-%E5%8D%81%E5%85%AD-git-rebase-%E5%8E%9F%E7%90%86%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/20170805173209090.png" alt="这里写图片描述"></p>
<p>执行merge：<br><img src="/2018/10/04/git-%E5%8D%81%E5%85%AD-git-rebase-%E5%8E%9F%E7%90%86%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/20170805173254089.png" alt="这里写图片描述">  </p>
<p><strong>rebase</strong><br>• git checkout mywork<br>• git rebase origin<br><img src="/2018/10/04/git-%E5%8D%81%E5%85%AD-git-rebase-%E5%8E%9F%E7%90%86%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/20170805173401824.png" alt="这里写图片描述">	 </p>
<p><img src="/2018/10/04/git-%E5%8D%81%E5%85%AD-git-rebase-%E5%8E%9F%E7%90%86%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/20170805173446088.png" alt="这里写图片描述">  </p>
<p>历史区别：<br><img src="/2018/10/04/git-%E5%8D%81%E5%85%AD-git-rebase-%E5%8E%9F%E7%90%86%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/20170805173535613.png" alt="这里写图片描述">  </p>
<p><img src="/2018/10/04/git-%E5%8D%81%E5%85%AD-git-rebase-%E5%8E%9F%E7%90%86%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/20170805173613469.png" alt="这里写图片描述">  </p>
<p><strong>rebase注意事项</strong><br>• rebase过程中也会出现冲突<br>• 解决冲突后，使⽤用git add添加，然后执⾏行行<br>• git rebase - - continue<br>• 接下来Git会继续应⽤用余下的补丁<br>• 任何时候都可以通过如下命令终⽌止rebase，分⽀支会恢复到<br>rebase开始前的状态<br>• git rebase - - abort</p>
<p><strong>rebase最佳实践</strong><br>• <strong>不不要对master分⽀支执⾏行行rebase，否则会引起很多<br>问题</strong><br>• <strong>⼀一般来说，执⾏行行rebase的分⽀支都是⾃自⼰己的本地分<br>⽀支，没有推送到远程版本库</strong></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>rebase</tag>
      </tags>
  </entry>
  <entry>
    <title>git(十四)-git subtree</title>
    <url>/2018/10/04/git-%E5%8D%81%E5%9B%9B-git-subtree/</url>
    <content><![CDATA[<p>git submodule弊端：<br> 这篇文章指出了submodule的一些问题： <span class="exturl" data-url="aHR0cDovL3d3dy5jb2NvYWNoaW5hLmNvbS9pbmR1c3RyeS8yMDEzMDUwOS82MTYxLmh0bWw=">http://www.cocoachina.com/industry/20130509/6161.html<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<p>，还有就是submodule的删除git没有直接的命令操作，需要开发者自己使用若干命令组合完成删除，因此在git的后续版本出现了subtree。</p>
<p>subtree：<br>新建2个工程一个是parent，一个是subtree<br><img src="/2018/10/04/git-%E5%8D%81%E5%9B%9B-git-subtree/20170803212211962.png" alt="这里写图片描述"><br><img src="/2018/10/04/git-%E5%8D%81%E5%9B%9B-git-subtree/20170803212247520.png" alt="这里写图片描述">  </p>
<p>在父级模块添加子模块作为subtree：<br>第一：$ git remote add subtree-origin <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzExNTY3MjE4NzQvY2hpbGQuZ2l0">https://github.com/1156721874/child.git<i class="fa fa-external-link-alt"></i></span><br>第二： git subtree add –prefix&#x3D;subtree subtree-origin master –squash<br>解释：建立一个从master分支拉取的本地仓库subtree ，squash的意思是将子模块的多次提交汇总成一次提交拉取下来。携带此参数，在父级的模块的提交日志中不会出现subtree模块开发者的提交日志，都是父级模块开发者的提交日志。不携带squash参数，才会将subtree的开发者的提交日志一并拉取过来。squash属于merge操作的一个参数和subtree没有关系，这个参数<strong>如果在关联subtree的时候使用了，那么后续的操作也要使用这个参数</strong>，不然会出现问题，问题的原因可能是：我们在push的时候会进行一次merge，而merge操作需要三方协调，合并的2个节点必须要有公共的父亲，但是squash参数形成的节点不会存在它前一个节点的指针，即找不到公共的父亲，因此push的时候会失败。<br><img src="/2018/10/04/git-%E5%8D%81%E5%9B%9B-git-subtree/20170803214030020.png" alt="这里写图片描述"></p>
<p>子模块内容可以立刻出出现：<br><img src="/2018/10/04/git-%E5%8D%81%E5%9B%9B-git-subtree/20170803214203016.png" alt="这里写图片描述"></p>
<p>此时我们将parent 工程推送到远程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push</span><br><span class="line">Counting objects: 5, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (3/3), done.</span><br><span class="line">Writing objects: 100% (5/5), 592 bytes | 0 bytes/s, done.</span><br><span class="line">Total 5 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/1156721874/mygit.git</span><br><span class="line">   33f9e75..9db9adb  master -&gt; master</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们在远程看一下subtree的样子：<br><img src="/2018/10/04/git-%E5%8D%81%E5%9B%9B-git-subtree/20170803220135609.png" alt="这里写图片描述"><br>然后点进去：<br><img src="/2018/10/04/git-%E5%8D%81%E5%9B%9B-git-subtree/20170803220205091.png" alt="这里写图片描述"></p>
<p>可以看到他和submodule不同，submodule的子模块是另一个仓库的一个连接，点进去直接就去了另外一个仓库，而subtree不是这样的。</p>
<p><strong>接下来我们在子模块添加一个文件然后推送到远程，之后在父级模块更新下来这次修改：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo &#x27;hello world &#x27; &gt; hello.txt</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/child (master)</span><br><span class="line">$ git add .</span><br><span class="line">warning: LF will be replaced by CRLF in hello.txt.</span><br><span class="line">The file will have its original line endings in your working directory.</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/child (master)</span><br><span class="line">$ git commit -m &#x27;add helllo world&#x27;</span><br><span class="line">[master 4be81af] add helllo world</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 hello.txt</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/child (master)</span><br><span class="line">$ git push</span><br><span class="line">fatal: TaskCanceledException encountered.</span><br><span class="line">   ▒▒ȡ▒▒һ▒▒▒▒▒▒</span><br><span class="line">Username for &#x27;https://github.com&#x27;: 1156721874@qq.com</span><br><span class="line">Counting objects: 3, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (3/3), 285 bytes | 0 bytes/s, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/1156721874/child.git</span><br><span class="line">   2463028..4be81af  master -&gt; master</span><br></pre></td></tr></table></figure>
<p>然后在父级模块我们更新子模块：<br>执行：git subtree pull  –prefix&#x3D;subtree subtree-origin master –squash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git subtree pull  --prefix=subtree subtree-origin master --squash</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From https://github.com/1156721874/child</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line">   2463028..4be81af  master     -&gt; subtree-origin/master</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> subtree/hello.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 subtree/hello.txt</span><br><span class="line"></span><br><span class="line">$ ls</span><br><span class="line">parent.txt  README.md  subtree/</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/mygit (master)</span><br><span class="line">$ ls subtree/</span><br><span class="line">hello.txt  subtree.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到hello.txt出现在子模块中。</p>
<p><strong>我们在做第二种入口的操作，在父级模块直接修改subtree子模块，然后在子模块仓库拉取所做的更新：</strong><br><img src="/2018/10/04/git-%E5%8D%81%E5%9B%9B-git-subtree/20170803223143761.png" alt="这里写图片描述"><br>在远程的github，我们进入父级仓库的subtree查看刚才的修改：<br><img src="/2018/10/04/git-%E5%8D%81%E5%9B%9B-git-subtree/20170803223258752.png" alt="这里写图片描述"><br>可以看到修改被推送成功。</p>
<p>在subtree仓库我们pull拉取刚才的推送：<br><img src="/2018/10/04/git-%E5%8D%81%E5%9B%9B-git-subtree/20170805101343339.png" alt="这里写图片描述"><br><img src="/2018/10/04/git-%E5%8D%81%E5%9B%9B-git-subtree/20170805101545364.png" alt="这里写图片描述"></p>
<p> <strong>另外一个问题：</strong><br> 1、我们在subtree修改了一个文件hello.txt，然后提交推送到远程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Administrator@CeaserWang MINGW64 /e/Study/child (master)</span><br><span class="line">$ echo &#x27;welcome git &#x27; &gt;&gt; hello.txt</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/child (master)</span><br><span class="line">$ cat hello.txt</span><br><span class="line">hello world</span><br><span class="line">ok ok ok</span><br><span class="line">welcome git</span><br><span class="line">$ git add .</span><br><span class="line">warning: LF will be replaced by CRLF in hello.txt.</span><br><span class="line">The file will have its original line endings in your working directory.</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/child (master)</span><br><span class="line">$ git commit -m &#x27;add welcome in hello.txt&#x27;</span><br><span class="line">[master aa261fe] add welcome in hello.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/child (master)</span><br><span class="line">$ git push</span><br><span class="line">Counting objects: 3, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (3/3), 309 bytes | 0 bytes/s, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/1156721874/child.git</span><br><span class="line">   66caa3a..aa261fe  master -&gt; master</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2、之后我们在subtree的父级仓库，pull拉取下来subtree的修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Administrator@CeaserWang MINGW64 /e/Study/mygit (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">Administrator@CeaserWang MINGW64 /e/Study/mygit (master)</span><br><span class="line">$ git subtree pull  --prefix=subtree subtree-origin master --squash</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From https://github.com/1156721874/child</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line">   66caa3a..aa261fe  master     -&gt; subtree-origin/master</span><br><span class="line">Auto-merging subtree/hello.txt</span><br><span class="line">CONFLICT (content): Merge conflict in subtree/hello.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>出现了一个冲突：CONFLICT (content): Merge conflict in subtree&#x2F;hello.txt<br>3、冲突的导致原因：<br>我们看一下冲突的文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat subtree/hello.txt</span><br><span class="line">hello world</span><br><span class="line">ok ok ok</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">=======</span><br><span class="line">welcome git</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; 95b3323c6bb088bf8968982a5d592c38c1e2f889</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们看到HEAD的指向是空的，按照一般的逻辑，这个 git subtree pull可以fast forward，但是为什么会出现冲突，原因还是在于squash这个参数，pull需要进行fetch 和merge操作，而merge需要三方参与，但是squash把subtree的多次提交合并为一条新的commit，merge的两个节点没有共同的父亲，导致冲突。这就是squash在某些场景不会产生冲突，但是实际产生冲突的根本原因所在。所以还是那条准则，squash如果使用全部都是用，不使用，全部都不使用。</p>
<p>个人建议：使用subtree的时候不要使用squash参数。</p>
<p>在前边的subtree的时候使用squash，有一个场景就是 在subtree里边我们做了多次提交，然后在subtree的父级仓库里边subtree pull的时候会出现冲突，但是我们不使用squash同样流程的操作也会出现冲突，我们的解释是使用squash找不到共同的祖先节点导致冲突，看一下gitk：<br><img src="/2018/10/04/git-%E5%8D%81%E5%9B%9B-git-subtree/20170805115320028.png" alt="这里写图片描述"></p>
<p>左右2条线一直往上追踪没有了交点，这是出现冲突的根本原因所在。追根到底是2个仓库导致的。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>subtree</tag>
      </tags>
  </entry>
  <entry>
    <title>git(四)-分支进阶与版本回退</title>
    <url>/2018/10/04/git-%E5%9B%9B-%E5%88%86%E6%94%AF%E8%BF%9B%E9%98%B6%E4%B8%8E%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/</url>
    <content><![CDATA[<p>当前只有一个分支：<br><img src="/2018/10/04/git-%E5%9B%9B-%E5%88%86%E6%94%AF%E8%BF%9B%E9%98%B6%E4%B8%8E%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/20170730111032675.png" alt="这里写图片描述"></p>
<span id="more"></span>

<p>刚刚创建了一个dev分支：<br><img src="/2018/10/04/git-%E5%9B%9B-%E5%88%86%E6%94%AF%E8%BF%9B%E9%98%B6%E4%B8%8E%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/20170730111132706.png" alt="这里写图片描述"></p>
<p>dev分支进行了修改并且提交，形成新的节点：<br><img src="/2018/10/04/git-%E5%9B%9B-%E5%88%86%E6%94%AF%E8%BF%9B%E9%98%B6%E4%B8%8E%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/20170730111230311.png" alt="这里写图片描述"></p>
<p>将分支进行合并：<br><img src="/2018/10/04/git-%E5%9B%9B-%E5%88%86%E6%94%AF%E8%BF%9B%E9%98%B6%E4%B8%8E%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/20170730111328285.png" alt="这里写图片描述"><br>这种merge是一种平fast forward的快进的方式，就是将master的指针指向dev的提交节点位置，不会产生新的提交。</p>
<p>将dev分支删除之后：<br><img src="/2018/10/04/git-%E5%9B%9B-%E5%88%86%E6%94%AF%E8%BF%9B%E9%98%B6%E4%B8%8E%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/20170730111528831.png" alt="这里写图片描述"></p>
<p>分支 合并冲突，在第三个节点创建feature1分支，然后在feature1进行了一次提交，然后在master进行了一次提交，最后合并：<br><img src="/2018/10/04/git-%E5%9B%9B-%E5%88%86%E6%94%AF%E8%BF%9B%E9%98%B6%E4%B8%8E%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/20170730111839977.png" alt="这里写图片描述">  </p>
<p>fast-forward：<br>• 如果可能，合并分⽀支时Git会使⽤用fast-forward模式<br>• 在这种模式下，删除分⽀支时会丢掉分⽀支信息<br>• 合并时加上 - - no-ff参数会禁⽤用fast-forward，这样会多出⼀一<br>个commit id<br>• git merge - -no-ff dev<br>• 查看log<br>• git log - -graph</p>
<p>实际操作验证非快进提交：<br><img src="/2018/10/04/git-%E5%9B%9B-%E5%88%86%E6%94%AF%E8%BF%9B%E9%98%B6%E4%B8%8E%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/20170730112802333.png" alt="这里写图片描述"></p>
<p>切换到master：<br><img src="/2018/10/04/git-%E5%9B%9B-%E5%88%86%E6%94%AF%E8%BF%9B%E9%98%B6%E4%B8%8E%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/20170730113137409.png" alt="这里写图片描述">  </p>
<p>然后执行：git merge –no-ff dev</p>
<p>此时出现提交界面：<br><img src="/2018/10/04/git-%E5%9B%9B-%E5%88%86%E6%94%AF%E8%BF%9B%E9%98%B6%E4%B8%8E%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/20170730113325901.png" alt="这里写图片描述">  </p>
<p>最后我们merge完毕之后看master的日志：<br><img src="/2018/10/04/git-%E5%9B%9B-%E5%88%86%E6%94%AF%E8%BF%9B%E9%98%B6%E4%B8%8E%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/20170730113547340.png" alt="这里写图片描述"></p>
<p>很明显出现了一次提交，这样就保留了分支不被删除。</p>
<p><strong>版本的回退：</strong><br>当前版本库有四次提交;<br><img src="/2018/10/04/git-%E5%9B%9B-%E5%88%86%E6%94%AF%E8%BF%9B%E9%98%B6%E4%B8%8E%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/20170730115924491.png" alt="这里写图片描述"></p>
<p><img src="/2018/10/04/git-%E5%9B%9B-%E5%88%86%E6%94%AF%E8%BF%9B%E9%98%B6%E4%B8%8E%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/20170730120647419.png" alt="这里写图片描述"></p>
<p>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at 25db944 third commit</span><br><span class="line"></span><br><span class="line"> $ git reset --hard HEAD^^</span><br><span class="line">HEAD is now at adeef6e fisrt commit in test.txt</span><br><span class="line"></span><br><span class="line">$ git reset --hard 8214</span><br><span class="line">HEAD is now at 821425d fourth commit</span><br><span class="line"></span><br><span class="line">$ git reset --hard HEAD~2</span><br><span class="line">HEAD is now at 1806ac5 second commit</span><br><span class="line"></span><br><span class="line">``</span><br><span class="line">另外我们在回退的时候，在想回去的话，之前的版本号我们没法通过git log命令找到，因为git log记录的是提交记录。</span><br><span class="line">但是我们可以使用git reflog命令得到版本号。git reflog记录的是工作日志。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$ git reflog<br>1806ac5 (HEAD -&gt; master) HEAD@{0}: reset: moving to HEAD~2<br>821425d HEAD@{1}: reset: moving to 8214<br>adeef6e HEAD@{2}: reset: moving to HEAD^^<br>25db944 HEAD@{3}: reset: moving to HEAD^<br>821425d HEAD@{4}: commit: fourth commit<br>25db944 HEAD@{5}: commit: third commit<br>1806ac5 (HEAD -&gt; master) HEAD@{6}: commit: second commit<br>adeef6e HEAD@{7}: commit (initial): fisrt commit in test.txt</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>版本回退</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop(1.1.2)+hbase0.98+hive+pig+sqoop+mysql+vsftp+tomcat+linux搭建命令</title>
    <url>/2018/09/28/hadoop-1-1-2-hbase0-98-hive-pig-sqoop-mysql-vsftp-tomcat-linux%E6%90%AD%E5%BB%BA%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><strong>一、linux基本操作</strong></p>
<span id="more"></span>
<pre><code>Linux系统下要和外界进行文件传输需要使用ftp，对此需要搭建ftp服务
</code></pre>
<p><strong>(1)vsftp install :</strong><br>        reference file :&#x2F;mnt&#x2F;linuxshare&#x2F;RHEL 5.2下vsftp配置全教程 - 51CTO.COM.htm<br>        install:<br>        rpm -ivh vsftpd-2.0.5-12.el5.rpm<br>        start:<br>        service vsftpd start<br>        安装完成后，vsftpd配置文件为&#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf，通过以下命令可启动vsftpd并将其设置为自动启动。<br>           service vsftpd restart<br>        chkconfig vsftpd on<br>        使用ftp需要关闭防火墙，把Linux的防火墙清空:<br>        iptables -F<br>        service iptables stop<br>        chkconfig iptables off<br><strong>(2)linux cloudy install package（linux云应用安装）</strong><br>    &#x2F;mnt&#x2F;linuxshare&#x2F;epel-release-5-4.noarch.rpm<br><strong>(3)Linux下配置环境变量：</strong><br>        1.修改&#x2F;etc&#x2F;profile文件<br>        如果你的计算机仅仅作为开发使用时推荐使用这种方法，因为所有用户的shell都有权使用这些环境变量，可能会给系统带来安全性问题。<br>        (1)用文本编辑器打开&#x2F;etc&#x2F;profile<br>        (2)在profile文件末尾加入：<br>        JAVA_HOME&#x3D;&#x2F;usr&#x2F;share&#x2F;jdk1.5.0_05<br>        PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH<br>        CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar<br>        export JAVA_HOME<br>        export PATH<br>        export CLASSPATH</p>
<pre><code>    一、linux基本操作
    Linux系统下要和外界进行文件传输需要使用ftp，对此需要搭建ftp服务
    (1)vsftp install :
    reference file :/mnt/linuxshare/RHEL 5.2下vsftp配置全教程 - 51CTO.COM.htm
    install:
    rpm -ivh vsftpd-2.0.5-12.el5.rpm
    start:
    service vsftpd start
    安装完成后，vsftpd配置文件为/etc/vsftpd/vsftpd.conf，通过以下命令可启动vsftpd并将其设置为自动启动。
       service vsftpd restart
    chkconfig vsftpd on
    使用ftp需要关闭防火墙，把Linux的防火墙清空:
    iptables -F
    service iptables stop
    chkconfig iptables off
    (2)linux cloudy install package（linux云应用安装）
    /mnt/linuxshare/epel-release-5-4.noarch.rpm
    (3)Linux下配置环境变量：
    1.修改/etc/profile文件
    如果你的计算机仅仅作为开发使用时推荐使用这种方法，因为所有用户的shell都有权使用这些环境变量，可能会给系统带来安全性问题。
    (1)用文本编辑器打开/etc/profile
    (2)在profile文件末尾加入：
    JAVA_HOME=/usr/share/jdk1.5.0_05
    PATH=$JAVA_HOME/bin:$PATH
    CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
    export JAVA_HOME
    export PATH
    export CLASSPATH
</code></pre>
<p> <strong>(4)jdk的安装与卸载</strong><br>            <strong>jdk卸载</strong><br>            卸载默认的：<br>            用root用户登陆到系统，打开一个终端输入<br>             rpm -qa|grep gcj<br>            显示内容其中包含下面两行信息<br>             java-1.4.2-gcj-compat-1.4.2.0-27jpp<br>             java-1.4.2-gcj-compat-devel-l.4.2.0-27jpp<br>            卸载<br>             rpm -e java-1.4.2-gcj-compat-devel-l.4.2.0-27jpp<br>             rpm -e java-1.4.2-gcj-compat-l.4.2.0-27jpp<br>            卸载其他自己安装的JDK就直接用rpm -e <javaXXXXX><br>       <strong>卸载rpm版的jdk：</strong><br>               #rpm -qa|grep jdk<br>               显示：jdk-1.6.0_10-fcs<br>               卸载：#rpm -e  –nodeps  jdk-1.6.0_10-fcs</p>
<p><strong>(5)设置环境变量汇总</strong></p>
<pre><code>            1、/etc/profile设置环境变量
            a. 你要将 /usr/share/jdk1.5.0_05jdk 改为你的jdk安装目录
            b. linux下用冒号“:”来分隔路径
            c. $PATH / $CLASSPATH / $JAVA_HOME 是用来引用原来的环境变量的值,在设置环境变量时特别要注意不能把原来的值给覆盖掉了，这是一种常见的错误。
            d. CLASSPATH中当前目录“.”不能丢,把当前目录丢掉也是常见的错误。
            e. export是把这三个变量导出为全局变量。
            f. 大小写必须严格区分。

            2. 修改.bashrc文件　　
            这种方法更为安全，它可以把使用这些环境变量的权限控制到用户级别，如果你需要给某个用户权限使用这些环境变量，你只需要修改其个人用户主目录下的.bashrc文件就可以了。
            (1)用文本编辑器打开用户目录下的.bashrc文件
            (2)在.bashrc文件末尾加入：　　
            set JAVA_HOME=/usr/java/jdk1.7.0_55
            export JAVA_HOME
            set PATH=$JAVA_HOME/bin:$PATH
            export PATH
            set CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
            export CLASSPATH
            (3)重新登录

            3. 直接在shell下设置变量
            不赞成使用这种方法，因为换个shell，你的设置就无效了，因此这种方法仅仅是临时使用，以后要使用的时候又要重新设置，比较麻烦。
            只需在shell终端执行下列命令：
            export JAVA_HOME=/usr/java/jdk1.7.0_55
            export PATH=$JAVA_HOME/bin:$PATH
            export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
</code></pre>
<p><strong>(6)压缩包的压缩与解压与其他</strong><br>            tar -zxvf apache-tomcat-6.0.39.tar.gz<br>            gzip -d apache-tomcat-6.0.39.tar.gz<br>              查看当前进程<br>            ps -ef|grep tomcat<br><strong>(7)杀死进程</strong><br>             kill -9 idnum<br>            命令行上网<br>            wget <span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguMS4xMjYv">http://192.168.1.126<i class="fa fa-external-link-alt"></i></span><br>            rpm的查看与卸载<br>            rpm: redhat package management<br>            rpm -qa|grep jdk 查看linux安装的包<br>            rpm -e 包名 卸载<br><strong>(7)小结</strong><br>            &#x2F;etc&#x2F;profile  有用户登陆设置环境变量（命令：source &#x2F;etc&#x2F;profile 可以让设置生效）<br>            &#x2F;etc&#x2F;bashrc  设置的命令 如果一有用户登陆就执行初始化脚本。<br>            &#x2F;home&#x2F;wzq(用户)  .bash_profile为单独的用户设置环境变量<br>            &#x2F;home&#x2F;wzq(用户)  .bashrc 为单独的用户登录时执行的脚本（执行的程序）<br>            &#x2F;etc&#x2F;rc.local    开机启动执行的脚本<br>            举例tomcat：<br>            JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.7.0_55<br>            PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH<br>            CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar<br>            export JAVA_HOME<br>            export PATH<br>            export CLASSPATH<br>            启动：&#x2F;tomcat6&#x2F;bin&#x2F;startup.sh</p>
<pre><code>    mysqladmin -u root password &quot;operater&quot;  设置mysql密码
    启动mysql：
    service mysql start
    开机启动：
    chkconfig iptables on

    注意：
    修改MySQL数据库root用户的初始密码，先查下初始密码
    [root@vmoel5u4 mysql_installer]# vi /root/.mysql_secret
    设置初始密码即可
</code></pre>
<p><strong>(8)修改主机名</strong></p>
<pre><code>修改当前回话的主机名：hostname hadoop
永久修改主机名文件所在目录：vi /etc/sysconfig/network
ip和主机名绑定：vi /etc/hosts  加入一行：
10.164.10.100 hadoop
重启网卡：service network restart
测试：ping hadoop
</code></pre>
<p><strong>(9)SSH的免密码登陆：</strong><br>        ssh-keygen -t rsa 生成秘钥文件<br>        cp ~&#x2F;.ssh&#x2F;id_rsa.pub ~&#x2F;.ssh&#x2F;authorized_keys<br>        注意：此处一定要设置，不然jobtracker无法启动！！！另外可以把所有机器上的所有authorized_keys收集起来放在一个大的authorized_keys文件里边，然后用这个大的文件分别覆盖<br>        所有机器的authorized_keys文件，可以实现所有机器之间的免密码登陆。<br>        hadoop环境搭建<br><strong>（10）hadoop设置环境变量</strong><br>        &#x2F;etc&#x2F;profile<br>        export JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.7.0_55<br>        export HADOOP_HOME&#x3D;&#x2F;usr&#x2F;hadoop<br>        export PATH&#x3D;.:$HADOOP_HOME&#x2F;bin:$JAVA_HOME&#x2F;bin:$PATH<br>        export CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar<br>        export JAVA_HOME<br>        export PATH<br>        export CLASSPATH<br><strong>（11）修改配置</strong><br>        修改$HADOOP_HOME_HOME&#x2F;conf下的hadoop-env.sh、core-site.xml、hdfs-site.xml、mapred-site.xml<br>        细节见文档<br>        非伪分布特殊配置<br>        config&#x2F;masters  文件里边配置jobtracker所在节点所在机器<br>        config&#x2F;slaves   文件里边配置datanode和tasktracker所在节点的机器<br><strong>（12）hadoop格式化</strong><br>            hadoop namenode -format<br>            windows&#x2F;linux下查看进程的命令：jps<br><strong>(13)启动hadoop:start-all.sh   启动5个java进程如下</strong><br>            5500 JobTracker<br>            4660 NameNode<br>            4251 Bootstrap<br>            4914 SecondaryNameNode<br>            5659 Jps<br>            4774 DataNode<br>            5091 TaskTracker<br>            验证：<br>            linux下浏览器，hadoop:50070(namaeNode),hadoop:50030(jobTracker)<br>            windows下验证需要绑定主机名：修改文件路径如下：<br>            C:\Windows\System32\drivers\etc\hosts文件<br>            加入一行：192.168.1.123 hadoop</p>
<p><strong>（14）Warning: $HADOOP_HOME is deprecated.的修改</strong><br>            加入一行：export HADOOP_HOME_WARN_SUPPRESS&#x3D;1</p>
<p><strong>（15）hadoop复制</strong><br>            scp -r 源文件路径:目标文件路径 （配置好SSH免密码登陆）<br>            export HADOOP_ROOT_LOGGER&#x3D;DEBUG,console<br><strong>（16）hdfs文件系统操作命令;</strong><br>        hadoop fs -ls  &#x2F; :根目录下的数据<br>        hadoop fs -lsr  &#x2F; :根目录下的数据(递归查看)<br>        hadoop fs -mkdir &#x2F;d1:在HDFS下创建文件夹<br>        hadoop fs -put &#x2F;root&#x2F;install.log(linux文件路径) &#x2F;usr&#x2F;d1 : 从linux上传文件到HDFS文件系统目录（文件夹d1存在，如果不存在，那么上传后install.log的文件名为d1）<br>        hadoop fs -get &#x2F;usr&#x2F;d1&#x2F;install.log（HDFS文件系统路径） &#x2F;home&#x2F;wzq&#x2F;copyinstall.log:  下载到linux的&#x2F;home&#x2F;wzq文件夹下 并且改名为copyinstall.log<br>        hadoop fs -get &#x2F;usr&#x2F;d1&#x2F;install.log（HDFS文件系统路径） . :复制到当前目录下<br>        hadoop fs -text :查看HDFS中的文件<br>        hadoop fs -rm :删除HDFS文件系统下的文件<br>        hadoop fs -rmr :递归删除HDFS文件系统下的文件盒文件夹<br>        hadoop fs -help:查看手册<br>        hadoop fs -ls hdfs:hadoop:9000&#x2F;<br>        （2）RPC(remove process call)</p>
<pre><code>    命令：
    zcat *.gz &gt; abc.gz 把所有的以gz结尾的文件汇总放到一个文件abc文件里边
    eclipse安装路径：/root/Genuitec/MyEclipse-8.6
</code></pre>
<p><strong>二、hbase安装</strong><br><strong>(1)hbase-env.sh</strong><br>    export JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.7.0_55<br><strong>(2)hbase-site.xml</strong><br>        <configuration><br>        <property><br>        <name>hbase.rootdir</name><br>        <value>hdfs:&#x2F;&#x2F;hadoop:9000&#x2F;hbase</value><br>        </property><br>        </configuration><br><strong>(3)&#x2F;usr&#x2F;hbase-0.94.20&#x2F;bin&#x2F;start-hbase.sh(注意：要在hadoop启动的情况下启动hbase才能启动)</strong><br>        进入hbase命令模式：&#x2F;usr&#x2F;hbase-0.94.20&#x2F;bin&#x2F;目录下。<br>        hbase shell</p>
<p><strong>（4）hbase-env.sh</strong><br>        hbase与hadoop结合<br>        export HBASE_CLASSPATH&#x3D;&#x2F;usr&#x2F;hadoop&#x2F;conf（hadoop配置目录）<br><strong>（5）hbase-site.xml 打开分布模式</strong><br>        <property><br>        <name>hbase.cluster.distributed</name><br>        <value>true</value><br>        </property><br>        export HBASE_CLASSPATH&#x3D;&#x2F;usr&#x2F;hadoop&#x2F;conf<br>         regionservers中写入节点名字【默认是localhost】</p>
<pre><code>验证hbase安装成功
http://192.168.1.121:60010/master.jsp
</code></pre>
<p><strong>(6)hbase 的shell命令</strong><br>            1 status 查看状态<br>            2 version  查看hbase版本<br>            3 create ‘member’,’member_id’,’address’,’info’ 建表<br>                      表明      列族         列族     列族<br>            4 list 查看有那些表<br>            5 describe ‘member’ 查看表结构<br>            6 修改表结构<br>             alter ‘member’,{NAME&#x3D;&gt;’member_id’,METHOD&#x3D;&gt;’delete’}<br>            修改之前首先离线此表：disable ‘member’<br>            总结步骤：<br>            （1）disable ‘member’<br>            （2）alter ‘member’,{NAME&#x3D;&gt;’member_id’,METHOD&#x3D;&gt;’delete’}<br>            （3）enable ‘member’<br>            7 删除表<br>              disable ‘temp_table’<br>              drop ‘temp_table’<br>            8 检查一个表是否存在<br>              exists ‘member’<br>            9 判断表enable或disable<br>              is_enabled ‘member’<br>              is_disabled ‘member’<br>            10插入<br>                <img src="/2018/09/28/hadoop-1-1-2-hbase0-98-hive-pig-sqoop-mysql-vsftp-tomcat-linux%E6%90%AD%E5%BB%BA%E5%91%BD%E4%BB%A4/20151211133642653.png" alt="这里写图片描述"><br>                Put ‘member’,’name’,’info:age’,’24’<br>            11 查询<br>            Get ‘member’,’name’<br>            Get ‘member’,’name’,’info’<br>            Get ‘member’,’name’,’info:age’<br>            <img src="/2018/09/28/hadoop-1-1-2-hbase0-98-hive-pig-sqoop-mysql-vsftp-tomcat-linux%E6%90%AD%E5%BB%BA%E5%91%BD%E4%BB%A4/20151211133723437.png" alt="这里写图片描述"><br>            12 更新<br>            Put ‘member’,’name’,’info:age’,’24’<br>            13 通过时间戳来获取数据<br>                Get ‘member’,’name’,{COLUMN&#x3D;&gt;’info:age’,TIMESTAMP&#x3D;&gt;2532452345345}<br>            14 全表扫描<br>                Scan ‘member’<br>            15 删除某个字段<br>                Delete ‘member’,’name’,’info:age’<br>            16 删除整行<br>                Deleteall ‘member’,’xiaoming’<br>            17 查询表有多少行<br>                Count ‘member’<br>            18 清空一个表<br>                Truncate ‘member’<br>    Habase API<br>        <span class="exturl" data-url="aHR0cHM6Ly9oYmFzZS5hcGFjaGUub3JnL2FwaWRvY3MvaW5kZXguaHRtbA==">https://hbase.apache.org/apidocs/index.html<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>三、pig的安装</strong><br>            1、 进入grunt shell<br>            Pig –x shell<br>            2 、pig 配置<br>                export PIG_HOME&#x3D;&#x2F;usr&#x2F;pig-0.12.0<br>            export PATH&#x3D;.:$HADOOP_HOME&#x2F;bin:$JAVA_HOME&#x2F;bin:$HBASE_HOME&#x2F;bin:$PIG_HOME&#x2F;bin:$PATH<br>            export CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar<br>            export PIG_CLASSPATH&#x3D;$HADOOP_HOME&#x2F;conf&#x2F;<br>            3、 启动pig<br>                Pig<br>            4、 常用命令<br>                Ls cd cat<br>            5、 复制文件到操作系统<br>            copyToLocal<br>            6、 执行操作系统命令<br>                Sh 进入操作系统命令状态<br>            7、  pig数据类型<br><img src="/2018/09/28/hadoop-1-1-2-hbase0-98-hive-pig-sqoop-mysql-vsftp-tomcat-linux%E6%90%AD%E5%BB%BA%E5%91%BD%E4%BB%A4/20151211134053215.png" alt="这里写图片描述"><br>            8、 pig Latin常用语句<br>            <img src="/2018/09/28/hadoop-1-1-2-hbase0-98-hive-pig-sqoop-mysql-vsftp-tomcat-linux%E6%90%AD%E5%BB%BA%E5%91%BD%E4%BB%A4/20151211134124883.png" alt="这里写图片描述"><br>            9、 举例<br>                 Records &#x3D; LOAD ‘input&#x2F;a&#x2F;b&#x2F;exe.txt’  AS  (year:chararray,temperature:int,quality:int);<br>                 变量                                抽象结构<br>            10 、展现<br>                Dump Records<br>    <img src="/2018/09/28/hadoop-1-1-2-hbase0-98-hive-pig-sqoop-mysql-vsftp-tomcat-linux%E6%90%AD%E5%BB%BA%E5%91%BD%E4%BB%A4/20151211134209802.png" alt="这里写图片描述"><br>            11、 查看结构<br>            Describe records<br>    <img src="/2018/09/28/hadoop-1-1-2-hbase0-98-hive-pig-sqoop-mysql-vsftp-tomcat-linux%E6%90%AD%E5%BB%BA%E5%91%BD%E4%BB%A4/20151211134249127.png" alt="这里写图片描述"><br>            12、 筛选<br>        (1)	Filtered_records &#x3D; filter records by temperature !&#x3D;9999 and (quality &#x3D;&#x3D; 0 or quality &#x3D;&#x3D; 4 or quality&#x3D;&#x3D;5 or quality &#x3D;&#x3D; 9);<br>        (2)	dump Filtered_records<br>        13 、group函数<br>             (1)Group_records &#x3D; group filtered_records by year ;<br>             (2)Dump Group_records;<br><img src="/2018/09/28/hadoop-1-1-2-hbase0-98-hive-pig-sqoop-mysql-vsftp-tomcat-linux%E6%90%AD%E5%BB%BA%E5%91%BD%E4%BB%A4/20151211134326654.png" alt="这里写图片描述"><br>        14 、Max函数<br>            Max_temp &#x3D; foreach grouped_records generate group ,max(filtered_records.tempetature);<br>        Dump Max_temp<br>        15、  函数<br>        (1)A &#x3D;load  ‘input&#x2F;grid&#x2F;home&#x2F;csdn.txt’  using  PigStorage(‘#’) as (id ,pw,em);<br>            (2)B &#x3D; foreach A generate em;<br>            (3)Store B into ‘output&#x2F;home&#x2F;email.txt’  using PigStorage();</p>
<p><strong>四、hive的安装</strong><br>            hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。 其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。</p>
<pre><code>        1、安装（http://blog.csdn.net/yfkiss/article/details/7721329）
        文件Hive/bin/hive-configsh末尾加入
        export JAVA_HOME=/usr/java/jdk1.7.0_55
        export HADOOP_HOME=/usr/hadoop
        export HIVE_HOME=/usr/hive
        2、搭建
            在hdfs上建目录：
         hadoop fs -mkdir /tmp
         hadoop fs -mkdir /user/hive/warehouse

        3、添加权限：
         hadoop fs -chmod g+w   /tmp
         hadoop fs -chmod g+w   /user/hive/warehouse

        4、下载解压hive：
         wget http://labs.mop.com/apache-mirror/hive/stable/hive-0.8.1.tar.gz .
         tar -zxvf hive-0.8.1.tar.gz
        5、设置HADOOP_HOME、HIVE_HOME
        export HADOOP_HOME=/home/zxm/hadoop/hadoop-1.0.3
        export HIVE_HOME=/home/work/hadoop/hive-0.8.1

        6、多用户支持
        (确认已安装好mysql)
        启动mysql：
        mysql -u root -p
        mysql&gt;grant all on hive.* to root@localhost identified by &#39;operater&#39;
        7、修改hive conf/hive-site.xml，如下：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;property&gt;  </span><br><span class="line">		  &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;  </span><br><span class="line">		  &lt;value&gt;jdbc:mysql://localhost:3306/hive?createDatabaseIfNotExist=true&lt;alue&gt;  </span><br><span class="line">		  &lt;description&gt;JDBC connect string for a JDBC metastore&lt;/description&gt;  </span><br><span class="line">		&lt;/property&gt;  </span><br><span class="line">		&lt;property&gt;  </span><br><span class="line">		  &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;  </span><br><span class="line">		  &lt;value&gt;com.mysql.jdbc.Driver&lt;alue&gt;  </span><br><span class="line">		  &lt;description&gt;Driver class name for a JDBC metastore&lt;/description&gt;  </span><br><span class="line">		&lt;/property&gt;  </span><br><span class="line">		&lt;property&gt;  </span><br><span class="line">		  &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;  </span><br><span class="line">		  &lt;value&gt;root&lt;alue&gt;  </span><br><span class="line">		  &lt;description&gt;username to use against metastore database&lt;/description&gt;  </span><br><span class="line">		&lt;/property&gt;  </span><br><span class="line">		&lt;property&gt;  </span><br><span class="line">		  &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;  </span><br><span class="line">		  &lt;value&gt;operater&lt;alue&gt;  </span><br><span class="line">		  &lt;description&gt;password to use against metastore database&lt;/description&gt;  </span><br><span class="line">		&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">		&lt;property&gt;</span><br><span class="line">		  &lt;name&gt;hive.metastore.schema.verification&lt;/name&gt;</span><br><span class="line">		  &lt;!--&lt;value&gt;true&lt;/value&gt;--&gt;</span><br><span class="line">		  &lt;value&gt;false&lt;/value&gt;</span><br><span class="line">		   &lt;description&gt;</span><br><span class="line">		   Enforce metastore schema version consistency.</span><br><span class="line">		   True: Verify that version information stored in metastore matches with one from Hive jars.  Also disable automatic</span><br><span class="line">		         schema migration attempt. Users are required to manully migrate schema after Hive upgrade which ensures</span><br><span class="line">		         proper metastore schema migration. (Default)</span><br><span class="line">		   False: Warn if the version information stored in metastore doesn&#x27;t match with one from in Hive jars.</span><br><span class="line">		   &lt;/description&gt;</span><br><span class="line">		&lt;/property&gt;</span><br></pre></td></tr></table></figure>
<pre><code>        8、下载mysql jdbc包：
        wget http://downloads.mysql.com/archives/mysql-connector-java-5.0/mysql-connector-java-5.0.8.tar.gz .
        解压：
        tar -zxvf mysql-connector-java-5.0.8.tar.gz
        将mysql-connector-java-5.0.8-bin.jar拷贝到hive lib目录下：
        cp mysql-connector-java-5.0.8/mysql-connector-java-5.0.8-bin.jar  ./lib
        9、启动hive：
        Cd  /usr/hive/bin
        ./hive
        10、测试
        Show tables;
</code></pre>
<p><strong>五、SQOOP的安装</strong></p>
<pre><code>        1.项目环境（http://blog.csdn.net/dhtz123456/article/details/12943833）
               项目用到的hadoop的版本是1.2.1，所以对应的sqoop是sqoop-1.4.4.bin__hadoop-1.0.0，mysql的jdbc是mysql-connector-java-5.1.24
        2.安装
             1).解压sqoop，配置环境变量：在/etc/profile中添加：
        export $SQOOP_HOME=/usr/sqoop
        export $PATH = $SQOOP_HOME/bin:$PATH
           2). 执行    source /etc/profile
        3. 复制集群中hadoop的core包以及mysql-jdbc包到sqoop-lib目录下。
        4. 配置home路径，conf/sqoop-env.sh下
        Set path to where bin/hadoop is available
        export HADOOP_COMMON_HOME=/usr/hadoop

        Set path to where hadoop-*-core.jar is available
        export HADOOP_MAPRED_HOME=/usr/hadoop

        set the path to where bin/hbase is available
        export HBASE_HOME=/usr/hbase-0.94.20

        Set the path to where bin/hive is available
        export HIVE_HOME=/home/hadoop/hive-0.11.0
        5 命令
        ![这里写图片描述](2018/09/28/hadoop-1-1-2-hbase0-98-hive-pig-sqoop-mysql-vsftp-tomcat-linux搭建命令/20151211134706254.png)
        从mysql导入数据的例子
        ![这里写图片描述](2018/09/28/hadoop-1-1-2-hbase0-98-hive-pig-sqoop-mysql-vsftp-tomcat-linux搭建命令/20151211134735349.png)
        导入到hbase命令
        ![这里写图片描述](2018/09/28/hadoop-1-1-2-hbase0-98-hive-pig-sqoop-mysql-vsftp-tomcat-linux搭建命令/20151211134815140.png)
        从oracle导入数据
        ![这里写图片描述](2018/09/28/hadoop-1-1-2-hbase0-98-hive-pig-sqoop-mysql-vsftp-tomcat-linux搭建命令/20151211134841352.png)
        ![这里写图片描述](2018/09/28/hadoop-1-1-2-hbase0-98-hive-pig-sqoop-mysql-vsftp-tomcat-linux搭建命令/20151211134910954.png)
</code></pre>
<p><strong>六、其他linux上的hadoop使用技巧与命令</strong><br>1、复制一台机器的上的hadoop到其他机器<br>    Scp  -rp  .&#x2F;hadoop-0.20.2  grid@h1:&#x2F;home&#x2F;grid<br>2、awk命令<br>    输入：<br>    <img src="/2018/09/28/hadoop-1-1-2-hbase0-98-hive-pig-sqoop-mysql-vsftp-tomcat-linux%E6%90%AD%E5%BB%BA%E5%91%BD%E4%BB%A4/20151211135104291.png" alt="这里写图片描述"><br>    输出：<br>    <img src="/2018/09/28/hadoop-1-1-2-hbase0-98-hive-pig-sqoop-mysql-vsftp-tomcat-linux%E6%90%AD%E5%BB%BA%E5%91%BD%E4%BB%A4/20151211135133008.png" alt="这里写图片描述"><br>    找出含有rr的文件名：<br>    <img src="/2018/09/28/hadoop-1-1-2-hbase0-98-hive-pig-sqoop-mysql-vsftp-tomcat-linux%E6%90%AD%E5%BB%BA%E5%91%BD%E4%BB%A4/20151211135208891.png" alt="这里写图片描述"><br>利用AWK复制hadoop结点<br><img src="/2018/09/28/hadoop-1-1-2-hbase0-98-hive-pig-sqoop-mysql-vsftp-tomcat-linux%E6%90%AD%E5%BB%BA%E5%91%BD%E4%BB%A4/20151211135241062.png" alt="这里写图片描述"><br>或者把命令放到文件中然后执行文件：<br><img src="/2018/09/28/hadoop-1-1-2-hbase0-98-hive-pig-sqoop-mysql-vsftp-tomcat-linux%E6%90%AD%E5%BB%BA%E5%91%BD%E4%BB%A4/20151211135308637.png" alt="这里写图片描述"><br>知识点：<br>1、	awk和sed命令 功能很强大<br>2、	集群的实施<br><img src="/2018/09/28/hadoop-1-1-2-hbase0-98-hive-pig-sqoop-mysql-vsftp-tomcat-linux%E6%90%AD%E5%BB%BA%E5%91%BD%E4%BB%A4/20151211135343825.png" alt="这里写图片描述"><br>解决办法：<br><img src="/2018/09/28/hadoop-1-1-2-hbase0-98-hive-pig-sqoop-mysql-vsftp-tomcat-linux%E6%90%AD%E5%BB%BA%E5%91%BD%E4%BB%A4/20151211135419203.png" alt="这里写图片描述"><br>DNS软件： 推荐“bind”<br>创建用户<br>Sudo groupadd hadoop<br>Sudo useradd  –s  &#x2F;bin&#x2F;bash  -d  &#x2F;home&#x2F;grid  -m  grid  -g  hadoop  –G  admin<br>安装SSH<br>Sudo apt—get install ssh</p>
<p>SSH免密码登陆<br> Ssh –keygen  -t  dsa  -p  ‘’  -f  <del>&#x2F;.ssh&#x2F;id_dsa<br>秘钥复制<br>Scp  grid@h1:</del>&#x2F;.ssh&#x2F;id_dsa.pub ~&#x2F;.ssh&#x2F;h1_dsa.pub<br>Cat ~&#x2F;.ssh&#x2F;h1_dsa.pub  &gt;&gt; ~&#x2F;.ssh&#x2F;authorized_keys<br>修改masters加入主节点名称<br>修改slaves加入子节点</p>
]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>hadoop hbase hive pig sqoop mysql vsftp tomcat linux</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop2.5.1+Hbase0.98安装</title>
    <url>/2018/09/28/hadoop2-5-1-Hbase0-98%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p><strong>一、Hadoop2.5.1编译zlib的安装与使用</strong></p>
<p>zlib是一个很好的压缩解压缩库，今天我们分别介绍如何在Linux与Windows上安装与使用：</p>
<span id="more"></span>
<p><strong>一：Linux平台</strong><br>首先看看自己的机器上是不是已经安装好zlib了：<br>whereis zlib<br>如果安装好了，会输出zlib的路径，这样直接跳过前2步。</p>
<p><em>1.	下载</em><br>在<span class="exturl" data-url="aHR0cDovL3d3dy56bGliLm5ldC8lRTQlQjglOEIlRTglQkQlQkR6bGliJUU3JTlBJTg0JUU2JTlDJTgwJUU2JTk2JUIwJUU3JTg5JTg4JUVGJUJDJThDJUU2JTg4JTkxJUU3JTlBJTg0JUU2JTk4JUFGMS4yLjMlRUYlQkMlODglRTUlQUUlOTglRTclQkQlOTElRTglQjIlOEMlRTQlQkMlQkMlRTQlQjglOEElRTQlQjglOEQlRTUlOEUlQkIlRUYlQkMlOEMlRTUlOEYlQUYlRTQlQkIlQTUlRTYlODklQkUlRTUlODglQUIlRTclOUElODQlRTUlOUMlQjAlRTYlOTYlQjklRTQlQjglOEIlRTglQkQlQkQlRUYlQkMlODk=">http://www.zlib.net/下载zlib的最新版，我的是1.2.3（官网貌似上不去，可以找别的地方下载）<i class="fa fa-external-link-alt"></i></span><br><em>2.解压，编译：</em><br>.&#x2F;configure<br>make<br>sudo make install<br>再进行配置一下系统的文件，加载刚才编译安装的zlib生成的库文件<br> vi &#x2F;etc&#x2F;ld.so.conf.d&#x2F;zlib.conf<br>加入如下内容后保存退出<br>&#x2F;data&#x2F;program&#x2F;zlib&#x2F;lib<br>也就是添加安装目录的文件路径，库文件。ldconfig  运行之后就会加载安装的库文件了</p>
<p>Openssl安装：<br>yum install openssl-devel</p>
<p><strong>Protobuf 安装：</strong><br>Tar –xzvf protobuf-2.5.0.tar.gz<br>执行：<br>   cd protobuf-2.5.0<br>   .&#x2F;configure –prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;protoc&#x2F;<br>   make<br>   make install<br><strong>添加环境变量：</strong><br>exportPATH&#x3D;.:&#x2F;usr&#x2F;local&#x2F;protoc&#x2F;bin:$PATH<br>更新配置文件source &#x2F;etc&#x2F;profile<br>   验证 protoc –version    libprotoc 2.5.0<br><strong>Hadoop2.5.1编译</strong><br> 初次运行：<br>    $mvn package -Pdist,native -Dskiptests -Dtar<br>    再次运行：<br>    $mvn clean package -Dmaven.test.skip&#x3D;true<br>    $mvn package -Pdist,native -Dskiptests -Dtar<br>    正常编译需要等待40分钟左右<br>$cp hadoop-2.5.1-src&#x2F;hadoop-dist&#x2F;target&#x2F;hadoop-2.5.1&#x2F;lib&#x2F;native</p>
<p><strong>二、hadoop的安装预配置</strong><br>1、Hadoop2.5.1环境变量配置（配置&#x2F;etc&#x2F;profile）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.7.0_55</span><br><span class="line">export HADOOP_HOME=/usr/hadoop</span><br><span class="line">export HBASE_HOME=/usr/hbase-0.94.20</span><br><span class="line">export PIG_HOME=/usr/pig-0.12.0</span><br><span class="line">export HIVE_HOME=/usr/hive</span><br><span class="line">export SQOOP_HOME=/usr/sqoop</span><br><span class="line">export MAVEN_HOME=/usr/apache-maven-3.0.5</span><br><span class="line">export FINDBUGS_HOME=/usr/findbugs-3.0.0</span><br><span class="line">export ANT_HOME=/usr/apache-ant-1.9.4</span><br><span class="line">export PATH=.:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$JAVA_HOME/bin:$HBASE_HOME/bin:$PIG_HOME/bin:$HIVE_HOME/bin:$SQOOP_HOME:$PATH:$MAVEN_HOME/bin:/usr/local/protoc/bin:/usr/local/zlib/lib:$FINDBUGS_HOME/bin:$ANT_HOME/bin</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native</span><br><span class="line">export HADOOP_OPTS=&quot;-Djava.library.path=$HADOOP_HOME/lib/native&quot;</span><br><span class="line">export	JAVA_LIBRARY_PATH=$JAVA_LIBRARY_PATH:$HADOOP_HOME/lib/nativeexport PIG_CLASSPATH=$HADOOP_HOME/conf/</span><br><span class="line">export JAVA_HOME</span><br><span class="line">export PATH</span><br><span class="line">export CLASSPATH</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2、hadoop-env.sh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.7.0_55</span><br><span class="line">#export HADOOP_HOME=/usr/hadoop</span><br><span class="line">export HADOOP_PREFIX=/usr/hadoop</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3、core-site.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">          &lt;property&gt;        </span><br><span class="line">            &lt;name&gt;fs.defaultFS&lt;/name&gt;        </span><br><span class="line">            &lt;value&gt;hdfs://hadoop:9000&lt;/value&gt;   </span><br><span class="line">            &lt;description&gt;&lt;/description&gt;   </span><br><span class="line">           &lt;/property&gt;    </span><br><span class="line"></span><br><span class="line">	&lt;property&gt;</span><br><span class="line">	    &lt;name&gt;io.file.buffer.size&lt;/name&gt;        </span><br><span class="line">            &lt;value&gt;&lt;/value&gt;   </span><br><span class="line">        &lt;/property&gt;              </span><br><span class="line">           &lt;property&gt;        </span><br><span class="line">            &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;       </span><br><span class="line">            &lt;value&gt;/usr/hadoop/tmp&lt;/value&gt;   </span><br><span class="line">            &lt;description&gt;自己设置tmp，默认位置会被定期清除&lt;/description&gt;             </span><br><span class="line">           &lt;/property&gt;</span><br><span class="line">	&lt;property&gt;</span><br><span class="line">	    &lt;name&gt;hadoop.native.lib&lt;/name&gt;        </span><br><span class="line">            &lt;value&gt;false&lt;/value&gt;   </span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4、Hdfs-site.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">	&lt;property&gt;  </span><br><span class="line">            &lt;name&gt;dfs.replication&lt;/name&gt;    </span><br><span class="line">            &lt;value&gt;1&lt;/value&gt;  </span><br><span class="line">            &lt;description&gt;dfs备份数量&lt;/description&gt;    </span><br><span class="line">         &lt;/property&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">            &lt;property&gt;    </span><br><span class="line">            &lt;name&gt;dfs.namenode.handler.count&lt;/name&gt;    </span><br><span class="line">            &lt;value&gt;100&lt;/value&gt;    </span><br><span class="line">            &lt;/property&gt;</span><br><span class="line">--&gt;</span><br><span class="line">            &lt;property&gt;    </span><br><span class="line">            &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;    </span><br><span class="line">            &lt;value&gt;/usr/hadoop/tmp/dfs/name&lt;/value&gt;    </span><br><span class="line">            &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">            &lt;property&gt;    </span><br><span class="line">            &lt;name&gt;dfs.namenode.data.dir&lt;/name&gt;    </span><br><span class="line">            &lt;value&gt;/usr/hadoop/tmp/dfs/data&lt;/value&gt;      </span><br><span class="line">            &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">            &lt;property&gt;    </span><br><span class="line">            &lt;name&gt;dfs.permissions &lt;/name&gt;    </span><br><span class="line">            &lt;value&gt;true&lt;/value&gt;     </span><br><span class="line">&lt;description&gt;文件读写的权限检查 &lt;/description&gt;  </span><br><span class="line">            &lt;/property&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>5、Yarn-site.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Site specific YARN configuration properties --&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">&lt;property&gt;   </span><br><span class="line">    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;   </span><br><span class="line">    &lt;value&gt;mapreduce_shuffle&lt;/value&gt;     </span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;   </span><br><span class="line">    &lt;name&gt;yarn.ac1.enable&lt;/name&gt;   </span><br><span class="line">    &lt;value&gt;false&lt;/value&gt;     </span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;   </span><br><span class="line">    &lt;name&gt;yarn.admin.ac1&lt;/name&gt;   </span><br><span class="line">    &lt;value&gt;Admin ACL&lt;/value&gt;     </span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;   </span><br><span class="line">    &lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;   </span><br><span class="line">    &lt;value&gt;false&lt;/value&gt;     </span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;   </span><br><span class="line">    &lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;   </span><br><span class="line">    &lt;value&gt;false&lt;/value&gt;     </span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">--&gt;</span><br><span class="line">  &lt;property&gt;   </span><br><span class="line">    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;   </span><br><span class="line">    &lt;value&gt;mapreduce_shuffle&lt;/value&gt;     </span><br><span class="line">  &lt;/property&gt;         </span><br><span class="line">  &lt;property&gt;  </span><br><span class="line">    &lt;description&gt;The address of the applications manager interface in the RM.&lt;/description&gt;           </span><br><span class="line">    &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt;             </span><br><span class="line">    &lt;value&gt;hadoop:18040&lt;/value&gt;               </span><br><span class="line">  &lt;/property&gt;  </span><br><span class="line">  &lt;property&gt;   </span><br><span class="line">    &lt;description&gt;The address of the scheduler interface.&lt;/description&gt;   </span><br><span class="line">    &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt;     </span><br><span class="line">    &lt;value&gt;hadoop:18030&lt;/value&gt;       </span><br><span class="line">  &lt;/property&gt;  </span><br><span class="line">  &lt;property&gt;   </span><br><span class="line">    &lt;description&gt;The address of the RM web application.&lt;/description&gt;   </span><br><span class="line">    &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt;     </span><br><span class="line">    &lt;value&gt;hadoop:18088&lt;/value&gt;       </span><br><span class="line">  &lt;/property&gt;  </span><br><span class="line">  &lt;property&gt;   </span><br><span class="line">    &lt;description&gt;The address of the resource tracker interface.&lt;/description&gt;   </span><br><span class="line">    &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt;     </span><br><span class="line">     &lt;value&gt;hadoop:8025&lt;/value&gt;      </span><br><span class="line">  &lt;/property&gt;  </span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>三、Hbase 0.98搭建</strong></p>
<p><strong>hbase-env.sh</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># The java implementation to use.  Java 1.6 required.</span><br><span class="line">export JAVA_HOME=/usr/java/jdk1.7.0_71</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>hbase-site.xml</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;hbase.rootdir&lt;/name&gt;</span><br><span class="line">&lt;value&gt;hdfs://hadoopmaster:9000/hbase&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;  </span><br><span class="line">  &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;  </span><br><span class="line">  &lt;value&gt;true&lt;/value&gt;  </span><br><span class="line">&lt;/property&gt;  </span><br><span class="line">&lt;property&gt;  </span><br><span class="line">  &lt;name&gt;hbase.master&lt;/name&gt;  </span><br><span class="line">  &lt;value&gt;hdfs://hadoopmaster:60000&lt;/value&gt;  </span><br><span class="line">&lt;/property&gt;  </span><br><span class="line">&lt;property&gt;  </span><br><span class="line">  &lt;name&gt;hbase.tmp.dir&lt;/name&gt;  </span><br><span class="line">  &lt;value&gt;/home/hbase/tmp&lt;/value&gt;  </span><br><span class="line">&lt;/property&gt;  </span><br><span class="line">&lt;property&gt;  </span><br><span class="line">  &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;  </span><br><span class="line">  &lt;value&gt;hadoopmaster&lt;/value&gt;  </span><br><span class="line">&lt;/property&gt;  </span><br><span class="line">&lt;property&gt;  </span><br><span class="line">  &lt;name&gt;hbase.zookeeper.property.clientPort&lt;/name&gt;  </span><br><span class="line">  &lt;value&gt;2181&lt;/value&gt;  </span><br><span class="line">&lt;/property&gt;  </span><br><span class="line">&lt;property&gt;  </span><br><span class="line">  &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt;  </span><br><span class="line">  &lt;value&gt;/home/hbase/zookeeper&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Conf下增加文件regionservers 加入节点名字，比如hadoopmaster。</p>
<p>至此，进程如下：<br>[root@hadoopmaster conf]# jps<br>5841 NodeManager<br>5739 ResourceManager<br>5386 DataNode<br>7482 HRegionServer<br>5526 SecondaryNameNode<br>7348 HMaster<br>5290 NameNode<br>7563 Jps<br>7280 HQuorumPeer<br>注：启动hbase的时候 hadoop的slf4j-log4j12-1.7.5.jar与hbase 的slf4j-log4j12-1.6.4.jar会发生冲突 把hbase的删除即可。<br>查看所有监控的ip以及端口启动情况<br>Netstat –tnlp<br><strong>四、部分配置与hadoop原理</strong><br>1 、启动HDFS<br><img src="/2018/09/28/hadoop2-5-1-Hbase0-98%E5%AE%89%E8%A3%85/20151211140929829.png" alt="这里写图片描述"><br>2、日志文件结构：<br><img src="/2018/09/28/hadoop2-5-1-Hbase0-98%E5%AE%89%E8%A3%85/20151211140958933.png" alt="这里写图片描述"><br><img src="/2018/09/28/hadoop2-5-1-Hbase0-98%E5%AE%89%E8%A3%85/20151211141028540.png" alt="这里写图片描述"><br>3、Uber模式:<br><img src="/2018/09/28/hadoop2-5-1-Hbase0-98%E5%AE%89%E8%A3%85/20151211141128852.png" alt="这里写图片描述"><br>4、Uber作业条件:<br><img src="/2018/09/28/hadoop2-5-1-Hbase0-98%E5%AE%89%E8%A3%85/20151211141159862.png" alt="这里写图片描述"><br>5、历史服务器:<br><img src="/2018/09/28/hadoop2-5-1-Hbase0-98%E5%AE%89%E8%A3%85/20151211141228405.png" alt="这里写图片描述"><br>6、secondary namenode<br><img src="/2018/09/28/hadoop2-5-1-Hbase0-98%E5%AE%89%E8%A3%85/20151211142336518.png" alt="这里写图片描述"><br>7、安全模式;<br>    安全模式(系统升级时使用)：<br>    查看namenode出于那个状态<br>    Hadoop dfsadmin –safemode  get<br>    进入安全模式（hadoop启动的时候是安全模式）<br>    Hadoop dfsadmin –safemode enter<br>    离开安全模式<br>    Hadoop dfsadmin –safemode leave<br>8 、文件读取过程<br><img src="/2018/09/28/hadoop2-5-1-Hbase0-98%E5%AE%89%E8%A3%85/20151211142510437.png" alt="这里写图片描述"><br>9、文件写入过程<br><img src="/2018/09/28/hadoop2-5-1-Hbase0-98%E5%AE%89%E8%A3%85/20151211142610720.png" alt="这里写图片描述"><br>10、Hadoop管理员常用命令<br><img src="/2018/09/28/hadoop2-5-1-Hbase0-98%E5%AE%89%E8%A3%85/20151211142652408.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>hadoop hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>hive原理与源码分析-ACID及总结（八）</title>
    <url>/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-ACID%E5%8F%8A%E6%80%BB%E7%BB%93%EF%BC%88%E5%85%AB%EF%BC%89/</url>
    <content><![CDATA[<p><strong>ACID是什么？</strong><br>数据库事务的四个特征</p>
<span id="more"></span>
<p>Atomicity原子性：要么成功要么失败，不会残留一半的数据<br>Consisitency一致性：一旦操作完成，后续的操作可以看到操作的结果<br>Isolation隔离性：一个用户的未完成操作不会对其它用户产生影响<br>Durability持久性：一旦操作完成，操作将会持久化，不会受系统故障得影响</p>
<p><strong>Hive ACID</strong><br>Hive 0.13 以后的版本开始支持ACID<br>主要用于以下场景：<br>    流式数据处理：如Flume, Storm和Kafka，数据进入即可见<br>    不常变化的维表：如在维表中增加或者删除一个维度<br>    数据订正：INSERT／UPDATE／DELETE</p>
<p><strong>ACID限制</strong><br>不支持BEGIN，COMMIT和ROLLBACK，只支持单条语句的ACID (Auto-Commit)<br>目前只支持Orc File Format<br>只支持分桶的表Bucketed<br>不支持从非ACID的会话读写ACID表(DbTxnManager)<br>只支持快照级别隔离<br>不兼容之前的ZooKeeperLockManager</p>
<p>虽然有很多限制，但是还是也有他的强项，比如流式API<br><strong>Streaming APIs</strong><br><span class="exturl" data-url="aHR0cHM6Ly9jd2lraS5hcGFjaGUub3JnL2NvbmZsdWVuY2UvZGlzcGxheS9IaXZlL1N0cmVhbWluZytEYXRhK0luZ2VzdA==">https://cwiki.apache.org/confluence/display/Hive/Streaming+Data+Ingest<i class="fa fa-external-link-alt"></i></span> (Hive 0.14)<br><span class="exturl" data-url="aHR0cHM6Ly9jd2lraS5hcGFjaGUub3JnL2NvbmZsdWVuY2UvZGlzcGxheS9IaXZlL0hDYXRhbG9nK1N0cmVhbWluZytNdXRhdGlvbitBUEk=">https://cwiki.apache.org/confluence/display/Hive/HCatalog+Streaming+Mutation+API<i class="fa fa-external-link-alt"></i></span> (Hive 2.0.0)</p>
<p><strong>新的语法</strong><br>INSERT INTO tbl VALUES(1, ‘fred’, …)<br>UPDATE tbl SET (x&#x3D;5, …) WHERE …<br>DELETE FROM tbl WHERE …<br>支持分区表与非分区表（回忆PPR, PPD优化器）</p>
<p><strong>一些限制</strong><br>目前只支持ORCFile<br>    <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kYXRsYXMuY29tL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvbWFzdGVyL3FsL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvcWwvaW8vQWNpZElucHV0Rm9ybWF0LmphdmE/bGluZT0xMDg=">https://www.codatlas.com/github.com/apache/hive/master/ql/src/java/org/apache/hadoop/hive/ql/io/AcidInputFormat.java?line=108<i class="fa fa-external-link-alt"></i></span> 源码告诉你为什么<br>    要支持文件的事物，除了os提供之外，就是hive自己实现，比如：OrcInputFormat<br>    <img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-ACID%E5%8F%8A%E6%80%BB%E7%BB%93%EF%BC%88%E5%85%AB%EF%BC%89/20170529130405614.png" alt="这里写图片描述"><br>表必须是Bucket表<br>    可以只有一个Bucket，但性能会比单机还差<br>表上必须有transactional&#x3D;true的标记<br>    TBLPROPERTIES(‘transactional’ &#x3D;‘true)</p>
<p><strong>ACID设计</strong><br>HDFS是一个Write-once, Read-many-times的文件系统，不支持文件修改（In-place Update)<br>    把操作变成增量文件（Delta Files)<br>    在读取的时间，合并增量文件(Stitched Together)<br>写的时候需要全局唯一的事务ID<br>    由MetaStore生成<br>读的时候只读已经提交过的结果<br>    快照一致性、无锁<br>    查询开始时候向查询提供一份快照</p>
<p><strong>Bucket和Partition的重要区别</strong><br>Bucket是一个文件<br>Partition是一组文件<br>事务ACID必须基于Bucket + OrcFile<br>从理论上，以后可以支持多种文件的事务，但目前还不支持</p>
<p><strong>文件合并</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-ACID%E5%8F%8A%E6%80%BB%E7%BB%93%EF%BC%88%E5%85%AB%EF%BC%89/20170529131048959.png" alt="这里写图片描述"><br>读的时候对原始文件和增量文件进行合并</p>
<p><strong>ACID增量在HDFS上的存储</strong><br>分区路径（Storage Descriptor）保持不变<br>    $warehouse&#x2F;$db&#x2F;$tbl&#x2F;$part<br>事务生成的bucket文件<br>    基础文件Base Files: $part&#x2F;base_$tid&#x2F;bucket_*<br>    增量文件Delta Files: $part&#x2F;delta_$tid_$tid&#x2F;bucket_*</p>
<p><strong>InputFormat&#x2F;OutputFormat</strong><br>AcidInputFormat &#x2F; AcidOutputFormat<br>    全局唯一键事务、Bucket、行<br>AcidReader支持事务的版本号<br>目前只有Orc支持</p>
<p><strong>文件分发</strong><br>对于MapReduce读取文件（TableScan只在Map）<br>读取Splits同时读取Delta<br>Key Ranges<br>Indexes<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-ACID%E5%8F%8A%E6%80%BB%E7%BB%93%EF%BC%88%E5%85%AB%EF%BC%89/20170529131539090.png" alt="这里写图片描述">  </p>
<p>Delta会读到内存，有益处的风险，Delta一般 不会超过10个。</p>
<p><strong>事务管理器Transaction Manager</strong><br>Hive 0.14以前有两种表级的事务管理器，DML来了，表锁住，查询暂停，两种实现<br>    In Memory – Not Durable 即放在内存里边，断电丢失<br>    Zoo Keeper – 额外组件的安装，配置复杂<br>锁必须与事务相结合，事务提交时释放锁<br>MetaStore可以做ACID，因为MetaStore底层是关系型数据库中心结点<br>使用MetaStore DB(MySQL)生成全局唯一递增的事务Id</p>
<p><strong>事务模型Transaction Model</strong><br>互联网新技术在线教育领航者<br>事务模型Transaction Model<br>Hive 0.14开始，事务auto-commit，语句级<br>    不支持BEGIN／COMMIT／ROLLBACK<br>快照隔离<br>    整个查询执行期间，数据是一致的<br>SHOW TRANSACTIONS语句</p>
<p><strong>锁模型Locking Model</strong><br>三种类型的锁<br>    Shared<br>    Semi-Shared (能与Shared共存，不能与Semi-Shared共存）<br>    Exclusive<br>不同操作需要不同类型的锁<br>    SELECT, INSERT – shared<br>    UPDATE, DELETE – semi-shared<br>    DROP, INSERT OVERWRITE - exclusive</p>
<p><strong>Compactor</strong><br>每一个Transaction(或者Streaming中的一个Batch)创建一个增量文件（Delta File)<br>想象一会，会有很多Delta File，回忆一下会对Namenode造成什么影响<br>需要一些方式去合并<br>    Minor Compaction: 把很多delta合并成一个delta<br>    Major Compaction: 把很多delta合并成Base</p>
<p><strong>Minor Compaction</strong><br>当有10个（可配置）以上的增量文件时<br>结果：1个Base + 1个Delta<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-ACID%E5%8F%8A%E6%80%BB%E7%BB%93%EF%BC%88%E5%85%AB%EF%BC%89/20170529141813052.png" alt="这里写图片描述">  </p>
<p><strong>Major Compaction</strong><br>当Delta达到基表的10%文件大小（可配置）时运行<br>结果只有一个基表<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-ACID%E5%8F%8A%E6%80%BB%E7%BB%93%EF%BC%88%E5%85%AB%EF%BC%89/20170529141959387.png" alt="这里写图片描述"></p>
<p><strong>Compactor如何执行？</strong><br>MetaStore定期执行<br>    不需要用户手工调度<br>    ALTER TABLE COMPACT语句<br>无锁，可与Query&#x2F;DML同时执行<br>    在一边执行，然后原子性替换<br>SHOW COMPACTIONS</p>
<p><strong>流式写入</strong><br>数据流式地流入Hive<br>没有流式功能的话，通常需要小时调度<br>hive.hcatlog.streaming接口<br>    用户实时看到数据，可实时查询<br>Flume&#x2F;Storm&#x2F;Kafka</p>
<p><strong>参考代码及实现</strong><br><span class="exturl" data-url="aHR0cHM6Ly9pc3N1ZXMuYXBhY2hlLm9yZy9qaXJhL2Jyb3dzZS9ISVZFLTUzMTc=">https://issues.apache.org/jira/browse/HIVE-5317<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>Hive再看</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-ACID%E5%8F%8A%E6%80%BB%E7%BB%93%EF%BC%88%E5%85%AB%EF%BC%89/20170529142929705.png" alt="这里写图片描述">  </p>
<p><strong>复习及总结</strong><br>Hive是什么？<br>Driver做什么用的？<br>逻辑优化器？<br>物理优化器？<br>四种执行引擎？<br>查看执行计划？<br>JOIN／Group By倾斜怎么办？<br>HiveServer 2&#x2F; MetaStore&#x2F; LLAP<br>ACID</p>
<p><strong>Hive Join优化</strong><br><span class="exturl" data-url="aHR0cHM6Ly9jd2lraS5hcGFjaGUub3JnL2NvbmZsdWVuY2UvZGlzcGxheS9IaXZlL0xhbmd1YWdlTWFudWFsK0pvaW5PcHRpbWl6YXRpb24=">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+JoinOptimization<i class="fa fa-external-link-alt"></i></span><br>对抗倾斜</p>
<p>Hive CBO<br><span class="exturl" data-url="aHR0cHM6Ly9jd2lraS5hcGFjaGUub3JnL2NvbmZsdWVuY2UvZGlzcGxheS9IaXZlL0Nvc3QtYmFzZWQrb3B0aW1pemF0aW9uK2luK0hpdmU=">https://cwiki.apache.org/confluence/display/Hive/Cost-based+optimization+in+Hive<i class="fa fa-external-link-alt"></i></span><br>自定义优化器</p>
]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>hive原理与源码分析-UDxF、优化器及执行引擎（五）</title>
    <url>/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-UDxF%E3%80%81%E4%BC%98%E5%8C%96%E5%99%A8%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<p><strong>什么是UDF？</strong><br>UDF的全称是User-Defined-Functions<br>Hive中一共有三种UDF</p>
<span id="more"></span>
<p>UDF（User-Defined Function）：输入一行，输入一行，1-&gt;1<br>UDAF（User-Defined Aggregation Function）：输入N行，输出一行，N-&gt;1<br>UDTF（User-Defined Table-generating Function)：输入一行，输出N行，1-&gt;N</p>
<p><strong>一切都是UDxF</strong><br>内置操作符（本质上是一个UDF）<br>加、减、乘、除、等号、大于、小于……<br>内置UDF<br>常用数学操作，常用内符串操作……<br>常用日期操作……<br>内置UDAF<br>Count, sum , avg …<br>内置UDTF<br>Explode<br>自定义UDxF<br><span class="exturl" data-url="aHR0cHM6Ly9jd2lraS5hcGFjaGUub3JnL2NvbmZsdWVuY2UvZGlzcGxheS9IaXZlL0xhbmd1YWdlTWFudWFsK1VERg==">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>UDF源码举例</strong><br>一个简单的加号 1+2.5<br>    <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kYXRsYXMuY29tL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvbWFzdGVyL3FsL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvcWwvdWRmL2dlbmVyaWMvR2VuZXJpY1VERk9QUGx1cy5qYXZh">https://www.codatlas.com/github.com/apache/hive/master/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFOPPlus.java<i class="fa fa-external-link-alt"></i></span><br>类型转换 cast(1.5 as string)<br>    <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kYXRsYXMuY29tL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvbWFzdGVyL3FsL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvcWwvdWRmL1VERlRvU3RyaW5nLmphdmE/bGluZT0xMjA=">https://www.codatlas.com/github.com/apache/hive/master/ql/src/java/org/apache/hadoop/hive/ql/udf/UDFToString.java?line=120<i class="fa fa-external-link-alt"></i></span><br>返回字符串长度 length(s)<br>    <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kYXRsYXMuY29tL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvbWFzdGVyL3FsL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvcWwvdWRmL1VERkxlbmd0aC5qYXZh">https://www.codatlas.com/github.com/apache/hive/master/ql/src/java/org/apache/hadoop/hive/ql/udf/UDFLength.java<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>PTF是一种特殊的UDF</strong><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kYXRsYXMuY29tL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvbWFzdGVyL3FsL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvcWwvdWRmL2dlbmVyaWMvR2VuZXJpY1VERkxlYWQuamF2YQ==">https://www.codatlas.com/github.com/apache/hive/master/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFLead.java<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kYXRsYXMuY29tL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvbWFzdGVyL3FsL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvcWwvdWRmL2dlbmVyaWMvR2VuZXJpY1VERkxlYWRMYWcuamF2YT9saW5lPTM1">https://www.codatlas.com/github.com/apache/hive/master/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDFLeadLag.java?line=35<i class="fa fa-external-link-alt"></i></span><br>用于窗口函数的计算</p>
<p><strong>UDF存在下列Operator中</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-UDxF%E3%80%81%E4%BC%98%E5%8C%96%E5%99%A8%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E4%BA%94%EF%BC%89/20170514170358457.png" alt="这里写图片描述"></p>
<p><strong>演示</strong><br><span class="exturl" data-url="aHR0cHM6Ly9jd2lraS5hcGFjaGUub3JnL2NvbmZsdWVuY2UvZGlzcGxheS9IaXZlL0hpdmVQbHVnaW5zI0hpdmVQbHVnaW5zLUNyZWF0aW5nQ3VzdG9tVURGcw==">https://cwiki.apache.org/confluence/display/Hive/HivePlugins#HivePlugins-CreatingCustomUDFs<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>UDAF</strong><br>UDAF用于聚合<br>存在于GroupByOperator -&gt; GenericUDAFEvaluator<br>    思考：为什么Group By Operator即有ExprNodeEvaluator又月GenericUDAFEvaluator?<br>    <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kYXRsYXMuY29tL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvbWFzdGVyL3FsL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvcWwvZXhlYy9Hcm91cEJ5T3BlcmF0b3IuamF2YQ==">https://www.codatlas.com/github.com/apache/hive/master/ql/src/java/org/apache/hadoop/hive/ql/exec/GroupByOperator.java<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>UDAF源码举例</strong><br>通用接口<br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC91ZGYvZ2VuZXJpYy9HZW5lcmljVURBRkV2YWx1YXRvci5qYXZhP2xpbmU9NzA=">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDAFEvaluator.java?line=70<i class="fa fa-external-link-alt"></i></span><br>当中有四种模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Mode.</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public static enum Mode &#123;</span><br><span class="line">  /**</span><br><span class="line">   * PARTIAL1: from original data to partial aggregation data: iterate() and</span><br><span class="line">   * terminatePartial() will be called.</span><br><span class="line">   */</span><br><span class="line">  PARTIAL1,</span><br><span class="line">      /**</span><br><span class="line">   * PARTIAL2: from partial aggregation data to partial aggregation data:</span><br><span class="line">   * merge() and terminatePartial() will be called.</span><br><span class="line">   */</span><br><span class="line">  PARTIAL2,</span><br><span class="line">      /**</span><br><span class="line">   * FINAL: from partial aggregation to full aggregation: merge() and</span><br><span class="line">   * terminate() will be called.</span><br><span class="line">   */</span><br><span class="line">  FINAL,</span><br><span class="line">      /**</span><br><span class="line">   * COMPLETE: from original data directly to full aggregation: iterate() and</span><br><span class="line">   * terminate() will be called.</span><br><span class="line">   */</span><br><span class="line">  COMPLETE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Sum<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kYXRsYXMuY29tL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvbWFzdGVyL3FsL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvcWwvdWRmL2dlbmVyaWMvR2VuZXJpY1VEQUZTdW0uamF2YQ==">https://www.codatlas.com/github.com/apache/hive/master/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDAFSum.java<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>回忆一下Group By执行的四种模式</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-UDxF%E3%80%81%E4%BC%98%E5%8C%96%E5%99%A8%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E4%BA%94%EF%BC%89/20170514195921527.png" alt="这里写图片描述"></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9wYXJzZS9TZW1hbnRpY0FuYWx5emVyLmphdmE/bGluZT05NzQ5">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java?line=9749<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>对应一下UDAF四种模式</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-UDxF%E3%80%81%E4%BC%98%E5%8C%96%E5%99%A8%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E4%BA%94%EF%BC%89/2017051420054406.png" alt="这里写图片描述">  </p>
<p><strong>自定义UDAF</strong><br><span class="exturl" data-url="aHR0cHM6Ly9jd2lraS5hcGFjaGUub3JnL2NvbmZsdWVuY2UvZGlzcGxheS9IaXZlL0dlbmVyaWNVREFGQ2FzZVN0dWR5">https://cwiki.apache.org/confluence/display/Hive/GenericUDAFCaseStudy<i class="fa fa-external-link-alt"></i></span><br>写Resolver<br>写Evaluator<br>    getNewAggregationBuffer()<br>    iterate()<br>    terminatePartial()<br>    merge()<br>    terminate()</p>
<p><strong>UDTF</strong><br>UDTF用于行转列、拆分行、生成小表<br>存在于UDTFOperator<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kYXRsYXMuY29tL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvbWFzdGVyL3FsL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvcWwvZXhlYy9VRFRGT3BlcmF0b3IuamF2YQ==">https://www.codatlas.com/github.com/apache/hive/master/ql/src/java/org/apache/hadoop/hive/ql/exec/UDTFOperator.java<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  @Override</span><br><span class="line">  public void process(Object row, int tag) throws HiveException &#123;</span><br><span class="line">  //输入一行数据</span><br><span class="line">    // The UDTF expects arguments in an object[]</span><br><span class="line">    StructObjectInspector soi = (StructObjectInspector) inputObjInspectors[tag];</span><br><span class="line">    List&lt;? extends StructField&gt; fields = soi.getAllStructFieldRefs();</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; fields.size(); i++) &#123;</span><br><span class="line">      objToSendToUDTF[i] = soi.getStructFieldData(row, fields.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">//对输出的多个数据处理</span><br><span class="line">    genericUDTF.process(objToSendToUDTF);</span><br><span class="line">    if (conf.isOuterLV() &amp;&amp; collector.getCounter() == 0) &#123;</span><br><span class="line">      collector.collect(outerObj);</span><br><span class="line">    &#125;</span><br><span class="line">    collector.reset();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC91ZGYvZ2VuZXJpYy9HZW5lcmljVURURi5qYXZhP2xpbmU9ODE=">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDTF.java?line=81<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Give a set of arguments for the UDTF to process.</span><br><span class="line"> *</span><br><span class="line"> * @param args</span><br><span class="line"> *          object array of arguments</span><br><span class="line"> */</span><br><span class="line">public abstract void process(Object[] args) throws HiveException;</span><br></pre></td></tr></table></figure>

<p>经常会与LateralView一起使用<br>    为什么？单独生成小表是无意义的<br>    会将生成的小表和原来的表进行join</p>
<p><strong>Lateral View</strong><br>把某一列拆分成一个小表<br>把拆出来的小表作为一个视图<br>用这个视图和原表作Join (Map Join)<br><span class="exturl" data-url="aHR0cHM6Ly9jd2lraS5hcGFjaGUub3JnL2NvbmZsdWVuY2UvZGlzcGxheS9IaXZlL0xhbmd1YWdlTWFudWFsK0xhdGVyYWxWaWV3">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+LateralView<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>Lateral View源码和执行计划</strong><br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9leGVjL0xhdGVyYWxWaWV3Sm9pbk9wZXJhdG9yLmphdmE/bGluZT00Mw==">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/exec/LateralViewJoinOperator.java?line=43<i class="fa fa-external-link-alt"></i></span></p>
<p>逻辑执行计划：<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-UDxF%E3%80%81%E4%BC%98%E5%8C%96%E5%99%A8%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E4%BA%94%EF%BC%89/20170514202109291.png" alt="这里写图片描述"></p>
<p><strong>UDTF源码举例</strong><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kYXRsYXMuY29tL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvbWFzdGVyL3FsL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvcWwvdWRmL2dlbmVyaWMvR2VuZXJpY1VEVEZFeHBsb2RlLmphdmE=">https://www.codatlas.com/github.com/apache/hive/master/ql/src/java/org/apache/hadoop/hive/ql/udf/generic/GenericUDTFExplode.java<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void process(Object[] o) throws HiveException &#123;</span><br><span class="line">//输入一行数据</span><br><span class="line">  switch (inputOI.getCategory()) &#123;</span><br><span class="line">  case LIST:</span><br><span class="line">    ListObjectInspector listOI = (ListObjectInspector)inputOI;</span><br><span class="line">    List&lt;?&gt; list = listOI.getList(o[0]);</span><br><span class="line">    if (list == null) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (Object r : list) &#123;</span><br><span class="line">      forwardListObj[0] = r;</span><br><span class="line">      //处理</span><br><span class="line">      forward(forwardListObj);</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">  case MAP:</span><br><span class="line">    MapObjectInspector mapOI = (MapObjectInspector)inputOI;</span><br><span class="line">    Map&lt;?,?&gt; map = mapOI.getMap(o[0]);</span><br><span class="line">    if (map == null) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (Entry&lt;?,?&gt; r : map.entrySet()) &#123;</span><br><span class="line">      forwardMapObj[0] = r.getKey();</span><br><span class="line">      forwardMapObj[1] = r.getValue();</span><br><span class="line">      forward(forwardMapObj);</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    throw new TaskExecutionException(&quot;explode() can only operate on an array or a map&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如，一些价格，以逗号分隔，存储在一个字段中</p>
<p><strong>自定义UDTF</strong><br><span class="exturl" data-url="aHR0cHM6Ly9jd2lraS5hcGFjaGUub3JnL2NvbmZsdWVuY2UvZGlzcGxheS9IaXZlL0RldmVsb3Blckd1aWRlK1VEVEY=">https://cwiki.apache.org/confluence/display/Hive/DeveloperGuide+UDTF<i class="fa fa-external-link-alt"></i></span><br>比UDAF要简单很多</p>
<p><strong>Transform</strong><br>与UDTF类似，只是以自定义脚本的形式，编写<br>适合语言控，比如我特别喜欢Python或者特别喜欢Ruby，但并不推荐<br><span class="exturl" data-url="aHR0cHM6Ly9jd2lraS5hcGFjaGUub3JnL2NvbmZsdWVuY2UvZGlzcGxheS9IaXZlL0xhbmd1YWdlTWFudWFsK1RyYW5zZm9ybQ==">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Transform<i class="fa fa-external-link-alt"></i></span></p>
<p>为什么不推荐呢看源码<br><strong>Transform源码分析</strong><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kYXRsYXMuY29tL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvbWFzdGVyL3FsL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvcWwvZXhlYy9TY3JpcHRPcGVyYXRvci5qYXZh">https://www.codatlas.com/github.com/apache/hive/master/ql/src/java/org/apache/hadoop/hive/ql/exec/ScriptOperator.java<i class="fa fa-external-link-alt"></i></span></p>
<p>hive默认的分隔符是”ctra+a”，倘若每行数据里边有tab分隔符，那么数据就会错乱，线程也会错乱。所以我们要在数据之中没有类似tab这样的分隔符的时候才能使用Transform不会出错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">。。。。。。。。。。。略</span><br><span class="line">  public void process(Object row, int tag) throws HiveException &#123;</span><br><span class="line">  。。。。。。。。。。略</span><br><span class="line">  //启动2个线程，</span><br><span class="line">  outThread.start();</span><br><span class="line">  errThread.start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Hive流程 – 回顾</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-UDxF%E3%80%81%E4%BC%98%E5%8C%96%E5%99%A8%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E4%BA%94%EF%BC%89/20170514205734778.png" alt="这里写图片描述">  </p>
<p>Optimizer其实优化器的调用者：<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-UDxF%E3%80%81%E4%BC%98%E5%8C%96%E5%99%A8%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E4%BA%94%EF%BC%89/20170514205912937.png" alt="这里写图片描述"></p>
<p><strong>基于规则的优化的执行</strong><br>根据配置初始化一个规则列表，然后一条规则一条规则地执行<br>把根据QB生成的逻辑执行计划改写成新的逻辑执行计划<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kYXRsYXMuY29tL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvbWFzdGVyL3FsL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvcWwvb3B0aW1pemVyL09wdGltaXplci5qYXZhP2xpbmU9MjQw">https://www.codatlas.com/github.com/apache/hive/master/ql/src/java/org/apache/hadoop/hive/ql/optimizer/Optimizer.java?line=240<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Invoke all the transformations one-by-one, and alter the query plan.</span><br><span class="line"> *</span><br><span class="line"> * @return ParseContext</span><br><span class="line"> * @throws SemanticException</span><br><span class="line"> */</span><br><span class="line">public ParseContext optimize() throws SemanticException &#123;</span><br><span class="line">  for (Transform t : transformations) &#123;</span><br><span class="line">    t.beginPerfLogging();</span><br><span class="line">    pctx = t.transform(pctx);</span><br><span class="line">    t.endPerfLogging(t.toString());</span><br><span class="line">  &#125;</span><br><span class="line">  return pctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>基于规则的优化的执行</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-UDxF%E3%80%81%E4%BC%98%E5%8C%96%E5%99%A8%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E4%BA%94%EF%BC%89/20170514215438866.png" alt="这里写图片描述"></p>
<p><strong>demo 1： 简单谓词下推优化器</strong><br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9wcGQvU2ltcGxlUHJlZGljYXRlUHVzaERvd24uamF2YT9saW5lPTU1">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/ppd/SimplePredicatePushDown.java?line=55<i class="fa fa-external-link-alt"></i></span></p>
<p><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-UDxF%E3%80%81%E4%BC%98%E5%8C%96%E5%99%A8%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E4%BA%94%EF%BC%89/20170514220105056.png" alt="这里写图片描述"></p>
<p><strong>demo 2： ReduceSinkDeDuplication</strong><br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9vcHRpbWl6ZXIvY29ycmVsYXRpb24vUmVkdWNlU2lua0RlRHVwbGljYXRpb24uamF2YT9saW5lPTk0">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/optimizer/correlation/ReduceSinkDeDuplication.java?line=94<i class="fa fa-external-link-alt"></i></span><br>去重优化器，减少map作业数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// If multiple rules can be matched with same cost, last rule will be choosen as a processor</span><br><span class="line">// see DefaultRuleDispatcher#dispatch()</span><br><span class="line">Map&lt;Rule, NodeProcessor&gt; opRules = new LinkedHashMap&lt;Rule, NodeProcessor&gt;();</span><br><span class="line">//reduce sink后边有reduce sink 执行ReduceSinkDeduplicateProcFactory.getReducerReducerProc()优化</span><br><span class="line">opRules.put(new RuleRegExp(&quot;R1&quot;, RS + &quot;%.*%&quot; + RS + &quot;%&quot;),</span><br><span class="line">    ReduceSinkDeduplicateProcFactory.getReducerReducerProc());</span><br><span class="line">    //reduce sink后边有group by + reduce sink执行ReduceSinkDeduplicateProcFactory.getGroupbyReducerProc()优化</span><br><span class="line">opRules.put(new RuleRegExp(&quot;R2&quot;, RS + &quot;%&quot; + GBY + &quot;%.*%&quot; + RS + &quot;%&quot;),</span><br><span class="line">    ReduceSinkDeduplicateProcFactory.getGroupbyReducerProc());</span><br><span class="line">if (mergeJoins) &#123;</span><br><span class="line">//jion 后边有reduce sink执行ReduceSinkDeduplicateProcFactory.getJoinReducerProc()优化</span><br><span class="line">  opRules.put(new RuleRegExp(&quot;R3&quot;, JOIN + &quot;%.*%&quot; + RS + &quot;%&quot;),</span><br><span class="line">      ReduceSinkDeduplicateProcFactory.getJoinReducerProc());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-UDxF%E3%80%81%E4%BC%98%E5%8C%96%E5%99%A8%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E4%BA%94%EF%BC%89/20170514220833201.png" alt="这里写图片描述"></p>
<p><strong>demo 3： JoinReorder</strong><br>我们建议小表放在左边，大表放在右边，但是没有这种情况下，<br>虽然大表要放右边，有了JoinReorder，大表就可以放左边了JoinReorder可以改写成这样的形式来优化。这种优化需要打开开关。<br>为什么？看代码<br>    <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kYXRsYXMuY29tL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvbWFzdGVyL3FsL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvcWwvb3B0aW1pemVyL0pvaW5SZW9yZGVyLmphdmE/bGluZT00MA==">https://www.codatlas.com/github.com/apache/hive/master/ql/src/java/org/apache/hadoop/hive/ql/optimizer/JoinReorder.java?line=40<i class="fa fa-external-link-alt"></i></span><br>只能是大表，不能是大的子查询<br>    思考：为什么？<br>所以，打开这个开关时，简单查询是不需要小表放左边的<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-UDxF%E3%80%81%E4%BC%98%E5%8C%96%E5%99%A8%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E4%BA%94%EF%BC%89/20170514221850831.png" alt="这里写图片描述"><br>我们看一下这个开关：<br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9vcHRpbWl6ZXIvT3B0aW1pemVyLmphdmE/bGluZT0xODY=">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/optimizer/Optimizer.java?line=186<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (HiveConf.getBoolVar(hiveConf, HiveConf.ConfVars.NWAYJOINREORDER)) &#123;</span><br><span class="line">  transformations.add(new JoinReorder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvY29tbW9uL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvY29uZi9IaXZlQ29uZi5qYXZhP2xpbmU9MzM1Mw==">https://insight.io/github.com/apache/hive/blob/master/common/src/java/org/apache/hadoop/hive/conf/HiveConf.java?line=3353<i class="fa fa-external-link-alt"></i></span><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-UDxF%E3%80%81%E4%BC%98%E5%8C%96%E5%99%A8%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E4%BA%94%EF%BC%89/20170514222441553.png" alt="这里写图片描述"><br>默认情况是开发，但是只能是表，不能是子查询。</p>
<p><strong>更多优化器</strong><br>更多优化器请根据Optimizer的代码自行阅读<br>如果作为一个用户，只需要知道优化器的作用即可<br>如果是源码程序员，可尝试手动写一个优化器</p>
<p><strong>Hive流程 – 回顾</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-UDxF%E3%80%81%E4%BC%98%E5%8C%96%E5%99%A8%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E4%BA%94%EF%BC%89/20170514222707054.png" alt="这里写图片描述"></p>
<p><strong>Hive执行引擎</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-UDxF%E3%80%81%E4%BC%98%E5%8C%96%E5%99%A8%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E4%BA%94%EF%BC%89/20170514222926367.png" alt="这里写图片描述"></p>
<p><strong>执行引擎</strong><br>四种执行引擎<br>Local<br>MapReduce<br>Spark<br>    <span class="exturl" data-url="aHR0cHM6Ly9jd2lraS5hcGFjaGUub3JnL2NvbmZsdWVuY2UvZGlzcGxheS9IaXZlL0hpdmUrb24rU3BhcmslM0ErR2V0dGluZytTdGFydGVk">https://cwiki.apache.org/confluence/display/Hive/Hive+on+Spark%3A+Getting+Started<i class="fa fa-external-link-alt"></i></span><br>Tez<br>    <span class="exturl" data-url="aHR0cHM6Ly9jd2lraS5hcGFjaGUub3JnL2NvbmZsdWVuY2UvZGlzcGxheS9IaXZlL0hpdmUrb24rVGV6">https://cwiki.apache.org/confluence/display/Hive/Hive+on+Tez<i class="fa fa-external-link-alt"></i></span><br>Tez + LLAP</p>
<p><strong>代码部分</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-UDxF%E3%80%81%E4%BC%98%E5%8C%96%E5%99%A8%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E4%BA%94%EF%BC%89/20170514223227098.png" alt="这里写图片描述"><br>物理执行引擎生成一个TaskCompiler，TaskCompiler会对不同的执行引擎，比如spark，tez、mr等执行不同的物理计划编译器，local是mapreduce（四个线程做map，一个线程做reduce）。<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kYXRsYXMuY29tL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvbWFzdGVyL3FsL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvcWwvcGFyc2UvVGFza0NvbXBpbGVyLmphdmE/bGluZT04Nw==">https://www.codatlas.com/github.com/apache/hive/master/ql/src/java/org/apache/hadoop/hive/ql/parse/TaskCompiler.java?line=87<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>Hive流程 – 我们还没介绍的</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-UDxF%E3%80%81%E4%BC%98%E5%8C%96%E5%99%A8%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E4%BA%94%EF%BC%89/20170514223655980.png" alt="这里写图片描述"><br>逻辑执行计划生成物理执行计划，而物理执行计划是如何调整的。</p>
]]></content>
  </entry>
  <entry>
    <title>hive原理与源码分析-hive源码架构与理论（一）</title>
    <url>/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-hive%E6%BA%90%E7%A0%81%E6%9E%B6%E6%9E%84%E4%B8%8E%E7%90%86%E8%AE%BA%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p><strong>什么是Hive？</strong><br>数据仓库：存储、查询、分析大规模数据</p>
<span id="more"></span>
<p>SQL语言：简单易用的类SQL查询语言<br>编程模型：允许开发者自定义UDF、Transform、Mapper、Reducer，来更简单地完成复杂MapReduce无法完成的工作<br>数据格式：处理Hadoop上任意数据格式的数据，或者使用优化的格式存储Hadoop上的数据，RCFile，ORCFile，Parquest<br>数据服务：HiveServer2，多种API访问Hadoop上的数据，JDBC，ODBC<br>元数据服务：数据什么样，数据在哪里，Hadoop上的唯一标准<br><strong>Hive和Hadoop的关系</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-hive%E6%BA%90%E7%A0%81%E6%9E%B6%E6%9E%84%E4%B8%8E%E7%90%86%E8%AE%BA%EF%BC%88%E4%B8%80%EF%BC%89/20170502212603341.png" alt="这里写图片描述"><br><strong>Hive Cli</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-hive%E6%BA%90%E7%A0%81%E6%9E%B6%E6%9E%84%E4%B8%8E%E7%90%86%E8%AE%BA%EF%BC%88%E4%B8%80%EF%BC%89/20170502212656437.png" alt="这里写图片描述"></p>
<p><strong>Compiler的流程</strong><br>hive简单理解的功能就是把一条sql进行解析成mr任务去给hadoop执行，那么hive的核心就是怎么去解释这条sql：<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-hive%E6%BA%90%E7%A0%81%E6%9E%B6%E6%9E%84%E4%B8%8E%E7%90%86%E8%AE%BA%EF%BC%88%E4%B8%80%EF%BC%89/20170502212923204.png" alt="这里写图片描述"><br><strong>hive架构</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-hive%E6%BA%90%E7%A0%81%E6%9E%B6%E6%9E%84%E4%B8%8E%E7%90%86%E8%AE%BA%EF%BC%88%E4%B8%80%EF%BC%89/20170502213042020.png" alt="这里写图片描述"></p>
<p>源码在哪里？</p>
<p>三个重要的模块：<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-hive%E6%BA%90%E7%A0%81%E6%9E%B6%E6%9E%84%E4%B8%8E%E7%90%86%E8%AE%BA%EF%BC%88%E4%B8%80%EF%BC%89/20170502214223020.png" alt="这里写图片描述"><br><strong>HiveParser:</strong><br>这个类是解析sql的入口<br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9wYXJzZS9QYXJzZURyaXZlci5qYXZhP2xpbmU9MTgz">源码位置<i class="fa fa-external-link-alt"></i></span><br>入参是一条字符串的sql，输出是一棵树（AST【抽象语法树（abstract syntax tree或者缩写为AST），或者语法树（syntax tree）】），ASTNode 是树的头结点，他有孩子的数组，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ASTNode parse(String command, Context ctx)</span><br><span class="line">    throws ParseException &#123;</span><br><span class="line">  return parse(command, ctx, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ASTNode：</strong><br>ASTNode获取孩子节点的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * (non-Javadoc)</span><br><span class="line"> *</span><br><span class="line"> * @see org.apache.hadoop.hive.ql.lib.Node#getChildren()</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public ArrayList&lt;Node&gt; getChildren() &#123;</span><br><span class="line">  if (super.getChildCount() == 0) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>接下来是一颗抽象语法树变成一个QB（query block）<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZXJhL2hpdmUvYmxvYi90cnVuay9xbC9zcmMvamF2YS9vcmcvYXBhY2hlL2hhZG9vcC9oaXZlL3FsL3BhcnNlL1NlbWFudGljQW5hbHl6ZXIuamF2YQ==">SemanticAnalyzer.java<i class="fa fa-external-link-alt"></i></span> （语义分析器），之前老的版本大约将近7000行代码，由于Java一个类的代码行数过多时会出现编译上的问题，现在优化分割了。<br>需要一个树的根节点ast就能对整棵树进行解析（深度优先搜索）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">......略........</span><br><span class="line">  @Override</span><br><span class="line">  @SuppressWarnings(&quot;nls&quot;)</span><br><span class="line">  public void analyzeInternal(ASTNode ast) throws SemanticException &#123;</span><br><span class="line">    reset();</span><br><span class="line"></span><br><span class="line">    QB qb = new QB(null, null, false);//最终返回结果</span><br><span class="line">    this.qb = qb;</span><br><span class="line">    this.ast = ast;</span><br><span class="line">    ASTNode child = ast;</span><br><span class="line">...........略.....</span><br><span class="line">    // continue analyzing from the child ASTNode.</span><br><span class="line">    doPhase1(child, qb, initPhase1Ctx());</span><br><span class="line">    getMetaData(qb);//元数据</span><br><span class="line">    LOG.info(&quot;Completed getting MetaData in Semantic Analysis&quot;);</span><br><span class="line">   Operator sinkOp = genPlan(qb);//将qb生成DAG</span><br><span class="line">  ......略........</span><br><span class="line">      ParseContext pCtx = new ParseContext(conf, qb, child, opToPartPruner,</span><br><span class="line">        opToPartList, topOps, topSelOps, opParseCtx, joinContext, topToTable,</span><br><span class="line">        loadTableWork, loadFileWork, ctx, idToTableNameMap, destTableId, uCtx,</span><br><span class="line">        listMapJoinOpsNoReducer, groupOpToInputTables, prunedPartitions,</span><br><span class="line">        opToSamplePruner);</span><br><span class="line"></span><br><span class="line">    Optimizer optm = new Optimizer();//逻辑优化器</span><br><span class="line">    optm.setPctx(pCtx);</span><br><span class="line">    optm.initialize(conf);</span><br><span class="line">    pCtx = optm.optimize();</span><br><span class="line">    init(pCtx);</span><br><span class="line">    qb = pCtx.getQB();</span><br><span class="line">    ............略.......</span><br><span class="line">     genMapRedTasks(qb);</span><br><span class="line">     ............略......</span><br></pre></td></tr></table></figure>
<p>最后生成一个QB：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">..............................略.........</span><br><span class="line">public class QB &#123;</span><br><span class="line"></span><br><span class="line">  private static final Log LOG = LogFactory.getLog(&quot;hive.ql.parse.QB&quot;);</span><br><span class="line"></span><br><span class="line">  private final int numJoins = 0;</span><br><span class="line">  private final int numGbys = 0;</span><br><span class="line">  private int numSels = 0;</span><br><span class="line">  private int numSelDi = 0;</span><br><span class="line">  private HashMap&lt;String, String&gt; aliasToTabs;</span><br><span class="line">  private HashMap&lt;String, QBExpr&gt; aliasToSubq;</span><br><span class="line">  private List&lt;String&gt; aliases;</span><br><span class="line">  **private QBParseInfo qbp;</span><br><span class="line">  private QBMetaData qbm;**</span><br><span class="line">  private QBJoinTree qbjoin;</span><br><span class="line">  private String id;</span><br><span class="line">  private boolean isQuery;</span><br><span class="line">  private CreateTableDesc tblDesc = null; // table descriptor of the final</span><br><span class="line">..............................略...............</span><br></pre></td></tr></table></figure>
<p>QB的两个重要变量是 qbp和qbm他们都有QB的引用，这样组成了一棵树。<br>在analyzeInternal方法中 <strong>Operator sinkOp &#x3D; genPlan(qb);</strong> 我们看一下<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZXJhL2hpdmUvYmxvYi90cnVuay9xbC9zcmMvamF2YS9vcmcvYXBhY2hlL2hhZG9vcC9oaXZlL3FsL2V4ZWMvT3BlcmF0b3IuamF2YQ==">Operator<i class="fa fa-external-link-alt"></i></span> 类的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class Operator&lt;T extends Serializable&gt; implements Serializable,</span><br><span class="line">    Node &#123;</span><br><span class="line"></span><br><span class="line">  // Bean methods</span><br><span class="line"></span><br><span class="line">  private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">  protected List&lt;Operator&lt;? extends Serializable&gt;&gt; childOperators;</span><br><span class="line">  protected List&lt;Operator&lt;? extends Serializable&gt;&gt; parentOperators;</span><br><span class="line">  protected String operatorId;</span><br><span class="line">  ......................略.............</span><br></pre></td></tr></table></figure>
<p>从代码中可以看到Operator 有很多children和parent，由此这是一个有向无环图（DAG）,QB经过genPlan（）方法变成了一个DAG,接下来的<strong>Optimizer optm &#x3D; new Optimizer();</strong> 是逻辑优化器，那么hive有多少逻辑优化器呢？进入<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nsb3VkZXJhL2hpdmUvYmxvYi90cnVuay9xbC9zcmMvamF2YS9vcmcvYXBhY2hlL2hhZG9vcC9oaXZlL3FsL29wdGltaXplci9PcHRpbWl6ZXIuamF2YQ==">Optimizer<i class="fa fa-external-link-alt"></i></span>：<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-hive%E6%BA%90%E7%A0%81%E6%9E%B6%E6%9E%84%E4%B8%8E%E7%90%86%E8%AE%BA%EF%BC%88%E4%B8%80%EF%BC%89/20170504214748395.png" alt="这里写图片描述"><br>经过这些优化器，sinkOp 变成了一个改写的Operator ，genMapRedTasks(qb);方法是对逻辑优化器进行切分生成一个task有向无环图，以及task的拆分，以及task的物理优化都会在genMapRedTasks（）中进行。<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-hive%E6%BA%90%E7%A0%81%E6%9E%B6%E6%9E%84%E4%B8%8E%E7%90%86%E8%AE%BA%EF%BC%88%E4%B8%80%EF%BC%89/20170504215533873.png" alt="这里写图片描述"><br>以上逻辑是整个hivesql的编译流程代码的大体脉络。</p>
<p><strong>Hive和数据库RDBMS</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-hive%E6%BA%90%E7%A0%81%E6%9E%B6%E6%9E%84%E4%B8%8E%E7%90%86%E8%AE%BA%EF%BC%88%E4%B8%80%EF%BC%89/20170504220038302.png" alt="这里写图片描述"></p>
<p><strong>Hive数据模型</strong><br>DataBase<br>和RDBMS中数据库的概念一致<br>每一个DataBase都对应的一个HDFS目录<br>例如：<br>Hive &gt; create database hugo;<br>对应的HDFS目录是：<br>&#x2F;user&#x2F;hugo&#x2F;hive&#x2F;hugo.db</p>
<p><strong>元数据</strong><br>对hdfs数据的描述与映射，可以理解为数据的数据。关于hive的学习重点是<span class="exturl" data-url="aHR0cHM6Ly9jd2lraS5hcGFjaGUub3JnL2NvbmZsdWVuY2UvZGlzcGxheS9IaXZlL0xhbmd1YWdlTWFudWFs">hive query language<i class="fa fa-external-link-alt"></i></span>手册的翻阅</p>
<p><strong>排序与分发的各种By</strong><br>与传统关系型数据库最大的区别就是处理数据的能力<br>这种能力最大的体现就是排序与分发的原理<br>order by 是全局排序，只有一个reduce，数据量多时速度慢<br>sort by 是随机分发到一个reduce然后reduce内部排序<br>distribute by 是根据 distribute by 的字段把相应的记录分发到那个reduce<br>cluster by是distribute by + sort by的简写</p>
<p><strong>查看查询计划</strong><br> explain 命令，可以用于查看对应查询而产生的查询计划<br>例如：<br>Hive &gt; explian select * from src limit 1;<br>        ABSTRACT SYNTAX TREE:<br>        (TOK_QUERY (TOK_FROM (TOK_TABREF (TOK_TABNAME src))) (TOK_INSERT (TOK_DESTINATION (TOK_DIR TOK_TMP_FILE))     (TOK_SELECT (TOK_SELEXPR TOK_ALLCOLREF)) (TOK_LIMIT 1)))<br>        STAGE DEPENDENCIES:<br>        Stage-0 is a root stage<br>        STAGE PLANS:<br>        Stage: Stage-0<br>        Fetch Operator<br>        limit: 1</p>
<p><strong>常用优化</strong><br>扫描相关<br>        谓词下推（Predicate Push Down）<br>        列剪裁（Column Pruning）<br>        分区剪裁（Partition Pruning）<br>关联JOIN相关<br>        Join操作左边为小表<br>        Join启动的job个数<br>        MapJoin<br>分组Group By相关<br>        Skew In Data<br>合并 小文件<br><strong>列剪裁（Column Pruning）</strong><br>在读数据的时候，只关心感兴趣的列，而忽略其他列，尽量不要写select * from XXX<br>    例如，对于查询：<br>    select a,b from src where e &lt; 10;<br>    其中，src 包含 5 个列 (a,b,c,d,e)，列 c，d 将会被忽略，只会读取a, b, e 列<br>    选项默认为真： hive.optimize.cp &#x3D; true</p>
<p><strong>分区剪裁（Partition Pruning）</strong><br>在查询的过程中减少不必要的分区<br>例如，对于下列查询：<br>SELECT * FROM T1 JOIN (SELECT * FROM T2) subq ON (T1.c1&#x3D;subq.c2)<br>WHERE subq.prtn &#x3D; 100;<br>会在子查询中就考虑 subq.prtn &#x3D; 100 条件，从而减少读入的分区数目。<br>选项默认为真： hive.optimize.pruner&#x3D;true</p>
<p><strong>Join操作左边为小表</strong><br>应该将条目少的表&#x2F;子查询放在 Join 操作符的左边<br>    原因是在 Join 操作的 Reduce 阶段，位于 Join 操作符左边的表的内容会被加载进内存，将条目少的表放在左边，可以有效减少发生 OOM 错误的几率<br><strong>Join启动的job个数</strong><br>如果 Join 的 key 相同，不管有多少个表，都会则会合并为一个 Map-Reduce<br>一个 Map-Reduce (Tez)任务，而不是 ‘n’ 个<br>在做 OUTER JOIN 的时候也是一样<br>    INSERT OVERWRITE TABLE pv_users<br>    SELECT pv.pageid, u.age FROM page_view p<br>    JOIN user u ON (pv.userid &#x3D; u.userid)<br>    JOIN newuser x ON (u.userid &#x3D; x.userid);<br><strong>join不支持不等值连接</strong><br>!&#x3D; &lt;&gt; 在join的on条件中不支持<br>    select …. from ….<br>    join ….<br>    on (a.key !&#x3D; b.key);<br>    为什么？<br>    想象一下a.key是不均匀的，加入一共1亿条数据，只有一条数据的key是1，其他的都是0，这样会撑爆一个节点。而且回去其他机器找数据是找不到的。<br><strong>Group By - Skew In Data</strong><br>主要关注的是数据倾斜<br>hive.groupby.skewindata &#x3D; true<br>当选项设定为 true，生成的查询计划会有两个 MR Job。<br>第一个 MR Job 中，Map 的输出结果集合会随机分布到 Reduce 中，每个 Reduce 做部分聚合操作，并输出结果，这样处理的结果是相同的 Group By Key 有可能被分发到不同的 Reduce 中，从而达到负载均衡的目的；<br>第二个 MR Job 再根据预处理的数据结果按照 Group By Key 分布到 Reduce 中（这个过程可以保证相同的 Group By Key 被分布到同一个 Reduce 中），最后完成最终的聚合操作</p>
<p><strong>合并小文件</strong><br>合并功能会增加任务运行时间。<br>合并操作的性能很大程度上取决于“单个reduce端输出文件大小”。Reduce端的输出越大，耗时越长。<br>合并操作会对每个Hive任务增加一次MapReduce任务。<br>小文件越多，读取metastore的次数就越多，sql的解析变慢，而且小文件对hadoop伤害很大。hadoop不怕文件大，就怕文件小而且多，这样文件的映射在namenode中就多，namenode负载过大，为此hive对小文件进行合并。</p>
<p><strong>SerDe</strong><br>SerDe 是 Serialize&#x2F;Deserilize 的简称，目的是用于序列化和反序列化。<br>序列化（往磁盘上写）的格式包括：<br>分隔符（tab、逗号、CTRL-A）<br>Thrift 协议<br>反序列化（往内存里读）：<br>Java Integer&#x2F;String&#x2F;ArrayList&#x2F;HashMap<br>Hadoop Writable 类<br>用户自定义类</p>
<p><strong>何时考虑增加新的SerDe</strong><br>用户的数据有特殊的序列化格式，当前的 Hive 不支持，而用户又不想在将数据加载至 Hive 前转换数据格式<br>用户有更有效的序列化磁盘数据的方法</p>
<p><strong>例子-使用RegexSerDe</strong><br>CREATE TABLE apache_log(<br>host STRING, identity STRING, user STRING,<br>time STRING, request STRING, status STRING,<br>size STRING, referer STRING, agent STRING)<br>ROW FORMAT SERDE ‘org.apache.hadoop.hive.contrib.serde2.RegexSerDe’<br>WITH SERDEPROPERTIES<br>( “input.regex” &#x3D; “([^ ]<em>) ([^ ]</em>) ([^ ]<em>) (-|\^\*\]) ([^ &quot;]</em>|&quot;[^&quot;]<em>&quot;) (-|[0-9]</em>) (-|[0-9]<em>)(?: ([^ &quot;]</em>|&quot;[^&quot;]<em>&quot;) ([^ &quot;]</em>|&quot;[^&quot;]*&quot;))?”,<br>“output.format.string” &#x3D; “%1$s %2$s %3$s %4$s %5$s %6$s %7$s %8$s %9$s”<br>) STORED AS TEXTFILE;</p>
]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>hive原理与源码分析-序列化器与反序列化器（三）</title>
    <url>/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p><strong>使用IDE调试一条简单的SQL</strong></p>
<span id="more"></span>
<p>画出AST<br>画出Operator Tree</p>
<p><strong>已有表结构：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; desc src;</span><br><span class="line">OK</span><br><span class="line">key                     int                                         </span><br><span class="line">value                   string</span><br></pre></td></tr></table></figure>
<p><strong>执行计划：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hive&gt; explain select * from src a join src b on a.key=b.key where a.key&lt;100;</span><br><span class="line">OK</span><br><span class="line">STAGE DEPENDENCIES:</span><br><span class="line">  Stage-4 is a root stage</span><br><span class="line">  Stage-3 depends on stages: Stage-4</span><br><span class="line">  Stage-0 depends on stages: Stage-3</span><br><span class="line"></span><br><span class="line">STAGE PLANS:</span><br><span class="line">  Stage: Stage-4</span><br><span class="line">    Map Reduce Local Work</span><br><span class="line">      Alias -&gt; Map Local Tables:</span><br><span class="line">        a</span><br><span class="line">          Fetch Operator</span><br><span class="line">            limit: -1</span><br><span class="line">      Alias -&gt; Map Local Operator Tree:</span><br><span class="line">        a</span><br><span class="line">          TableScan</span><br><span class="line">            alias: a</span><br><span class="line">            Statistics: Num rows: 55 Data size: 5812 Basic stats: COMPLETE Column stats: NONE</span><br><span class="line">            Filter Operator</span><br><span class="line">              predicate: (key &lt; 100) (type: boolean)</span><br><span class="line">              Statistics: Num rows: 18 Data size: 1902 Basic stats: COMPLETE Column stats: NONE</span><br><span class="line">              HashTable Sink Operator</span><br><span class="line">                keys:</span><br><span class="line">                  0 key (type: int)</span><br><span class="line">                  1 key (type: int)</span><br><span class="line"></span><br><span class="line">  Stage: Stage-3</span><br><span class="line">    Map Reduce</span><br><span class="line">      Map Operator Tree:</span><br><span class="line">          TableScan</span><br><span class="line">            alias: b</span><br><span class="line">            Statistics: Num rows: 55 Data size: 5812 Basic stats: COMPLETE Column stats: NONE</span><br><span class="line">            Filter Operator</span><br><span class="line">              predicate: (key &lt; 100) (type: boolean)</span><br><span class="line">              Statistics: Num rows: 18 Data size: 1902 Basic stats: COMPLETE Column stats: NONE</span><br><span class="line">              Map Join Operator</span><br><span class="line">                condition map:</span><br><span class="line">                     Inner Join 0 to 1</span><br><span class="line">                keys:</span><br><span class="line">                  0 key (type: int)</span><br><span class="line">                  1 key (type: int)</span><br><span class="line">                outputColumnNames: _col0, _col1, _col5, _col6</span><br><span class="line">                Statistics: Num rows: 19 Data size: 2092 Basic stats: COMPLETE Column stats: NONE</span><br><span class="line">                Select Operator</span><br><span class="line">                  expressions: _col0 (type: int), _col1 (type: string), _col5 (type: int), _col6 (type: string)</span><br><span class="line">                  outputColumnNames: _col0, _col1, _col2, _col3</span><br><span class="line">                  Statistics: Num rows: 19 Data size: 2092 Basic stats: COMPLETE Column stats: NONE</span><br><span class="line">                  File Output Operator</span><br><span class="line">                    compressed: false</span><br><span class="line">                    Statistics: Num rows: 19 Data size: 2092 Basic stats: COMPLETE Column stats: NONE</span><br><span class="line">                    table:</span><br><span class="line">                        input format: org.apache.hadoop.mapred.TextInputFormat</span><br><span class="line">                        output format: org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat</span><br><span class="line">                        serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe</span><br><span class="line">      Local Work:</span><br><span class="line">        Map Reduce Local Work</span><br><span class="line"></span><br><span class="line">  Stage: Stage-0</span><br><span class="line">    Fetch Operator</span><br><span class="line">      limit: -1</span><br><span class="line">      Processor Tree:</span><br><span class="line">        ListSink</span><br></pre></td></tr></table></figure>
<p>Stage-4:是小表序列化<br>Stage-3：mr任务<br>Stage-0：对mr输出文件的输出</p>
<p><strong>逻辑执行计划Stage-3</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%EF%BC%88%E4%B8%89%EF%BC%89/20170507201653831.png" alt="这里写图片描述"></p>
<p>TableScanOperator:  from src  a &#x2F;from src b 【a表加载进入内存，b在磁盘上边】<br>FilterOperator: where  a.key&lt;100<br>SelectOperator : select *<br>MapJoinOperator : on a.key &#x3D; b.key<br>FileSyncOperator:输出<br>整个流程：从b表加载一条数据 FilterOperator一下，SelectOperator 选择出记录，用MapJoinOperator 和内存中的ajoin一下，然后输出</p>
<p><strong>SerDe简介</strong><br>SerDe是Serializer和Deserializer的缩写<br>序列化器与反序列化器<br>Hive使用SerDe接口去完成IO操作<br>接口三个主要功能：<br>序列化(Serialization)，从Hive写FS<br>反序列化（Deserialization），从FS读入Hive<br>解释读写字段，加起文件到字段结构的桥梁</p>
<p><strong>Hive核心三大组件</strong><br>Hive有三大核心组件：<br>Query Processor：查询处理工具，源码ql包<br>SerDe：序列化与反序列化器，源码serde包<br>MetaStore：元数据存储及服务，源码metastore包<br>请注意：<br>HiveServer2、MR和Tez引擎并不是Hive的三大核心组件，只是周边，后续我们会做分析<br>关于MR和Tez的性能比较点这：<span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9saW5uL3AvNTMyNTE0Ny5odG1s">http://www.cnblogs.com/linn/p/5325147.html<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>SerDe所处的位置</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%EF%BC%88%E4%B8%89%EF%BC%89/20170507203959466.png" alt="这里写图片描述"></p>
<p><strong>序列化和反序列化的目的</strong><br>Serde是用于序列化和反序列化。<br>序列化的目的是Hive格式输出成为特定格式，包括：<br>分隔符（tab、逗号、CTRL-A）<br>Thrift 协议<br>反序列化的目的是HDFS格式读入Hive内存中，包括：<br>Java Integer&#x2F;String&#x2F;ArrayList&#x2F;HashMap<br>Hadoop Writable 类<br>用户自定义类</p>
<p><strong>内置SerDe与外置SerDe</strong><br>内置SerDe<br>LazySimpleSerde<br>ColumnarSerde<br>AvroSerde<br>ORC<br>RegexSerde<br>Thrift<br>Parquet<br>CSV<br>JSONSerde<br>自定义Serde，读写自定义格式的数据</p>
<p><strong>例子:使用RegexSerDe</strong><br>分析http请求日志。<br>CREATE TABLE apache_log(<br>host STRING, identity STRING, user STRING,<br>time STRING, request STRING, status STRING,<br>size STRING, referer STRING, agent STRING)<br>ROW FORMAT SERDE ‘org.apache.hadoop.hive.contrib.serde2.RegexSerDe’<br>WITH SERDEPROPERTIES<br>( “input.regex” &#x3D; “([^ ]<em>) ([^ ]</em>) ([^ ]<em>) (-|\^\*\]) ([^ &quot;]</em>|&quot;[^&quot;]<em>&quot;) (-|[0-9]</em>) (-|[0-9]<em>)(?: ([^ &quot;]</em>|&quot;[^&quot;]<em>&quot;) ([^ &quot;]</em>|&quot;[^&quot;]<em>&quot;))?”,<br>“output.format.string” &#x3D; “%1$s %2$s %3$s %4$s %5$s %6$s %7$s %8$s %9$s”<br>) STORED AS TEXTFILE;<br>( “input.regex” &#x3D; “([^ ]</em>) ([^ ]<em>) ([^ ]</em>) (-|\^\<em>\]) ([^ &quot;]</em>|&quot;[^&quot;]<em>&quot;) (-|[0-9]</em>) (-|[0-9]<em>)(?: ([^ &quot;]</em>|&quot;[^&quot;]<em>&quot;) ([^ &quot;]</em>|&quot;[^&quot;]<em>&quot;))?”<br>这个正则表达式是Serializer的过程，<br>( “input.regex” &#x3D; “([^ ]</em>) ([^ ]<em>) ([^ ]</em>) (-|\^\<em>\]) ([^ &quot;]</em>|&quot;[^&quot;]<em>&quot;) (-|[0-9]</em>) (-|[0-9]<em>)(?: ([^ &quot;]</em>|&quot;[^&quot;]<em>&quot;) ([^ &quot;]</em>|&quot;[^&quot;]*&quot;))?”<br>这条正则表达式是DeSerializer的过程。</p>
<p><strong>SerDe的源码分析</strong><br>相对于SemanticAnalyzer，Serde的编写较为规范，也较为好懂<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kYXRsYXMuY29tL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvbWFzdGVyL3NlcmRlL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvc2VyZGUyLw==">https://www.codatlas.com/github.com/apache/hive/master/serde/src/java/org/apache/hadoop/hive/serde2/<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>AbstractSerde</strong><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kYXRsYXMuY29tL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvbWFzdGVyL3NlcmRlL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvc2VyZGUyL0Fic3RyYWN0U2VyRGUuamF2YQ==">https://www.codatlas.com/github.com/apache/hive/master/serde/src/java/org/apache/hadoop/hive/serde2/AbstractSerDe.java<i class="fa fa-external-link-alt"></i></span><br>AbstractSerde<br>serialize() 接口：Object -&gt; Writable<br>deserialize()接口：Writable -&gt; Object</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Abstract class for implementing SerDe. The abstract class has been created, so that</span><br><span class="line"> * new methods can be added in the underlying interface, SerDe, and only implementations</span><br><span class="line"> * that need those methods overwrite it.</span><br><span class="line"> */</span><br><span class="line">public abstract class AbstractSerDe implements Deserializer, Serializer &#123;</span><br><span class="line">。。。。。。。。。。略</span><br><span class="line">  /**</span><br><span class="line">   * Initialize the HiveSerializer.</span><br><span class="line">   * @param conf System properties. Can be null in compile time</span><br><span class="line">   * @param tbl table properties</span><br><span class="line">   * @throws SerDeException</span><br><span class="line">   */</span><br><span class="line">   //初始化</span><br><span class="line">  @Deprecated</span><br><span class="line">  public abstract void initialize(@Nullable Configuration conf, Properties tbl)</span><br><span class="line">      throws SerDeException;</span><br><span class="line">。。。。。。略</span><br><span class="line">  /**</span><br><span class="line">   * Serialize an object by navigating inside the Object with the</span><br><span class="line">   * ObjectInspector. In most cases, the return value of this function will be</span><br><span class="line">   * constant since the function will reuse the Writable object. If the client</span><br><span class="line">   * wants to keep a copy of the Writable, the client needs to clone the</span><br><span class="line">   * returned value.</span><br><span class="line">   */</span><br><span class="line">   //序列化操作，参数obj是hive中的对象，Writable 是hadoop中的数据格式描述抽象</span><br><span class="line">  public abstract Writable serialize(Object obj, ObjectInspector objInspector)</span><br><span class="line">      throws SerDeException;</span><br><span class="line"></span><br><span class="line">。。。。。。。。。。略</span><br><span class="line">  /**</span><br><span class="line">   * Deserialize an object out of a Writable blob. In most cases, the return</span><br><span class="line">   * value of this function will be constant since the function will reuse the</span><br><span class="line">   * returned object. If the client wants to keep a copy of the object, the</span><br><span class="line">   * client needs to clone the returned value by calling</span><br><span class="line">   * ObjectInspectorUtils.getStandardObject().</span><br><span class="line">   *</span><br><span class="line">   * @param blob The Writable object containing a serialized object</span><br><span class="line">   * @return A Java object representing the contents in the blob.</span><br><span class="line">   */</span><br><span class="line">   //反序列化 blob是hadoop中的数据抽象格式，返回的是Object是hive中的对象</span><br><span class="line">  public abstract Object deserialize(Writable blob) throws SerDeException;</span><br><span class="line">..........略。。。。。。。</span><br></pre></td></tr></table></figure>

<p>具体的SerDe <span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvc2VyZGUvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9zZXJkZTIvbGF6eS9MYXp5U2ltcGxlU2VyRGUuamF2YQ==">https://insight.io/github.com/apache/hive/blob/master/serde/src/java/org/apache/hadoop/hive/serde2/lazy/LazySimpleSerDe.java<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Public</span><br><span class="line">@Stable</span><br><span class="line">@SerDeSpec(schemaProps = &#123;</span><br><span class="line">    serdeConstants.LIST_COLUMNS, serdeConstants.LIST_COLUMN_TYPES,</span><br><span class="line">    serdeConstants.FIELD_DELIM, serdeConstants.COLLECTION_DELIM, serdeConstants.MAPKEY_DELIM,</span><br><span class="line">    serdeConstants.SERIALIZATION_FORMAT, serdeConstants.SERIALIZATION_NULL_FORMAT,</span><br><span class="line">    serdeConstants.SERIALIZATION_ESCAPE_CRLF,</span><br><span class="line">    serdeConstants.SERIALIZATION_LAST_COLUMN_TAKES_REST,</span><br><span class="line">    serdeConstants.ESCAPE_CHAR,</span><br><span class="line">    serdeConstants.SERIALIZATION_ENCODING,</span><br><span class="line">    LazySerDeParameters.SERIALIZATION_EXTEND_NESTING_LEVELS,</span><br><span class="line">    LazySerDeParameters.SERIALIZATION_EXTEND_ADDITIONAL_NESTING_LEVELS</span><br><span class="line">    &#125;)</span><br><span class="line">public class LazySimpleSerDe extends AbstractEncodingAwareSerDe &#123;</span><br><span class="line">。。。。。。。。略。。。。。</span><br></pre></td></tr></table></figure>
<p>如果我们想要改变存储在文件上的分隔符在哪个地方改动呢？打开<span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvc2VyZGUvc3JjL2dlbi90aHJpZnQvZ2VuLWphdmFiZWFuL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvc2VyZGUvc2VyZGVDb25zdGFudHMuamF2YT9saW5lPTYx">serdeConstants<i class="fa fa-external-link-alt"></i></span>这个类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static final String FIELD_DELIM = &quot;field.delim&quot;;//字段域分隔符</span><br><span class="line">public static final String COLLECTION_DELIM = &quot;colelction.delim&quot;;//集合内部元素之间分隔符</span><br><span class="line">public static final String MAPKEY_DELIM = &quot;mapkey.delim&quot;;//map的key和value之间的分割符</span><br></pre></td></tr></table></figure>

<p><strong>ObjectInspector</strong><br>ObjectInspector作用相当大，它解耦了数据使用和数据格式<br>ObjectInspector接口使得Hive可以不拘泥于一种特定数据格式<br>在输入端和输出端切换不同的输入&#x2F;输出格式<br>在不同的Operator上使用不同的数据格式<br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvc2VyZGUvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9zZXJkZTIvb2JqZWN0aW5zcGVjdG9yL09iamVjdEluc3BlY3Rvci5qYXZh">https://insight.io/github.com/apache/hive/blob/master/serde/src/java/org/apache/hadoop/hive/serde2/objectinspector/ObjectInspector.java<i class="fa fa-external-link-alt"></i></span><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%EF%BC%88%E4%B8%89%EF%BC%89/20170507212442779.png" alt="这里写图片描述"></p>
<p>我们在上文的 explain select * from src a join src b on a.key&#x3D;b.key where a.key&lt;100;执行计划的时候，在stage-3有一个 Map Operator，这个操作是一个读操作，即反序列化Deserializer。<br><strong>Deserializer是如何工作的</strong><br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9leGVjL01hcE9wZXJhdG9yLmphdmE/bGluZT0xMjU=">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/exec/MapOperator.java?line=125<i class="fa fa-external-link-alt"></i></span><br>value : hadoop中一条数据；context：hadoop的配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Object readRow(Writable value, ExecMapperContext context) throws SerDeException &#123;</span><br><span class="line">  Object deserialized = deserializer.deserialize(value);</span><br><span class="line">  Object row = partTblObjectInspectorConverter.convert(deserialized);</span><br><span class="line">  if (hasVC()) &#123;</span><br><span class="line">    rowWithPartAndVC[0] = row;</span><br><span class="line">    if (context != null) &#123;</span><br><span class="line">      populateVirtualColumnValues(context, vcs, vcValues, deserializer);</span><br><span class="line">    &#125;</span><br><span class="line">    int vcPos = isPartitioned() ? 2 : 1;</span><br><span class="line">    rowWithPartAndVC[vcPos] = vcValues;</span><br><span class="line">    return  rowWithPartAndVC;</span><br><span class="line">  &#125; else if (isPartitioned()) &#123;</span><br><span class="line">    rowWithPart[0] = row;</span><br><span class="line">    return rowWithPart;</span><br><span class="line">  &#125;</span><br><span class="line">  return row;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Serializer是如何工作的</strong><br>源码：<span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9leGVjL1JlZHVjZVNpbmtPcGVyYXRvci5qYXZhP2xpbmU9MTEy">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/exec/ReduceSinkOperator.java?line=112<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">。。。。。。。。。。略</span><br><span class="line">  protected transient Serializer keySerializer;</span><br><span class="line">  protected transient boolean keyIsText;</span><br><span class="line">  protected transient Serializer valueSerializer;</span><br><span class="line">  。。。。。。。。。。。。。略</span><br><span class="line">    protected transient ObjectInspector keyObjectInspector;</span><br><span class="line">  protected transient ObjectInspector valueObjectInspector;</span><br></pre></td></tr></table></figure>
<p>我们在写数据的时候serialize(Object obj, ObjectInspector objInspector) obj是个什么对象我们是通过objInspector来描述的。</p>
<p>FileSinkOperator：<br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9leGVjL0ZpbGVTaW5rT3BlcmF0b3IuamF2YT9saW5lPTky">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/exec/FileSinkOperator.java?line=92<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FileSinkOperator extends TerminalOperator&lt;FileSinkDesc&gt; implements</span><br><span class="line">    Serializable &#123;</span><br><span class="line">    。。。。。。。。。略。。。。</span><br></pre></td></tr></table></figure>
<p>FileSinkDesc：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Explain(displayName = &quot;File Output Operator&quot;, explainLevels = &#123; Level.USER, Level.DEFAULT, Level.EXTENDED &#125;)</span><br><span class="line">public class FileSinkDesc extends AbstractOperatorDesc &#123;</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9wbGFuL1JlZHVjZVNpbmtEZXNjLmphdmE/bGluZT00Mg==">ReduceSinkDesc<i class="fa fa-external-link-alt"></i></span>原理也是如此：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Explain(displayName = &quot;Reduce Output Operator&quot;, explainLevels = &#123; Level.USER, Level.DEFAULT, Level.EXTENDED &#125;)</span><br><span class="line">public class ReduceSinkDesc extends AbstractOperatorDesc &#123;</span><br></pre></td></tr></table></figure>

<p>在FileSinkDesc的注解@Explain中有个displayName&#x3D;File Output Operator和我们之前的执行计划中的输出：<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%EF%BC%88%E4%B8%89%EF%BC%89/20170507220329675.png" alt="这里写图片描述"><br>由此我们在根据执行bebug的时候就是根据类似于这种注解去判断的。</p>
<p>Hive的本质是一条SQL生成的一系列Operators，并执行它们 每个Operators的原理和适应条件，决定查询的性能 这里的代码是<span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9leGVjL1JlZHVjZVNpbmtPcGVyYXRvci5qYXZhP2xpbmU9NTYw">ReduceSinkOperator<i class="fa fa-external-link-alt"></i></span>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private BytesWritable makeValueWritable(Object row) throws Exception &#123;</span><br><span class="line">  int length = valueEval.length;</span><br><span class="line"></span><br><span class="line">  // Evaluate the value</span><br><span class="line">  for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">    cachedValues[i] = valueEval[i].evaluate(row);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Serialize the value</span><br><span class="line">  return (BytesWritable) valueSerializer.serialize(cachedValues, valueObjectInspector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>valueSerializer.serialize(cachedValues, valueObjectInspector);将row序列化最终为为BytesWritable【hadoop的数据类型】<br>ReduceSinkOperator的Sink是下沉的意思，此处是map的输出结果输入到reduce中，row是map的结果，输出是BytesWritable，即用BytesWritable作为reduce的输入。<br>由此可以看出，hive的主要功能是对一条sql解析生成若干operator，并且执行他们，和关系型数据库还有很大的不同的，关系型数据库还有存储 功能。</p>
<p><strong>创建自定义Serde</strong><br>参考：<span class="exturl" data-url="aHR0cHM6Ly9jd2lraS5hcGFjaGUub3JnL2NvbmZsdWVuY2UvZGlzcGxheS9IaXZlL0RldmVsb3Blckd1aWRl">https://cwiki.apache.org/confluence/display/Hive/DeveloperGuide<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>何时添加自定义SerDe</strong><br>用户有更有效的序列化磁盘数据的方法，添加Ser（不常出现）<br>用户的数据有特殊的序列化格式，当前的 Hive 不支持，而用户又不想在将数据加载至 Hive 前转换数据格式，添加De（经常出现）</p>
<p><strong>Hive常用可编程用户接口</strong>文件格式FileFormats<br>序列化与反序列化器Serde<br>Map-Reduce脚本<br>UDxF(UDF, UDAF, UDTF)</p>
<p><strong>创建自定义SerDe</strong><br>大多数情况，只需要De而不是SerDe<br>只需要读取（反序列化）特殊格式的数据，而不是写（序列化）数据<br>读完之后用Hive内置的数据结构处理会更高效</p>
<p><strong>创建自定义SerDe的过程</strong><br>1.准备数据<br>2.使用IDE，继承AbstractSerde接口<br>3.实现serialize()和deserialize()方法<br>4.将创建的类打包为serde.jar<br>5.Add serde.jar 命令添加分布式缓存<br>6.建表，指定刚才编写的类<br>7.读写数据</p>
]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>hive原理与源码分析-服务化：LLAP、HiveServer2、MetaStore（七）</title>
    <url>/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%9C%8D%E5%8A%A1%E5%8C%96%EF%BC%9ALLAP%E3%80%81HiveServer2%E3%80%81MetaStore%EF%BC%88%E4%B8%83%EF%BC%89/</url>
    <content><![CDATA[<p><strong>hive流程回顾</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%9C%8D%E5%8A%A1%E5%8C%96%EF%BC%9ALLAP%E3%80%81HiveServer2%E3%80%81MetaStore%EF%BC%88%E4%B8%83%EF%BC%89/20170521124731490.png" alt="这里写图片描述"></p>
<span id="more"></span>

<p><strong>LLAP</strong><br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1495352230994&di=f355678bbabd6fe6962ff26d859987ad&imgtype=0&src=http://i.xxshe.com/HVyH5TFl.jpg" alt="这里写图片描述"><br>LLAP是Live Long and Prosper（生生不息，繁荣昌盛）的缩写，现已故的美国演员、导演伦纳德·尼莫伊的每一条推文都用它来做结束语。伦纳德·尼莫伊在美国电视剧《星际迷航》中扮演斯波克而成名。是当前的美国网络流行语。</p>
<p>LLAP本来是想表达Long Lived Process （长驻进程）<br>后来借用了星际迷航的东西，搞成了LLAP，Live Long And Process(Prosper)</p>
<p><strong>LLAP设计目的</strong><br>Live-Long And Process<br>进一步提升Hive的执行速度<br>    长驻在服务端的守护进程<br>    取代直接与HDFS的DataNode交互（IO性能）<br>    紧密集成的基于DAG的框架<br>    缓存、预读机制<br>    查询片段处理与访问控制<br>    降低申请、释放Yarn Container的开销</p>
<p><strong>LLAP守护进程的特点</strong><br>与DataNode一样部署在服务端<br>结点无状态<br>故障恢复<br>弹性扩展</p>
<p><strong>LLAP示例</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%9C%8D%E5%8A%A1%E5%8C%96%EF%BC%9ALLAP%E3%80%81HiveServer2%E3%80%81MetaStore%EF%BC%88%E4%B8%83%EF%BC%89/20170521133759952.png" alt="这里写图片描述"></p>
<p><strong>执行示例</strong><br>Tez AM控制查询执行<br>查询的初始阶段在LLAP<br>Shuffle Join在Yarn Container执行<br>多个查询可以并发使用LLAP</p>
<p><strong>LLAP设计文档</strong><br><span class="exturl" data-url="aHR0cHM6Ly9pc3N1ZXMuYXBhY2hlLm9yZy9qaXJhL3NlY3VyZS9hdHRhY2htZW50LzEyNjY1NzA0L0xMQVBkZXNpZ25kb2N1bWVudC5wZGY=">https://issues.apache.org/jira/secure/attachment/12665704/LLAPdesigndocument.pdf<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9jd2lraS5hcGFjaGUub3JnL2NvbmZsdWVuY2UvZGlzcGxheS9IaXZlL0xMQVA=">https://cwiki.apache.org/confluence/display/Hive/LLAP<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>LLAP源码</strong><br>服务端LlapDaemon<br>    <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kYXRsYXMuY29tL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvbWFzdGVyL2xsYXAtc2VydmVyL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvbGxhcC9kYWVtb24vaW1wbC9MbGFwRGFlbW9uLmphdmE/bGluZT04Mw==">https://www.codatlas.com/github.com/apache/hive/master/llap-server/src/java/org/apache/hadoop/hive/llap/daemon/impl/LlapDaemon.java?line=83<i class="fa fa-external-link-alt"></i></span><br>客户端 LlapServiceDriver<br>    <span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kYXRsYXMuY29tL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvbWFzdGVyL2xsYXAtc2VydmVyL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvbGxhcC9jbGkvTGxhcFNlcnZpY2VEcml2ZXIuamF2YT9saW5lPTgz">https://www.codatlas.com/github.com/apache/hive/master/llap-server/src/java/org/apache/hadoop/hive/llap/cli/LlapServiceDriver.java?line=83<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>加速执行查询片段 Query Fragments</strong><br>加速查询片段（Query Fragments）的执行<br>    Filters (FIL, where)<br>    Projections (SEL, select col)<br>    Data Transformations (UDF)<br>    Partial Aggregates (UDAF)<br>    Sorting<br>    Bucketing<br>    Hash Joins &#x2F; Semi Joins</p>
<p><strong>LLAP加速执行查询片段 Query Fragments</strong></p>
<p>加速查询片段（Query Fragments）的执行<br>并发执行<br>客户端API直接访问<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kYXRsYXMuY29tL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvbWFzdGVyL2xsYXAtc2VydmVyL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvbGxhcC9kYWVtb24vaW1wbC9RdWVyeUluZm8uamF2YT9saW5lPTQw">https://www.codatlas.com/github.com/apache/hive/master/llap-server/src/java/org/apache/hadoop/hive/llap/daemon/impl/QueryInfo.java?line=40<i class="fa fa-external-link-alt"></i></span><br>tez任务的执行，查询片段会交给llap执行，直接在内存中执行，加快执行速度。这块和impla差不多。</p>
<p><strong>LLAP IO</strong><br>降低解压、抽取数据的开销<br>原来每个Task执行一次，现在一开始仅执行一次<br>支持多种数据格式，用一种新的InputFormat进行封装，目前效果最好是ORCFile<br>预测读、Bloom Filter提升读效率<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kYXRsYXMuY29tL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvbWFzdGVyL2xsYXAtc2VydmVyL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvbGxhcC9pby9hcGkvaW1wbC9MbGFwSW5wdXRGb3JtYXQuamF2YT9saW5lPTgz">https://www.codatlas.com/github.com/apache/hive/master/llap-server/src/java/org/apache/hadoop/hive/llap/io/api/impl/LlapInputFormat.java?line=83<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>LLAP Caching</strong><br>缓存输入文件的元数据<br>缓存数据本身<br>可扩展的缓存失效机制：默认是LRFU<br>可扩展的缓存粒度控制：默认是列块为基本单位 ORCFile<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kYXRsYXMuY29tL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvbWFzdGVyL2xsYXAtc2VydmVyL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvbGxhcC9jYWNoZS9Mb3dMZXZlbENhY2hlLmphdmE/bGluZT0yNw==">https://www.codatlas.com/github.com/apache/hive/master/llap-server/src/java/org/apache/hadoop/hive/llap/cache/LowLevelCache.java?line=27<i class="fa fa-external-link-alt"></i></span><br>提供了读和写的方法，内部实现用的是一个currenthashmap。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DiskRangeList getFileData(Object fileKey, DiskRangeList range, long baseOffset,</span><br><span class="line">    DiskRangeListFactory factory, LowLevelCacheCounters qfCounters, BooleanRef gotAllData);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Puts file data into cache.</span><br><span class="line"> * @return null if all data was put; bitmask indicating which chunks were not put otherwise;</span><br><span class="line"> *         the replacement chunks from cache are updated directly in the array.</span><br><span class="line"> */</span><br><span class="line">long[] putFileData(Object fileKey, DiskRange[] ranges, MemoryBuffer[] chunks,</span><br><span class="line">    long baseOffset, Priority priority, LowLevelCacheCounters qfCounters);</span><br></pre></td></tr></table></figure>


<p><strong>ORCFile在LLAP使用LowLevelCache</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%9C%8D%E5%8A%A1%E5%8C%96%EF%BC%9ALLAP%E3%80%81HiveServer2%E3%80%81MetaStore%EF%BC%88%E4%B8%83%EF%BC%89/20170521140811396.png" alt="这里写图片描述">  </p>
<p><strong>过载控制</strong><br>目前，自身没有控制<br>提交Tez作业的Yarn有控制<br>依赖于上层Yarn的控制<br>调优需要根据实际情况多次测试</p>
<p><strong>ACID</strong><br>支持一致性和原子性<br>Delta Files 增量变更文件<br>一系列表的状态，可进行合并<br>支持多版本，请求指定版本</p>
<p><strong>通过Yarn直接部署LLAP</strong><br><span class="exturl" data-url="aHR0cDovL3B1YmxpYy1yZXBvLTEuaG9ydG9ud29ya3MuY29tL3NsaWRlci8wLjMwL0hvcnRvbndvcmtzVGVjaG5pY2FsUHJldmlldy1TbGlkZXIucGRm">http://public-repo-1.hortonworks.com/slider/0.30/HortonworksTechnicalPreview-Slider.pdf<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>Hive Server 2</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%9C%8D%E5%8A%A1%E5%8C%96%EF%BC%9ALLAP%E3%80%81HiveServer2%E3%80%81MetaStore%EF%BC%88%E4%B8%83%EF%BC%89/20170521154336328.png" alt="这里写图片描述"><br>注意metadata可以放在外边，不一定在hiveserver2里边。<br><strong>认证模型</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%9C%8D%E5%8A%A1%E5%8C%96%EF%BC%9ALLAP%E3%80%81HiveServer2%E3%80%81MetaStore%EF%BC%88%E4%B8%83%EF%BC%89/20170521154645267.png" alt="这里写图片描述">  </p>
<p>博客:<br><span class="exturl" data-url="aHR0cDovL2Jsb2cuY2xvdWRlcmEuY29tL2Jsb2cvMjAxMy8wNy9ob3ctaGl2ZXNlcnZlcjItYnJpbmdzLXNlY3VyaXR5LWFuZC1jb25jdXJyZW5jeS10by1hcGFjaGUtaGl2ZS8=">http://blog.cloudera.com/blog/2013/07/how-hiveserver2-brings-security-and-concurrency-to-apache-hive/<i class="fa fa-external-link-alt"></i></span></p>
<p><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%9C%8D%E5%8A%A1%E5%8C%96%EF%BC%9ALLAP%E3%80%81HiveServer2%E3%80%81MetaStore%EF%BC%88%E4%B8%83%EF%BC%89/20170521154941019.png" alt="这里写图片描述">  </p>
<p><strong>代码查看</strong><br>一个标准的Thrift Server<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kYXRsYXMuY29tL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvbWFzdGVyL3NlcnZpY2Uvc3JjL2phdmEvb3JnL2FwYWNoZS9oaXZlL3NlcnZpY2Uvc2VydmVyL0hpdmVTZXJ2ZXIyLmphdmE/bGluZT05NQ==">https://www.codatlas.com/github.com/apache/hive/master/service/src/java/org/apache/hive/service/server/HiveServer2.java?line=95<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  HiveConf.setLoadHiveServer2Config(true);</span><br><span class="line">  try &#123;</span><br><span class="line">    ServerOptionsProcessor oproc = new ServerOptionsProcessor(&quot;hiveserver2&quot;);</span><br><span class="line">    ServerOptionsProcessorResponse oprocResponse = oproc.parse(args);</span><br><span class="line"></span><br><span class="line">    // NOTE: It is critical to do this here so that log4j is reinitialized</span><br><span class="line">    // before any of the other core hive classes are loaded</span><br><span class="line">    String initLog4jMessage = LogUtils.initHiveLog4j();</span><br><span class="line">    LOG.debug(initLog4jMessage);</span><br><span class="line">    HiveStringUtils.startupShutdownMessage(HiveServer2.class, args, LOG);</span><br><span class="line"></span><br><span class="line">    // Logger debug message from &quot;oproc&quot; after log4j initialize properly</span><br><span class="line">    LOG.debug(oproc.getDebugMessage().toString());</span><br><span class="line"></span><br><span class="line">    // Call the executor which will execute the appropriate command based on the parsed options</span><br><span class="line">    oprocResponse.getServerOptionsExecutor().execute();</span><br><span class="line">  &#125; catch (LogInitializationException e) &#123;</span><br><span class="line">    LOG.error(&quot;Error initializing log: &quot; + e.getMessage(), e);</span><br><span class="line">    System.exit(-1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Configurations and Run</strong><br>Config:<br>    hive.server2.transport.mode &#x3D; binary | http | https<br>    hive.server2.thrift.port &#x3D; 10000<br>    hive.server2.thrift.bind.host<br>    hive.server2.thrift.min.worker.threads &#x3D; 5<br>    hive.server2.thrift.max.worker.threads &#x3D; 500<br>    hive.server2.async.exec.threads &#x3D; 50<br>    hive.server2.async.exec.shutdown.timeout &#x3D; 10 (seconds)<br>    hive.support.concurrency &#x3D; true hive.zookeeper.quorum &#x3D;<br>    …<br>Run:<br>    Start HiveServer2<br>    bin&#x2F;hiveserver2 &amp;<br>Start CLI (use standard JDBC)<br>    bin&#x2F;beeline<br>    !connect jdbc:hive2:&#x2F;&#x2F;localhost:10000<br>    show tables;<br>    select * from tablename limit 10;</p>
<p><strong>新版支持监控Web UI</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%9C%8D%E5%8A%A1%E5%8C%96%EF%BC%9ALLAP%E3%80%81HiveServer2%E3%80%81MetaStore%EF%BC%88%E4%B8%83%EF%BC%89/20170521160025567.png" alt="这里写图片描述"><br>10002端口<br><span class="exturl" data-url="aHR0cHM6Ly9jd2lraS5hcGFjaGUub3JnL2NvbmZsdWVuY2UvZGlzcGxheS9IaXZlL1NldHRpbmcrVXArSGl2ZVNlcnZlcjI=">https://cwiki.apache.org/confluence/display/Hive/Setting+Up+HiveServer2<i class="fa fa-external-link-alt"></i></span><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%9C%8D%E5%8A%A1%E5%8C%96%EF%BC%9ALLAP%E3%80%81HiveServer2%E3%80%81MetaStore%EF%BC%88%E4%B8%83%EF%BC%89/20170521160520699.png" alt="这里写图片描述"></p>
<p><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%9C%8D%E5%8A%A1%E5%8C%96%EF%BC%9ALLAP%E3%80%81HiveServer2%E3%80%81MetaStore%EF%BC%88%E4%B8%83%EF%BC%89/20170521161036186.png" alt="这里写图片描述">  </p>
<p><strong>JDBC</strong><br><span class="exturl" data-url="aHR0cHM6Ly9jd2lraS5hcGFjaGUub3JnL2NvbmZsdWVuY2UvZGlzcGxheS9IaXZlL0hpdmVKREJDSW50ZXJmYWNl">https://cwiki.apache.org/confluence/display/Hive/HiveJDBCInterface<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kYXRsYXMuY29tL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvbWFzdGVyL2pkYmMvc3JjL2phdmEvb3JnL2FwYWNoZS9oaXZlL2pkYmMvSGl2ZUNvbm5lY3Rpb24uamF2YT9saW5lPTExMw==">https://www.codatlas.com/github.com/apache/hive/master/jdbc/src/java/org/apache/hive/jdbc/HiveConnection.java?line=113<i class="fa fa-external-link-alt"></i></span><br>JDBC的本质是一个HiveServer2的Thrift Client，只不过对用户暴露了JDBC接口</p>
<p><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%9C%8D%E5%8A%A1%E5%8C%96%EF%BC%9ALLAP%E3%80%81HiveServer2%E3%80%81MetaStore%EF%BC%88%E4%B8%83%EF%BC%89/20170521161551376.png" alt="这里写图片描述">  </p>
<p><strong>JDBC</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%9C%8D%E5%8A%A1%E5%8C%96%EF%BC%9ALLAP%E3%80%81HiveServer2%E3%80%81MetaStore%EF%BC%88%E4%B8%83%EF%BC%89/20170521161700376.png" alt="这里写图片描述"></p>
<p><strong>MetaStore (HMS)</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%9C%8D%E5%8A%A1%E5%8C%96%EF%BC%9ALLAP%E3%80%81HiveServer2%E3%80%81MetaStore%EF%BC%88%E4%B8%83%EF%BC%89/20170521161821236.png" alt="这里写图片描述">  </p>
<p><strong>MetaStore配置</strong><br>hive.metastore.uris<br>    如果这个值为空，就表示使用本地数据库<br>    一个逗号分隔的列表，表示使用Meta Store</p>
<p><strong>MetaStore做什么</strong><br>表结构的增删改<br>数据本身目录的删除、修改<br>数据结构、数据类型、序列化查询<br>元数据服务化，给别的程序如Pig、Impala、MR、Spark使用<br>Hcatlog本质上是一个MetaStore客户端<br>降低配置，提升安全</p>
<p><strong>相关部署文档</strong><br><span class="exturl" data-url="aHR0cHM6Ly9jd2lraS5hcGFjaGUub3JnL2NvbmZsdWVuY2UvZGlzcGxheS9IaXZlL0FkbWluTWFudWFsK01ldGFzdG9yZUFkbWlu">https://cwiki.apache.org/confluence/display/Hive/AdminManual+MetastoreAdmin<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>层次结构</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%9C%8D%E5%8A%A1%E5%8C%96%EF%BC%9ALLAP%E3%80%81HiveServer2%E3%80%81MetaStore%EF%BC%88%E4%B8%83%EF%BC%89/20170521162507869.png" alt="这里写图片描述">  </p>
<p><strong>MetaStore代码</strong><br>服务端：<br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvbWV0YXN0b3JlL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvbWV0YXN0b3JlL0hpdmVNZXRhU3RvcmUuamF2YT9saW5lPTE2NQ==">https://insight.io/github.com/apache/hive/blob/master/metastore/src/java/org/apache/hadoop/hive/metastore/HiveMetaStore.java?line=165<i class="fa fa-external-link-alt"></i></span><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%9C%8D%E5%8A%A1%E5%8C%96%EF%BC%9ALLAP%E3%80%81HiveServer2%E3%80%81MetaStore%EF%BC%88%E4%B8%83%EF%BC%89/20170521163135751.png" alt="这里写图片描述"><br>客户端：<br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvbWV0YXN0b3JlL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvbWV0YXN0b3JlL0lNZXRhU3RvcmVDbGllbnQuamF2YT9saW5lPTEwNA==">https://insight.io/github.com/apache/hive/blob/master/metastore/src/java/org/apache/hadoop/hive/metastore/IMetaStoreClient.java?line=104<i class="fa fa-external-link-alt"></i></span><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%9C%8D%E5%8A%A1%E5%8C%96%EF%BC%9ALLAP%E3%80%81HiveServer2%E3%80%81MetaStore%EF%BC%88%E4%B8%83%EF%BC%89/20170521163229862.png" alt="这里写图片描述"><br>IMetaStoreClient内部含有很多获取表的方法。</p>
<p><strong>本地与远程</strong><br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvbWV0YXN0b3JlL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvbWV0YXN0b3JlL0hpdmVNZXRhU3RvcmVDbGllbnQuamF2YT9saW5lPTE1NQ==">https://insight.io/github.com/apache/hive/blob/master/metastore/src/java/org/apache/hadoop/hive/metastore/HiveMetaStoreClient.java?line=155<i class="fa fa-external-link-alt"></i></span><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%9C%8D%E5%8A%A1%E5%8C%96%EF%BC%9ALLAP%E3%80%81HiveServer2%E3%80%81MetaStore%EF%BC%88%E4%B8%83%EF%BC%89/20170521164029248.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>hive原理与源码分析-物理执行计划与执行引擎（六）</title>
    <url>/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%89%A9%E7%90%86%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    <content><![CDATA[<p><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%89%A9%E7%90%86%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E5%85%AD%EF%BC%89/20170516204226246.png" alt="这里写图片描述">  </p>
<span id="more"></span>
<p><strong>Hive执行</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%89%A9%E7%90%86%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E5%85%AD%EF%BC%89/20170516204330223.png" alt="这里写图片描述"></p>
<p><strong>相关配置</strong><br>hive.execution.engine - Hive执行引擎<br>    mr - 在MapReduce上执行<br>    tez - 在Tez上执行<br>    spark - 在Spark上执行<br>hive.execution.mode – Hive执行模式<br>    container - 在Yarn Container内执行Query Fragments<br>    llap – 在LLAP内执行Query Fragments<br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvY29tbW9uL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvY29uZi9IaXZlQ29uZi5qYXZhP2xpbmU9MjYzNQ==">https://insight.io/github.com/apache/hive/blob/master/common/src/java/org/apache/hadoop/hive/conf/HiveConf.java?line=2635<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>物理执行计划和逻辑执行计划的区别</strong><br>逻辑执行计划是一个Operator图<br>物理执行计划是一个Task图<br>物理执行计划是把逻辑执行计划切分成子图<br>物理执行计划图的每个Task结点内是一个Operator结点的子图</p>
<p><strong>举个例子</strong><br>SELECT * FROM a JOIN b ON a.id&#x3D;b.id;<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%89%A9%E7%90%86%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E5%85%AD%EF%BC%89/20170516204932273.png" alt="这里写图片描述"></p>
<p><strong>物理执行计划的Task类型</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%89%A9%E7%90%86%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E5%85%AD%EF%BC%89/20170516205328150.png" alt="这里写图片描述">  </p>
<p><strong>逻辑层和物理层的分界</strong><br>逻辑优化的最后一步<br>Optimizer的最后一步<br>SimpleFetchOptimzer<br>看代码<br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9vcHRpbWl6ZXIvT3B0aW1pemVyLmphdmE/bGluZT0yMjg=">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/optimizer/Optimizer.java?line=228<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (!HiveConf.getVar(hiveConf, HiveConf.ConfVars.HIVEFETCHTASKCONVERSION).equals(&quot;none&quot;)) &#123;</span><br><span class="line">  transformations.add(new SimpleFetchOptimizer()); // must be called last</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>SemanticAnalyzer第七步</strong><br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9wYXJzZS9TZW1hbnRpY0FuYWx5emVyLmphdmE/bGluZT0xMTM1Ng==">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java?line=11356<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">  LOG.debug(&quot;Before logical optimization\n&quot; + Operator.toString(pCtx.getTopOps().values()));</span><br><span class="line">&#125;</span><br><span class="line">Optimizer optm = new Optimizer();</span><br><span class="line">optm.setPctx(pCtx);</span><br><span class="line">optm.initialize(conf);</span><br><span class="line">pCtx = optm.optimize();//fetchTask在逻辑执行计划最后一步生成</span><br><span class="line">if (pCtx.getColumnAccessInfo() != null) &#123;</span><br><span class="line">  // set ColumnAccessInfo for view column authorization</span><br><span class="line">  setColumnAccessInfo(pCtx.getColumnAccessInfo());</span><br><span class="line">&#125;</span><br><span class="line">FetchTask origFetchTask = pCtx.getFetchTask();//fetchTask是物理执行计划的开始</span><br><span class="line">if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">  LOG.debug(&quot;After logical optimization\n&quot; + Operator.toString(pCtx.getTopOps().values()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>开始搞物理执行计划</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%89%A9%E7%90%86%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E5%85%AD%EF%BC%89/20170516210713670.png" alt="这里写图片描述"><br>TaskCompilerFactory是编译器的工厂类<br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9wYXJzZS9UYXNrQ29tcGlsZXJGYWN0b3J5LmphdmE/bGluZT0zOA==">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/parse/TaskCompilerFactory.java?line=38<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns the appropriate compiler to translate the operator tree</span><br><span class="line"> * into executable units.</span><br><span class="line"> */</span><br><span class="line">public static TaskCompiler getCompiler(HiveConf conf, ParseContext parseContext) &#123;</span><br><span class="line">  if (HiveConf.getVar(conf, HiveConf.ConfVars.HIVE_EXECUTION_ENGINE).equals(&quot;tez&quot;)) &#123;</span><br><span class="line">    return new TezCompiler();</span><br><span class="line">  &#125; else if (HiveConf.getVar(conf, HiveConf.ConfVars.HIVE_EXECUTION_ENGINE).equals(&quot;spark&quot;)) &#123;</span><br><span class="line">    return new SparkCompiler();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return new MapReduceCompiler();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>支持tez、spark、和mr方式。<br>途中rootTask就是生成的有向无环图的指针。</p>
<p><strong>TaskCompiler</strong><br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9wYXJzZS9UYXNrQ29tcGlsZXIuamF2YT9saW5lPTg3">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/parse/TaskCompiler.java?line=87<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//生成物理执行计划</span><br><span class="line">    generateTaskTree(rootTasks, pCtx, mvTask, inputs, outputs);</span><br><span class="line"></span><br><span class="line">    // For each task, set the key descriptor for the reducer</span><br><span class="line">    for (Task&lt;? extends Serializable&gt; rootTask : rootTasks) &#123;</span><br><span class="line">      GenMapRedUtils.setKeyAndValueDescForTaskTree(rootTask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If a task contains an operator which instructs bucketizedhiveinputformat</span><br><span class="line">    // to be used, please do so</span><br><span class="line">    for (Task&lt;? extends Serializable&gt; rootTask : rootTasks) &#123;</span><br><span class="line">      setInputFormat(rootTask);</span><br><span class="line">    &#125;</span><br><span class="line">//物理优化</span><br><span class="line">    optimizeTaskPlan(rootTasks, pCtx, ctx);</span><br></pre></td></tr></table></figure>
<p>TaskCompiler.generateTaskTree()<br>MapReduceCompler.generateTaskTree()<br>SparkCompler.generateTaskTree()<br>TezCompler.generateTaskTree()</p>
<p><strong>不同的引擎有不同的物理优化</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%89%A9%E7%90%86%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E5%85%AD%EF%BC%89/20170516211729545.png" alt="这里写图片描述"></p>
<p><strong>MapReduceCompiler 生成物理执行计划</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%89%A9%E7%90%86%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E5%85%AD%EF%BC%89/20170516212355116.png" alt="这里写图片描述"><br>这个过程就是讲逻辑执行计划切分成物理执行计划。</p>
<p><strong>如何切割逻辑执行计划？</strong><br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9vcHRpbWl6ZXIvR2VuTWFwUmVkVXRpbHMuamF2YT9saW5lPTQwNQ==">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/optimizer/GenMapRedUtils.java?line=405<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Met cRS in pOP(parentTask with RS)-cRS-cOP(noTask) case</span><br><span class="line">   * Create new child task for cRS-cOP and link two tasks by temporary file : pOP-FS / TS-cRS-cOP</span><br><span class="line">   *</span><br><span class="line">   * @param cRS</span><br><span class="line">   *          the reduce sink operator encountered</span><br><span class="line">   * @param opProcCtx</span><br><span class="line">   *          processing context</span><br><span class="line">   */</span><br><span class="line">  static void splitPlan(ReduceSinkOperator cRS, GenMRProcContext opProcCtx)</span><br><span class="line">      throws SemanticException &#123;</span><br><span class="line">    // Generate a new task</span><br><span class="line">    ParseContext parseCtx = opProcCtx.getParseCtx();</span><br><span class="line">    Task&lt;? extends Serializable&gt; parentTask = opProcCtx.getCurrTask();</span><br><span class="line"></span><br><span class="line">    MapredWork childPlan = getMapRedWork(parseCtx);</span><br><span class="line">    Task&lt;? extends Serializable&gt; childTask = TaskFactory.get(childPlan, parseCtx</span><br><span class="line">        .getConf());</span><br><span class="line">    Operator&lt;? extends OperatorDesc&gt; reducer = cRS.getChildOperators().get(0);</span><br><span class="line"></span><br><span class="line">    // Add the reducer</span><br><span class="line">    ReduceWork rWork = new ReduceWork();</span><br><span class="line">    childPlan.setReduceWork(rWork);</span><br><span class="line">    rWork.setReducer(reducer);</span><br><span class="line">    ReduceSinkDesc desc = cRS.getConf();</span><br><span class="line">    childPlan.getReduceWork().setNumReduceTasks(new Integer(desc.getNumReducers()));</span><br><span class="line"></span><br><span class="line">    opProcCtx.getOpTaskMap().put(reducer, childTask);</span><br><span class="line"></span><br><span class="line">    splitTasks(cRS, parentTask, childTask, opProcCtx);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>MR物理优化器</strong><br>spark物理执行计划、tez物理执行计划、mr物理执行计划之后会有物理优化器，下列是一些优化器<br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9vcHRpbWl6ZXIvcGh5c2ljYWwvUGh5c2ljYWxPcHRpbWl6ZXIuamF2YT9saW5lPTQ3">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/optimizer/physical/PhysicalOptimizer.java?line=47<i class="fa fa-external-link-alt"></i></span></p>
<p><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%89%A9%E7%90%86%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E5%85%AD%EF%BC%89/20170516213606789.png" alt="这里写图片描述"><br>这些优化器是为mr专用的，而spark和tez是不用这些优化器的。<br>奇怪的是mr物理优化器的名字是PhysicalOptimizer，而逻辑优化器就是Optimizer。</p>
<p>hive-on-MR vs hive-on-tez<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%89%A9%E7%90%86%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E5%85%AD%EF%BC%89/20170516214307582.png" alt="这里写图片描述"><br>从图中可以看出，加入mr的方式中间有一些机器死掉了，但是他们计算的中间结果会写到磁盘，下一次会接着执行，数据不会丢失，但是tez的形式中间数据没有落盘，只要死掉数据就会有问题。这就是mr和tez的区别，mr更稳定一些，tez比较快。</p>
<p><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%89%A9%E7%90%86%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E5%85%AD%EF%BC%89/20170516214916963.png" alt="这里写图片描述"><br> shuffle的区别<br> <img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%89%A9%E7%90%86%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E5%85%AD%EF%BC%89/20170516215059945.png" alt="这里写图片描述">  </p>
<p><strong>TezCompiler</strong><br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9wYXJzZS9UZXpDb21waWxlci5qYXZhP2xpbmU9NDU3">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/parse/TezCompiler.java?line=457<i class="fa fa-external-link-alt"></i></span><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%89%A9%E7%90%86%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E5%85%AD%EF%BC%89/20170516220031494.png" alt="这里写图片描述">  </p>
<p><strong>SparkCompiler</strong><br>基本上和TezCompiler一致<br>代码注释上直接写着：<br>Cloned from TezCompiler<br>优化器和逻辑执行计划的切分在一起<br>生成Spark作业<br><span class="exturl" data-url="aHR0cHM6Ly9pc3N1ZXMuYXBhY2hlLm9yZy9qaXJhL3NlY3VyZS9hdHRhY2htZW50LzEyNjUyNTE3L0hpdmUtb24tU3BhcmsucGRm">https://issues.apache.org/jira/secure/attachment/12652517/Hive-on-Spark.pdf<i class="fa fa-external-link-alt"></i></span><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%89%A9%E7%90%86%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E5%85%AD%EF%BC%89/20170516220341279.png" alt="这里写图片描述"><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%89%A9%E7%90%86%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E5%85%AD%EF%BC%89/20170516220542813.png" alt="这里写图片描述">  </p>
<p><strong>很有意思</strong><br>Spark编译时直接拷贝了Tez代码<br>命名时加上了Spark前缀<br>进一步可见：Spark和Tez在执行机制上非常类似</p>
<p><strong>基于路径规则优化总结</strong><br>Optimizer会根据规则优化逻辑执行计划，并修改逻辑执行计划为优化后的逻辑执行计划<br>TaskCompiler（无论哪种）会根据规则来切分逻辑执行计划<br>Hive中对Operator图的修改基本上都是基于深度优先路径规则的</p>
<p><strong>深度优先递规下降遍历</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%89%A9%E7%90%86%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E5%85%AD%EF%BC%89/20170520094123424.png" alt="这里写图片描述">  </p>
<p><strong>提交不同引擎的作业MR</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%89%A9%E7%90%86%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E5%85%AD%EF%BC%89/20170520094939458.png" alt="这里写图片描述">  </p>
<p><strong>提交不同引擎作业Spark</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%89%A9%E7%90%86%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E5%85%AD%EF%BC%89/20170520095018693.png" alt="这里写图片描述">  </p>
<p><strong>提交不同引擎的作业Tez</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%89%A9%E7%90%86%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E5%85%AD%EF%BC%89/20170520095057366.png" alt="这里写图片描述">  </p>
<p>Driver的 launchTask方法：<br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9Ecml2ZXIuamF2YT9saW5lPTIxMzA=">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/Driver.java?line=2130<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>广度优先，并发提交</strong><br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9Ecml2ZXIuamF2YT9saW5lPTE4MzA=">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/Driver.java?line=1830<i class="fa fa-external-link-alt"></i></span><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%89%A9%E7%90%86%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88%E5%85%AD%EF%BC%89/20170520095808761.png" alt="这里写图片描述">  </p>
]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>hive原理与源码分析-算子Operators及查询优化器Optimizers（四）</title>
    <url>/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%AE%97%E5%AD%90Operators%E5%8F%8A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8Optimizers%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<p><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%AE%97%E5%AD%90Operators%E5%8F%8A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8Optimizers%EF%BC%88%E5%9B%9B%EF%BC%89/20170509211147684.png" alt="这里写图片描述"></p>
<span id="more"></span>
<p><strong>Operator接口</strong><br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9leGVjL09wZXJhdG9yLmphdmE/bGluZT02Ng==">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/exec/Operator.java?line=66<i class="fa fa-external-link-alt"></i></span><br>这个接口最重要的一个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Process the row.</span><br><span class="line"> * @param row The object representing the row.</span><br><span class="line"> * @param tag</span><br><span class="line"> *          The tag of the row usually means which parent this row comes from.</span><br><span class="line"> *          Rows with the same tag should have exactly the same rowInspector</span><br><span class="line"> *          all the time.</span><br><span class="line"> */</span><br><span class="line">public abstract void process(Object row, int tag) throws HiveException;</span><br></pre></td></tr></table></figure>
<p>row是一行数据，tag代表是那张表。用一个整数代表是那张表。<br>hadoop在执行任务的时候会在每个节点创建一个进程。<br>每个进程一个实例<br>每个实例开始执行一次initialize()方法<br>每个实例执行多次process()方法，每行执行一次，这个进程有几行就执行几次<br>每个实例最后执行一次close()方法<br>对于Operator比较正要的有group by Operator和join Operator<br>前文章节SemanticAnalyzer生成一个QB，之后递归genplan(),然后是genBodyPlan()，genBodyPlan会对group by进行处理：<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%AE%97%E5%AD%90Operators%E5%8F%8A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8Optimizers%EF%BC%88%E5%9B%9B%EF%BC%89/20170509213828136.png" alt="这里写图片描述"><br>HiveConf.ConfVars.HIVEMAPSIDEAGGREGATE：在map阶段进行预聚合减少数据量<br> HiveConf.ConfVars.HIVEGROUPBYSKEW：将一个group by拆成2个group by减少数据量<br> <strong>Hive Group By</strong><br> HiveConf.ConfVars.HIVEMAPSIDEAGGREGATE：hive.map.aggr，使用Map端预聚合<br>HiveConf.ConfVars.HIVEGROUPBYSKEW：hive.groupby.skewindata，是否优化倾斜的查询为两道作业<br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9wYXJzZS9TZW1hbnRpY0FuYWx5emVyLmphdmE/bGluZT05NzEz">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java?line=9713<i class="fa fa-external-link-alt"></i></span><br>一共四中情况<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%AE%97%E5%AD%90Operators%E5%8F%8A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8Optimizers%EF%BC%88%E5%9B%9B%EF%BC%89/20170509215359704.png" alt="这里写图片描述"></p>
<p><strong>Hive GroupBy hive.groupby.skewindata</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%AE%97%E5%AD%90Operators%E5%8F%8A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8Optimizers%EF%BC%88%E5%9B%9B%EF%BC%89/20170509215502001.png" alt="这里写图片描述"><br>Hive GroupBy hive.groupby.skewindata关闭的时候只有一道mr作业，当参数打开的时候，会进行预聚合，整个过程是2道mr作业。</p>
<p><strong>hive.groupby.skewindata源码</strong><br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9wYXJzZS9TZW1hbnRpY0FuYWx5emVyLmphdmE/bGluZT02MTE0">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java?line=6114<i class="fa fa-external-link-alt"></i></span><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%AE%97%E5%AD%90Operators%E5%8F%8A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8Optimizers%EF%BC%88%E5%9B%9B%EF%BC%89/20170513102443029.png" alt="这里写图片描述"></p>
<p>这样我们就能完美了吗，我们的group by就不会倾斜了吗？大部分的group by是不会倾斜的，但是有一种是特殊的。</p>
<p><strong>代数型聚合与非代数聚合</strong><br>代数型聚合：可以通过部分结果计算出最终结果的聚合方法，如count、sum<br>非代数型聚合：无法通过部分结果计算出最终结果的聚合方法，如percentile，median<br>Group By优化只适用于代数型聚合，代数型UDAF，思考为什么？</p>
<p>group by聚合：<br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9leGVjL0dyb3VwQnlPcGVyYXRvci5qYXZhP2xpbmU9NzM1">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/exec/GroupByOperator.java?line=735<i class="fa fa-external-link-alt"></i></span><br>group by的聚合逻辑就是这个process方法， process方法会调用 processHashAggr和 processAggr方法，即hash聚合和普通 聚合的方法。<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%AE%97%E5%AD%90Operators%E5%8F%8A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8Optimizers%EF%BC%88%E5%9B%9B%EF%BC%89/20170513103611159.png" alt="这里写图片描述"></p>
<p><strong>Join关联</strong><br>Join是Hive是最难的部分，也是最需要优化的部分<br>常用Join方法<br>普通（Reduce端）Join， Common (Reduce-Side) Join<br>广播（Map端）Join，Broadcast（Map-Side）Join<br>Bucket Map Join<br>Sort Merge Bucket Map Join<br>倾斜Join，Skew Join</p>
<p>先从最简单的Common Join开始，此join是所有join的基础。<br><strong>Common Join</strong><br>也叫做Reduce端Join<br>背景知识：Hive只支持等值Join，不支持非等值Join<br>        扫描N张表<br>        Join Key相同的放在一起（相同Reduce） -&gt; 结果<br>流程:<br>        Mapper: 扫描，并处理N张表，生成发给Reduce的<code>&lt;Key, Value&gt; Key = &#123;JoinKey, TableAlias&#125;, Value = &#123;row&#125;</code><br>        Shuffle阶段<br>        JoinKey相同的Reduce放到相同的<br>        TableAlias 是排序的标识，就是表的编号，相同表的数据在一起是排序的。<br>        Reducer: 处理Join Key并输出结果<br>最坏的情况<br>        所有的数据都被发送到相同的结点，同一个Reduce</p>
<p>JoinOperator：<br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9leGVjL0pvaW5PcGVyYXRvci5qYXZhP2xpbmU9Nzg=">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/exec/JoinOperator.java?line=78<i class="fa fa-external-link-alt"></i></span><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%AE%97%E5%AD%90Operators%E5%8F%8A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8Optimizers%EF%BC%88%E5%9B%9B%EF%BC%89/20170513110021266.png" alt="这里写图片描述"><br>从这个过程中我们可以看到，可以看到左边的表放到内存（放不下才会放到磁盘），因此我们join的时候要把小标放到左边，提供性能。</p>
<p>commonJoinOperation下边还有一些特化的Operator：</p>
<p><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%AE%97%E5%AD%90Operators%E5%8F%8A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8Optimizers%EF%BC%88%E5%9B%9B%EF%BC%89/20170513110611864.png" alt="这里写图片描述"></p>
<p>先说最简单的commonJoinOperator<br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9leGVjL0NvbW1vbkpvaW5PcGVyYXRvci5qYXZhP2xpbmU9NTY5">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/exec/CommonJoinOperator.java?line=569<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// creates objects in recursive manner</span><br><span class="line">  private void genObject(int aliasNum, boolean allLeftFirst, boolean allLeftNull)</span><br><span class="line">      throws HiveException &#123;</span><br><span class="line">    JoinCondDesc joinCond = condn[aliasNum - 1];</span><br><span class="line">    int type = joinCond.getType();</span><br><span class="line">    int left = joinCond.getLeft();</span><br><span class="line">    int right = joinCond.getRight();</span><br><span class="line"></span><br><span class="line">    if (needsPostEvaluation &amp;&amp; aliasNum == numAliases - 2) &#123;</span><br><span class="line">      int nextType = condn[aliasNum].getType();</span><br><span class="line">      if (nextType == JoinDesc.RIGHT_OUTER_JOIN || nextType == JoinDesc.FULL_OUTER_JOIN) &#123;</span><br><span class="line">        // Initialize container to use for storing tuples before emitting them</span><br><span class="line">        rowContainerPostFilteredOuterJoin = new HashMap&lt;&gt;();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean[] skip = skipVectors[aliasNum];</span><br><span class="line">    boolean[] prevSkip = skipVectors[aliasNum - 1];</span><br><span class="line"></span><br><span class="line">    // search for match in the rhs table</span><br><span class="line">    //内存里边的小表</span><br><span class="line">    AbstractRowContainer&lt;List&lt;Object&gt;&gt; aliasRes = storage[order[aliasNum]];</span><br><span class="line">    。。。。。。略。。。。</span><br><span class="line">    根据判断，执行inner join或者left join</span><br><span class="line">      if (type == JoinDesc.INNER_JOIN) &#123;</span><br><span class="line">        innerJoin(skip, left, right);</span><br><span class="line">      &#125; else if (type == JoinDesc.LEFT_SEMI_JOIN) &#123;</span><br><span class="line">        if (innerJoin(skip, left, right)) &#123;</span><br><span class="line">          // if left-semi-join found a match, skipping the rest of the rows in the</span><br><span class="line">          // rhs table of the semijoin</span><br><span class="line">          done = true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (type == JoinDesc.LEFT_OUTER_JOIN ||</span><br><span class="line">          (type == JoinDesc.FULL_OUTER_JOIN &amp;&amp; rightNull)) &#123;</span><br><span class="line">        int result = leftOuterJoin(skip, left, right);</span><br><span class="line">        if (result &lt; 0) &#123;</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">        done = result &gt; 0;</span><br><span class="line">      &#125; else if (type == JoinDesc.RIGHT_OUTER_JOIN ||</span><br><span class="line">          (type == JoinDesc.FULL_OUTER_JOIN &amp;&amp; allLeftNull)) &#123;</span><br><span class="line">        if (allLeftFirst &amp;&amp; !rightOuterJoin(skip, left, right) ||</span><br><span class="line">          !allLeftFirst &amp;&amp; !innerJoin(skip, left, right)) &#123;</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (type == JoinDesc.FULL_OUTER_JOIN) &#123;</span><br><span class="line">        if (tryLOForFO &amp;&amp; leftOuterJoin(skip, left, right) &gt; 0) &#123;</span><br><span class="line">          loopAgain = allLeftFirst;</span><br><span class="line">          done = !loopAgain;</span><br><span class="line">          tryLOForFO = false;</span><br><span class="line">        &#125; else if (allLeftFirst &amp;&amp; !rightOuterJoin(skip, left, right) ||</span><br><span class="line">          !allLeftFirst &amp;&amp; !innerJoin(skip, left, right)) &#123;</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>每来一条数据就会读取一下小表的内容，如果小表比较小，过程会比较快</p>
<p><strong>MapJoin</strong><br>也叫广播Join，Broadcast Join<br>从 (n-1)张小表创建Hashtable，Hashtable的键是 Joinkey, 把这张Hashtable广播到每一个结点的map上，只处理大表.<br>每一个大表的mapper在小表的hashtable中查找join key -&gt; Join Result<br>Ex: Join by “CityId”<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%AE%97%E5%AD%90Operators%E5%8F%8A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8Optimizers%EF%BC%88%E5%9B%9B%EF%BC%89/20170513112913270.png" alt="这里写图片描述"><br>MapJoin适合小表足够小的情况，否则就走 ReduceSinkOperator<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%AE%97%E5%AD%90Operators%E5%8F%8A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8Optimizers%EF%BC%88%E5%9B%9B%EF%BC%89/20170513113327235.png" alt="这里写图片描述"></p>
<p><strong>如何决定MapJoin</strong><br>内存要求: N-1 张小表必须能够完全读入内存<br>Hive决定MapJoin的两种方式（手动／自动）<br>    手动，通过Query Hints（不再推荐）:<br>        SELECT &#x2F;*+ MAPJOIN(cities) <em>&#x2F; * FROM cities JOIN sales on cities.cityId&#x3D;sales.cityId;<br>        &#x2F;</em>+ MAPJOIN(cities) *&#x2F; *会决定把cities读入内存，放在hashTable里边，分发到每一个节点。<br>自动，打开(“hive.auto.convert.join”)<br>        如果N-1张小表小于: “hive.mapjoin.smalltable.filesize”这个值</p>
<p><strong>MapJoin Optimizers</strong><br>构造查询计划Query Plan时，决定MapJoin优化<br>    “逻辑优化器Logical (Compile-time) optimizers” ：修改逻辑执行计划，把JoinOperator修改成MapJoinOperator<br>    “物理优化器Physical (Runtime) optimizers” 修改物理执行计划(MapRedWork, TezWork, SparkWork), 引入条件判断等机制<br>    <img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%AE%97%E5%AD%90Operators%E5%8F%8A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8Optimizers%EF%BC%88%E5%9B%9B%EF%BC%89/20170513125436340.png" alt="这里写图片描述"></p>
<p>逻辑优化之后ReduceSinkOperator.和普通的join operator被摘掉，换成mapjoin。<br>物理执行计划会被关联到具体的执行引擎，逻辑执行计划的小表部分会在本地执行，即左边小表在本地执行，逻辑执行计划的大表部分会被在远端执行。<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%AE%97%E5%AD%90Operators%E5%8F%8A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8Optimizers%EF%BC%88%E5%9B%9B%EF%BC%89/20170513130349171.png" alt="这里写图片描述"></p>
<p><strong>MapJoin Optimizers (MR)</strong><br>Query Hint: 编译时知道哪个表是小表的情况.（手动模式，加一个&#x2F;*+ MAPJOIN(cities) *&#x2F; *注释）<br>        Logical Optimizer逻辑优化器: MapJoinProcessor<br>Auto-conversion: 编译时不知道哪个表是小表的情况（自动模式）<br>    Physical Optimizer物理优化器: CommonJoinResolver, MapJoinResolver.<br>        创建Conditional Tasks 把每个表是小表的情况考虑进去<br>        Noconditional mode: 如果没有子查询的话，表的大小是在编译时可以知道的，否则是不知道的(join of intermediate results..)<br>        自动模式模式分了三种情况，其中一个属于小表，这是前两种情况，第三种是都不是小表。<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%AE%97%E5%AD%90Operators%E5%8F%8A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8Optimizers%EF%BC%88%E5%9B%9B%EF%BC%89/20170513131323724.png" alt="这里写图片描述"><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%AE%97%E5%AD%90Operators%E5%8F%8A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8Optimizers%EF%BC%88%E5%9B%9B%EF%BC%89/20170513131358807.png" alt="这里写图片描述"><br>这个过程在CommonJoinResolver中，<br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9vcHRpbWl6ZXIvcGh5c2ljYWwvQ29tbW9uSm9pblJlc29sdmVyLmphdmE/bGluZT03MQ==">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/optimizer/physical/CommonJoinResolver.java?line=71<i class="fa fa-external-link-alt"></i></span><br>实现细节是：<br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9vcHRpbWl6ZXIvcGh5c2ljYWwvQ29tbW9uSm9pblRhc2tEaXNwYXRjaGVyLmphdmE/bGluZT0xOTE=">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/optimizer/physical/CommonJoinTaskDispatcher.java?line=191<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>BucketMapJoin</strong><br>Bucketed 表: 根据不同的值分成不同的桶<br>CREATE TABLE cities (cityid int, value string) CLUSTERED BY (cityId) INTO 2 BUCKETS;即建表的时候指定桶。<br>如果把分桶键（Bucket Key）作为关联键（Join Key）: For each bucket of table, rows with matching joinKey values will be in corresponding bucket of other table<br>像Mapjoin, but big-table mappers load to memory only relevant small-table bucket‟s hashmap<br>Ex: Bucketed by “CityId”, Join by “CityId”<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%AE%97%E5%AD%90Operators%E5%8F%8A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8Optimizers%EF%BC%88%E5%9B%9B%EF%BC%89/20170513132619074.png" alt="这里写图片描述"><br>1和3在一个桶（奇数），2和4一个桶（偶数）。</p>
<p><strong>Bucket MapJoin 执行过程</strong><br>与MapJoin非常类似<br>    HashTableSink (小表) 写Hashtable是每个桶写一个Hashtable，而不是每张表写一个<br>    HashTableLoader (大表Mapper mapper) 也是每个桶读取一次HashTable</p>
<p><strong>SMB Join</strong><br>CREATE TABLE cities (cityid int, cityName string) CLUSTERED BY (cityId) SORTED BY (cityId) INTO 2 BUCKETS;<br>Join tables are bucketed and sorted (per bucket)<br>This allows sort-merge join per bucket.<br>    Advance table until find a match</p>
<p>建表的时候对桶内的指定字段进行排序，这样的安排可以直接使用common join operator,不需要使用map join operator，直接把表读出来交给common join operator</p>
<p><strong>SMB Join</strong><br>MR和Spark执行方式相同<br>用mapper处理大表，处理过程中直接读取对应的小表<br>Map直接读取小表中相应的文件，相应的部分，避免了广播的开销<br>小表没有大小的限制<br>前提是，要知道经常使用哪个键做Join<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%AE%97%E5%AD%90Operators%E5%8F%8A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8Optimizers%EF%BC%88%E5%9B%9B%EF%BC%89/20170513134449192.png" alt="这里写图片描述"></p>
<p><strong>SMB Join Optimizers: MR</strong><br>SMB 需要识别„大表‟，以便在大表上运行mapper，执行过程中读取„小表‟. 通常来说，在编译时决定<br>手动方法，用户可以手动提供hints<br>    Triggered by “hive.optimize.bucketmapjoin.sortedmerge”<br>    Logical Optimizer逻辑优化器: SortedMergeBucketMapJoinProc<br>自动触发: “hive.auto.convert.sortmerge.join.bigtable.selection.policy” 一个处理类<br>    Triggered by “hive.auto.convert.sortmerge.join”<br>    Logical Optimizer: SortedBucketMapJoinProc<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%AE%97%E5%AD%90Operators%E5%8F%8A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8Optimizers%EF%BC%88%E5%9B%9B%EF%BC%89/20170513134553834.png" alt="这里写图片描述"><br>逻辑优化器SortedMergeBucketMapjoinProc的处理过程：<br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9vcHRpbWl6ZXIvU29ydGVkTWVyZ2VCdWNrZXRNYXBqb2luUHJvYy5qYXZhP2xpbmU9NDI=">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/optimizer/SortedMergeBucketMapjoinProc.java?line=42<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object process(Node nd, Stack&lt;Node&gt; stack, NodeProcessorCtx procCtx,</span><br><span class="line">    Object... nodeOutputs) throws SemanticException &#123;</span><br><span class="line">  if (nd instanceof SMBMapJoinOperator) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MapJoinOperator mapJoinOp = (MapJoinOperator) nd;</span><br><span class="line">  SortBucketJoinProcCtx smbJoinContext = (SortBucketJoinProcCtx) procCtx;</span><br><span class="line"></span><br><span class="line">  boolean convert =</span><br><span class="line">      canConvertBucketMapJoinToSMBJoin(mapJoinOp, stack, smbJoinContext, nodeOutputs);</span><br><span class="line"></span><br><span class="line">  // Throw an error if the user asked for sort merge bucketed mapjoin to be enforced</span><br><span class="line">  // and sort merge bucketed mapjoin cannot be performed</span><br><span class="line">  if (!convert &amp;&amp;</span><br><span class="line">      pGraphContext.getConf().getBoolVar(</span><br><span class="line">          HiveConf.ConfVars.HIVEENFORCESORTMERGEBUCKETMAPJOIN)) &#123;</span><br><span class="line">    throw new SemanticException(ErrorMsg.SORTMERGE_MAPJOIN_FAILED.getMsg());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (convert) &#123;</span><br><span class="line">    convertBucketMapJoinToSMBJoin(mapJoinOp, smbJoinContext);</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到原来的那个汇总：<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%AE%97%E5%AD%90Operators%E5%8F%8A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8Optimizers%EF%BC%88%E5%9B%9B%EF%BC%89/20170513110611864.png" alt="这里写图片描述"><br>join operator是最基本的，其他的mapjoin，SMB都是属于优化。</p>
<p><strong>倾斜关联Skew Join</strong><br>倾斜键Skew keys &#x3D; 高频出现的键, 非常多的键，多到一个reduce处理不了<br>使用Common Join处理非倾斜键，使用Map Join处理倾斜键.<br>A join B on A.id&#x3D;B.id, 如果A 表中id&#x3D;1倾斜, 那么查询会变成<br>A join B on A.id&#x3D;B.id and A.id!&#x3D;1 union<br>A join B on A.id&#x3D;B.id and A.id&#x3D;1<br>判断是否是倾斜的，主要是判断建是不是倾斜的，那么怎么判断一个建是不是倾斜的呢？</p>
<p><strong>Skew Join Optimizers (Compile Time, MR)</strong><br>建表时指定倾斜键: create table … skewed by (key) on (key_value);<br>开关“hive.optimize.skewjoin.compiletime”<br>Logical Optimizer逻辑优化器: SkewJoinOptimizer查看元数据<br>直接指定倾斜建，是最好的一种，他会直接给出union的方式处理倾斜：<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%AE%97%E5%AD%90Operators%E5%8F%8A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8Optimizers%EF%BC%88%E5%9B%9B%EF%BC%89/20170513141135746.png" alt="这里写图片描述"><br>但是实际环境是苛刻的很多情况并不知道那个建会倾斜，往下看。</p>
<p><strong>Skew Join Optimizers (Runtime, MR)</strong><br>开关“hive.optimize.skewjoin”<br>Physical Optimizer: SkewJoinResolver<br>JoinOperator处理时候计数，如果某个可以被某个节点处理次数超过 “hive.skewjoin.key” 域值<br>倾斜键Skew key被跳过并且把值拷到单独的目录<br>ConditionalTask会单独针对倾斜的键作处理，并将结果作Union<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%AE%97%E5%AD%90Operators%E5%8F%8A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8Optimizers%EF%BC%88%E5%9B%9B%EF%BC%89/20170513141311082.png" alt="这里写图片描述"><br>即最终结果是倾斜的建处理之后的结果加上未倾斜的common join的结果。不可否认这是一种笨重的方法，最好的方法是直接指定那个键会倾斜，单独处理倾斜。当出现处理慢的时候我们排查是join慢还是group by慢，如果是join慢能不能用map join处理，如果是group by慢，能不能进行预聚合。</p>
]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>java高阶编程知识点---The road of alibaba</title>
    <url>/2018/09/27/java%E9%AB%98%E9%98%B6%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9-The-road-of-alibaba/</url>
    <content><![CDATA[<p>第一部分   面试初级</p>
<span id="more"></span>

<p>阿里面试题目总结：</p>
<p>第一轮面试电话（5月6号）：</p>
<p>1.自我介绍，包括做过项目。</p>
<p>2.有看过哪些JDK源码，了解哪些常用库。</p>
<p>3.集合框架HashMap的扩容机制，ConcurrnetHashMap的原理</p>
<p>java集合框架图：<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3RlZmFuaWU4NjA2MjQvYXJ0aWNsZS9kZXRhaWxzLzcyNDU4NzM=">http://blog.csdn.net/stefanie860624/article/details/7245873<i class="fa fa-external-link-alt"></i></span></p>
<p>4.jvm内存模型与gc内存回收机制</p>
<p>5.classloader结构，是否可以自己定义一个java.lang.String类，为什么？ 双亲代理机制。</p>
<p>6.了解哪些设计模式，6个设计原则分别是什么？每种设计原则体现的设计模式是哪个？</p>
<p>7.关于设计模式看了哪些书？书名是什么？</p>
<p>8.uml模型图画过哪些？ 类图中类之间的关系有哪些，区别分别是什么？</p>
<p>9.画uml中类图时候用过一种虚线么？做什么用的？</p>
<p>10.做过应用相关性能测试的，举个例子，实际项目中怎么使用的。</p>
<p>用过并发框架相关的哪些内容</p>
<p>11.了解哪些osgi的框架？</p>
<p>12有没有做过jvm内存调优，如何做的，举例子，用过哪些工具？</p>
<p>&#x2F;&#x2F;一些不记得了</p>
<p>第二轮面试视频</p>
<p>1.自我介绍</p>
<p>2.看过哪些源码</p>
<p>3.java的io库的类结构图所用到的设计模式如何体现</p>
<p>4.画出自己设计过的设计模式如何体现，画出结构图，并进行讲解。</p>
<p>5.画出自己做的架构的项目架构图 如何扩展等</p>
<p>6.数据库设计中主键id设计的原则</p>
<p>7.jvm内存调优用过哪些工具，jstate做什么用的？如何dump出当前线程状态？</p>
<p>8.并发框架是否有了解</p>
<p>9.classloader的双亲代理机制</p>
<p>10.应用服务器的jvm调优实际经验，如何做的，在哪里用到的</p>
<p>11.在哪里获取最新资讯，逛什么论坛。最新的Swift语言有什么看法</p>
<p>12.设计原则与设计模式对应</p>
<p>13.servlet&#x2F;filter作用原理配置</p>
<p>14.ibatis in操作 以及一个属性的作用</p>
<p>15.spring aop 用了什么设计原则，自动注入配置是做什么用的</p>
<p>16.jboss的类加载器</p>
<p>17.session共享机制</p>
<p>18.做过最成功的一件事情是什么？</p>
<p>19.最大的争执是什么？</p>
<p>20.为什么想要离职去阿里</p>
<p>&#x2F;&#x2F;问题很多，一些不记得了</p>
<p>第三轮面试电话：</p>
<p>1.现在公司负责什么？</p>
<p>2.项目主要目的是做什么的？</p>
<p>3.公司管理方式、项目问题反馈机制是什么？</p>
<p>4.Java 的序列化做什么用的 序列化id会出现哪些问题？</p>
<p>5.OSGi用过哪些？类加载器结构如何，如何在一个bundle中加载另外一个bundle中的一个类？</p>
<p>6.nio是否了解 阻塞之后通知机制是怎样的？</p>
<p>7.uml设计类图如何画，类之间关系以及区别</p>
<p>8.spring如何不许要配置文件加载bean定义，可能是问自动注解或者是properties文件定义bean</p>
<p>9.ibatis等框架是不是都是实际在使用的,技术细节</p>
<p>10.为什么想离职去阿里</p>
<p>&#x2F;&#x2F;一些不记得了</p>
<p>第四轮总监面电话面试：</p>
<p>1.自我介绍</p>
<p>2.公司做什么，业务， 负责内容，汇报机制等</p>
<p>3.企业级应用安全相关</p>
<p>4.http协议，返回码，301与302区别</p>
<p>5.多线程并发用过哪些</p>
<p>6.应用服务器相关，谈最熟悉的</p>
<p>7.为什么离职</p>
<p>&#x2F;&#x2F;这个太多不记得了，很多不太会。</p>
<p>第二部分   面试升级</p>
<p><span class="exturl" data-url="aHR0cDovL2x2d2Vud2VuLml0ZXllLmNvbS9ibG9nLzE0OTU3MDc=">http://lvwenwen.iteye.com/blog/1495707<i class="fa fa-external-link-alt"></i></span></p>
<p>第三部分  Java集合框架、IO框架、虚拟机相关、线程</p>
<p>l  JAVA IO 设计模式彻底分析：<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvb3JhY2xlX21pY3Jvc29mdC9hcnRpY2xlL2RldGFpbHMvMjQ0NDk0Nw==">http://blog.csdn.net/oracle_microsoft/article/details/2444947<i class="fa fa-external-link-alt"></i></span></p>
<p>l  JVM类加载机制：<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbnlzeXh4Zy9hcnRpY2xlL2RldGFpbHMvNDE5NzgwMTk/cmVmPW15cmVhZA==">http://blog.csdn.net/nysyxxg/article/details/41978019?ref=myread<i class="fa fa-external-link-alt"></i></span></p>
<p>l  Java虚拟机学习分享：<span class="exturl" data-url="aHR0cDovL2Jicy5jc2RuLm5ldC90b3BpY3MvMzkwMjUxNzk0">http://bbs.csdn.net/topics/390251794<i class="fa fa-external-link-alt"></i></span></p>
<p>l  JDK动态代理实现原理：<span class="exturl" data-url="aHR0cDovL3Jlam95Lml0ZXllLmNvbS9ibG9nLzE2Mjc0MDU=">http://rejoy.iteye.com/blog/1627405<i class="fa fa-external-link-alt"></i></span><br>l  java容器类源码分析——LinkedHashMap：<span class="exturl" data-url="aHR0cDovL3d3dy5pdGV5ZS5jb20vdG9waWMvMTEzMTMyMQ==">http://www.iteye.com/topic/1131321<i class="fa fa-external-link-alt"></i></span><br>l  ConcurrentHashMap：<span class="exturl" data-url="aHR0cDovL2l3ZWJjb2RlLml0ZXllLmNvbS9ibG9nLzEzMDY2NDA=">http://iwebcode.iteye.com/blog/1306640<i class="fa fa-external-link-alt"></i></span><br>l  解读ClassLoader：<span class="exturl" data-url="aHR0cDovL3d3dy5pdGV5ZS5jb20vdG9waWMvODM5Nzg=">http://www.iteye.com/topic/83978<i class="fa fa-external-link-alt"></i></span><br>l  Java并发编程：线程池的使用：<span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9kb2xwaGluMDUyMC9wLzM5MzI5MjEuaHRtbA==">http://www.cnblogs.com/dolphin0520/p/3932921.html<i class="fa fa-external-link-alt"></i></span><br>l  深入理解HashMap: <span class="exturl" data-url="aHR0cDovL3d3dy5pdGV5ZS5jb20vdG9waWMvNTM5NDY1">http://www.iteye.com/topic/539465<i class="fa fa-external-link-alt"></i></span><br>l  需要完全掌握的集合（走读源代码）：<br>Map m1 &#x3D; newHashMap();</p>
<p>Map m2 &#x3D; newHashtable();</p>
<p>Map m3 &#x3D; newTreeMap();</p>
<p>Mapm4 &#x3D; new  ConcurrentHashMap();</p>
<p>Map m5 &#x3D; new  LinkedHashMap();</p>
<p>Set s1 &#x3D; newHashSet();</p>
<p>Set s2 &#x3D; newTreeSet();</p>
<p>Set s3 &#x3D; newLinkedHashSet();</p>
<p>List l1 &#x3D; newArrayList();</p>
<p>List l2 &#x3D; new  LinkedList();</p>
<p>Deque<String> deque &#x3D; newLinkedList<String>();&#x2F;&#x2F;栈</p>
<p>Queue<String> queue &#x3D; newLinkedList<String>();&#x2F;&#x2F;队列<br>第四部分   Tomcat以及其他项目源码</p>
<p>java类加载器-Tomcat类加载器：<span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9tZXRveS9wLzM5MTc1MzUuaHRtbA==">http://www.cnblogs.com/metoy/p/3917535.html<i class="fa fa-external-link-alt"></i></span><br>Tomcat源码分析：<span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9tZXRveS9wLzM4NTU4NzUuaHRtbA==">http://www.cnblogs.com/metoy/p/3855875.html<i class="fa fa-external-link-alt"></i></span><br>Spring源码走读：<br>《Spring_IOC_.pdf》、<br>《spring源码解析.pdf》、<br>《Spring技术内幕：深入解析Spring架构与设计原理第2版》<br>第五部分  理论</p>
<p>设计模式六大原则：<span class="exturl" data-url="aHR0cDovL2Z5ZDIyMi5pdGV5ZS5jb20vYmxvZy8xNDQzMTUw">http://fyd222.iteye.com/blog/1443150<i class="fa fa-external-link-alt"></i></span><br>计算机网络的基础诸如TCP、IP、三次握手。<br>第六部       推荐书籍（重点）</p>
<p>《阿里Java Web技术内幕（修订版）试读样章》</p>
<p>《深入理解_Java_虚拟机_(JVM_高级特性与最佳实践)》</p>
<p>此博客全部看完：<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hqdHRvbnkvYXJ0aWNsZS9saXN0Lw==">http://blog.csdn.net/chjttony/article/list/<i class="fa fa-external-link-alt"></i></span></p>
<p>《淘宝技术这十年，完整最终确认版》</p>
<p>第七部分    提高（云计算方向）</p>
<p>《大型分布式网站架构设计与实践》</p>
<p>《Storm 实战：构建大数据实时计算试读样章》</p>
<p>《重构大数据统计试读样章》</p>
<p>JDK源码视频300集（讲师是尚学堂讲师高级高琪，此视频看完绝对走火入魔，慎入。。。哈哈）：</p>
<p>链接：<span class="exturl" data-url="aHR0cDovL3Bhbi5iYWlkdS5jb20vcy8xbWcxSmFpTyVFNSVBRiU4NiVFNyVBMCU4MSVFRiVCQyU5QXQyMXM=">http://pan.baidu.com/s/1mg1JaiO密码：t21s<i class="fa fa-external-link-alt"></i></span></p>
<p>第八部分    算法</p>
<p>1、  递归、冒泡排序、归并排序、插入排序、快速排序以及他们的平均复杂度。</p>
<p>2、  平衡二叉树、满二叉树、红黑树。</p>
<p>3、  链表、数组。</p>
<p>4、  B树、B+数。</p>
<p>未完待续…..</p>
<p>你要想得到你从未有过的东西，就必须做你从未做过的事！</p>
]]></content>
      <categories>
        <category>技术之路</category>
      </categories>
  </entry>
  <entry>
    <title>hive原理与源码分析-语法分析器和语义分析器（二）</title>
    <url>/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E5%92%8C%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>玩个游戏：<br>执行：find . -name ‘*.java’ | xargs grep –color ‘main(‘ | awk ‘{print $1}’ | uniq | grep -v test</p>
<span id="more"></span>
<p>找到cli的执行main方法：<br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvY2xpL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvY2xpL0NsaURyaXZlci5qYXZhP2xpbmU9Njg1">https://insight.io/github.com/apache/hive/blob/master/cli/src/java/org/apache/hadoop/hive/cli/CliDriver.java?line=685<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">  int ret = new CliDriver().run(args);</span><br><span class="line">  System.exit(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main方法调用了CliDriver实体的runmethod：<br>在run methond中最后返回的是executeDriver方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public  int run(String[] args) throws Exception &#123;</span><br><span class="line">。。。。。。。。。略 。。。</span><br><span class="line"> return executeDriver(ss, conf, oproc);</span><br><span class="line">。。。。。。。。。略</span><br></pre></td></tr></table></figure>
<p>继续跟进executeDriver（）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  private int executeDriver(CliSessionState ss, HiveConf conf, OptionsProcessor oproc)</span><br><span class="line">      throws Exception &#123;</span><br><span class="line">。。。。。。。。略</span><br><span class="line">   while ((line = reader.readLine(curPrompt + &quot;&gt; &quot;)) != null) &#123;</span><br><span class="line">      if (!prefix.equals(&quot;&quot;)) &#123;</span><br><span class="line">        prefix += &#x27;\n&#x27;;</span><br><span class="line">      &#125;</span><br><span class="line">      if (line.trim().startsWith(&quot;--&quot;)) &#123;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">      if (line.trim().endsWith(&quot;;&quot;) &amp;&amp; !line.trim().endsWith(&quot;\\;&quot;)) &#123;</span><br><span class="line">        line = prefix + line;</span><br><span class="line">        ret = cli.processLine(line, true);</span><br><span class="line">        prefix = &quot;&quot;;</span><br><span class="line">        curDB = getFormattedDb(conf, ss);</span><br><span class="line">        curPrompt = prompt + curDB;</span><br><span class="line">        dbSpaces = dbSpaces.length() == curDB.length() ? dbSpaces : spacesForString(curDB);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        prefix = prefix + line;</span><br><span class="line">        curPrompt = prompt2 + dbSpaces;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    。。。。。。。。。。略</span><br></pre></td></tr></table></figure>
<p>executeDriver方法将一条sql用“；”拆分成多条语句，每条语句执行 <strong>ret &#x3D; cli.processLine(line, true);</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Processes a line of semicolon separated commands</span><br><span class="line">   * @param line The commands to process</span><br><span class="line">   * @param allowInterrupting  When true the function will handle SIG_INT (Ctrl+C) by interrupting the processing and               </span><br><span class="line">   * returning -1</span><br><span class="line">   * @return 0 if ok</span><br><span class="line">   */</span><br><span class="line">  public int processLine(String line, boolean allowInterrupting) &#123;</span><br><span class="line">  。。。。。。。。。略</span><br><span class="line">   ret = processCmd(command);</span><br><span class="line">   。。。。。。。。。略</span><br></pre></td></tr></table></figure>
<p>然后进入processCmd方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int processCmd(String cmd) &#123;</span><br><span class="line">。。。。。。。。。略。。。。。。。</span><br><span class="line"> if (cmd_trimmed.toLowerCase().equals(&quot;quit&quot;) || cmd_trimmed.toLowerCase().equals(&quot;exit&quot;)) &#123;</span><br><span class="line"> 。。。。。。。。。略。。。。。。。</span><br><span class="line">  &#125; else if (tokens[0].equalsIgnoreCase(&quot;source&quot;)) &#123;</span><br><span class="line">  。。。。。。。。。略。。。。。。。</span><br><span class="line">    &#125; else if (cmd_trimmed.startsWith(&quot;!&quot;)) &#123;</span><br><span class="line">    。。。。。。。。。略。。。。。。。</span><br><span class="line">        &#125;  else &#123; // local mode</span><br><span class="line">              try &#123;</span><br><span class="line">        CommandProcessor proc = CommandProcessorFactory.get(tokens, (HiveConf) conf);</span><br><span class="line">        ret = processLocalCmd(cmd, proc, ss);</span><br><span class="line">      &#125; catch (SQLException e) &#123;</span><br><span class="line">        console.printError(&quot;Failed processing command &quot; + tokens[0] + &quot; &quot; + e.getLocalizedMessage(),</span><br><span class="line">          org.apache.hadoop.util.StringUtils.stringifyException(e));</span><br><span class="line">        ret = 1;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ss.resetThreadName();</span><br><span class="line">    return ret;</span><br></pre></td></tr></table></figure>
<p>首先processCmd判断是不是退出命令，然后是source和“！”开始的特殊命令（非SQL）的处理，最后是sql的处理逻辑，<br> CommandProcessor proc &#x3D; CommandProcessorFactory.get(tokens, (HiveConf) conf);这句生成了一个CommandProcessor ，那么CommandProcessor 是个什么鬼呢？进入get方法看看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static CommandProcessor get(String[] cmd, HiveConf conf)</span><br><span class="line">    throws SQLException &#123;</span><br><span class="line">  CommandProcessor result = getForHiveCommand(cmd, conf);</span><br><span class="line">  if (result != null) &#123;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">  if (isBlank(cmd[0])) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (conf == null) &#123;</span><br><span class="line">      return new Driver();//此处返回的是一个Driver，即Driver是CommandProcessor 的下属类型。</span><br><span class="line">    &#125;</span><br><span class="line">    Driver drv = mapDrivers.get(conf);</span><br><span class="line">    if (drv == null) &#123;</span><br><span class="line">      drv = new Driver();</span><br><span class="line">      mapDrivers.put(conf, drv);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      drv.resetQueryState();</span><br><span class="line">    &#125;</span><br><span class="line">    drv.init();</span><br><span class="line">    return drv;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CommandProcessor proc = CommandProcessorFactory.get(tokens, (HiveConf) conf);</span><br><span class="line">ret = processLocalCmd(cmd, proc, ss);</span><br></pre></td></tr></table></figure>
<p>这里的proc是一个Driver，进入processLocalCmd：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int processLocalCmd(String cmd, CommandProcessor proc, CliSessionState ss) &#123;</span><br><span class="line">  int tryCount = 0;</span><br><span class="line">  boolean needRetry;</span><br><span class="line">  int ret = 0;</span><br><span class="line"></span><br><span class="line">  do &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      needRetry = false;</span><br><span class="line">      if (proc != null) &#123;</span><br><span class="line">        if (proc instanceof Driver) &#123;//一定为true</span><br><span class="line">          Driver qp = (Driver) proc;</span><br><span class="line">          PrintStream out = ss.out;</span><br><span class="line">          long start = System.currentTimeMillis();</span><br><span class="line">          if (ss.getIsVerbose()) &#123;</span><br><span class="line">            out.println(cmd);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          qp.setTryCount(tryCount);</span><br><span class="line">          ret = qp.run(cmd).getResponseCode();//此处调用的是Driver的run</span><br><span class="line">          if (ret != 0) &#123;</span><br><span class="line">            qp.close();</span><br><span class="line">            return ret;</span><br><span class="line">          &#125;</span><br><span class="line">          。。。。。。。。。。略</span><br></pre></td></tr></table></figure>
<p>进入<span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9Ecml2ZXIuamF2YT9saW5lPTEyODE=">run方法<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public CommandProcessorResponse run(String command)</span><br><span class="line">    throws CommandNeedRetryException &#123;</span><br><span class="line">  return run(command, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public CommandProcessorResponse run(String command, boolean alreadyCompiled)</span><br><span class="line">      throws CommandNeedRetryException &#123;</span><br><span class="line">  CommandProcessorResponse cpr = runInternal(command, alreadyCompiled);</span><br><span class="line"></span><br><span class="line">  if(cpr.getResponseCode() == 0) &#123;</span><br><span class="line">    return cpr;</span><br><span class="line">  &#125;</span><br><span class="line">  SessionState ss = SessionState.get();</span><br><span class="line">  if(ss == null) &#123;</span><br><span class="line">    return cpr;</span><br><span class="line">  &#125;</span><br><span class="line">  MetaDataFormatter mdf = MetaDataFormatUtils.getFormatter(ss.getConf());</span><br><span class="line">  if(!(mdf instanceof JsonMetaDataFormatter)) &#123;</span><br><span class="line">    return cpr;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p> CommandProcessorResponse cpr &#x3D; <span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9Ecml2ZXIuamF2YT9saW5lPTE0NTg=">runInternal<i class="fa fa-external-link-alt"></i></span>(command, alreadyCompiled);执行sql的编译和返回结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> private CommandProcessorResponse runInternal(String command, boolean alreadyCompiled)</span><br><span class="line">     throws CommandNeedRetryException &#123;</span><br><span class="line">     。。。。。略</span><br><span class="line">       // compile internal will automatically reset the perf logger</span><br><span class="line">       ret = compileInternal(command, true);</span><br><span class="line">。。。。。。。略</span><br></pre></td></tr></table></figure>
<p> <span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9Ecml2ZXIuamF2YT9saW5lPTEzNTU=">compileInternal<i class="fa fa-external-link-alt"></i></span>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private int compileInternal(String command, boolean deferClose) &#123;</span><br><span class="line">。。。。。。略。。。。</span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">     ret = compile(command, true, deferClose);</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">     compileLock.unlock();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>compile(command, true, deferClose);</strong><br>就是<span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9Ecml2ZXIuamF2YT9saW5lPTQxNQ==">hive的入口<i class="fa fa-external-link-alt"></i></span>了。<br>Driver的run方法最终会执行compile()操作,Compiler作语法解析和语义分析。<br>回顾一下解析步骤：<br><strong>第一部分：语法分析</strong><br>语法解析Parser<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E5%92%8C%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/20170507124349883.png" alt="这里写图片描述"></p>
<p>tree &#x3D; ParseUtils.parse(command, ctx);【<span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9Ecml2ZXIuamF2YT9saW5lPTUxMA==">源码<i class="fa fa-external-link-alt"></i></span>】ParseUtils封装了ParseDriver 对sql的解析工作，ParseUtils的<span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9wYXJzZS9QYXJzZVV0aWxzLmphdmE/bGluZT03NA==">parse<i class="fa fa-external-link-alt"></i></span>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** Parses the Hive query. */</span><br><span class="line">public static ASTNode parse(</span><br><span class="line">    String command, Context ctx, boolean setTokenRewriteStream) throws ParseException &#123;</span><br><span class="line">  ParseDriver pd = new ParseDriver();</span><br><span class="line">  ASTNode tree = pd.parse(command, ctx, setTokenRewriteStream);</span><br><span class="line">  tree = findRootNonNullToken(tree);</span><br><span class="line">  handleSetColRefs(tree);</span><br><span class="line">  return tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ParseDriver 对command进行词法分析和语法解析（统称为语法分析），返回一个抽象语法树AST，进入parseDriver的parse方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ASTNode parse(String command, Context ctx, boolean setTokenRewriteStream)</span><br><span class="line">    throws ParseException &#123;</span><br><span class="line">  if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">    LOG.debug(&quot;Parsing command: &quot; + command);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  HiveLexerX lexer = new HiveLexerX(new ANTLRNoCaseStringStream(command));//词法分析</span><br><span class="line">  TokenRewriteStream tokens = new TokenRewriteStream(lexer);//根据词法分析的结果得到tokens的，此时不只是单纯的字符串，而是具有特殊意义的字符串的封装，其本身是一个流。</span><br><span class="line">  if (ctx != null) &#123;</span><br><span class="line">    if ( setTokenRewriteStream) &#123;</span><br><span class="line">      ctx.setTokenRewriteStream(tokens);</span><br><span class="line">    &#125;</span><br><span class="line">    lexer.setHiveConf(ctx.getConf());</span><br><span class="line">  &#125;</span><br><span class="line">  HiveParser parser = new HiveParser(tokens);</span><br><span class="line">  if (ctx != null) &#123;</span><br><span class="line">    parser.setHiveConf(ctx.getConf());</span><br><span class="line">  &#125;</span><br><span class="line">  parser.setTreeAdaptor(adaptor);</span><br><span class="line">  HiveParser.statement_return r = null;</span><br><span class="line">  try &#123;</span><br><span class="line">    r = parser.statement();</span><br><span class="line">  &#125; catch (RecognitionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    throw new ParseException(parser.errors);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (lexer.getErrors().size() == 0 &amp;&amp; parser.errors.size() == 0) &#123;</span><br><span class="line">    LOG.debug(&quot;Parse Completed&quot;);</span><br><span class="line">  &#125; else if (lexer.getErrors().size() != 0) &#123;</span><br><span class="line">    throw new ParseException(lexer.getErrors());</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    throw new ParseException(parser.errors);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ASTNode tree = (ASTNode) r.getTree();//生成AST返回</span><br><span class="line">  tree.setUnknownTokenBoundaries();</span><br><span class="line">  return tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Antlr对Hive SQL解析的代码如上述代码逻辑，HiveLexerX，HiveParser分别是Antlr对语法文件HiveLexer.g编译后自动生成的词法解析和语法解析类，在这两个类中进行复杂的解析。<br>这是解析的第一步，生辰了一个ATS。<br>看一下之后的词法分析，<br><strong>词法分析器Lexer - HiveLexerX</strong><br>输入：一堆字符，这里是HiveSQL<br>输出：一串Toker，这里是TokenRewriteStream<br>也称词法分析器 **Lexical Analyzer(LA)**或者Scanner<br>建议翻阅《编译原理》<br>上文提到HiveLexer.g，即文法分析依靠一个文件<span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9wYXJzZS9IaXZlTGV4ZXIuZw==">HiveLexer.g<i class="fa fa-external-link-alt"></i></span>：<br>文件定义了一些hive的关键字，form、where，数字的定义格式【0–9】，分隔符，比较符之类的etc。每一个关键字都会变成一个token。<br>例如：规定hive中以数字或者下划线开头：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CharSetName</span><br><span class="line">    :</span><br><span class="line">    &#x27;_&#x27; (Letter | Digit | &#x27;_&#x27; | &#x27;-&#x27; | &#x27;.&#x27; | &#x27;:&#x27; )+</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>
<p>如果你对这个规则不满意可以修改它。<br><strong>语法解析 HiveParser:</strong><br>如何获得ASTNode<br>HiveParser.statement().getTree()<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kYXRsYXMuY29tL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvbWFzdGVyL3FsL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvcWwvcGFyc2UvUGFyc2VEcml2ZXIuamF2YT9saW5lPTE5Nw==">https://www.codatlas.com/github.com/apache/hive/master/ql/src/java/org/apache/hadoop/hive/ql/parse/ParseDriver.java?line=197<i class="fa fa-external-link-alt"></i></span><br>HiveParser是Antlr根据HiveParser.g生成的文件<br> 进入HiveParser .java看到第一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// $ANTLR 3.5.2 org/apache/hadoop/hive/ql/parse/HiveParser.g 2017-05-03 10:08:46</span><br></pre></td></tr></table></figure>
<p>此Java文件在2017-05-03被生成的。但是<span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9wYXJzZS9IaXZlUGFyc2VyLmc=">HiveParser.g<i class="fa fa-external-link-alt"></i></span>我们进去看一下：<br>用select字句举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">selectStatement</span><br><span class="line">   :</span><br><span class="line">   a=atomSelectStatement</span><br><span class="line">   set=setOpSelectStatement[$atomSelectStatement.tree]?</span><br><span class="line">   o=orderByClause?</span><br><span class="line">   c=clusterByClause?</span><br><span class="line">   d=distributeByClause?</span><br><span class="line">   sort=sortByClause?</span><br><span class="line">   l=limitClause?</span><br><span class="line">   &#123;</span><br><span class="line">   if(set == null)&#123;</span><br><span class="line">   $a.tree.getFirstChildWithType(TOK_INSERT).addChild($o.tree);</span><br><span class="line">   $a.tree.getFirstChildWithType(TOK_INSERT).addChild($c.tree);</span><br><span class="line">   $a.tree.getFirstChildWithType(TOK_INSERT).addChild($d.tree);</span><br><span class="line">   $a.tree.getFirstChildWithType(TOK_INSERT).addChild($sort.tree);</span><br><span class="line">   $a.tree.getFirstChildWithType(TOK_INSERT).addChild($l.tree);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   -&gt; &#123;set == null&#125;?</span><br><span class="line">      &#123;$a.tree&#125;</span><br><span class="line">   -&gt; &#123;o==null &amp;&amp; c==null &amp;&amp; d==null &amp;&amp; sort==null &amp;&amp; l==null&#125;?</span><br><span class="line">      &#123;$set.tree&#125;</span><br><span class="line">   -&gt; ^(TOK_QUERY</span><br><span class="line">          ^(TOK_FROM</span><br><span class="line">            ^(TOK_SUBQUERY</span><br><span class="line">              &#123;$set.tree&#125;</span><br><span class="line">              &#123;adaptor.create(Identifier, generateUnionAlias())&#125;</span><br><span class="line">             )</span><br><span class="line">          )</span><br><span class="line">          ^(TOK_INSERT</span><br><span class="line">             ^(TOK_DESTINATION ^(TOK_DIR TOK_TMP_FILE))</span><br><span class="line">             ^(TOK_SELECT ^(TOK_SELEXPR TOK_SETCOLREF))</span><br><span class="line">             $o? $c? $d? $sort? $l?</span><br><span class="line">          )</span><br><span class="line">      )</span><br><span class="line">   ;</span><br></pre></td></tr></table></figure>
<p>用图形表示：<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E5%92%8C%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/20170507135143434.png" alt="这里写图片描述"><br>TMP_FIEL是输出路径，hive是基于mr的上层框架，mr必须要有一个数据文件，mr任务完毕之后结果会存放在TMP_FIEL此路径下边，然后cli回去读取这个结果文件，展示数据结果。而另一个框架瞅准了hive的这个弱点，没有临时文件，impala边执行边输出结果。</p>
<p><strong>增加一种语法</strong>这时候，你知道了……<br>如果我们想为Hive增加一种新的语法……<br>第一步……<br>就是修改HiveParser.g<br>如果要引入关键字，还需要修改HiveLexer.g</p>
<p><strong>第二部分：语义解析初步 - SemanticAnalyzer</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E5%92%8C%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/20170507140229032.png" alt="这里写图片描述"><br><strong>SQL执行顺序</strong><br>一个SQL大致分为以下7部分，按顺序执行<br>(5)SELECT (6)DISTINCT <select list><br>(1)FROM <table source><br>(2)WHERE <condition><br>(3)GROUP BY <group by list><br>(4)HAVING <having condition><br>(7) ORDER BY <order by list><br><strong>Operators对应SQL</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E5%92%8C%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/20170507142034604.png" alt="这里写图片描述"><br><strong>Operator过程</strong><br>每个步骤对应一个逻辑运算符(Operator)<br>每个Operator输出一个虚表(VirtualTable)<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E5%92%8C%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/20170507142121618.png" alt="这里写图片描述"><br><strong>语义解析器 - SemanticAnalyzer</strong><br>语义解析器：<br>输入AST树（见3.3.2）<br>输出Operator图<br>回到Compiler代码，看入口在哪里<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kYXRsYXMuY29tL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvbWFzdGVyL3FsL3NyYy9qYXZhL29yZy9hcGFjaGUvaGFkb29wL2hpdmUvcWwvRHJpdmVyLmphdmE/bGluZT01MDM=">https://www.codatlas.com/github.com/apache/hive/master/ql/src/java/org/apache/hadoop/hive/ql/Driver.java?line=503<i class="fa fa-external-link-alt"></i></span><br>SemanticAnalyzer.analyze()<br>SemanticAnalyzer.analyzeInternal()</p>
<p>在回到<span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9Ecml2ZXIuamF2YT9saW5lPTU1MQ==">Driver.java<i class="fa fa-external-link-alt"></i></span>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...........ignore</span><br><span class="line">BaseSemanticAnalyzer sem = SemanticAnalyzerFactory.get(queryState, tree);</span><br><span class="line">............ignore</span><br><span class="line">      // Do semantic analysis and plan generation</span><br><span class="line">      if (saHooks != null &amp;&amp; !saHooks.isEmpty()) &#123;</span><br><span class="line">        HiveSemanticAnalyzerHookContext hookCtx = new HiveSemanticAnalyzerHookContextImpl();</span><br><span class="line">        hookCtx.setConf(conf);</span><br><span class="line">        hookCtx.setUserName(userName);</span><br><span class="line">        hookCtx.setIpAddress(SessionState.get().getUserIpAddress());</span><br><span class="line">        hookCtx.setCommand(command);</span><br><span class="line">        for (HiveSemanticAnalyzerHook hook : saHooks) &#123;</span><br><span class="line">          tree = hook.preAnalyze(hookCtx, tree);</span><br><span class="line">        &#125;</span><br><span class="line">        sem.analyze(tree, ctx);</span><br><span class="line">        hookCtx.update(sem);</span><br><span class="line">        for (HiveSemanticAnalyzerHook hook : saHooks) &#123;</span><br><span class="line">          hook.postAnalyze(hookCtx, sem.getAllRootTasks());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        sem.analyze(tree, ctx);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>进入sem.analyze(tree,ctx)<br>【<span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9wYXJzZS9CYXNlU2VtYW50aWNBbmFseXplci5qYXZhP2xpbmU9MjU1JUUzJTgwJTkx">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/parse/BaseSemanticAnalyzer.java?line=255】<i class="fa fa-external-link-alt"></i></span>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void analyze(ASTNode ast, Context ctx) throws SemanticException &#123;</span><br><span class="line">  initCtx(ctx);//初始化上下文</span><br><span class="line">  init(true);</span><br><span class="line">  analyzeInternal(ast);//此方法在BaseSemanticAnalyzer中为一个抽象方法【 public abstract void analyzeInternal(ASTNode ast) throws SemanticException;】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>analyzeInternal方法有很多实现：<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E5%92%8C%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/20170507143542388.png" alt="这里写图片描述"></p>
<p><strong>用于查询的 SemanticAnalyzer</strong><br>继承自BaseSemanticAnalyzer的语义分析器有很多种<br>其中最重要的是用于查询的SemanticAnalyzer类（很奇怪这种命名，不应该是叫QuerySemanticAnalyzer么？不应该把抽象类的Base一词去掉么？忍吧）<br>他们有很多是replaction的，有些是ddl的，有些是做查询的，我们在此处关注做查询的。</p>
<p><strong>一万多行语义分析</strong><br>看到了么？截止2016年11月20日<br>SemanticAnalyzer有13623行<br>Hive优化的秘密全在于此<br>不要急，慢慢来<br>注意：输入的ASTTree后续的QB的生成，逻辑执行计划、逻辑执行计划的优化、物理执行计划的切分、物理执行计划的优化、以及mr任务的生成全部都在这1万多行的代码里边的逻辑中。</p>
<p><strong>生成QB - genResolvedParseTree()</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E5%92%8C%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/20170507144838047.png" alt="这里写图片描述"></p>
<p>关注<span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9wYXJzZS9TZW1hbnRpY0FuYWx5emVyLmphdmE/bGluZT0xMDg4MA==">SemanticAnalyzer<i class="fa fa-external-link-alt"></i></span> 的 analyzeInterna方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void analyzeInternal(ASTNode ast) throws SemanticException &#123;</span><br><span class="line">  analyzeInternal(ast, new PlannerContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入analyzeInternal(ast, new PlannerContext());</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void analyzeInternal(ASTNode ast, PlannerContext plannerCtx) throws SemanticException &#123;</span><br><span class="line">  // 1. Generate Resolved Parse tree from syntax tree</span><br><span class="line">  LOG.info(&quot;Starting Semantic Analysis&quot;);</span><br><span class="line">  //change the location of position alias process here</span><br><span class="line">  processPositionAlias(ast);</span><br><span class="line">  if (!genResolvedParseTree(ast, plannerCtx)) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  。。。。。。。。。。。略。。。。。。</span><br></pre></td></tr></table></figure>
<p>进入genResolvedParseTree(ast, plannerCtx)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean genResolvedParseTree(ASTNode ast, PlannerContext plannerCtx) throws SemanticException &#123;</span><br><span class="line">。。。。。。。略。。。。。。。。</span><br><span class="line">    // 4. continue analyzing from the child ASTNode.</span><br><span class="line">  Phase1Ctx ctx_1 = initPhase1Ctx();</span><br><span class="line">  preProcessForInsert(child, qb);</span><br><span class="line">  if (!doPhase1(child, qb, ctx_1, plannerCtx)) &#123;</span><br><span class="line">    // if phase1Result false return</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  。。。。。。。。。。。。略。。。。。。</span><br></pre></td></tr></table></figure>
<p>如果doPhase1执行成功那么就会得到一个QB，进入doPhase1方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Phase 1: (including, but not limited to):</span><br><span class="line"> * 1. Gets all the aliases for all the tables / subqueries and makes the</span><br><span class="line"> * appropriate mapping in aliasToTabs, aliasToSubq 2. Gets the location of the</span><br><span class="line"> * destination and names the clause &quot;inclause&quot; + i 3. Creates a map from a</span><br><span class="line"> * string representation of an aggregation tree to the actual aggregation AST</span><br><span class="line"> * 4. Creates a mapping from the clause name to the select expression AST in</span><br><span class="line"> * destToSelExpr 5. Creates a mapping from a table alias to the lateral view</span><br><span class="line"> * AST&#x27;s in aliasToLateralViews</span><br><span class="line"> *</span><br><span class="line"> * @param ast</span><br><span class="line"> * @param qb</span><br><span class="line"> * @param ctx_1</span><br><span class="line"> * @throws SemanticException</span><br><span class="line"> */</span><br><span class="line">@SuppressWarnings(&#123;&quot;fallthrough&quot;, &quot;nls&quot;&#125;)</span><br><span class="line">public boolean doPhase1(ASTNode ast, QB qb, Phase1Ctx ctx_1, PlannerContext plannerCtx)</span><br><span class="line">    throws SemanticException &#123;</span><br><span class="line">          。。。。。。。。。。。。。。。。略。。。。。。。。</span><br><span class="line">      case HiveParser.TOK_SELECT://select类型的token</span><br><span class="line">      qb.countSel();//对qb做标记</span><br><span class="line">      qbp.setSelExprForClause(ctx_1.dest, ast);</span><br><span class="line">      。。。。。。。。。。。。。。。。。略。。。。。。</span><br><span class="line">     case HiveParser.TOK_WHERE://where类型token</span><br><span class="line">     //对where的孩子进行处理，为什么是ast.getChild(0)？这个是和之前的HiveParser.g结构相辅相成的。</span><br><span class="line">      qbp.setWhrExprForClause(ctx_1.dest, ast);</span><br><span class="line">      if (!SubQueryUtils.findSubQueries((ASTNode) ast.getChild(0)).isEmpty())</span><br><span class="line">          queryProperties.setFilterWithSubQuery(true);</span><br><span class="line">      break;</span><br><span class="line">    。。。。。。。。。。。。。。。。略。。。。。。。。</span><br><span class="line">    case HiveParser.TOK_GROUPBY:</span><br><span class="line">    case HiveParser.TOK_ROLLUP_GROUPBY:</span><br><span class="line">    case HiveParser.TOK_CUBE_GROUPBY:</span><br><span class="line">    case HiveParser.TOK_GROUPING_SETS:</span><br><span class="line">    。。。。。。。。。。。。略。。。。。。。。</span><br><span class="line">        if (!skipRecursion) &#123;</span><br><span class="line">    // Iterate over the rest of the children</span><br><span class="line">    int child_count = ast.getChildCount();</span><br><span class="line">    for (int child_pos = 0; child_pos &lt; child_count &amp;&amp; phase1Result; ++child_pos) &#123;</span><br><span class="line">      // Recurse</span><br><span class="line">      phase1Result = phase1Result &amp;&amp; doPhase1(</span><br><span class="line">          (ASTNode)ast.getChild(child_pos), qb, ctx_1, plannerCtx);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  。。。。。。。。。。。。。。。略。。。。。。。。。</span><br></pre></td></tr></table></figure>
<p>参数qb是一个空的QB，在不同case类型下对齐进行填满。<br>doPhase1对ASTTree中的每个元素的TOK类型进行case，针对于不同的case对节点数据进行填充。<br>for遍历整棵ASTTree，中间对每个元素递归调用doPhase1，这种方式是一种深度优先搜索的算法。<br>经过一轮深度优先遍历，不带元数据的QB树就生成了。<br>doPhase1执行完毕之后得到QB，QB里边的只是一些关键字还有一些表的名字，但是和hdfs的文件路径对应不起来，所以需要metaData映射关系，之后在SemanticAnalyzer中调用了  <span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9wYXJzZS9TZW1hbnRpY0FuYWx5emVyLmphdmE/bGluZT0xMTE1NA==">getMetaData<i class="fa fa-external-link-alt"></i></span> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void getMetaData(QB qb) throws SemanticException &#123;</span><br><span class="line">  getMetaData(qb, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void getMetaData(QB qb, boolean enableMaterialization) throws SemanticException &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    if (enableMaterialization) &#123;</span><br><span class="line">      getMaterializationMetadata(qb);</span><br><span class="line">    &#125;</span><br><span class="line">    getMetaData(qb, null);</span><br><span class="line">  &#125; catch (HiveException e) &#123;</span><br><span class="line">    // Has to use full name to make sure it does not conflict with</span><br><span class="line">    // org.apache.commons.lang.StringUtils</span><br><span class="line">    LOG.error(org.apache.hadoop.util.StringUtils.stringifyException(e));</span><br><span class="line">    if (e instanceof SemanticException) &#123;</span><br><span class="line">      throw (SemanticException)e;</span><br><span class="line">    &#125;</span><br><span class="line">    throw new SemanticException(e.getMessage(), e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getMetaData又会递归的去取元数据（从mysql中），经过doPhase1和getMetaData得到一个完整的QB，接下来就是逻辑执行技术的生成。</p>
<p><strong>Logical Plan Generator - SemanticAnalyzer.genPlan()</strong><br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E5%92%8C%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/20170507151904057.png" alt="这里写图片描述"><br><strong>Logical Plan Generator - genPlan</strong><br>genPlan()实现QB-&gt;Operator<br>genPlan() 也是深度优先的递归<br> Operator sinkOp &#x3D; genOPTree(ast, plannerCtx);【<span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC9wYXJzZS9TZW1hbnRpY0FuYWx5emVyLmphdmE/bGluZT0xMTIzNSVFMyU4MCU5MSVFNyU5NCU5RiVFNiU4OCU5MG9wJUVGJUJDJTlB">https://insight.io/github.com/apache/hive/blob/master/ql/src/java/org/apache/hadoop/hive/ql/parse/SemanticAnalyzer.java?line=11235】生成op：<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Operator genOPTree(ASTNode ast, PlannerContext plannerCtx) throws SemanticException &#123;</span><br><span class="line">  // fetch all the hints in qb</span><br><span class="line">  List&lt;ASTNode&gt; hintsList = new ArrayList&lt;&gt;();</span><br><span class="line">  getHintsFromQB(qb, hintsList);</span><br><span class="line">  getQB().getParseInfo().setHintList(hintsList);</span><br><span class="line">  return genPlan(qb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大体的递归过程：<br><img src="/2018/10/04/hive%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E5%92%8C%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/20170507152953495.png" alt="这里写图片描述"></p>
<p><strong>表达式分析</strong><br>•类型推倒 100  INT 100.1  DOUBLE ‘Hello’  STRING TRUE  BOOL<br>•隐式类型转换 对于fun(DOUBLE, DOUBLE),有输入A—INT, B—DOUBLE fun(double(A), B) 如1+2.5  double(1) + 2.5<br>NULL值类型转换<br>•表达式求值 f(g(A), B)  A, g(), B, f() 逆波兰表达式<br>•BOOL表达式分析 合取范式 (C1 and C2) or C3  (C1 or C3) and (C2 or C3) SELECT * FROM T,P WHERE (T.A&gt;10 AND P.B&lt;100) OR T.B&gt;10   SELECT * FROM T,P WHERE (T.A&gt;10 OR T.B&gt;10) AND (P.B&lt;100 OR T.B&gt;10) 当条件变换为合取范式时，可以对AND连接的每一项进行下推优化<br><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC91ZGYvVURGVG9Mb25nLmphdmE=">UDFToLong<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public LongWritable evaluate(Text i) &#123;</span><br><span class="line">//有三种情况为null</span><br><span class="line">//第一Text是null</span><br><span class="line">  if (i == null) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">  //猜测不是数字，返回null</span><br><span class="line">    if (!LazyUtils.isNumberMaybe(i.getBytes(), 0, i.getLength())) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      longWritable.set(LazyLong.parseLong(i.getBytes(), 0, i.getLength(), 10));//使用LazyLong装换，没有用jdk的API</span><br><span class="line">      return longWritable;</span><br><span class="line">    &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">      // MySQL returns 0 if the string is not a well-formed numeric value.</span><br><span class="line">      // return LongWritable.valueOf(0);</span><br><span class="line">      // But we decided to return NULL instead, which is more conservative.</span><br><span class="line">      //出错返回null</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly9pbnNpZ2h0LmlvL2dpdGh1Yi5jb20vYXBhY2hlL2hpdmUvYmxvYi9tYXN0ZXIvcWwvc3JjL2phdmEvb3JnL2FwYWNoZS9oYWRvb3AvaGl2ZS9xbC91ZGYvVURGVG9JbnRlZ2VyLmphdmE=">UDFToInteger<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public IntWritable evaluate(Text i) &#123;</span><br><span class="line">//Text 为null，返回null</span><br><span class="line">  if (i == null) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">  //猜测失败，返回null</span><br><span class="line">    if (!LazyUtils.isNumberMaybe(i.getBytes(), 0, i.getLength())) &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      intWritable.set(LazyInteger.parseInt(i.getBytes(), 0, i.getLength(), 10));//使用LazyInteger，未使用jdk的API</span><br><span class="line">      return intWritable;</span><br><span class="line">    &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">      // MySQL returns 0 if the string is not a well-formed numeric value.</span><br><span class="line">      // return IntWritable.valueOf(0);</span><br><span class="line">      // But we decided to return NULL instead, which is more conservative.</span><br><span class="line">      //报错返回null</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk8-Collector收集器之并行流陷阱与原理</title>
    <url>/2018/10/04/jdk8-Collector%E6%94%B6%E9%9B%86%E5%99%A8%E4%B9%8B%E5%B9%B6%E8%A1%8C%E6%B5%81%E9%99%B7%E9%98%B1%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>收集器Collector是jdk8中最为重要的接口之一，一个Collector可分为5个部分（第五个是我自己加上的）：<br>1、supplier</p>
<span id="more"></span>
<p>2、accumulator<br>3、combiner<br>4、finisher<br>5、characteristics</p>
<p>Collector有三个泛型：&lt;T, A, R&gt;分别是：<br>T：被操作集合的每个元素类型<br>A：supplier提供的中间容器类型<br>R：返回的结果类型</p>
<p>从收集器源码可以看出他的组成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Collector&lt;T, A, R&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * A function that creates and returns a new mutable result container.</span><br><span class="line">     * @return a function which returns a new, mutable result container</span><br><span class="line">     * 容器提供者</span><br><span class="line">     */</span><br><span class="line">    Supplier&lt;A&gt; supplier();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * A function that folds a value into a mutable result container.</span><br><span class="line">     * @return a function which folds a value into a mutable result container</span><br><span class="line">     * 累加操作</span><br><span class="line">     */</span><br><span class="line">    BiConsumer&lt;A, T&gt; accumulator();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * A function that accepts two partial results and merges them.  The</span><br><span class="line">     * combiner function may fold state from one argument into the other and</span><br><span class="line">     * return that, or may return a new result container.</span><br><span class="line">     *</span><br><span class="line">     * @return a function which combines two partial results into a combined</span><br><span class="line">     * result</span><br><span class="line">     * 并发的情况将每个线程的中间容器A合并</span><br><span class="line">     */</span><br><span class="line">    BinaryOperator&lt;A&gt; combiner();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Perform the final transformation from the intermediate accumulation type</span><br><span class="line">     * &#123;@code A&#125; to the final result type &#123;@code R&#125;.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;If the characteristic &#123;@code IDENTITY_TRANSFORM&#125; is</span><br><span class="line">     * set, this function may be presumed to be an identity transform with an</span><br><span class="line">     * unchecked cast from &#123;@code A&#125; to &#123;@code R&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @return a function which transforms the intermediate result to the final</span><br><span class="line">     * result</span><br><span class="line">     * 终止操作</span><br><span class="line">     */</span><br><span class="line">    Function&lt;A, R&gt; finisher();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns a &#123;@code Set&#125; of &#123;@code Collector.Characteristics&#125; indicating</span><br><span class="line">     * the characteristics of this Collector.  This set should be immutable.</span><br><span class="line">     *</span><br><span class="line">     * @return an immutable set of collector characteristics</span><br><span class="line">     * 收集器特性</span><br><span class="line">     */</span><br><span class="line">    Set&lt;Characteristics&gt; characteristics();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns a new &#123;@code Collector&#125; described by the given &#123;@code supplier&#125;,</span><br><span class="line">     * &#123;@code accumulator&#125;, and &#123;@code combiner&#125; functions.  The resulting</span><br><span class="line">     * &#123;@code Collector&#125; has the &#123;@code Collector.Characteristics.IDENTITY_FINISH&#125;</span><br><span class="line">     * characteristic.</span><br><span class="line">     *</span><br><span class="line">     * @param supplier The supplier function for the new collector</span><br><span class="line">     * @param accumulator The accumulator function for the new collector</span><br><span class="line">     * @param combiner The combiner function for the new collector</span><br><span class="line">     * @param characteristics The collector characteristics for the new</span><br><span class="line">     *                        collector</span><br><span class="line">     * @param &lt;T&gt; The type of input elements for the new collector</span><br><span class="line">     * @param &lt;R&gt; The type of intermediate accumulation result, and final result,</span><br><span class="line">     *           for the new collector</span><br><span class="line">     * @throws NullPointerException if any argument is null</span><br><span class="line">     * @return the new &#123;@code Collector&#125;</span><br><span class="line">     */</span><br><span class="line">    public static&lt;T, R&gt; Collector&lt;T, R, R&gt; of(Supplier&lt;R&gt; supplier,</span><br><span class="line">                                              BiConsumer&lt;R, T&gt; accumulator,</span><br><span class="line">                                              BinaryOperator&lt;R&gt; combiner,</span><br><span class="line">                                              Characteristics... characteristics) &#123;</span><br><span class="line">        Objects.requireNonNull(supplier);</span><br><span class="line">        Objects.requireNonNull(accumulator);</span><br><span class="line">        Objects.requireNonNull(combiner);</span><br><span class="line">        Objects.requireNonNull(characteristics);</span><br><span class="line">        Set&lt;Characteristics&gt; cs = (characteristics.length == 0)</span><br><span class="line">                                  ? Collectors.CH_ID</span><br><span class="line">                                  : Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.IDENTITY_FINISH,</span><br><span class="line">                                                                           characteristics));</span><br><span class="line">        return new Collectors.CollectorImpl&lt;&gt;(supplier, accumulator, combiner, cs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns a new &#123;@code Collector&#125; described by the given &#123;@code supplier&#125;,</span><br><span class="line">     * &#123;@code accumulator&#125;, &#123;@code combiner&#125;, and &#123;@code finisher&#125; functions.</span><br><span class="line">     *</span><br><span class="line">     * @param supplier The supplier function for the new collector</span><br><span class="line">     * @param accumulator The accumulator function for the new collector</span><br><span class="line">     * @param combiner The combiner function for the new collector</span><br><span class="line">     * @param finisher The finisher function for the new collector</span><br><span class="line">     * @param characteristics The collector characteristics for the new</span><br><span class="line">     *                        collector</span><br><span class="line">     * @param &lt;T&gt; The type of input elements for the new collector</span><br><span class="line">     * @param &lt;A&gt; The intermediate accumulation type of the new collector</span><br><span class="line">     * @param &lt;R&gt; The final result type of the new collector</span><br><span class="line">     * @throws NullPointerException if any argument is null</span><br><span class="line">     * @return the new &#123;@code Collector&#125;</span><br><span class="line">     */</span><br><span class="line">    public static&lt;T, A, R&gt; Collector&lt;T, A, R&gt; of(Supplier&lt;A&gt; supplier,</span><br><span class="line">                                                 BiConsumer&lt;A, T&gt; accumulator,</span><br><span class="line">                                                 BinaryOperator&lt;A&gt; combiner,</span><br><span class="line">                                                 Function&lt;A, R&gt; finisher,</span><br><span class="line">                                                 Characteristics... characteristics) &#123;</span><br><span class="line">        Objects.requireNonNull(supplier);</span><br><span class="line">        Objects.requireNonNull(accumulator);</span><br><span class="line">        Objects.requireNonNull(combiner);</span><br><span class="line">        Objects.requireNonNull(finisher);</span><br><span class="line">        Objects.requireNonNull(characteristics);</span><br><span class="line">        Set&lt;Characteristics&gt; cs = Collectors.CH_NOID;</span><br><span class="line">        if (characteristics.length &gt; 0) &#123;</span><br><span class="line">            cs = EnumSet.noneOf(Characteristics.class);</span><br><span class="line">            Collections.addAll(cs, characteristics);</span><br><span class="line">            cs = Collections.unmodifiableSet(cs);</span><br><span class="line">        &#125;</span><br><span class="line">        return new Collectors.CollectorImpl&lt;&gt;(supplier, accumulator, combiner, finisher, cs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Characteristics indicating properties of a &#123;@code Collector&#125;, which can</span><br><span class="line">     * be used to optimize reduction implementations.</span><br><span class="line">     */</span><br><span class="line">    enum Characteristics &#123;</span><br><span class="line">        /**</span><br><span class="line">         * Indicates that this collector is &lt;em&gt;concurrent&lt;/em&gt;, meaning that</span><br><span class="line">         * the result container can support the accumulator function being</span><br><span class="line">         * called concurrently with the same result container from multiple</span><br><span class="line">         * threads.</span><br><span class="line">         *</span><br><span class="line">         * &lt;p&gt;If a &#123;@code CONCURRENT&#125; collector is not also &#123;@code UNORDERED&#125;,</span><br><span class="line">         * then it should only be evaluated concurrently if applied to an</span><br><span class="line">         * unordered data source.</span><br><span class="line">         */</span><br><span class="line">        CONCURRENT,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Indicates that the collection operation does not commit to preserving</span><br><span class="line">         * the encounter order of input elements.  (This might be true if the</span><br><span class="line">         * result container has no intrinsic order, such as a &#123;@link Set&#125;.)</span><br><span class="line">         */</span><br><span class="line">        UNORDERED,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Indicates that the finisher function is the identity function and</span><br><span class="line">         * can be elided.  If set, it must be the case that an unchecked cast</span><br><span class="line">         * from A to R will succeed.</span><br><span class="line">         */</span><br><span class="line">        IDENTITY_FINISH</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Javadoc对前边四个做了说明：</p>
<p>  A {@code Collector} is specified by four functions that work together to<br>  accumulate entries into a mutable result container, and optionally perform<br>  a final transform on the result.  They are:<br>      creation of a new result container ({@link #supplier()})<br>      incorporating a new data element into a result container ({@link #accumulator()})<br>      combining two result containers into one ({@link #combiner()})<br>      performing an optional final transform on the container ({@link #finisher()})</p>
<p>**supplier:**是一个容器提供者，提供容器A,比如：List list &#x3D; new ArrayList()；<br>**accumulator:**是要操作的集合的每个元素以怎样的形式添加到supplier提供的容器A当中，即做累加操作，比如：List.add(item)；<br>**combiner:**用于在多线程并发的情况下，每个线程都有一个supplier和，如果有N个线程那么就有N个supplier提供的容器A，执行的是类似List.addAll(listB)这样的操作,只有在characteristics没有被设置成CONCURRENT并且是并发的情况下 才会被调用。ps：characteristics被设置成CONCURRENT时，整个收集器只有一个容器，而不是每个线程都有一个容器，此时combiner()方法不会被调用，这种情况会出现java.util.ConcurrentModificationException异常,此时需要使用线程安全的容器作为supplier返回的对象。<br>**finisher:**是终止操作，如果收集器的characteristics被设置成IDENTITY_FINISH，那么会将中间集合A牵制转换为结果R类型，如果A和R没有父子之类的继承关系，会报类型转换失败的错误，如果收集器的characteristics没有被设置成IDENTITY_FINISH，那么finisher()方法会被调用，返回结果类型R。</p>
<p>关于枚举<strong>Characteristics</strong>是用来控制收集器的相关特性，它在Collector接口内部：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Characteristics indicating properties of a &#123;@code Collector&#125;, which can</span><br><span class="line">    * be used to optimize reduction implementations.</span><br><span class="line">    */</span><br><span class="line">   enum Characteristics &#123;</span><br><span class="line">       /**</span><br><span class="line">        * Indicates that this collector is &lt;em&gt;concurrent&lt;/em&gt;, meaning that</span><br><span class="line">        * the result container can support the accumulator function being</span><br><span class="line">        * called concurrently with the same result container from multiple</span><br><span class="line">        * threads.</span><br><span class="line">        *如果一个收集器被标记为concurrent特性，那么accumulator 方法可以被多线程并发的的调用，并且只使用一个容器A</span><br><span class="line">        * &lt;p&gt;If a &#123;@code CONCURRENT&#125; collector is not also &#123;@code UNORDERED&#125;,</span><br><span class="line">        * then it should only be evaluated concurrently if applied to an</span><br><span class="line">        * unordered data source.</span><br><span class="line">        * 如果收集器被标记为concurrent，但是要操作的集合失败有序的，那么最终得到的结果不能保证原来的顺序</span><br><span class="line">        */</span><br><span class="line">       CONCURRENT,</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Indicates that the collection operation does not commit to preserving</span><br><span class="line">        * the encounter order of input elements.  (This might be true if the</span><br><span class="line">        * result container has no intrinsic order, such as a &#123;@link Set&#125;.)</span><br><span class="line">        * 适用于无序的集合</span><br><span class="line">        */</span><br><span class="line">       UNORDERED,</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Indicates that the finisher function is the identity function and</span><br><span class="line">        * can be elided.  If set, it must be the case that an unchecked cast</span><br><span class="line">        * from A to R will succeed.</span><br><span class="line">        * 如果收集器特性被设置IDENTITY_FINISH，那么会强制将中间容器A类型转换为结果类型R</span><br><span class="line">        */</span><br><span class="line">       IDENTITY_FINISH</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>下面我们写一个自定义的收集器了解他的原理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.ceaser.jdk8lambda.stream2;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line">import java.util.function.BiConsumer;</span><br><span class="line">import java.util.function.BinaryOperator;</span><br><span class="line">import java.util.function.Function;</span><br><span class="line">import java.util.function.Supplier;</span><br><span class="line">import java.util.stream.Collector;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">import static java.util.stream.Collector.Characteristics.CONCURRENT;</span><br><span class="line">import static java.util.stream.Collector.Characteristics.IDENTITY_FINISH;</span><br><span class="line">import static java.util.stream.Collector.Characteristics.UNORDERED;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by CeaserWang on 2017/2/27.</span><br><span class="line"> * 此收集器的作用是将Set集合转换为Map</span><br><span class="line"> */</span><br><span class="line">public class MyCollectorA&lt;T&gt; implements Collector&lt;T,Set&lt;T&gt;,Map&lt;T,T&gt;&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Supplier&lt;Set&lt;T&gt;&gt; supplier() &#123;</span><br><span class="line">        System.out.println(&quot;supplier invoked...&quot;);</span><br><span class="line">        return HashSet::new;//实例化一个存放中间结果的集合Set</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public BiConsumer&lt;Set&lt;T&gt;,T&gt; accumulator() &#123;</span><br><span class="line">        System.out.println(&quot;accumulator invoked...&quot;);</span><br><span class="line">        return (item1,item2) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            /**</span><br><span class="line">             *  *  A a1 = supplier.get();</span><br><span class="line">             *     accumulator.accept(a1, t1);</span><br><span class="line">             *     accumulator.accept(a1, t2);</span><br><span class="line">             *     R r1 = finisher.apply(a1);  // result without splitting</span><br><span class="line">             *</span><br><span class="line">             *     A a2 = supplier.get();</span><br><span class="line">             *     accumulator.accept(a2, t1);</span><br><span class="line">             *     A a3 = supplier.get();</span><br><span class="line">             *     accumulator.accept(a3, t2);</span><br><span class="line">             *     R r2 = finisher.apply(combiner.apply(a2, a3));  // result with splitting</span><br><span class="line">             */</span><br><span class="line"></span><br><span class="line">           // System.out.println(&quot;current thread : &quot;+item1+&quot; , &quot;+Thread.currentThread().getName());</span><br><span class="line">            item1.add(item2);//将遍历的每个元素加入到Set当中</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public BinaryOperator&lt;Set&lt;T&gt;&gt; combiner() &#123;</span><br><span class="line">        System.out.println(&quot;combiner invoked...&quot;);</span><br><span class="line">        return (item1,item2) -&gt; &#123;</span><br><span class="line">            item1.addAll(item2);//多线程下，集合Set的合并操作</span><br><span class="line">            System.out.println(&quot;--------&quot;);</span><br><span class="line">            return item1;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Function&lt;Set&lt;T&gt;,Map&lt;T,T&gt;&gt; finisher() &#123;</span><br><span class="line">        System.out.println(&quot;finisher invoked...&quot;);</span><br><span class="line">        return (item1) -&gt;&#123;</span><br><span class="line">            Map&lt;T,T&gt; rm = new HashMap&lt;T,T&gt;();</span><br><span class="line">            item1.stream(). forEach( (bean) -&gt; rm.put(bean,bean) );//将Set集合的每个元素加入到新的map之中</span><br><span class="line">          return rm;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;Characteristics&gt; characteristics() &#123;</span><br><span class="line">        System.out.println(&quot;characteristics invoked...&quot;);</span><br><span class="line">        return Collections.unmodifiableSet(EnumSet.of(UNORDERED,CONCURRENT));//支持并发操作，并且是不能保证原始集合的顺序。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by Ceaser Wang on 2017/2/27.</span><br><span class="line"> */</span><br><span class="line">public class MyCollectorATest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(&quot;hello&quot;,&quot;world&quot;,&quot;welcome&quot;,&quot;helloworld&quot;,&quot;helloworldA&quot;);</span><br><span class="line">        Set&lt;String&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        set.addAll(list);</span><br><span class="line">        Map&lt;String,String&gt; maped =  set.parallelStream().collect(new MyCollectorA&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">characteristics invoked...</span><br><span class="line">supplier invoked...</span><br><span class="line">accumulator invoked...</span><br><span class="line">characteristics invoked...</span><br><span class="line">finisher invoked...</span><br></pre></td></tr></table></figure>
<p><strong>并发陷阱分析：</strong></p>
<pre><code>可以看到收集器的特性被设置成CONCURRENT，并且是parallelStream，执行过程中没有调用combiner()方法。因为只有一个公用的容器没必要再去掉combiner()合并中间结果。PS：在单线程模式下，并且特性设置成CONCURRENT，combiner()会被调用。
</code></pre>
<p>接下来我们将accumulator的这行注释放开：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(&quot;current thread : &quot;+item1+&quot; , &quot;+Thread.currentThread().getName());</span><br></pre></td></tr></table></figure>
<p>再去运行，会报错（如果一次没有出现，多运行几次）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.util.ConcurrentModificationException: java.util.ConcurrentModificationException</span><br><span class="line">	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">	at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">	at java.util.concurrent.ForkJoinTask.getThrowableException(ForkJoinTask.java:593)</span><br><span class="line">	at java.util.concurrent.ForkJoinTask.reportException(ForkJoinTask.java:677)</span><br><span class="line">	at java.util.concurrent.ForkJoinTask.invoke(ForkJoinTask.java:735)</span><br><span class="line">	at java.util.stream.ForEachOps$ForEachOp.evaluateParallel(ForEachOps.java:160)</span><br><span class="line">	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateParallel(ForEachOps.java:174)</span><br><span class="line">	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:233)</span><br><span class="line">	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418)</span><br><span class="line">	at java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:583)</span><br><span class="line">	at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:496)</span><br><span class="line">	at com.ceaser.jdk8lambda.stream2.MyCollectorATest.main(MyCollectorATest.java:17)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)</span><br><span class="line">Caused by: java.util.ConcurrentModificationException</span><br><span class="line">	at java.util.HashMap$HashIterator.nextNode(HashMap.java:1437)</span><br><span class="line">	at java.util.HashMap$KeyIterator.next(HashMap.java:1461)</span><br><span class="line">	at java.util.AbstractCollection.toString(AbstractCollection.java:461)</span><br><span class="line">	at java.lang.String.valueOf(String.java:2994)</span><br><span class="line">	at java.lang.StringBuilder.append(StringBuilder.java:131)</span><br><span class="line">	at com.ceaser.jdk8lambda.stream2.MyCollectorA.lambda$accumulator$0(MyCollectorA.java:43)</span><br><span class="line">	at java.util.stream.ReferencePipeline.lambda$collect$1(ReferencePipeline.java:496)</span><br><span class="line">	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)</span><br><span class="line">	at java.util.HashMap$KeySpliterator.forEachRemaining(HashMap.java:1548)</span><br><span class="line">	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)</span><br><span class="line">	at java.util.stream.ForEachOps$ForEachTask.compute(ForEachOps.java:291)</span><br><span class="line">	at java.util.concurrent.CountedCompleter.exec(CountedCompleter.java:731)</span><br><span class="line">	at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)</span><br><span class="line">	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)</span><br><span class="line">	at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)</span><br><span class="line">	at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)</span><br></pre></td></tr></table></figure>

<p>为什么呢？<br>我们只是输出了中间容器的内容，我们看下这行错误信息对应的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">at java.util.AbstractCollection.toString(AbstractCollection.java:461)</span><br></pre></td></tr></table></figure>
<p>对应的是AbstractCollection的toString：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String toString() &#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    if (! it.hasNext())</span><br><span class="line">        return &quot;[]&quot;;</span><br><span class="line"></span><br><span class="line">    StringBuilder sb = new StringBuilder();</span><br><span class="line">    sb.append(&#x27;[&#x27;);</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        **E e = it.next();**//这样代码是对Set集合进行遍历</span><br><span class="line">        sb.append(e == this ? &quot;(this Collection)&quot; : e);</span><br><span class="line">        if (! it.hasNext())</span><br><span class="line">            return sb.append(&#x27;]&#x27;).toString();</span><br><span class="line">        sb.append(&#x27;,&#x27;).append(&#x27; &#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>E e &#x3D; it.next();<br>此行代码是对集合进行遍历，在多线程下对未同步的集合同时遍历和修改操作会导致ConcurrentModificationException这种异常（其他的HashMap多线程下回出现死循环问题），<br>为此我们需要替换使用线程安全的集合，比如ConcurrentHashMap等等。</p>
<p><strong>IDENTITY_FINISH特性：</strong></p>
<p>打开collect方法的源码我们看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public final &lt;R, A&gt; R collect(Collector&lt;? super P_OUT, A, R&gt; collector) &#123;</span><br><span class="line">    A container;</span><br><span class="line">    if (isParallel()</span><br><span class="line">            &amp;&amp; (collector.characteristics().contains(Collector.Characteristics.CONCURRENT))</span><br><span class="line">            &amp;&amp; (!isOrdered() || collector.characteristics().contains(Collector.Characteristics.UNORDERED))) &#123;</span><br><span class="line">        container = collector.supplier().get();</span><br><span class="line">        BiConsumer&lt;A, ? super P_OUT&gt; accumulator = collector.accumulator();</span><br><span class="line">        forEach(u -&gt; accumulator.accept(container, u));</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        container = evaluate(ReduceOps.makeRef(collector));</span><br><span class="line">    &#125;</span><br><span class="line">    return collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)</span><br><span class="line">           ? (R) container</span><br><span class="line">           : collector.finisher().apply(container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当收集器的特性包含IDENTITY_FINISH特性时，会把收集器内部的中间集合A强制转换为R（当中间容器类型A和结果类型R不同时，但是又设置了IDENTITY_FINISH特性，那么会抛出java.lang.ClassCastException），否则才会调用收集器的finisher()方法。</p>
]]></content>
      <categories>
        <category>javaBase</category>
      </categories>
      <tags>
        <tag>jdk8 并发收集器</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk8-方法引用</title>
    <url>/2018/10/04/jdk8-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p><strong>方法引用的形式</strong><br>方法引用的标准形式是:类名::方法名。（注意：只需要写方法名，不需要写括号）</p>
<span id="more"></span>

<p>有以下四种形式的方法引用:</p>
<p>类型	示例<br>引用静态方法	ContainingClass::staticMethodName<br>引用某个对象的实例方法	containingObject::instanceMethodName<br>引用某个类型的任意对象的实例方法	ContainingType::methodName<br>引用构造方法	ClassName::new</p>
<p>下面我们通过一个小Demo来分别学习这几种形式的方法引用:<br>Student 类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int score;</span><br><span class="line"></span><br><span class="line">    public Student(String name, int score) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getScore() &#123;</span><br><span class="line">        return score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setScore(int score) &#123;</span><br><span class="line">        this.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static int coompareStudentByScore(Student student1,Student student2)&#123;</span><br><span class="line">        return student1.getScore() - student2.getScore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static int coompareStudentByName(Student student1,Student student2)&#123;</span><br><span class="line">        return student1.getName().compareToIgnoreCase(student2.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int compareScore(Student student)&#123;</span><br><span class="line">        return this.score-student.getScore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StudentComparator 比较器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class StudentComparator &#123;</span><br><span class="line"></span><br><span class="line">    public  int coompareStudentByScore(Student student1,Student student2)&#123;</span><br><span class="line">        return student1.getScore() - student2.getScore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public  int coompareStudentByName(Student student1,Student student2)&#123;</span><br><span class="line">        return student1.getName().compareToIgnoreCase(student2.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类：MethodReferenceTest</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> * Created by CeaserWang on 2017/1/15.</span><br><span class="line"> */</span><br><span class="line">public class MethodReferenceTest &#123;</span><br><span class="line"></span><br><span class="line">    public String toString(Supplier&lt;String&gt; supplier)&#123;</span><br><span class="line">        return supplier.get()+&quot;test&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString2(String str, Function&lt;String,String&gt; function)&#123;</span><br><span class="line">        return function.apply(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student student1   = new Student(&quot;zhangsan&quot;,20);</span><br><span class="line">        Student student2   = new Student(&quot;lisi&quot;,90);</span><br><span class="line">        Student student3   = new Student(&quot;wangwu&quot;,50);</span><br><span class="line">        Student student4   = new Student(&quot;zhaoliu&quot;,60);</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; students = Arrays.asList(student1,student2,student3,student4);</span><br><span class="line">		//lambda形式</span><br><span class="line">       students.sort((studentparam1,studentparam2) -&gt; Student.coompareStudentByName(studentparam1,studentparam2));</span><br><span class="line">        students.forEach(student -&gt; System.out.println(student.getName()));*/</span><br><span class="line">       // 引用静态方法</span><br><span class="line">       /* students.sort( Student::coompareStudentByName);</span><br><span class="line">        students.forEach(student -&gt; System.out.println(student.getName()));</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;----------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">		//引用某个对象的实例方法</span><br><span class="line">        StudentComparator studentComparator = new StudentComparator();</span><br><span class="line">        students.sort(studentComparator::coompareStudentByScore);</span><br><span class="line">        students.forEach(student -&gt; System.out.println(student.getScore()));</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;----------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        //引用某个类型的任意对象的实例方法</span><br><span class="line">        students.sort(Student::compareScore);</span><br><span class="line">        students.forEach(student -&gt; System.out.println(student.getScore()));</span><br><span class="line">        MethodReferenceTest methodReferenceTest =  new MethodReferenceTest();</span><br><span class="line">        //引用构造方法</span><br><span class="line">        System.out.println( methodReferenceTest.toString(String::new));</span><br><span class="line">        System.out.println( methodReferenceTest.toString2(&quot;hello&quot;,String::new));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javaBase</category>
      </categories>
      <tags>
        <tag>jdk8  method reference</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk8新加入的default方法</title>
    <url>/2018/10/04/jdk8%E6%96%B0%E5%8A%A0%E5%85%A5%E7%9A%84default%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>default方法的加入是为了兼容jdk8以前的版本的需要。<br>（1）当前有两个接口MyInterface和MyInterface1，它们都有相同名字的default方法，之后实现类Myclass同时implements了MyInterface和MyInterface1，同时Myclass实现了default方法，此时Myclass调用default调的是谁的？</p>
<span id="more"></span>
<p>（2）一个接口I有一个default方法，另一个实现类A实现了了此接口，并且重写了default方法，之后另一个类B继承了实现类A并且实现了接口I，那么在这种情况下，实现类B调用的default方法又是谁的呢？针对这两种情况编写测试代码：</p>
<p>接口MyInterface</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by CeaserWang on 2017/1/16.</span><br><span class="line"> */</span><br><span class="line">public interface MyInterface &#123;</span><br><span class="line">default void  meyhod()&#123;</span><br><span class="line">    System.out.println(&quot;MyInterface&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口MyInterface1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface MyInterface1 &#123;</span><br><span class="line">    default void  meyhod()&#123;</span><br><span class="line">        System.out.println(&quot;MyInterface1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现类ExtendsClass</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ExtendsClass implements  MyInterface &#123;</span><br><span class="line"></span><br><span class="line">    public void  meyhod()&#123;</span><br><span class="line">        System.out.println(&quot;ExtendsClass&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类FixClass</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FixClass extends  ExtendsClass implements  MyInterface1 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类Myclass</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Myclass implements  MyInterface,MyInterface1 &#123;</span><br><span class="line"></span><br><span class="line">  public  void  meyhod()&#123;</span><br><span class="line">       System.out.println(&quot;Myclass&quot;);</span><br><span class="line">      //MyInterface1.super.meyhod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Myclass myclass = new Myclass();</span><br><span class="line">        myclass.meyhod();</span><br><span class="line"></span><br><span class="line">        FixClass fixClass = new FixClass();</span><br><span class="line">        fixClass.meyhod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行Myclass 结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Myclass</span><br><span class="line">ExtendsClass</span><br></pre></td></tr></table></figure>

<p>结论:<br>针对于第一种情况，default方法调用的是自身的实现的default方法。<br>针对于第二种情况，default方法调用的是“就近原则”，ExtendsClass 首先被实现，那么首选是ExtendsClass 的default方法，因此输出“ExtendsClass”。</p>
]]></content>
      <categories>
        <category>javaBase</category>
      </categories>
      <tags>
        <tag>jdk8 default method</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（10）自定义类加载器深入详解</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8810%EF%BC%89%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%B7%B1%E5%85%A5%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>上一节走读了类加载器的Java doc，这一节我们实现一个自定义的类加载器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br><span class="line">public class MyTest16 extends  ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    private String classLoaderName;</span><br><span class="line">    private final String fileExtension = &quot;.class&quot;;</span><br><span class="line"></span><br><span class="line">    public MyTest16(String classLoaderName)&#123;</span><br><span class="line">		/**</span><br><span class="line">		父类ClassLoader的构造器</span><br><span class="line">		protected ClassLoader() &#123;</span><br><span class="line">            this(checkCreateClassLoader(), getSystemClassLoader());</span><br><span class="line">	    &#125;</span><br><span class="line">		**/</span><br><span class="line">		//使用系统类加载器作为当前类的父类委托加载器</span><br><span class="line">		super();</span><br><span class="line">        this.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyTest16(ClassLoader classLoader,String classLoaderName)&#123;</span><br><span class="line">    /*</span><br><span class="line">	    父类ClassLoader带参数的构造器</span><br><span class="line">        protected ClassLoader(ClassLoader parent) &#123;</span><br><span class="line">        this(checkCreateClassLoader(), parent);</span><br><span class="line">    &#125;</span><br><span class="line">	*/</span><br><span class="line">	//使用自定义的类加载器作为当前类的父类委托加载器</span><br><span class="line">        super(classLoader);</span><br><span class="line">        this.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private byte[] loadClassData(String name )&#123;</span><br><span class="line">        InputStream inputStream = null;</span><br><span class="line">        ByteArrayOutputStream baos = null;</span><br><span class="line">        byte [] bytes = null;</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">            this.classLoaderName = this.classLoaderName.replace(&quot;.&quot;,&quot;/&quot;);</span><br><span class="line">            baos = new ByteArrayOutputStream();</span><br><span class="line">            int ch = 0;</span><br><span class="line">            while (-1 !=(ch = inputStream.read()))&#123;</span><br><span class="line">                baos.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            bytes = baos.toByteArray();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">                baos.close();</span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String className) throws ClassNotFoundException &#123;</span><br><span class="line">        byte [] data = loadClassData(className);//中间调用子类的findClass方法</span><br><span class="line">        return defineClass(className,data,0,data.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public  static void test(ClassLoader classLoader) throws Exception&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = classLoader.loadClass(&quot;com.twodragonlake.jvm.classloader.MyTest&quot;);</span><br><span class="line">        Object object = clazz.newInstance();</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        MyTest16 myTest16 = new MyTest16(MyTest16.class.getClassLoader(),&quot;myClassLoader&quot;);</span><br><span class="line">        MyTest16.test(myTest16);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>‘<br>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.twodragonlake.jvm.classloader.MyTest@1540e19d</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>自定义类加载器</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（11）类加载器重要方法详解</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8811%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3pxNjU3ODcwMi9hcnRpY2xlL2RldGFpbHMvNzk1NDgxNTc=">上一节<i class="fa fa-external-link-alt"></i></span> 我们写了一个类加载器的实现，其中一个重要的方法是findClass，看一下它的介绍：<br><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzcvZG9jcy9hcGkvamF2YS9sYW5nL0NsYXNzTG9hZGVyLmh0bWwjbG9hZENsYXNzKGphdmEubGFuZy5TdHJpbmcsJTIwYm9vbGVhbik=">https://docs.oracle.com/javase/7/docs/api/java/lang/ClassLoader.html#loadClass(java.lang.String,%20boolean)<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<p><strong>findClass：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Finds the class with the specified &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt;.</span><br><span class="line">     * This method should be overridden by class loader implementations that</span><br><span class="line">     * follow the delegation model for loading classes, and will be invoked by</span><br><span class="line">     * the &#123;@link #loadClass &lt;tt&gt;loadClass&lt;/tt&gt;&#125; method after checking the</span><br><span class="line">     * parent class loader for the requested class.  The default implementation</span><br><span class="line">     * throws a &lt;tt&gt;ClassNotFoundException&lt;/tt&gt;.</span><br><span class="line">     *返回了指定二进制名字的class，这个方法应该被遵循父类委托机制的子类去重写，当检查完当前类的父类加载器之后，</span><br><span class="line">     * 然后会被loadClass 调动，这个方法默认抛出ClassNotFoundException异常</span><br><span class="line">     * @param  name The &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class</span><br><span class="line">     * @return  The resulting &lt;tt&gt;Class&lt;/tt&gt; object</span><br><span class="line">     * @throws  ClassNotFoundExceptionIf the class could not be found</span><br><span class="line">     * @since  1.2</span><br><span class="line">     */</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        throw new ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在findClass方法里边，先去加载类的字节码，然后给ClassLoader类的defineClass方法，将字节码转换为一个Class类型（为了调用newInstance()实例化），<br>看一下defineClass的介绍：</p>
<p><strong>defineClass</strong></p>
<p>Converts an array of bytes into an instance of class Class. Before the Class can be used it must be resolved.<br>This method assigns a default ProtectionDomain to the newly defined class. The ProtectionDomain is effectively granted the same set of permissions returned when Policy.getPolicy().getPermissions(new CodeSource(null, null)) is invoked. The default domain is created on the first invocation of defineClass, and re-used on subsequent invocations.<br><strong>将一个字节数组转换为一个Class类的实例，在这之前需要对Class进行过解析(类的加载过程[加载：连接[验证，准备，解析]]，初始化).</strong><br><strong>这个方法会给新建立的Class分配一个保护域，保护域是用来保证返回的新的Class的访问信息是正确的（比如相同包下边的包的包名是一样的），默认的域在第一创建的时候会被创建，之后再去调用会被复用。</strong><br>To assign a specific ProtectionDomain to the class, use the defineClass method that takes a ProtectionDomain as one of its arguments.<br><strong>如果想要手动指定保护域，需要调用另外一个重载的方法，有5个参数，最后一个参数指定要传入的保护域。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final Class&lt;?&gt; defineClass(String name,byte[] b,int off,int len) throws ClassFormatError;</span><br></pre></td></tr></table></figure>

<p>Parameters:<br>name - The expected binary name of the class, or null if not known<br><strong>指定了二进制名字的类，如果不确定就填入null</strong><br>b - The bytes that make up the class data. The bytes in positions off through off+len-1 should have the format of a valid class file as defined by The Java™ Virtual Machine Specification.<br><strong>字节数组存储的是符合Java虚拟机对class文件规范的class文件字节码，否则是解析不出来的。</strong><br>off - The start offset in b of the class data<br><strong>类数据的起始偏移量</strong><br>len - The length of the class data<br><strong>class字节码与类数据相关的长度</strong></p>
<p>Returns:<br>The Class object that was created from the specified class data.<br><strong>返回指定了class字节数组的Class的对象。</strong></p>
<p>Throws:<br>ClassFormatError - If the data did not contain a valid class<br><strong>如果字节码数据不是合法的符合虚拟机规范的直接抛出错误</strong><br>IndexOutOfBoundsException - If either off or len is negative, or if off+len is greater than b.length.<br><strong>偏移量不合法或者计算后不合法抛出IndexOutOfBoundsException</strong><br>SecurityException - If an attempt is made to add this class to a package that contains classes that were signed by a different set of<br>certificates than this class (which is unsigned), or if name begins with “java.”.<br><strong>jdk不允许我们定义以”java.”开头的包名的类，这样会抛出安全异常</strong></p>
<p>defineClass方法一直往下跟，会跟到如下的真正实现的方法，是一个native方法：<br>private native Class&lt;?&gt; defineClass1(String name, byte[] b, int off, int len, ProtectionDomain pd, String source);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException</span><br></pre></td></tr></table></figure>
<p><strong>loadClass方法</strong><br>Loads the class with the specified binary name. The default implementation of this method searches for classes in the following order:<br><strong>加载指定二进制名字的类，这个方法的默认实现是按照如下的规则查找</strong><br>Invoke findLoadedClass(String) to check if the class has already been loaded.<br><strong>调用findLoadedClass确定这个类是否已经被加载</strong><br>Invoke the loadClass method on the parent class loader. If the parent is null the class loader built-in to the virtual machine is used, instead.<br><strong>调用委托父类的loadClass，如果委托父类是是空的，那么会使用jvm内建的启动类加载器代替</strong><br>Invoke the findClass(String) method to find the class.<br><strong>调用findClass查找这个类。</strong><br>If the class was found using the above steps, and the resolve flag is true, this method will then invoke the resolveClass(Class) method on the resulting Class object.<br><strong>如果使用上述步骤找到了这个类，并且resolve 是true，那么就会将解析结果作为resolveClass的参数调用resolveClass方法。</strong><br>Subclasses of ClassLoader are encouraged to override findClass(String), rather than this method.<br><strong>子类被鼓励重写findClass方法，不推荐重写当前方法</strong><br>Unless overridden, this method synchronizes on the result of getClassLoadingLock method during the entire class loading process.<br><strong>除非被重写，否则这个方法会被同步，保证类只能被加载一次。</strong><br>Parameters:<br>name - The binary name of the class<br>resolve - If true then resolve the class<br>Returns:<br>The resulting Class object<br>Throws:<br>ClassNotFoundException - If the class could not be found</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>类加载器解析</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（12）类加载器双亲委托机制实例深度剖析</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8812%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%9C%BA%E5%88%B6%E5%AE%9E%E4%BE%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<p>我们在之前写过的一个<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3pxNjU3ODcwMi9hcnRpY2xlL2RldGFpbHMvNzk1NDgxNTc=">自定义类加载器<i class="fa fa-external-link-alt"></i></span>:<br>我们修改一下程序的findClass方法：</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Class&lt;?&gt; findClass(String className) throws ClassNotFoundException &#123;</span><br><span class="line">    System.out.println(&quot;findClass invoked &quot;+className);</span><br><span class="line">    System.out.println(&quot; this.classLoaderName : &quot;+ this.classLoaderName);</span><br><span class="line">    byte [] data = loadClassData(className);//中间调用子类的findClass方法</span><br><span class="line">    return defineClass(className,data,0,data.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有test方法我们加一些跟踪打印：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public  static void test(ClassLoader classLoader) throws Exception&#123;</span><br><span class="line">    Class&lt;?&gt; clazz = classLoader.loadClass(&quot;com.twodragonlake.jvm.classloader.MyTest&quot;);</span><br><span class="line">    Object object = clazz.newInstance();</span><br><span class="line">    System.out.println(object.getClass().getClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们在运行main方法，你会看到findClass的2行并没有打印，并且test方法打印的类加载器是应用类加载器， 也就是意味着我们的自定义类加载器并没有没使用，原因很简单，因为我们的MyTest16构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public MyTest16(String classLoaderName)&#123;</span><br><span class="line">    super();//使用系统类加载器作为当前类的父类委托加载器</span><br><span class="line">    this.classLoaderName = classLoaderName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的父类委托加载器是应用类加载器，我们当前的类“com.twodragonlake.jvm.classloader.MyTest”属于classpath下边，应用类加载可以加载classpath下边的类，所以最终是由应用类加载器加载的。</p>
<p>接下来我们打算加载一个外部的类，我们不把class文件放在当前工程里边，比我放在“E:\data\classes\com\twodragonlake\jvm\classloader.MyTest.class”这里，然后修改程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest16 extends  ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    private String classLoaderName;</span><br><span class="line">    private final String fileExtension = &quot;.class&quot;;</span><br><span class="line">    private String path;</span><br><span class="line"></span><br><span class="line">    public void setPath(String path) &#123;</span><br><span class="line">        this.path = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyTest16(String classLoaderName)&#123;</span><br><span class="line">        super();//使用系统类加载器作为当前类的父类委托加载器</span><br><span class="line">        this.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyTest16(ClassLoader classLoader,String classLoaderName)&#123;</span><br><span class="line">        super(classLoader);//使用自定义的类加载器作为当前类的父类委托加载器</span><br><span class="line">        this.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private byte[] loadClassData(String name )&#123;</span><br><span class="line">        InputStream inputStream = null;</span><br><span class="line">        ByteArrayOutputStream baos = null;</span><br><span class="line">        byte [] bytes = null;</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">            //this.classLoaderName = this.classLoaderName.replace(&quot;.&quot;,&quot;\\&quot;);</span><br><span class="line">            name = name.replace(&quot;.&quot;,&quot;\\&quot;);//将包名里边的&quot;.&quot;替换为路径分隔符</span><br><span class="line">            inputStream = new FileInputStream(new File(this.path + name + this.fileExtension));//文件来自于加载路径path下的包里边的class文件</span><br><span class="line">            baos = new ByteArrayOutputStream();</span><br><span class="line">            int ch = 0;</span><br><span class="line">            while (-1 !=(ch = inputStream.read()))&#123;</span><br><span class="line">                baos.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            bytes = baos.toByteArray();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">                baos.close();</span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String className) throws ClassNotFoundException &#123;</span><br><span class="line">        System.out.println(&quot;findClass invoked &quot;+className);</span><br><span class="line">        System.out.println(&quot; this.classLoaderName : &quot;+ this.classLoaderName);</span><br><span class="line">        byte [] data = loadClassData(className);//中间调用子类的findClass方法</span><br><span class="line">        return defineClass(className,data,0,data.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        MyTest16 myClassLoader = new MyTest16(&quot;myClassLoader&quot;);</span><br><span class="line">        myClassLoader.setPath(&quot;E:\\data\\classes\\&quot;);//设置加载路径</span><br><span class="line">        Class&lt;?&gt; clazz = myClassLoader.loadClass(&quot;com.twodragonlake.jvm.classloader.MyTest&quot;);</span><br><span class="line">        System.out.println(&quot;class :&quot;+clazz.hashCode());</span><br><span class="line">        Object object = clazz.newInstance();</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">findClass invoked com.twodragonlake.jvm.classloader.MyTest</span><br><span class="line"> this.classLoaderName : myClassLoader</span><br><span class="line">class :21685669</span><br><span class="line">com.twodragonlake.jvm.classloader.MyTest@7f31245a</span><br></pre></td></tr></table></figure>
<p>我们自定义的加载器的findClass 被调用，证明我们写的加载器起了作用。<br>注意：执行之前将当前工程下的MyTest.class文件删除，如果我们重新构建工程，让MyTest.class出现在当前工程里边，再去运行这个自定义类加载器，结果还是会被应用类加载器加载，我们删除MyTest.class的理由就是让应用类加载器加载失败，然后所有的父类委托都无法加载的时候最终让我们自定义的类加载器MyTest16 去加载。而MyTest16指定的加载路径在外部的一个路径，显然是可以的。</p>
<p>好，现在我们修改一下main方法，然后保留当前工程里边的MyTest.class文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    MyTest16 myClassLoader = new MyTest16(&quot;myClassLoader&quot;);</span><br><span class="line">    myClassLoader.setPath(&quot;E:\\data\\classes\\&quot;);</span><br><span class="line">    Class&lt;?&gt; clazz = myClassLoader.loadClass(&quot;com.twodragonlake.jvm.classloader.MyTest&quot;);</span><br><span class="line">    System.out.println(&quot;class :&quot;+clazz.hashCode());</span><br><span class="line">    Object object = clazz.newInstance();</span><br><span class="line">    System.out.println(object);</span><br><span class="line">    System.out.println(&quot;-----------------------------------------&quot;);</span><br><span class="line">    MyTest16 myClassLoader1 = new MyTest16(&quot;myClassLoader1&quot;);</span><br><span class="line">    myClassLoader1.setPath(&quot;E:\\data\\classes\\&quot;);</span><br><span class="line">    Class&lt;?&gt; clazza = myClassLoader1.loadClass(&quot;com.twodragonlake.jvm.classloader.MyTest&quot;);</span><br><span class="line">    System.out.println(&quot;class :&quot;+clazza.hashCode());</span><br><span class="line">    Object objecta = clazza.newInstance();</span><br><span class="line">      System.out.println(objecta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class :356573597</span><br><span class="line">com.twodragonlake.jvm.classloader.MyTest@677327b6</span><br><span class="line">-----------------------------------------</span><br><span class="line">class :356573597</span><br><span class="line">com.twodragonlake.jvm.classloader.MyTest@14ae5a5</span><br></pre></td></tr></table></figure>
<p>我们new了2个自定义加载器，结果可以看到使用了系统类加载器加载的，并且第二次加载使用了之前加载出来的结果，这是因为myClassLoader 和myClassLoader1 的父类加载器都是应用类加载器， 这个在<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3pxNjU3ODcwMi9hcnRpY2xlL2RldGFpbHMvNzk2MDA0MzU=">之前的loadClass方法的介绍<i class="fa fa-external-link-alt"></i></span>里边说过，中间会有一个判断是否加载过的方法 ，loadClass会去调用这个判重方法。</p>
<p>之后我们删除当前工程的MyTest.class文件，再去运行这个main方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">findClass invoked com.twodragonlake.jvm.classloader.MyTest</span><br><span class="line"> this.classLoaderName : myClassLoader</span><br><span class="line">class :21685669</span><br><span class="line">com.twodragonlake.jvm.classloader.MyTest@7f31245a</span><br><span class="line">-----------------------------------------</span><br><span class="line">findClass invoked com.twodragonlake.jvm.classloader.MyTest</span><br><span class="line"> this.classLoaderName : myClassLoader1</span><br><span class="line">class :1173230247</span><br><span class="line">com.twodragonlake.jvm.classloader.MyTest@330bedb4</span><br></pre></td></tr></table></figure>
<p>首先使用了我们自定义的类加载器加载的，并且被加载了2次！！因为类的hashCode编码不同。这两个class(clazz 和clazza )不是同一个class对象，这个和我们之前说过的一个类只能被加载一次是相互矛盾的，这个怎么解释呢，其实是不矛盾的，这里有一个命名空间的问题：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8812%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%9C%BA%E5%88%B6%E5%AE%9E%E4%BE%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/20180318164433605.png" alt="这里写图片描述"><br>在我们这个例子中myClassLoader和myClassLoader1虽然都是同一个类，但是他们是不同的2个对象，而且他们都去尝试用应用类加载器加载的时候都会失败，因为当前工程下的MyTest.class被删除了，导致应用类加载器加载MyTest.class失败，从而让我们自定义的类加载器有机会执行加载逻辑，myClassLoader和myClassLoader1不同的2个对象，同时对应不同的2个命名空间，在不同的命名空间里边，因此加载出来的类也是不同的。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>双亲委托</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（13）类的命名空间与卸载详解及jvisualvm使用</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8813%EF%BC%89%E7%B1%BB%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%8D%B8%E8%BD%BD%E8%AF%A6%E8%A7%A3%E5%8F%8Ajvisualvm%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><strong>类的命名空间</strong><br><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3pxNjU3ODcwMi9hcnRpY2xlL2RldGFpbHMvNzk2MDE3MTk=">上篇文章<i class="fa fa-external-link-alt"></i></span>的结尾到了命名空间的问题，我们接下来继续演进程序，我们删除当前工程的MyTest.class文件，然后修改main方法：</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    MyTest16 myClassLoader = new MyTest16(&quot;myClassLoader&quot;);</span><br><span class="line">    myClassLoader.setPath(&quot;E:\\data\\classes\\&quot;);</span><br><span class="line">    Class&lt;?&gt; clazz = myClassLoader.loadClass(&quot;com.twodragonlake.jvm.classloader.MyTest&quot;);</span><br><span class="line">    System.out.println(&quot;class :&quot;+clazz.hashCode());</span><br><span class="line">    Object object = clazz.newInstance();</span><br><span class="line">    System.out.println(object);</span><br><span class="line">    System.out.println(&quot;-----------------------------------------&quot;);</span><br><span class="line">    MyTest16 myClassLoader1 = new MyTest16(myClassLoader,&quot;myClassLoader1&quot;);</span><br><span class="line">    myClassLoader1.setPath(&quot;E:\\data\\classes\\&quot;);</span><br><span class="line">    Class&lt;?&gt; clazza = myClassLoader1.loadClass(&quot;com.twodragonlake.jvm.classloader.MyTest&quot;);</span><br><span class="line">    System.out.println(&quot;class :&quot;+clazza.hashCode());</span><br><span class="line">    Object objecta = clazza.newInstance();</span><br><span class="line">    System.out.println(objecta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改的地方是【MyTest16 myClassLoader1 &#x3D; new MyTest16(myClassLoader,”myClassLoader1”);】<br>用myClassLoader作为myClassLoader1 的父加载器。<br>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">findClass invoked com.twodragonlake.jvm.classloader.MyTest</span><br><span class="line"> this.classLoaderName : myClassLoader</span><br><span class="line">class :21685669</span><br><span class="line">com.twodragonlake.jvm.classloader.MyTest@7f31245a</span><br><span class="line">-----------------------------------------</span><br><span class="line">class :21685669</span><br><span class="line">com.twodragonlake.jvm.classloader.MyTest@6d6f6e28</span><br></pre></td></tr></table></figure>
<p>是不是懵逼了呢？首先MyTest.class文件被删除了，然后myClassLoader去加载的时候委托父加载器（应用类加载器）没有找到MyTest.class，所以myClassLoader完成加载任务，之后myClassLoader1去加载同一个类，首先会委托myClassLoader1的父加载器myClassLoader去加载，myClassLoader已经加载过MyTest.class，所以会直接返回之前的接在结果，因此看到的被加载类的hashcode编码是相同的，并且myClassLoader1没有再一次执行加载过程。</p>
<p>继续修改main方法，然后保留当前项目的MyTest.class文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    MyTest16 myClassLoader = new MyTest16(&quot;myClassLoader&quot;);</span><br><span class="line">    myClassLoader.setPath(&quot;E:\\data\\classes\\&quot;);</span><br><span class="line">    Class&lt;?&gt; clazz = myClassLoader.loadClass(&quot;com.twodragonlake.jvm.classloader.MyTest&quot;);</span><br><span class="line">    System.out.println(&quot;class :&quot;+clazz.hashCode());</span><br><span class="line">    Object object = clazz.newInstance();</span><br><span class="line">    System.out.println(object);</span><br><span class="line">    System.out.println(&quot;-----------------------------------------&quot;);</span><br><span class="line">    MyTest16 myClassLoader1 = new MyTest16(myClassLoader,&quot;myClassLoader1&quot;);</span><br><span class="line">    myClassLoader1.setPath(&quot;E:\\data\\classes\\&quot;);</span><br><span class="line">    Class&lt;?&gt; clazza = myClassLoader1.loadClass(&quot;com.twodragonlake.jvm.classloader.MyTest&quot;);</span><br><span class="line">    System.out.println(&quot;class :&quot;+clazza.hashCode());</span><br><span class="line">    Object objecta = clazza.newInstance();</span><br><span class="line">    System.out.println(objecta);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;---------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">    MyTest16 myClassLoader2 = new MyTest16(&quot;myClassLoader2&quot;);</span><br><span class="line">    myClassLoader2.setPath(&quot;E:\\data\\classes\\&quot;);</span><br><span class="line">    Class&lt;?&gt; clazz2 = myClassLoader2.loadClass(&quot;com.twodragonlake.jvm.classloader.MyTest&quot;);</span><br><span class="line">    System.out.println(&quot;class :&quot;+clazz2.hashCode());</span><br><span class="line">    Object object2 = clazz2.newInstance();</span><br><span class="line">    System.out.println(object2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没错，new了一个myClassLoader2 然后运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class :356573597</span><br><span class="line">com.twodragonlake.jvm.classloader.MyTest@677327b6</span><br><span class="line">-----------------------------------------</span><br><span class="line">class :356573597</span><br><span class="line">com.twodragonlake.jvm.classloader.MyTest@14ae5a5</span><br><span class="line">---------------------------------------------</span><br><span class="line">class :356573597</span><br><span class="line">com.twodragonlake.jvm.classloader.MyTest@7f31245a</span><br></pre></td></tr></table></figure>
<p>这个结果还是挺简单的，从myClassLoader开始都是应用类加载器，下边的myClassLoader1 和 myClassLoader2都是用的系统类加载器。</p>
<p>如果我们把当前工程下的MyTest.class删除呢？~<br>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">findClass invoked com.twodragonlake.jvm.classloader.MyTest</span><br><span class="line"> this.classLoaderName : myClassLoader</span><br><span class="line">class :21685669</span><br><span class="line">com.twodragonlake.jvm.classloader.MyTest@7f31245a</span><br><span class="line">-----------------------------------------</span><br><span class="line">class :21685669</span><br><span class="line">com.twodragonlake.jvm.classloader.MyTest@6d6f6e28</span><br><span class="line">---------------------------------------------</span><br><span class="line">findClass invoked com.twodragonlake.jvm.classloader.MyTest</span><br><span class="line"> this.classLoaderName : myClassLoader2</span><br><span class="line">class :856419764</span><br><span class="line">com.twodragonlake.jvm.classloader.MyTest@2503dbd3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>myClassLoader和myClassLoader1的打印结果之前分析过了这次略过，myClassLoader2的结果是怎么回事呢。首先MyTest.class被删除了，myClassLoader2的父加载器是应用类加载器，在当前工程下找不到，所以使用了myClassLoader2去加载，因此myClassLoader2的加载逻辑被调用，同时myClassLoader2有属于自己的命名空间，所以MyTest.class被加载，它的hashcode是和其他的加载器不一样的。</p>
<p>我们继续，再修改main方法一行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyTest16 myClassLoader2 = new MyTest16(myClassLoader1,&quot;myClassLoader2&quot;);</span><br></pre></td></tr></table></figure>
<p>即将myClassLoader2 的父加载器指定为myClassLoader1，然后保留当前工程的MyTest.class文件，打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class :356573597</span><br><span class="line">com.twodragonlake.jvm.classloader.MyTest@677327b6</span><br><span class="line">-----------------------------------------</span><br><span class="line">class :356573597</span><br><span class="line">com.twodragonlake.jvm.classloader.MyTest@14ae5a5</span><br><span class="line">---------------------------------------------</span><br><span class="line">class :356573597</span><br><span class="line">com.twodragonlake.jvm.classloader.MyTest@7f31245a</span><br></pre></td></tr></table></figure>
<p>显然都是应用类加载器加载的MyTest.class，因为能在当前工程找到MyTest.class文件。<br>如果我们把MyTest.class文件删除掉，再去运行，结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">findClass invoked com.twodragonlake.jvm.classloader.MyTest</span><br><span class="line"> this.classLoaderName : myClassLoader</span><br><span class="line">class :21685669</span><br><span class="line">com.twodragonlake.jvm.classloader.MyTest@7f31245a</span><br><span class="line">-----------------------------------------</span><br><span class="line">class :21685669</span><br><span class="line">com.twodragonlake.jvm.classloader.MyTest@6d6f6e28</span><br><span class="line">---------------------------------------------</span><br><span class="line">class :21685669</span><br><span class="line">com.twodragonlake.jvm.classloader.MyTest@135fbaa4</span><br></pre></td></tr></table></figure>
<p>可以看到myClassLoader从E:\data\classes\com\twodragonlake\jvm\classloader下边加载了一次之后，myClassLoader1和myClassLoader2都会使用之前myClassLoader加载的结果，因为myClassLoader1和myClassLoader2的父加载器都是myClassLoader。</p>
<p><strong>类的卸载</strong><br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8813%EF%BC%89%E7%B1%BB%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%8D%B8%E8%BD%BD%E8%AF%A6%E8%A7%A3%E5%8F%8Ajvisualvm%E4%BD%BF%E7%94%A8/20180318175607171.png" alt="这里写图片描述"><br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8813%EF%BC%89%E7%B1%BB%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%8D%B8%E8%BD%BD%E8%AF%A6%E8%A7%A3%E5%8F%8Ajvisualvm%E4%BD%BF%E7%94%A8/20180318175636684.png" alt="这里写图片描述"><br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8813%EF%BC%89%E7%B1%BB%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%8D%B8%E8%BD%BD%E8%AF%A6%E8%A7%A3%E5%8F%8Ajvisualvm%E4%BD%BF%E7%94%A8/20180318180041169.png" alt="这里写图片描述"><br>即Java虚拟机自带的加载器加载的类不会在整个jvm的生命周期中被卸载，而自定义加载器加载的类可以被卸载。</p>
<p>修改MyTest16的main方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    MyTest16 myClassLoader = new MyTest16(&quot;myClassLoader&quot;);</span><br><span class="line">    myClassLoader.setPath(&quot;E:\\data\\classes\\&quot;);</span><br><span class="line">    Class&lt;?&gt; clazz = myClassLoader.loadClass(&quot;com.twodragonlake.jvm.classloader.MyTest&quot;);</span><br><span class="line">    System.out.println(&quot;class :&quot;+clazz.hashCode());</span><br><span class="line">    Object object = clazz.newInstance();</span><br><span class="line">    System.out.println(object);</span><br><span class="line">    System.out.println(&quot;-----------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">    myClassLoader = new MyTest16(&quot;myClassLoader3&quot;);</span><br><span class="line">    myClassLoader.setPath(&quot;E:\\data\\classes\\&quot;);</span><br><span class="line">    clazz = myClassLoader.loadClass(&quot;com.twodragonlake.jvm.classloader.MyTest&quot;);</span><br><span class="line">    System.out.println(&quot;class :&quot;+clazz.hashCode());</span><br><span class="line">    object = clazz.newInstance();</span><br><span class="line">    System.out.println(object);</span><br><span class="line">    System.out.println(&quot;-----------------------------------------&quot;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>打印：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">findClass invoked com.twodragonlake.jvm.classloader.MyTest</span><br><span class="line"> this.classLoaderName : myClassLoader</span><br><span class="line">class :21685669</span><br><span class="line">com.twodragonlake.jvm.classloader.MyTest@7f31245a</span><br><span class="line">-----------------------------------------</span><br><span class="line">findClass invoked com.twodragonlake.jvm.classloader.MyTest</span><br><span class="line"> this.classLoaderName : myClassLoader3</span><br><span class="line">class :1173230247</span><br><span class="line">com.twodragonlake.jvm.classloader.MyTest@330bedb4</span><br><span class="line">-----------------------------------------</span><br></pre></td></tr></table></figure>

<p>我们怎么才能证明myClassLoader被卸载了呢，在启动参数里边加入【-XX:+TraceClassUnloading】运行也是没有结果可以看到被卸载，我们将将要被卸载的变量显示的置空一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      MyTest16 myClassLoader = new MyTest16(&quot;myClassLoader&quot;);</span><br><span class="line">      myClassLoader.setPath(&quot;E:\\data\\classes\\&quot;);</span><br><span class="line">      Class&lt;?&gt; clazz = myClassLoader.loadClass(&quot;com.twodragonlake.jvm.classloader.MyTest&quot;);</span><br><span class="line">      System.out.println(&quot;class :&quot;+clazz.hashCode());</span><br><span class="line">      Object object = clazz.newInstance();</span><br><span class="line">      System.out.println(object);</span><br><span class="line">      System.out.println(&quot;-----------------------------------------&quot;);</span><br><span class="line">// 显式置空</span><br><span class="line">      myClassLoader= null;</span><br><span class="line">      clazz = null;</span><br><span class="line">      object = null;</span><br><span class="line">      System.gc();</span><br><span class="line"></span><br><span class="line">      myClassLoader = new MyTest16(&quot;myClassLoader3&quot;);</span><br><span class="line">      myClassLoader.setPath(&quot;E:\\data\\classes\\&quot;);</span><br><span class="line">      clazz = myClassLoader.loadClass(&quot;com.twodragonlake.jvm.classloader.MyTest&quot;);</span><br><span class="line">      System.out.println(&quot;class :&quot;+clazz.hashCode());</span><br><span class="line">      object = clazz.newInstance();</span><br><span class="line">      System.out.println(object);</span><br><span class="line">      System.out.println(&quot;-----------------------------------------&quot;);</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">findClass invoked com.twodragonlake.jvm.classloader.MyTest</span><br><span class="line"> this.classLoaderName : myClassLoader</span><br><span class="line">class :21685669</span><br><span class="line">com.twodragonlake.jvm.classloader.MyTest@7f31245a</span><br><span class="line">-----------------------------------------</span><br><span class="line">[Unloading class com.twodragonlake.jvm.classloader.MyTest 0x00000007c0061828]</span><br><span class="line">findClass invoked com.twodragonlake.jvm.classloader.MyTest</span><br><span class="line"> this.classLoaderName : myClassLoader3</span><br><span class="line">class :1173230247</span><br><span class="line">com.twodragonlake.jvm.classloader.MyTest@330bedb4</span><br><span class="line">-----------------------------------------</span><br></pre></td></tr></table></figure>
<p>可以看到【[Unloading class com.twodragonlake.jvm.classloader.MyTest 0x00000007c0061828]】证明之前的被卸载了。<br>为了直观的看到jvm对它的回收我们使用jvisualvm工具，我们在System.gc();这行代码后面加上 Thread.sleep(100000);以便于我们观察。<br>先运行jvisualvm：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8813%EF%BC%89%E7%B1%BB%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%8D%B8%E8%BD%BD%E8%AF%A6%E8%A7%A3%E5%8F%8Ajvisualvm%E4%BD%BF%E7%94%A8/20180318194540694.png" alt="这里写图片描述"><br>然后运行我们的main方法在visualvm里边打开我们的程序进程，找到监视，可以看到有一个类被卸载：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8813%EF%BC%89%E7%B1%BB%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%8D%B8%E8%BD%BD%E8%AF%A6%E8%A7%A3%E5%8F%8Ajvisualvm%E4%BD%BF%E7%94%A8/20180318194809142.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>命名空间</tag>
        <tag>卸载</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（14）自定义类加载器在复杂类加载情况下的运行分析</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8814%EF%BC%89%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%9C%A8%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>接着上次的<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d6cTY1Nzg3MDIvYXJ0aWNsZS9kZXRhaWxzLzc5NjAxNzE5">事例<i class="fa fa-external-link-alt"></i></span> 我们上次加载的类都是MyTest的这样的一个类，但是如果我们要加载的类里边还有其他的一些类，那么加载器对于这种嵌套的情况是怎么工作的呢？<br>新建一个类MyCat</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyCat &#123;</span><br><span class="line">  public MyCat()&#123;</span><br><span class="line">      System.out.println(&quot;MyCat is loaded by : &quot;+this.getClass().getClassLoader());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>新建类MySample</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MySample &#123;</span><br><span class="line">  public MySample()&#123;</span><br><span class="line">      System.out.println(&quot;MySample is loaded by : &quot;+this.getClass().getClassLoader());</span><br><span class="line">      new MyCat();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MySample 的构造器里边引用了MyCat类，然后我们新建MyTest17使用上次的MyTest16加载MySample ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest17 &#123;</span><br><span class="line">  public static void main(String[] args)  throws Exception&#123;</span><br><span class="line">      MyTest16 loader1 = new MyTest16(&quot;loader1&quot;);</span><br><span class="line">      Class&lt;?&gt; clazz = loader1.loadClass(&quot;com.twodragonlake.jvm.classloader.MySample&quot;);</span><br><span class="line">      System.out.println(&quot;class :&quot;+clazz.hashCode());</span><br><span class="line">      Object object = clazz.newInstance();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果是怎样的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class :1735600054</span><br><span class="line">MySample is loaded by : sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">MyCat is loaded by : sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure>
<p>这个没啥可说的，MyTest16使用的是应用类加载器，其次我们没有指定MyTest16的Path，我们自定义的加载逻辑没有被调用(原因不再熬术，见之前的文章)。<br>在MySample的构造器里边我们去new MyCat的时候打印了MyCat构造器里边的打印语句，那么在实例化MyCat之前，MyCat类的字节码肯定得到了加载，MyCat打印的语句只是打印出来是谁加载的MyCat。‘’<br>如果我们把main方式里边的Object object &#x3D; clazz.newInstance();这行代码注释掉，那么并不会实例化MySample对象，即MySample构造方法不会被调用，<br>因此不会实例化MyCat对象，既没有对MyCat进行主动使用，这里就不会加载MyCat class<br>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class :1735600054</span><br></pre></td></tr></table></figure>
<p>其实MyCat class会不会加载是不一定的：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8814%EF%BC%89%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%9C%A8%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E5%88%86%E6%9E%90/20180405163458487.png" alt="这里写图片描述"><br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8814%EF%BC%89%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%9C%A8%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E5%88%86%E6%9E%90/20180405163626185.png" alt="这里写图片描述"><br>我们加入启动参数-XX:+TraceClassLoading：<br>看一下加载log<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8814%EF%BC%89%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%9C%A8%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E5%88%86%E6%9E%90/20180405164301583.png" alt="这里写图片描述"><br>MySample和MyCat都会如期的加载。</p>
<p>我们注释掉Object object &#x3D; clazz.newInstance();看加载log：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8814%EF%BC%89%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%9C%A8%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E5%88%86%E6%9E%90/20180405164537750.png" alt="这里写图片描述"><br>很明显MyCat没有被加载。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>自定义类加载器</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（15）类加载器命名空间实战剖析与透彻理解</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8815%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%AE%9E%E6%88%98%E5%89%96%E6%9E%90%E4%B8%8E%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>新建类MyTest17_1：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest17_1 &#123;</span><br><span class="line">    public static void main(String[] args)  throws Exception&#123;</span><br><span class="line">        MyTest16 loader1 = new MyTest16(&quot;loader1&quot;);</span><br><span class="line">        loader1.setPath(&quot;E:\\data\\classes\\&quot;);</span><br><span class="line">        Class&lt;?&gt; clazz = loader1.loadClass(&quot;com.twodragonlake.jvm.classloader.MySample&quot;);</span><br><span class="line">        System.out.println(&quot;class :&quot;+clazz.hashCode());</span><br><span class="line">        //如果注释掉改行，那么并不会实例化MySample对象，即MySample构造方法不会被调用</span><br><span class="line">        //因此不会实例化MyCat对象，既没有对MyCat进行主动使用，这里就不会加载MyCat class</span><br><span class="line">        Object object = clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和MyTest17不同的是我们指定了Path，运行结果还是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class :1735600054</span><br><span class="line">MySample is loaded by : sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">MyCat is loaded by : sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure>
<p>ok，现在我们把当前工程下的MySample和MyCat的class文件删除掉，然后copy一份到E:\data\classes\下边，运行程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">findClass invoked com.twodragonlake.jvm.classloader.MySample【加载MySample时MyTest16的打印】</span><br><span class="line"> this.classLoaderName : loader1                             【MySample是由MyTest16加载，MyTest16的打印】</span><br><span class="line">class :2133927002                                           【MyTest17_1的打印】</span><br><span class="line">MySample is loaded by : com.twodragonlake.jvm.classloader.MyTest16@677327b6   【MySample构造器】</span><br><span class="line">findClass invoked com.twodragonlake.jvm.classloader.MyCat   【MySample的构造器new MyCat的时候要先加载MyCat】</span><br><span class="line"> this.classLoaderName : loader1                              【MyCat是由MyTest16加载的】</span><br><span class="line">MyCat is loaded by : com.twodragonlake.jvm.classloader.MyTest16@677327b6  【MyCat构造器的打印】</span><br></pre></td></tr></table></figure>
<p>好，我们继续做一个实验，重新编译当前工程，让MyCat和MySample的class文件出现，然后删除MyCat的class文件，注意此时MySample在当前工程和【E:\data\classes\】下都有一份，而MyCat只在【E:\data\classes\】有一份，当前工程不存在MyCat的class文件，运行程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class :1735600054</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: com/twodragonlake/jvm/classloader/MyCat</span><br><span class="line">MySample is loaded by : sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">	at com.twodragonlake.jvm.classloader.MySample.&lt;init&gt;(MySample.java:6)</span><br><span class="line">	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">	at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">	at java.lang.Class.newInstance(Class.java:442)</span><br><span class="line">	at com.twodragonlake.jvm.classloader.MyTest17_1.main(MyTest17_1.java:11)</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: com.twodragonlake.jvm.classloader.MyCat</span><br><span class="line">	at java.net.URLClassLoader.findClass(URLClassLoader.java:381)</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">	... 7 more</span><br></pre></td></tr></table></figure>
<p><strong>分析：</strong>【 Class&lt;?&gt; clazz &#x3D; loader1.loadClass(“com.twodragonlake.jvm.classloader.MySample”);】运行的时候应用类加载器可以在当前classpath下找到MySample所以就会加载，因此打印【class :1735600054】然后在执行【 Object object &#x3D; clazz.newInstance();】的时候，MySample的构造器里边进行new MyCat的操作，这个时候加载了MySample的加载器（应用类加载器）会去尝试加载MyCat的class（应用类加载器先委托扩展类加载器，无法加载然后在委托系统类加载器加载，也无法加载，最后只能应用类加载器加载），但是MyCat的class已经被我们删除了，因此抛出ClassNotFoundException。</p>
<p>那好如果我们理解了这一步，接下来我们重新编译工程，重新让MyCat和MySample的class文件出现，然后我们删掉当前工程的MySample的class文件，保留当前工程的MyCat的class文件（PS：【E:\data\classes\】下边存在MyCat和MySample的class文件），运行程序，打印结果是啥呢？？？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">findClass invoked com.twodragonlake.jvm.classloader.MySample</span><br><span class="line"> this.classLoaderName : loader1</span><br><span class="line">class :2133927002</span><br><span class="line">MySample is loaded by : com.twodragonlake.jvm.classloader.MyTest16@677327b6</span><br><span class="line">MyCat is loaded by : sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure>
<p>首先MySample在当前工程已经被删除了，所以应用类加载器无法加载，会使用我们自定义的类加载器MyTest16去加载MySample，因此打印：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">findClass invoked com.twodragonlake.jvm.classloader.MySample</span><br><span class="line"> this.classLoaderName : loader1</span><br></pre></td></tr></table></figure>
<p>之后【class :2133927002】是MyTest17_1的打印，在MySample的构造器new MyCat的时候，加载器了MySample的加载器（MyTest16）会尝试加载MyCat，MyTest16自己并不会去加载MyCat，它首先会委托应用类加载器去加载，，应用类加载器能不能加载呢?答案是可以加载，因为MyCat在当前classPath下（当前工程里边的，不是【E:\data\classes\】下边的），所以后边不会出现自定义加载MyTest16的log日志，之后直接打印MyCat构造器的输出【MyCat is loaded by : sun.misc.Launcher$AppClassLoader@18b4aac2】。MySample和MyCat是由2个不同的加载器加载出来的。</p>
<p>ok，继续下一个实验：我们在MyCat 构造器里边加入一行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyCat &#123;</span><br><span class="line">    public MyCat()&#123;</span><br><span class="line">        System.out.println(&quot;MyCat is loaded by : &quot;+this.getClass().getClassLoader());</span><br><span class="line">        System.out.println(&quot;from MyCat : &quot;+MySample.class);//加入打印MySample的一行代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新build当前工程让MySample和MyCat文件出现在当前工程下，然后copy MyCat的class文件到【E:\data\classes\】下边，之后删除当前工程下的MySample的class文件，运行MyTest17_1程序。打印如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">findClass invoked com.twodragonlake.jvm.classloader.MySample</span><br><span class="line"> this.classLoaderName : loader1</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: com/twodragonlake/jvm/classloader/MySample</span><br><span class="line">	at com.twodragonlake.jvm.classloader.MyCat.&lt;init&gt;(MyCat.java:6)</span><br><span class="line">	at com.twodragonlake.jvm.classloader.MySample.&lt;init&gt;(MySample.java:6)</span><br><span class="line">	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">	at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">	at java.lang.Class.newInstance(Class.java:442)</span><br><span class="line">	at com.twodragonlake.jvm.classloader.MyTest17_1.main(MyTest17_1.java:11)</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: com.twodragonlake.jvm.classloader.MySample</span><br><span class="line">	at java.net.URLClassLoader.findClass(URLClassLoader.java:381)</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">	... 8 more</span><br><span class="line">class :2133927002</span><br><span class="line">MySample is loaded by : com.twodragonlake.jvm.classloader.MyTest16@677327b6</span><br><span class="line">MyCat is loaded by : sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure>
<p><strong>分析：</strong><br>首先这个例子和上一个例子只有一个地方不同就是在MyCat的构造器里边加了一行打印MySample的代码，而且MySample和MyCat是由不同的类加载器加载的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MySample is loaded by : com.twodragonlake.jvm.classloader.MyTest16@677327b6  【MySample由MyTest16加载】</span><br><span class="line">MyCat is loaded by : sun.misc.Launcher$AppClassLoader@18b4aac2                【MyCat由AppClassLoader加载】</span><br></pre></td></tr></table></figure>
<p>但是为什么出现MySample的ClassNotFoundException的异常呢，原因就是类的命名空间：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8815%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%AE%9E%E6%88%98%E5%89%96%E6%9E%90%E4%B8%8E%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3/20180405180203363.png" alt="这里写图片描述"><br>即，子加载器可以看到父加载器加载的类，但是父加载器看不到子加载器加载的类，这个例子当中，MySample由子加载器MyTest16加载，MyCat由父加载器AppClassLoader加载，因此在父加载器里边看不到子加载器MyTest16加载的类MySample，所以抛出ClassNotFoundException异常。</p>
<p>ok，最后一个例子，<br>MySample（加入MyCat的打印） ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MySample &#123;</span><br><span class="line">    public MySample()&#123;</span><br><span class="line">        System.out.println(&quot;MySample is loaded by : &quot;+this.getClass().getClassLoader());</span><br><span class="line">        new MyCat();</span><br><span class="line">        System.out.println(&quot;form MySample :&quot;+MyCat.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MyCat （注释掉MySample的打印）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyCat &#123;</span><br><span class="line">    public MyCat()&#123;</span><br><span class="line">        System.out.println(&quot;MyCat is loaded by : &quot;+this.getClass().getClassLoader());</span><br><span class="line">       // System.out.println(&quot;from MyCat : &quot;+MySample.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新buid当前工程，生成MyCat 和MySample的class文件，拷贝一份到【E:\data\classes\】下边，然后删除当前工程的MySample的class文件，运行MyTest17_1程序，打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">findClass invoked com.twodragonlake.jvm.classloader.MySample</span><br><span class="line"> this.classLoaderName : loader1</span><br><span class="line">class :2133927002</span><br><span class="line">MySample is loaded by : com.twodragonlake.jvm.classloader.MyTest16@677327b6</span><br><span class="line">MyCat is loaded by : sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">form MySample :class com.twodragonlake.jvm.classloader.MyCat</span><br></pre></td></tr></table></figure>
<p><strong>分析：</strong><br>首先MySample的class不在当前工程下，因此会使用自定义加载器MyTest16加载，MySample的构造器里边出现new MyCat，因此会使用子加载器MyTest16的父加载器应用类加载器加载MyCat，之后【System.out.println(“form MySample :”+MyCat.class);】这行代码是在子类加载器MyTest16里边出现，由于子类加载器可以看到父类加载器加载的类，因此不会抛出异常。</p>
<p><strong>关于命名空间的重要说明</strong><br>1、子加载器所加载的类能够访问到父加载器所加载的类<br>2、父加载器所加载的类无法访问到子类加载器所加载的类</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>类加载器命名空间</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（16）类加载器实战剖析与疑难点解析</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8816%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%9E%E6%88%98%E5%89%96%E6%9E%90%E4%B8%8E%E7%96%91%E9%9A%BE%E7%82%B9%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>三大类加载器所加载的路径范围：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest18 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(System.getProperty(&quot;sun.boot.class.path&quot;));//系统类加载器加载路径</span><br><span class="line">        System.out.println(System.getProperty(&quot;java.ext.dirs&quot;));//扩展类加载器加载路径</span><br><span class="line">        System.out.println(System.getProperty(&quot;java.class.path&quot;));//应用类加载器加载过程</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果（根据自身环境不同会有所差异）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_111\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\sunrsasign.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_111\jre\classes</span><br><span class="line">-------------------------------------------</span><br><span class="line">C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext;C:\WINDOWS\Sun\Java\lib\ext</span><br><span class="line">-------------------------------------------</span><br><span class="line">C:\Program Files\Java\jdk1.8.0_111\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\jaccess.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\jfxrt.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\localedata.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\nashorn.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\sunec.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\sunjce_provider.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\sunmscapi.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\sunpkcs11.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\zipfs.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\javaws.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\jfxswt.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\management-agent.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\plugin.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar;E:\Study\intelIde\jvm_lecture\out\production\classes;D:\IntelliJ IDEA 2017.2.4\lib\idea_rt.jar</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面我写一个程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest18_1 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        MyTest16 loader1 = new MyTest16(&quot;loader1&quot;);</span><br><span class="line">        loader1.setPath(&quot;E:\\data\\classes\\&quot;);</span><br><span class="line">        Class&lt;?&gt; clazz = loader1.loadClass(&quot;com.twodragonlake.jvm.classloader.MyTest&quot;);</span><br><span class="line">        System.out.println(&quot;class : &quot;+clazz.hashCode());</span><br><span class="line">        System.out.println(&quot;class loader :&quot; + clazz.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class : 1735600054</span><br><span class="line">class loader :sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure>
<p>MyTest是由应用类加载器加载，这个没啥毛病，那么我们能不能想办法让启动类加载器去加载MyTest呢？要想让启动类加载器加载MyTest必须让启动类加载器能够找到MyTest的class文件，那就需要把MyTest放到启动类加载器的加载目录里边。ok，那么我们找到启动类加载器的一个路径比如【C:\Program Files\Java\jdk1.8.0_111\jre\classes】我们定位到此目录下边，此时你会发现C:\Program Files\Java\jdk1.8.0_111\jre\下边并没有classes文件夹，我们新建一个classes即可，既然sun.boot.class.path变量指定了这个目录我们就能从里边尝试加载类，然后我们把工程下边的【com.twodragonlake.jvm.classloader.MyTest.class】放到C:\Program Files\Java\jdk1.8.0_111\jre\下边，<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8816%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%9E%E6%88%98%E5%89%96%E6%9E%90%E4%B8%8E%E7%96%91%E9%9A%BE%E7%82%B9%E8%A7%A3%E6%9E%90/2018040520113087.png" alt="这里写图片描述"><br>OK，此时我们运行MyTest18_1 得到打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class : 2133927002</span><br><span class="line">class loader :null</span><br></pre></td></tr></table></figure>
<p>null表明是由启动类加载器加载。即，MyTest.class是由启动类加载器加载。做完实验时候可以把classes目录删除，以免造成混绕。</p>
<p>接下来看一下扩展类加载器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class MyTest19 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AESKeyGenerator aesKeyGenerator = new AESKeyGenerator();</span><br><span class="line">        System.out.println(aesKeyGenerator.getClass().getClassLoader());</span><br><span class="line">        System.out.println(MyTest19.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sun.misc.Launcher$ExtClassLoader@12a3a380</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure>
<p>那好我们能不能修改扩展类加载器的加载路径java.ext.dirs的值，让其从当前目录加载如何？<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8816%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%9E%E6%88%98%E5%89%96%E6%9E%90%E4%B8%8E%E7%96%91%E9%9A%BE%E7%82%B9%E8%A7%A3%E6%9E%90/20180405202814804.png" alt="这里写图片描述"><br>显然AESKeyGenerator无法被加载，因为当前目录不存在这个类。</p>
<p>下一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest20 &#123;</span><br><span class="line">    public static void main(String[] args)  throws Exception&#123;</span><br><span class="line">        MyTest16 loader1 = new MyTest16(&quot;loader1&quot;) ;</span><br><span class="line">        MyTest16 loader2 = new MyTest16(&quot;loader2&quot;) ;</span><br><span class="line">        Class&lt;?&gt; clazz1 = loader1.loadClass(&quot;com.twodragonlake.jvm.classloader.MyPerson&quot;);</span><br><span class="line">        Class&lt;?&gt; clazz2 = loader2.loadClass(&quot;com.twodragonlake.jvm.classloader.MyPerson&quot;);</span><br><span class="line">        System.out.println(clazz1 ==  clazz2);</span><br><span class="line">        Object object1 = clazz1.newInstance();</span><br><span class="line">        Object object2 = clazz2.newInstance();</span><br><span class="line"></span><br><span class="line">        Method method   = clazz1.getMethod(&quot;setMyPerson&quot;,Object.class);</span><br><span class="line">        method.invoke(object1,object2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打印结果为true，原因是虽然loader1和loader2是2个不同的类加载器实例，但是他们都会委托应用类加载器去加载，如果应用类加载器加载过MyPerson，第二次不会再次加载。所以这2个加载器加载的类返回的结果是同一个类。<br>下边的我们用clazz1创建的Method，然后调用的时候我们传入的是clazz2的对象object2，由于object1和object2的class是同一个class，所以向下类型转换不会出现问题。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>classLoader</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（17）类加载器命名空间深度解析与实例分析</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8817%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>我们在 <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d6cTY1Nzg3MDIvYXJ0aWNsZS9kZXRhaWxzLzc5ODI5MzQx">上一节<i class="fa fa-external-link-alt"></i></span>讲到实例基础上做一下改动：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest21 &#123;</span><br><span class="line">    public static void main(String[] args)  throws Exception&#123;</span><br><span class="line">        MyTest16 loader1 = new MyTest16(&quot;loader1&quot;) ;</span><br><span class="line">        MyTest16 loader2 = new MyTest16(&quot;loader2&quot;) ;</span><br><span class="line">        loader1.setPath(&quot;E:\\data\\classes\\&quot;);</span><br><span class="line">        loader2.setPath(&quot;E:\\data\\classes\\&quot;);</span><br><span class="line">        Class&lt;?&gt; clazz1 = loader1.loadClass(&quot;com.twodragonlake.jvm.classloader.MyPerson&quot;);</span><br><span class="line">        Class&lt;?&gt; clazz2 = loader2.loadClass(&quot;com.twodragonlake.jvm.classloader.MyPerson&quot;);</span><br><span class="line">        System.out.println(clazz1 ==  clazz2);</span><br><span class="line">        Object object1 = clazz1.newInstance();</span><br><span class="line">        Object object2 = clazz2.newInstance();</span><br><span class="line"></span><br><span class="line">        Method method   = clazz1.getMethod(&quot;setMyPerson&quot;,Object.class);</span><br><span class="line">        method.invoke(object1,object2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即指定了loader1和loader2的path路径，然后我们重新编译当前工程，将com.twodragonlake.jvm.classloader.MyPerson的class文件复制一份到【E:\data\classes\】下边，然后删除当前工程的MyPerson的class文件，然后运行MyTest21 的main函数,打印 结果会是什么呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">findClass invoked com.twodragonlake.jvm.classloader.MyPerson</span><br><span class="line"> this.classLoaderName : loader1</span><br><span class="line">findClass invoked com.twodragonlake.jvm.classloader.MyPerson</span><br><span class="line"> this.classLoaderName : loader2</span><br><span class="line">false</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.reflect.InvocationTargetException</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">	at com.twodragonlake.jvm.classloader.MyTest21.main(MyTest21.java:18)</span><br><span class="line">Caused by: java.lang.ClassCastException: com.twodragonlake.jvm.classloader.MyPerson cannot be cast to com.twodragonlake.jvm.classloader.MyPerson</span><br><span class="line">	at com.twodragonlake.jvm.classloader.MyPerson.setMyPerson(MyPerson.java:6)</span><br><span class="line">	... 5 more</span><br></pre></td></tr></table></figure>
<p>分析：首先loader1和loader2虽然都是MyTest16的对象，但是他们之间在类加载的层次上没有任何的关系，loader1加载MyPerson的时候通过向上委托一直到启动类加载器然后又往下到应用类加载器都无法加载，只能通过loader1加载器来加载，loader1加载的MyPerson的class对象clazz1属于loader1的命名空间，同样的道理clazz2属于loader2的命名空间，clazz1和clazz2是不同的2个class对象，所以我们在通过反射调用clazz1的实体object1的setMyPerson方法的时候，传入的是clazz2的实体对象，clazz2和clazz1属于不同的命名空间，相互之间不可见，在强制向下转型的时候肯定是抛出转型失败的错误。<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8817%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90/20180406153748449.png" alt="这里写图片描述"><br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8817%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90/20180406153811702.png" alt="这里写图片描述"><br>子加载器加载的类可以看到父加载器加载的类；<br>父加载器加载的类无法看到子加载器加载的类；</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>classLoader namespace</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（18）类加载器命名空间总结与扩展类加载器要点分析</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8818%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%80%BB%E7%BB%93%E4%B8%8E%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E8%A6%81%E7%82%B9%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><strong>类加载双亲委托模型的好处：</strong><br>1、可以确保Java核心库的类型安全：所有的Java应用都至少会引用Java.lang.Object类，也就是说在运行期，java.lang.Object这个类会被加载到Java虚拟机中，如果这个加载过程是由Java应用自己的类加载器所完成的，</p>
<span id="more"></span>
<p>那么很有可能就会在JVM中存在多个版本的java.lang.Object类，而且这些类库中的类的加载工作都是由启动类加载器来统一完成，从而确保了Java应用所使用的都是同一个版本的Java核心类库，他们之间是相互兼容的。<br>2、可以确保Java核心类库所提供的类不会被自定义的类所替代。<br>3、不同的类加载器可以为相同名称(binary name)的类创建额外的命名空间，相同名称的类可以并存在Java虚拟机中，只需要用不同的类加载器来加载他们即可。不同类加载器所加载的类之间是不兼容的，这就相当于在Java<br>虚拟机内部创建了一个又一个相互隔离的Java类空间，这类技术在很多框架中得到了实际应用。</p>
<p><strong>扩展类加载器：</strong><br>看一段程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest22 &#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;MyTest22 initializer=&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(MyTest22.class.getClassLoader());</span><br><span class="line">        System.out.println(MyTest.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyTest22 initializer=</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure>
<p>很明显他们都是由应用类加载器加载，我们能不能想办法让扩展类加载器加载他们呢，试想我们修改变量【Java.ext.dirs】指向当前程序所在的路径是不是就可以了呢?<br>为此我们定位到【jvm_lecture\out\production\classes】下边，执行命令：<br>java -Djava.ext.dirs&#x3D;.&#x2F; com.twodragonlake.jvm.classloader.MyTest22<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8818%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%80%BB%E7%BB%93%E4%B8%8E%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E8%A6%81%E7%82%B9%E5%88%86%E6%9E%90/20180406163908960.png" alt="这里写图片描述"><br>奇怪的是按照双亲委托模型，在去加载MyTest22的时候先是应用类加载器委托扩展类加载器，扩展类加载器的加载路径是当前路径，MyTest22也在当前路径下边，但是为什么还是应用类加载器加载的呢？<br>这是因为扩展类加载器只能通过jar的形式来加载，不能加载class文件的形式，因此我们把MyTest文件放到jar里边：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\Study\intelIde\jvm_lecture\out\production\classes&gt;jar cvf test.jar com/twodragonlake/jvm/classloader/MyTest.class</span><br><span class="line">已添加清单</span><br><span class="line">正在添加: com/twodragonlake/jvm/classloader/MyTest.class(输入 = 657) (输出 = 373)(压缩了 43%)</span><br></pre></td></tr></table></figure>
<p>然后我们运行MyTest22程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\Study\intelIde\jvm_lecture\out\production\classes&gt;java -Djava.ext.dirs=./ com.twodragonlake.jvm.classloader.MyTest22</span><br><span class="line">MyTest22 initializer=</span><br><span class="line">sun.misc.Launcher$AppClassLoader@2a139a55</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@75b84c92</span><br></pre></td></tr></table></figure>
<p>结果发生了变化，MyTest22是由应用类加载器加载器没啥问题，MyTest由于放到jar包里边，应用类加载器在委托给扩展类加载器的时候，扩展类加载器在当前目录里边的test.jar里边找到了MyTest的class文件，为此扩展类加载器加载了MyTest。<br>如果我们运行【java -Djava.ext.dirs&#x3D;&#x2F; com.twodragonlake.jvm.classloader.MyTest22】即将根目录作为扩展类加载的加载路径，运行结果肯定都是由应用类加载器加载，因为扩展类加载器在根目录下找不到MyTest。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\Study\intelIde\jvm_lecture\out\production\classes&gt;java -Djava.ext.dirs=/ com.twodragonlake.jvm.classloader.MyTest22</span><br><span class="line">MyTest22 initializer=</span><br><span class="line">sun.misc.Launcher$AppClassLoader@73d16e93</span><br><span class="line">sun.misc.Launcher$AppClassLoader@73d16e93</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>classLoader namespace summary</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（1）类加载器深入解析与阶段分解</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%881%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E4%B8%8E%E9%98%B6%E6%AE%B5%E5%88%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><span id="more"></span>

<ul>
<li>在Java代码中，类型（class 、interface、 enum etc）的加载（将字节码从磁盘加载到内存），连接（类与类之间的关系的连接）与初始化过程都是在程序运行期间完成的，加载，连接，初始化顺序不是固定的，不同的虚拟机实现不一样。</li>
<li>提供了更大的灵活性，增加了更多的可能性。</li>
</ul>
<h2 id="类加载器深入剖析"><a href="#类加载器深入剖析" class="headerlink" title="类加载器深入剖析"></a>类加载器深入剖析</h2><ul>
<li>Java虚拟机与程序的周期</li>
<li>在如下几种情况下，Java虚拟机将结束生命周期。<ul>
<li>执行了System.ext()方法。</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止。</li>
<li>由于操作系统错误而导致Java虚拟机进程终止。</li>
<li><h2 id="类的加载、连接与初始化"><a href="#类的加载、连接与初始化" class="headerlink" title="类的加载、连接与初始化"></a>类的加载、连接与初始化</h2></li>
</ul>
</li>
<li>加载：查找并加载类的二进制数据</li>
<li>连接：<ul>
<li>验证：确保被加载类的正确性。</li>
<li>准备：为类的<font color=#ff0000 size=2 face="黑体">静态变量</font>分配内存，并将其初始化为<font color=#ff0000 size=2 face="黑体">默认值</font>。</li>
<li>解析：<font color=#ff0000 size=2 face="黑体">把类中的符号引用装换为直接引用</font>。</li>
</ul>
</li>
<li><font color=#ff0000 size=2 face="黑体">初始化：为类的静态变量赋予正确的初始值</font>。</li>
</ul>
<hr>
<ul>
<li><p>Java程序对类的使用方式可分为2种：<br> - 主动使用<br> - 被动使用</p>
</li>
<li><p>所有的Java虚拟机实现必须在每个类或者接口被Java程序“<font color=#ff0000 size=2 face="黑体">首次主动使用</font>”时才初始化他们。</p>
</li>
<li><p>主动使用（七种）</p>
<ul>
<li>创建类的实例。</li>
<li>访问某个类或者接口的静态变量，或者对该静态变量赋值。</li>
<li>调用类的静态方法。</li>
<li>反射 （如Class.forName(“com.test.Test”)）</li>
<li>初始化一个类的子类</li>
<li>Jav啊虚拟机启动时被标明为启动类的类(Java Test)</li>
<li>JDK1.7开始提供的动态 语言支持：<br>  Java.lang.invoke.MethodHandle实例的解析结果REF_getStattic REF_putStatic REF_invokeStatic句柄对应的类如果没有初始化，则初始化(了解)<br>  除了以上七中情况，其他使用Java类的方式都被看做是对类的被动使用，都不会导致类的<font color=#ff0000 size=2 face="黑体">初始化</font>(指的是加载，连接，初始化这个步骤的初始化)</li>
</ul>
</li>
</ul>
<p>实例介绍：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class MyTest &#123;</span><br><span class="line">/*</span><br><span class="line">对于静态字段来说，只有直接定义该字段的类才会被初始化</span><br><span class="line">当一个类初始化时，要求其父类全部都已经初始化完毕了</span><br><span class="line">-XX:+TraceClassLoading 用于追踪类的加载信息并打印出来</span><br><span class="line">-XX:+&lt;option&gt; 表示开启option选项</span><br><span class="line">-XX:-&lt;option&gt; 表示关闭option选项</span><br><span class="line">-XX:&lt;option&gt;=&lt;value&gt;,表示将option的选项的值设置为value</span><br><span class="line"> */</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //直接使用父类的变量 ，子类不会初始化，虽有用了子类的标识符</span><br><span class="line">        System.out.println(MyChild.str);</span><br><span class="line">        /*</span><br><span class="line">        MyParent1 static block</span><br><span class="line">        hello world</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //直接调用子类的变量 会首先初始化父类，然后再初始化子类</span><br><span class="line">       // System.out.println(MyChild.str2);</span><br><span class="line">        /*</span><br><span class="line">        MyParent1 static block</span><br><span class="line">        MyChild static bloack</span><br><span class="line">        welcome</span><br><span class="line">         */</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyParent1&#123;</span><br><span class="line">    public static String str  = &quot;hello world&quot;;</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;MyParent1 static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyChild extends  MyParent1&#123;</span><br><span class="line">    public static String str2 = &quot;welcome&quot;;</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;MyChild static bloack&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>类的加载：</p>
<ul>
<li>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区，然后在内存中创建一个Java.lang.Class对象(规范并未说明Class对象位于哪里，HotPot虚拟机将其放在了方法区中)用来封装类在方法区内的数据结构。</li>
<li>加载.class文件的方式<ul>
<li>从本地系统中直接加载</li>
<li>通过网络下载.class文件</li>
<li>从zip，jar等归档文件中加载.class文件</li>
<li>从专有数据库中提取 .class文件</li>
<li>将Java源文件动态编译为.class文件</li>
</ul>
</li>
</ul>
<h2 id="类的使用与卸载"><a href="#类的使用与卸载" class="headerlink" title="类的使用与卸载"></a>类的使用与卸载</h2><ul>
<li>使用 ：正常的使用，调用类的方法等</li>
<li>卸载 ：从内存中卸载。</li>
</ul>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>ClassLoader</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（19）平台特定的启动类加载器深入分析与自定义系统类加载器详解</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8819%EF%BC%89%E5%B9%B3%E5%8F%B0%E7%89%B9%E5%AE%9A%E7%9A%84%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>程序：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest23 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(System.getProperty(&quot;sun.boot.class.path&quot;));</span><br><span class="line">        System.out.println(&quot;-------------------------------------------&quot;);</span><br><span class="line">        System.out.println(System.getProperty(&quot;java.ext.dirs&quot;));</span><br><span class="line">        System.out.println(&quot;-------------------------------------------&quot;);</span><br><span class="line">        System.out.println(System.getProperty(&quot;java.class.path&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印是三个加载器的加载路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Program Files\Java\jdk1.8.0_111\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\sunrsasign.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_111\jre\classes</span><br><span class="line">-------------------------------------------</span><br><span class="line">C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext;C:\WINDOWS\Sun\Java\lib\ext</span><br><span class="line">-------------------------------------------</span><br><span class="line">C:\Program Files\Java\jdk1.8.0_111\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\jaccess.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\jfxrt.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\localedata.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\nashorn.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\sunec.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\sunjce_provider.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\sunmscapi.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\sunpkcs11.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\zipfs.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\javaws.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\jfxswt.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\management-agent.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\plugin.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar;E:\Study\intelIde\jvm_lecture\out\production\classes;D:\IntelliJ IDEA 2017.2.4\lib\idea_rt.jar</span><br></pre></td></tr></table></figure>
<p>然后我们在控制台用命令的形式运行MyTest23：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\Study\intelIde\jvm_lecture\out\production\classes&gt;java  com.twodragonlake.jvm.classloader.MyTest23</span><br><span class="line">C:\Program Files\Java\jre1.8.0_111\lib\resources.jar;C:\Program Files\Java\jre1.8.0_111\lib\rt.jar;C:\Program Files\Java\jre1.8.0_111\lib\sunrsasign.jar;C:\Program Files\Java\jre1.8.0_111\lib\jsse.jar;C:\Program Files\Java\jre</span><br><span class="line">1.8.0_111\lib\jce.jar;C:\Program Files\Java\jre1.8.0_111\lib\charsets.jar;C:\Program Files\Java\jre1.8.0_111\lib\jfr.jar;C:\Program Files\Java\jre1.8.0_111\classes</span><br><span class="line">-------------------------------------------</span><br><span class="line">C:\Program Files\Java\jre1.8.0_111\lib\ext;C:\WINDOWS\Sun\Java\lib\ext</span><br><span class="line">-------------------------------------------</span><br><span class="line">.;C:\Program Files\Java\jdk1.7.0_79\lib\dt.jar;C:\Program Files\Java\jdk1.7.0_79\lib\tools.jar;</span><br></pre></td></tr></table></figure>
<p>可以看到应用类加载器的加载路径和我们在idea运行的得到的路径不一样，有一个“.”的路径，就是当前路径，出现这种不一样原因是因为idea这种IDE工具在运行的时候会自动加上一些它认为有用的变量。</p>
<p>总结：<br>在运行期，一个Java类是由该类的完全限定名(binary name，二进制名)和用于加载该类的定义类加载器(defining loader)所共同决定的。<br> 如果同样的名字（即相同的完全限定名）的类是由两个不同的加载器所加载的，那么这些类就是不同的，即便.class文件的字节码完全一样，并且从相同的位置加载亦是如此。<br>加入我们修改【sun.boot.class.path】的路径会发生什么呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\Study\intelIde\jvm_lecture\out\production\classes&gt;java -Dsun.boot.class.path=./ com.twodragonlake.jvm.classloader.MyTest23</span><br><span class="line">Error occurred during initialization of VM</span><br><span class="line">java/lang/NoClassDefFoundError: java/lang/Object</span><br></pre></td></tr></table></figure>
<p>可以看到我们将【sun.boot.class.path】修改为当前路径之后程序直接无法运行。<br>在Oracle的Hotspot实现中，系统属性sun.boot.calss.path如果 修改错了，则运行会出错，提示如下错误信息：<br>Error occurred during initialization of VM<br>java&#x2F;lang&#x2F;NoClassDefFoundError: java&#x2F;lang&#x2F;Object</p>
<p>内建与jvm中的启动类加载器会加载Java.lang.ClassLoader以及其他的Java平台类，<br>当jvm启动时，一块特殊的机器码会运行，他会加载扩展类加载器以及系统类加载器，<br>这块特殊的机器码叫做启动类加载器 (Bootstrap)</p>
<p>启动类加载器并不是Java类，而其他的加载器则都是Java类，<br>启动类加载器是特定于平台的机器指令，他负责开启整个加载过程。</p>
<p>所有类加载器（除了启动类加载器）都被实现为Java类，不过，总归要有一个组件来加载第一个Java类加载器，<br>从而让整个加载过程能够顺利进行下去，加载第一个纯Java类加载器就是启动类加载器的职责。</p>
<p>启动类加载器还会负责加载供JRE正常运行所需要的基本组件。这包括java.util与java.lang包中的类等等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(ClassLoader.class.getClassLoader());</span><br></pre></td></tr></table></figure>
<p>这行代码打印的是null，原因就是ClassLoader就是由启动类加载器加载的。<br>那么我们怎么证明扩展类加载器和应用类加载器也是由启动类加载器加载呢，由于扩展类加载器和应用类加载器都是在Launcher这个类里边，并且不是public的，那么我们就无法在MyTest23里边直接引用他们，但是之前我们提到，如果一个类加载器加载了Launcher，那么这个加载了Launcher的加载器会尝试加载Launcher里边的类，因此我们只要知道Launcher是是由谁加载的就可以知道扩展类加载器和应用类加载器是由谁加载的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(Launcher.class.getClassLoader());</span><br></pre></td></tr></table></figure>
<p>运行的结果是null，为此可知扩展类加载器和应用类加载器都是由启动类加载器加载的。<br>我们看扩展类加载器的源码就可以知道他们的加载路径：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8819%EF%BC%89%E5%B9%B3%E5%8F%B0%E7%89%B9%E5%AE%9A%E7%9A%84%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E8%AF%A6%E8%A7%A3/20180406180020620.png" alt="这里写图片描述"><br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8819%EF%BC%89%E5%B9%B3%E5%8F%B0%E7%89%B9%E5%AE%9A%E7%9A%84%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E8%AF%A6%E8%A7%A3/201804061801059.png" alt="这里写图片描述"></p>
<p>我们可以通过ClassLoader类得到系统类加载器：System.out.println(ClassLoader.getSystemClassLoader());<br>看一下方法的doc：<br><font color="#FF0000"><br>public static ClassLoader getSystemClassLoader()<br>Returns the system class loader for delegation. This is the default delegation parent for new ClassLoader instances, and is typically the class loader used to start the application.<br>This method is first invoked early in the runtime’s startup sequence, at which point it creates the system class loader and sets it as the context class loader of the invoking Thread.<br>The default system class loader is an implementation-dependent instance of this class.<br>If the system property “java.system.class.loader” is defined when this method is first invoked then the value of that property is taken to be the name of a class that will be returned as the system class loader. The class is loaded using the default system class loader and must define a public constructor that takes a single parameter of type ClassLoader which is used as the delegation parent. An instance is then created using this constructor with the default system class loader as the parameter. The resulting class loader is defined to be the system class loader.<br>If a security manager is present, and the invoker’s class loader is not null and the invoker’s class loader is not the same as or an ancestor of the system class loader, then this method invokes the security manager’s checkPermission method with a RuntimePermission(“getClassLoader”) permission to verify access to the system class loader. If not, a SecurityException will be thrown.<br></font><br>如果系统属性【java.system.class.loader】被定义，那么这个属性的值对应的class会被默认的系统类加载器 加载，并且作为系统类加载器，这个被定义的加载器必须有一个单个参数的构造器，参数的类型是ClassLoader，用来代理父加载器，使用这个构造器传入默认的的系统类加载器会创建一个类加载器的实例，这个实例会成为系统类加载器。<br>Returns:<br>The system ClassLoader for delegation, or null if none</p>
<p>这个属性【java.system.class.loader】是jvm暴露出来的一个口子，让我们自定义实现系统类加载器。<br>那好我们用MyTest16作为系统类加载器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\Study\intelIde\jvm_lecture\out\production\classes&gt;java -Djava.system.class.loader=com.twodragonlake.jvm.classloader.MyTest16  com.twodragonlake.jvm.classloader.MyTest23</span><br><span class="line">Error occurred during initialization of VM</span><br><span class="line">java.lang.Error: java.lang.NoSuchMethodException: com.twodragonlake.jvm.classloader.MyTest16.&lt;init&gt;(java.lang.ClassLoader)</span><br><span class="line">        at java.lang.ClassLoader.initSystemClassLoader(Unknown Source)</span><br><span class="line">        at java.lang.ClassLoader.getSystemClassLoader(Unknown Source)</span><br><span class="line">Caused by: java.lang.NoSuchMethodException: com.twodragonlake.jvm.classloader.MyTest16.&lt;init&gt;(java.lang.ClassLoader)</span><br><span class="line">        at java.lang.Class.getConstructor0(Unknown Source)</span><br><span class="line">        at java.lang.Class.getDeclaredConstructor(Unknown Source)</span><br><span class="line">        at java.lang.SystemClassLoaderAction.run(Unknown Source)</span><br><span class="line">        at java.lang.SystemClassLoaderAction.run(Unknown Source)</span><br><span class="line">        at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">        at java.lang.ClassLoader.initSystemClassLoader(Unknown Source)</span><br><span class="line">        at java.lang.ClassLoader.getSystemClassLoader(Unknown Source)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>报错的原因是我们没有定义只有一个参数的构造器，刚才doc里边说明了需要一个构造器，并且只有一个参数，参数类型是【java.lang.ClassLoader】，<br>我们在MyTest16里边定义这个构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public MyTest16(ClassLoader classLoader)&#123;</span><br><span class="line">    super(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次运行【java -Djava.system.class.loader&#x3D;com.twodragonlake.jvm.classloader.MyTest16  com.twodragonlake.jvm.classloader.MyTest23】：<br>前提我们的MyTest23的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest23 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(System.getProperty(&quot;sun.boot.class.path&quot;));</span><br><span class="line">        System.out.println(&quot;-------------------------------------------&quot;);</span><br><span class="line">        System.out.println(System.getProperty(&quot;java.ext.dirs&quot;));</span><br><span class="line">        System.out.println(&quot;-------------------------------------------&quot;);</span><br><span class="line">        System.out.println(System.getProperty(&quot;java.class.path&quot;));</span><br><span class="line"></span><br><span class="line">        System.out.println(ClassLoader.class.getClassLoader());</span><br><span class="line">        //扩展类加载器和应用类加载器都是由启动类加载器加载的。</span><br><span class="line">        System.out.println(Launcher.class.getClassLoader());</span><br><span class="line"></span><br><span class="line">        System.out.println(ClassLoader.getSystemClassLoader());</span><br><span class="line">        System.out.println(System.getProperty(&quot;java.system.class.loader&quot;));//java.system.class.loader</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行命令的结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\Study\intelIde\jvm_lecture\out\production\classes&gt;java -Djava.system.class.loader=com.twodragonlake.jvm.classloader.MyTest16  com.twodragonlake.jvm.classloader.MyTest23</span><br><span class="line">C:\Program Files\Java\jre1.8.0_111\lib\resources.jar;C:\Program Files\Java\jre1.8.0_111\lib\rt.jar;C:\Program Files\Java\jre1.8.0_111\lib\sunrsasign.jar;C:\Program Files\Java\jre1.8.0_111\lib\jsse.jar;C:\Program Files\Java\jre</span><br><span class="line">1.8.0_111\lib\jce.jar;C:\Program Files\Java\jre1.8.0_111\lib\charsets.jar;C:\Program Files\Java\jre1.8.0_111\lib\jfr.jar;C:\Program Files\Java\jre1.8.0_111\classes</span><br><span class="line">-------------------------------------------</span><br><span class="line">C:\Program Files\Java\jre1.8.0_111\lib\ext;C:\WINDOWS\Sun\Java\lib\ext</span><br><span class="line">-------------------------------------------</span><br><span class="line">.;C:\Program Files\Java\jdk1.7.0_79\lib\dt.jar;C:\Program Files\Java\jdk1.7.0_79\lib\tools.jar;</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">com.twodragonlake.jvm.classloader.MyTest16@4e25154f</span><br><span class="line">com.twodragonlake.jvm.classloader.MyTest16</span><br></pre></td></tr></table></figure>
<p>程序是可以运行的，说明刚才的构造器的定义是必须的。<br>然后我们在MyTest23的main函数添加2行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(MyTest23.class.getClassLoader());</span><br><span class="line">System.out.println(MyTest16.class.getClassLoader());</span><br></pre></td></tr></table></figure>
<p>在控制台的用命令运行【java -Djava.system.class.loader&#x3D;com.twodragonlake.jvm.classloader.MyTest16  com.twodragonlake.jvm.classloader.MyTest23】输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure>
<p>MyTest16之所以是系统类加载器加载的，上边的官方doc里边已经说明了：<br>The class is loaded using the default system class loader and must define a public constructor that takes a single parameter of type ClassLoader which is used as the delegation parent.<br>自定义的系统类加载器由默认的系统类加载器加载。所以MyTest16作为自定义的系统类加载器的它自身的加载器就是默认的系统了加载器AppClassLoader。</p>
<p>然后我们在加一行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(ClassLoader.getSystemClassLoader());</span><br></pre></td></tr></table></figure>
<p>在控制台运行命令【java -Djava.system.class.loader&#x3D;com.twodragonlake.jvm.classloader.MyTest16  com.twodragonlake.jvm.classloader.MyTest23】输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.twodragonlake.jvm.classloader.MyTest16@4e25154f</span><br></pre></td></tr></table></figure>
<p>如果我们用idea直接运行得到是AppClassLoader，而控制台显式的指定了自定义系统类加载器，所以得到的系统类加载器是MyTest16。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>AppClassLoader 自定义类加载器</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（20）Launcher类源码分析以及forName方法底层剖析</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8820%EF%BC%89Launcher%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8AforName%E6%96%B9%E6%B3%95%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<p>上一节我们通过【ClassLoader.getSystemClassLoader()】得到系统类加载器，那么本节看一下这个方法的doc以及一些细节，方便我们更好的理解：<br><font color="#FF0000"></p>
<span id="more"></span>
<p>public static ClassLoader getSystemClassLoader()<br>Returns the system class loader for delegation. This is the default delegation parent for new ClassLoader instances, and is typically the class loader used to start the application.<br></font><br>返回用于代理的系统类加载器，对于一个类加载器实例来说这是默认的父级代理，也是最典型的用于启动应用的类加载器。<br><font color="#FF0000"><br>This method is first invoked early in the runtime’s startup sequence, at which point it creates the system class loader and sets it as the context class loader of the invoking Thread.<br></font><br>这个方法最早在运行时启动的就会被调用，在这个调用点上会去创建系统类加载器，并且将其设置在调用线程为【上下文加载器】。<br><font color="#FF0000"><br>The default system class loader is an implementation-dependent instance of this class.<br></font><br>默认的系统类加载器是一个与这个类实现相关的实例<br><font color="#FF0000"><br>If the system property “java.system.class.loader” is defined when this method is first invoked then the value of that property is taken to be the name of a class that will be returned as the system class loader. The class is loaded using the default system class loader and must define a public constructor that takes a single parameter of type ClassLoader which is used as the delegation parent. An instance is then created using this constructor with the default system class loader as the parameter. The resulting class loader is defined to be the system class loader.<br></font><br>如果系统属性【java.system.class.loader】被定义，那么这个属性的值对应的class会被默认的系统类加载器 加载，并且作为系统类加载器，这个被定义的加载器必须有一个单个参数的构造器，参数的类型是ClassLoader，用来代理父加载器，使用这个构造器传入默认的的系统类加载器会创建一个类加载器的实例，这个实例会成为系统类加载器。<br><font color="#FF0000"><br>If a security manager is present, and the invoker’s class loader is not null and the invoker’s class loader is not the same as or an ancestor of the system class loader, then this method invokes the security manager’s checkPermission method with a RuntimePermission(“getClassLoader”) permission to verify access to the system class loader. If not, a SecurityException will be thrown.<br></font><br>安全略过，主要是介绍一些安全接入的权限是否可以接入</p>
<p>伏笔：<br>1、【上下文加载器】<br>2、定义ClassLoader类型的构造器<br>方法体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static ClassLoader getSystemClassLoader() &#123;</span><br><span class="line">    initSystemClassLoader();//初始化系统类加载器</span><br><span class="line">    if (scl == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    //下边的是安全相关的，不做介绍</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    if (sm != null) &#123;</span><br><span class="line">        checkClassLoaderPermission(scl, Reflection.getCallerClass());</span><br><span class="line">    &#125;</span><br><span class="line">    return scl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入到initSystemClassLoader():</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS:</span><br><span class="line">sclSet、scl 成员变量介绍：</span><br><span class="line">    // The class loader for the system</span><br><span class="line">    // @GuardedBy(&quot;ClassLoader.class&quot;)</span><br><span class="line">    系统类加载器在ClassLoader的引用</span><br><span class="line">    private static ClassLoader scl;</span><br><span class="line"></span><br><span class="line">    // Set to true once the system class loader has been set</span><br><span class="line">    // @GuardedBy(&quot;ClassLoader.class&quot;)</span><br><span class="line">    //如果系统类加载器被加载过，即scl成员变量不是null，那么sclSet的值为true</span><br><span class="line">    private static boolean sclSet;</span><br><span class="line"></span><br><span class="line">    private static synchronized void initSystemClassLoader() &#123;</span><br><span class="line">        //系统类加载器是否被设置</span><br><span class="line">        if (!sclSet) &#123;</span><br><span class="line">             //双重判断，即sclSet是true，但是系统类加载器是null，排除非法异常</span><br><span class="line">            if (scl != null)</span><br><span class="line">                throw new IllegalStateException(&quot;recursive invocation&quot;);</span><br><span class="line">                //通过sun.misc.Launcher获取系统类加载器。sun.misc.Launcher是系统类加载器，扩展类加载器上层的一个概念，并且Oracle不是开源的</span><br><span class="line">            sun.misc.Launcher l = sun.misc.Launcher.getLauncher();</span><br><span class="line">            if (l != null) &#123;</span><br><span class="line">                Throwable oops = null;</span><br><span class="line">                scl = l.getClassLoader();</span><br><span class="line">                try &#123;</span><br><span class="line">                    scl = AccessController.doPrivileged(</span><br><span class="line">                        new SystemClassLoaderAction(scl));</span><br><span class="line">                &#125; catch (PrivilegedActionException pae) &#123;</span><br><span class="line">                    oops = pae.getCause();</span><br><span class="line">                    if (oops instanceof InvocationTargetException) &#123;</span><br><span class="line">                        oops = oops.getCause();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (oops != null) &#123;</span><br><span class="line">                    if (oops instanceof Error) &#123;</span><br><span class="line">                        throw (Error) oops;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // wrap the exception</span><br><span class="line">                        throw new Error(oops);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sclSet = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们在idea里边看到的sun.misc.Launcher.getLauncher()的实现是反编译工具给出的，oracle并没有给出源码，但是我们可以去<span class="exturl" data-url="aHR0cDovL29wZW5qZGsuamF2YS5uZXQv">openjdk<i class="fa fa-external-link-alt"></i></span>获取他的源码，也可以使用<span class="exturl" data-url="aHR0cDovL2dyZXBjb2RlLmNvbS9zZWFyY2glRTYlOUYlQTUlRTclOUMlOEIlRTYlQkElOTAlRTclQTAlODElRUYlQkMlOUE=">http://grepcode.com/search查看源码：<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2dyZXBjb2RlLmNvbS9zZWFyY2gvP3F1ZXJ5PXN1bi5taXNjLmxhdW5jaGVy">http://grepcode.com/search/?query=sun.misc.launcher<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2dyZXBjb2RlLmNvbS9maWxlL3JlcG9zaXRvcnkuZ3JlcGNvZGUuY29tL2phdmEvcm9vdC9qZGsvb3Blbmpkay84dTQwLWIyNS9zdW4vbWlzYy9MYXVuY2hlci5qYXZhI0xhdW5jaGVy">http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/sun/misc/Launcher.java#Launcher<i class="fa fa-external-link-alt"></i></span><br>sun.misc.Launcher.getLauncher()z返回值是sun.misc.Launcher内部的一个静态成员变量【 private static Launcher launcher &#x3D; new Launcher();】<br>那么我们看一下Launcher的构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Launcher() &#123;</span><br><span class="line">68         // Create the extension class loader</span><br><span class="line">			//获得系统类加载器</span><br><span class="line">69         ClassLoader extcl;</span><br><span class="line">70         try &#123;</span><br><span class="line">				//ExtClassLoader是Launcher的一个内部类，getExtClassLoader()getExtClassLoader()获取扩展类加载器，</span><br><span class="line">				/**</span><br><span class="line">					getExtClassLoader()方法里边返回扩展类加载器实例，并且通过系统属性java.ext.dirs加载其需要加载的类</span><br><span class="line">				*/</span><br><span class="line">71             extcl = ExtClassLoader.getExtClassLoader();</span><br><span class="line">72         &#125; catch (IOException e) &#123;</span><br><span class="line">73             throw new InternalError(</span><br><span class="line">74                 &quot;Could not create extension class loader&quot;, e);</span><br><span class="line">75         &#125;</span><br><span class="line">76</span><br><span class="line">77         // Now create the class loader to use to launch the application</span><br><span class="line">			//获取系统类加载器，并且将扩展类加载器作为他的委托传入</span><br><span class="line">78         try &#123;</span><br><span class="line">79             loader = AppClassLoader.getAppClassLoader(extcl);</span><br><span class="line">80         &#125; catch (IOException e) &#123;</span><br><span class="line">81             throw new InternalError(</span><br><span class="line">82                 &quot;Could not create application class loader&quot;, e);</span><br><span class="line">83         &#125;</span><br><span class="line">84</span><br><span class="line">85         // Also set the context class loader for the primordial thread.</span><br><span class="line">			//将系统类加载器作为当前线程上下文的加载器</span><br><span class="line">86         Thread.currentThread().setContextClassLoader(loader);</span><br><span class="line">87</span><br><span class="line">88         // Finally, install a security manager if requested</span><br><span class="line">89         String s = System.getProperty(&quot;java.security.manager&quot;);</span><br><span class="line">90         if (s != null) &#123;</span><br><span class="line">91             SecurityManager sm = null;</span><br><span class="line">92             if (&quot;&quot;.equals(s) || &quot;default&quot;.equals(s)) &#123;</span><br><span class="line">93                 sm = new java.lang.SecurityManager();</span><br><span class="line">94             &#125; else &#123;</span><br><span class="line">95                 try &#123;</span><br><span class="line">96                     sm = (SecurityManager)loader.loadClass(s).newInstance();</span><br><span class="line">97                 &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">98                 &#125; catch (InstantiationException e) &#123;</span><br><span class="line">99                 &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">100                &#125; catch (ClassCastException e) &#123;</span><br><span class="line">101                &#125;</span><br><span class="line">102            &#125;</span><br><span class="line">103            if (sm != null) &#123;</span><br><span class="line">104                System.setSecurityManager(sm);</span><br><span class="line">105            &#125; else &#123;</span><br><span class="line">106                throw new InternalError(</span><br><span class="line">107                    &quot;Could not create SecurityManager: &quot; + s);</span><br><span class="line">108            &#125;</span><br><span class="line">109        &#125;</span><br><span class="line">110    &#125;</span><br></pre></td></tr></table></figure>
<p>扩展类加载器获取加载文件数组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">169        private static File[]  getExtDirs() &#123;</span><br><span class="line">				//加载来源来自于系统属性java.ext.dirs</span><br><span class="line">170            String s = System.getProperty(&quot;java.ext.dirs&quot;);</span><br><span class="line">171            File[] dirs;</span><br><span class="line">172            if (s != null) &#123;</span><br><span class="line">173                StringTokenizer st =</span><br><span class="line">174                    new StringTokenizer(s, File.pathSeparator);</span><br><span class="line">175                int count = st.countTokens();</span><br><span class="line">176                dirs = new File[count];</span><br><span class="line">177                for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">178                    dirs[i] = new File(st.nextToken());</span><br><span class="line">179                &#125;</span><br><span class="line">180            &#125; else &#123;</span><br><span class="line">181                dirs = new File[0];</span><br><span class="line">182            &#125;</span><br><span class="line">183            return dirs;</span><br><span class="line">184        &#125;</span><br></pre></td></tr></table></figure>
<p>getAppClassLoader的方法：<br>入参是扩展类加载器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">267        public static ClassLoader getAppClassLoader(final ClassLoader extcl)</span><br><span class="line">268            throws IOException</span><br><span class="line">269        &#123;</span><br><span class="line">				//通过系统属性java.class.path获取加载路径</span><br><span class="line">270            final String s = System.getProperty(&quot;java.class.path&quot;);</span><br><span class="line">271            final File[] path = (s == null) ? new File[0] : getClassPath(s);</span><br><span class="line">272</span><br><span class="line">273            // Note: on bugid 4256530</span><br><span class="line">274            // Prior implementations of this doPrivileged() block supplied</span><br><span class="line">275            // a rather restrictive ACC via a call to the private method</span><br><span class="line">276            // AppClassLoader.getContext(). This proved overly restrictive</span><br><span class="line">277            // when loading  classes. Specifically it prevent</span><br><span class="line">278            // accessClassInPackage.sun.* grants from being honored.</span><br><span class="line">279            //</span><br><span class="line">280            return AccessController.doPrivileged(</span><br><span class="line">281                new PrivilegedAction&lt;AppClassLoader&gt;() &#123;</span><br><span class="line">282                    public AppClassLoader More ...run() &#123;</span><br><span class="line">283                    URL[] urls =</span><br><span class="line">284                        (s == null) ? new URL[0] : pathToURLs(path);</span><br><span class="line">						//构造系统类加载器的时候将他的委托父类传入，以及加载路径数组</span><br><span class="line">285                    return new AppClassLoader(urls, extcl);</span><br><span class="line">286                &#125;</span><br><span class="line">287            &#125;);</span><br><span class="line">288        &#125;</span><br><span class="line">289</span><br><span class="line">290        final URLClassPath ucp;</span><br><span class="line">291</span><br><span class="line">292        /*</span><br><span class="line">293         * Creates a new AppClassLoader</span><br><span class="line">294         */</span><br><span class="line">295        AppClassLoader(URL[] urls, ClassLoader parent) &#123;</span><br><span class="line">				//调用父类URLClassLoader,注意不管是系统类加载器还是扩展类加载器都是继承来自ClassLoader</span><br><span class="line">				//CLassLoader里边之前说过有一个硬编码的成员变量【private final ClassLoader parent;】</span><br><span class="line">				//此处的parent一直溯源到ClassLoader 类，将ClassLoader 的parent赋值为当前方法传入的parent入参，</span><br><span class="line">				//也就说明了系统类加载器的委托父类就是扩展类加载器</span><br><span class="line">296            super(urls, parent, factory);</span><br><span class="line">297            ucp = SharedSecrets.getJavaNetAccess().getURLClassPath(this);</span><br><span class="line">298            ucp.initLookupCache(this);</span><br><span class="line">299        &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们再回过头来看看idea里边反编译出来的获取系统类加载器的方法：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8820%EF%BC%89Launcher%E7%B1%BB%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8AforName%E6%96%B9%E6%B3%95%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90/20180415145420761.png" alt="这里写图片描述"><br>大家可能会有疑问，为什么反编译出来的变量都是var1、var2之类的呢？其实这个在龙哥的<span class="exturl" data-url="aHR0cDovL3d3dy5pcHJvZ3JhbW1pbmcuY24va290bGluX2xlc3Nvbi5odG1s">kotlin<i class="fa fa-external-link-alt"></i></span>课程中【27_Kotlin函数使用综述与显式返回类型分析】一讲里边介绍过，Java中并不总是在class 字节码中携带变量名，但是在kotlin里边就不是这样的，因为kotlin里边有具名参数的概念。</p>
<p>ok，我们回到initSystemClassLoader()方法,通过调用【 sun.misc.Launcher l &#x3D; sun.misc.Launcher.getLauncher();】获取到系统类加载器之后，赋值给ClassLoader的scl成员变量之后，还有一块代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    scl = AccessController.doPrivileged(</span><br><span class="line">        new SystemClassLoaderAction(scl));</span><br><span class="line">&#125; catch (PrivilegedActionException pae) &#123;</span><br><span class="line">    oops = pae.getCause();</span><br><span class="line">    if (oops instanceof InvocationTargetException) &#123;</span><br><span class="line">        oops = oops.getCause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这块逻辑的作用是看看是否设置了系统属性【java.system.class.loader】，即自定义的系统类加载器，如果设置了那么实例化自定义的系统类加载器返回，替代之前获取的系统类加载器，如果没有设置直接返回默认的系统类加载器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class SystemClassLoaderAction</span><br><span class="line">    implements PrivilegedExceptionAction&lt;ClassLoader&gt; &#123;</span><br><span class="line">    private ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    SystemClassLoaderAction(ClassLoader parent) &#123;</span><br><span class="line">        this.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ClassLoader run() throws Exception &#123;</span><br><span class="line">        String cls = System.getProperty(&quot;java.system.class.loader&quot;);</span><br><span class="line">        //自定义系统类加载器未定义，直接返回之前默认获取的系统类加载器</span><br><span class="line">        if (cls == null) &#123;</span><br><span class="line">            return parent;</span><br><span class="line">        &#125;</span><br><span class="line">		//如果定义了自定义的系统类加载器那么实例化并返回，替代默认的系统类加载器</span><br><span class="line">		//etDeclaredConstructor(new Class&lt;?&gt;[] &#123; ClassLoader.class &#125;)这个就是我们之前</span><br><span class="line">		//（https://blog.csdn.net/wzq6578702/article/details/79835695）</span><br><span class="line">		//在MyTest16里边加入一个参数是ClassLoader的构造器的原因，</span><br><span class="line">		//因为自定义的的加载器在这里会被反射调用，</span><br><span class="line">		//</span><br><span class="line">        Constructor&lt;?&gt; ctor = Class.forName(cls, true, parent)</span><br><span class="line">            .getDeclaredConstructor(new Class&lt;?&gt;[] &#123; ClassLoader.class &#125;);</span><br><span class="line">        ClassLoader sys = (ClassLoader) ctor.newInstance(</span><br><span class="line">            new Object[] &#123; parent &#125;);</span><br><span class="line">            //同样的道理 将自定义系统类加载器作为当前线程的上下文加载器。</span><br><span class="line">        Thread.currentThread().setContextClassLoader(sys);</span><br><span class="line">        return sys;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么接下来介绍一下 Class.forName(cls, true, parent)，Class.forName方法大部分做web开发的都是在开始写jdbc的时候接触，那么先看一下doc：<br>java.lang.Class<br>public static Class&lt;?&gt; forName(@NonNls String name,<br>                               boolean initialize,<br>                               ClassLoader loader)<br>                       throws ClassNotFoundException<br>接收三个参数。<br>第一参数是要被加载的类的全名，第二个参数是用来表示是否初始化这个要被加载的类，第三个参数是类加载器。<br><font color="#FF0000"><br>Returns the Class object associated with the class or interface with the given string name, using the given class loader. Given the fully qualified name for a class or interface (in the same format returned by getName) this method attempts to locate, load, and link the class or interface. The specified class loader is used to load the class or interface. If the parameter loader is null, the class is loaded through the bootstrap class loader. The class is initialized only if the initialize parameter is true and if it has not been initialized earlier.<br></font><br>通过给定的类加载器，即入参loader，返回入参name对应的类或接口的Class对象，通过给定的接口或者类的全名(通过getName方法获取)尝试去定位，加载，连接，给定的loader用来加载类或者接口，如果参数loader是null，那么就会使用启动类加载器去加载，，只在在入参initialize 为true并且类从来没有被加载的情况下才去初始化这个类。<br><font color="#FF0000"><br>If name denotes a primitive type or void, an attempt will be made to locate a user-defined class in the unnamed package whose name is name. Therefore, this method cannot be used to obtain any of the Class objects representing primitive types or void.<br></font><br>如果name是原生类型或者是void，那么就会尝试在用户定义类的没有包名的包（default package）下边去定位，因为这个方法不能用于包含原生类型或者void类型<br><font color="#FF0000"><br>If name denotes an array class, the component type of the array class is loaded but not initialized.<br></font><br>如果name对应的是一个数组类型，这个数组的组件类型会被加载但是不会初始化。<br><font color="#FF0000"><br>For example, in an instance method the expression:<br>Class.forName(“Foo”)<br>is equivalent to:<br>Class.forName(“Foo”, true, this.getClass().getClassLoader())<br>Note that this method throws errors related to loading, linking or initializing as specified in Sections 12.2, 12.3 and 12.4 of The Java Language Specification. Note that this method does not check whether the requested class is accessible to its caller.<br></font><br>这个方法会抛出Java语言规范的12.2，12.3，12.4章节里边的相关的对于加载，连接，初始化相关的异常，注意这个方法并不会检查对于调用者来说是否访问。<br><font color="#FF0000"><br>If the loader is null, and a securiy manager is present, and the caller’s class loader is not null, then this method calls the security manager’s checkPermission method with a RuntimePermissin(“getClassLoader”) permission to ensure it’s ok to access the bootstrap class loader.<br></font><br>如果laoder是null，并且安全管理器指定了，并且调用者的加载器不是null，那么这个方法会调用安全管理器的checkPermission 方法，使用RuntimePermissin(“getClassLoader”) 来确定是否可以接入启动类加载器【这块了解即可】<br>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   public static Class&lt;?&gt; forName(String name, boolean initialize,</span><br><span class="line">                                  ClassLoader loader)</span><br><span class="line">       throws ClassNotFoundException</span><br><span class="line">   &#123;</span><br><span class="line">       Class&lt;?&gt; caller = null;</span><br><span class="line">       SecurityManager sm = System.getSecurityManager();</span><br><span class="line">       if (sm != null) &#123;</span><br><span class="line">           // Reflective call to get caller class is only needed if a security manager</span><br><span class="line">           // is present.  Avoid the overhead of making this call otherwise.</span><br><span class="line">           //获取调用此forName方法的类的Class对象A</span><br><span class="line">           caller = Reflection.getCallerClass();</span><br><span class="line">           if (sun.misc.VM.isSystemDomainLoader(loader)) &#123;</span><br><span class="line">            //获取A的类加载器</span><br><span class="line">               ClassLoader ccl = ClassLoader.getClassLoader(caller);</span><br><span class="line">               //安全检查</span><br><span class="line">               if (!sun.misc.VM.isSystemDomainLoader(ccl)) &#123;</span><br><span class="line">                   sm.checkPermission(</span><br><span class="line">                       SecurityConstants.GET_CLASSLOADER_PERMISSION);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //name：要被加载的|initialize：是否初始化|loader：指定的类加载器（自定义加载器此处是系统类加载器）|caller调用者的Class对象</span><br><span class="line">       return forName0(name, initialize, loader, caller);</span><br><span class="line">   &#125;</span><br><span class="line">//forName0是一个本地方法</span><br><span class="line">   /** Called after security check for system loader access checks have been made. */</span><br><span class="line">   private static native Class&lt;?&gt; forName0(String name, boolean initialize,</span><br><span class="line">                                           ClassLoader loader,</span><br><span class="line">                                           Class&lt;?&gt; caller)</span><br><span class="line">       throws ClassNotFoundException;</span><br></pre></td></tr></table></figure>
<p>另外和只有一个参数的forName的区别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static Class&lt;?&gt; forName(String className)</span><br><span class="line">             throws ClassNotFoundException &#123;</span><br><span class="line">     Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">     // className：要加载的Class名字 | 是否初始化：此处需要初始化 |调用者的类加载器 | 调用者的Class对象</span><br><span class="line">     return forName0(className, true, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>launcher</tag>
        <tag>forName</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（21）线程上下文类加载器分析与实现</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8821%EF%BC%89%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>看一个程序来一下感性的认识：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest24 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getContextClassLoader());</span><br><span class="line">        System.out.println(Thread.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序的输出是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">null</span><br></pre></td></tr></table></figure>
<p>解析：<br>第一行当前的线程是运行MyTest24 的线程，而MyTest24 是由系统类加载器加载，所以打印的是系统类加载器<br>第二行Thread类是java核心库的类，是由启动类加载器加载，所以不打印 null</p>
<p><strong>当前类加载器(Current ClassLoader)</strong><br>每个类都会使用自己的类加载器(即加载自身的类加载器) 来去加载其他类(指的是所依赖的类)<br>如果ClassA引用了ClassY，那么ClassX的类加载器就会加载ClassY（前提是ClassY尚未被加载）</p>
<p><strong>线程上下文加载器（Context  ClassLoader）</strong><br>线程上下文类加载器是从jdk1.2开始引入的，类Thread中的getContextCLassLoader()与setContextClassLoader(ClassLoader classloader)<br>分别用来获取和设置上下文类加载器</p>
<p>如果没有通过与setContextClassLoader(ClassLoader classloader)进行设置的话，线程将继承其父线程的上下文类加载器。<br>Java应用运行时的初始线程的上下文加载器是系统类加载器，在线程中运行的代码可以通过该类加载器来加载类与资源<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8821%EF%BC%89%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0/20180423204738624.png" alt="这里写图片描述"><br><em>前言：</em><br>我们在使用jdbc的时候，不同的数据库的驱动都是由每个厂商自己去实现，开发者在使用的时候，只需要把驱动jar包<br>放到当前path下边就可以了，这些驱动是由系统类加载器加载，而java.sql下边的一些Class在使用的时候不可避免的<br>要去使用厂商自定义的实现的逻辑，但是这些java.sql下的类的加载器是由启动类加载器完成的加载，由于父加载器(启动类加载器)加载的类无法访问子加载器（系统类加载器或者应用类加载器）<br>加载的类，所以就无法在有些java.sql的类去访问具体的厂商实现，这个是双亲委托模型尴尬的一个局面。</p>
<p><strong>线程上下文加载器的重要性：</strong><br>SPI (Service Provider Interface)<br>父ClassLoader可以使用当前线程Thread.currentThread().getContextClassLoader()所指定的classloader加载的类。<br>这就改变了父ClassLoader不能使用子ClassLoader或是其他没有直接父子关系的CLassLoader加载的类的情况，即改变了<br>双亲委托模型。</p>
<p>线程上下文加载器就是当前线程的Current ClassLoader<br>在双亲委托模型下，类加载器由下至上的，即下层的类加载器会委托上层进行加载。但是对于SPI来说，有些接口是java<br>核心库所提供的，而java核心库是由启动类加载器来加载的，而这些接口的实现来自于不同的jar包（厂商提供），java<br>的启动类加载器是不会加载其他来源的jar包，这样传统的双亲委托模型就无法满足SPI的要求，而通过给当前线程设置上下文加载器<br>就可以设置上下文类加载器来实现对于接口实现类的加载。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>线程上下文类加载器</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（22）线程上下文类加载器本质剖析与实做&amp;ServiceLoader在SPI中的重要作用分析</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8822%EF%BC%89%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%AC%E8%B4%A8%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E5%81%9A-ServiceLoader%E5%9C%A8SPI%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E4%BD%9C%E7%94%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>   <strong>线程类上下文加载器的一般使用模式(获取-使用-还原)</strong></p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">try&#123;</span><br><span class="line">    Thread.currnetThread().setContextClassLoader(targetTccl);</span><br><span class="line">    myMethod();</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    Thread.currentThread().setContextClassLoader(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   myMethod里面则调用了Thread.currentThread().getContextClassLoader(),获取当前线程的上下文加载器做某些事情。<br>    如果一个类由类加载器A加载，那么这个类的依赖类也是由相同的类加载器加载的（如果该依赖类之前没有被加载过的话）<br>    ContextClassLoader的作用就是为了破坏java的类加载委托机制。</p>
<p>   当高层提供统一的接口让底层去实现，同时又要在高层加载（或实例化）底层的类时，就必须要通过线程上下文类加载器<br>    来帮助高层的ClassLoader找到并加载该类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest26 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ServiceLoader&lt;Driver&gt; serviceLoader = ServiceLoader.load(Driver.class);</span><br><span class="line">        Iterator&lt;Driver&gt; iterator = serviceLoader.iterator();</span><br><span class="line"></span><br><span class="line">        while(iterator.hasNext())&#123;</span><br><span class="line">            Driver driver =  iterator.next();</span><br><span class="line">            System.out.println(&quot;driver: &quot;+driver.getClass() + &quot;loader: &quot;+ driver.getClass().getClassLoader() );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;当前线程上下文类加载器: &quot; + Thread.currentThread().getContextClassLoader());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;ServiceLoader的类加载器: &quot;+ServiceLoader.class.getClassLoader());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">driver: class com.mysql.jdbc.Driverloader: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">driver: class com.mysql.fabric.jdbc.FabricMySQLDriverloader: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">当前线程上下文类加载器: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">ServiceLoader的类加载器: null</span><br></pre></td></tr></table></figure>
<p>我们可以看到ServiceLoader找到了mysql的两个驱动，这两个驱动都是由系统类加载器加载的，当前线程的上下文加载器默认也是系统类加载器，ServiceLoader是由启动类加载器加载，但是程序是怎样找到mysql的两个驱动的呢？我们没有在程序里边设置任何的属性或者路径之类的东西让程序能找到mysql的驱动，那么我们只能研究一下ServiceLoader的源码和doc看一下他们的原理：</p>
<font color="#FF0000">
public final class ServiceLoader  extends Object implements Iterable
A simple service-provider loading facility.
</font>
这是一个简单服务提供者的设施

<font color="#FF0000">
A service is a well-known set of interfaces and (usually abstract) classes. A service provider is a specific implementation of a service. The classes in a provider typically implement the interfaces and subclass the classes defined in the service itself. Service providers can be installed in an implementation of the Java platform in the form of extensions, that is, jar files placed into any of the usual extension directories. Providers can also be made available by adding them to the application's class path or by some other platform-specific means.
</font>

<p>服务是一个已知的接口和类（通常是抽象类）的集合，服务提供者就是服务的的一种具体实现，服务提供者通常去实现服务的接口和服务自身定义的类的子类。服务提供者可以以一种扩展的形式被安装到java平台的实现，有jar包的形式，文件形式等放到任何的扩展目录下边，服务提供者可以通过加在应用的classpath路径下边或者其他特定平台的手段让其变的可用。</p>
<font color="#FF0000">
For the purpose of loading, a service is represented by a single type, that is, a single interface or abstract class. (A concrete class can be used, but this is not recommended.) A provider of a given service contains one or more concrete classes that extend this service type with data and code specific to the provider. The provider class is typically not the entire provider itself but rather a proxy which contains enough information to decide whether the provider is able to satisfy a particular request together with code that can create the actual provider on demand. The details of provider classes tend to be highly service-specific; no single class or interface could possibly unify them, so no such type is defined here. The only requirement enforced by this facility is that provider classes must have a zero-argument constructor so that they can be instantiated during loading.
</font>

<p>出于加载的目的，服务表现为单个的类型，也就是说一个单个的接口或者抽象类（抽象类的实现类可以是被使用的，但是不是推荐的），给定服务的提供者包含一个或多个具体的实现类用来扩展服务类型，通过特定于提供者的数据或者代码。提供者通常不是提供者本身，而是以一种代理的形式，包含了足够的信息来确定提供者满足了特定的需求，并且加上了一些代码根据需要创建实际的提供者，服务提供者的细节和服务是挂钩的，没有单个的接口或者类将他们统一起来，因此这种类型并没有定义在这里面，对于这个基础设施来说他说施加的唯一需求就是提供者的类需要有一个无参构造器，这样就可以在加载的时候实例化他们。</p>
<font color="#FF0000">
A service provider is identified by placing a provider-configuration file in the resource directory META-INF/services. The file's name is the fully-qualified binary name of the service's type. The file contains a list of fully-qualified binary names of concrete provider classes, one per line. Space and tab characters surrounding each name, as well as blank lines, are ignored. The comment character is '#' ('\u0023', NUMBER SIGN); on each line all characters following the first comment character are ignored. The file must be encoded in UTF-8.
</font>

<p>服务提供者是通过将服务提供者的配置文件放在资源目录的【META-INF&#x2F;services】下边去标识的，这个文件的名字是服务类型的全限定名，文件的内容是一个具体的实现者的全限定名的列表，每一行一个实现者，围绕的空格和tab都会被忽略掉，同样空行也会被忽略掉，注解字符是【#】，在每一行#后边的都会被忽略掉，这个文件必须是UTF-8编码的。</p>
<font color="#FF0000">
If a particular concrete provider class is named in more than one configuration file, or is named in the same configuration file more than once, then the duplicates are ignored. The configuration file naming a particular provider need not be in the same jar file or other distribution unit as the provider itself. The provider must be accessible from the same class loader that was initially queried to locate the configuration file; note that this is not necessarily the class loader from which the file was actually loaded.
</font>

<p>如果一个具体的实现类在多个文件出现或者同一个文件出现多次，那么重复的部分会被忽略掉，配置文件指定的提供者不需要在同一个jar或者其他的分发单元里边，提供者的类必须可以让定位配置文件的那个加载器去加载，</p>
<font color="#FF0000">
Providers are located and instantiated lazily, that is, on demand. A service loader maintains a cache of the providers that have been loaded so far. Each invocation of the iterator method returns an iterator that first yields all of the elements of the cache, in instantiation order, and then lazily locates and instantiates any remaining providers, adding each one to the cache in turn. The cache can be cleared via the reload method.
Service loaders always execute in the security context of the caller. Trusted system code should typically invoke the methods in this class, and the methods of the iterators which they return, from within a privileged security context.
</font>

<p>提供者是延迟定位和实例化的，而是按需要进行，一个服务提供者维持了一份最近加载过的提供者的缓存，而每次对于iterator方法的调用都会返回一个迭代器，迭代的是之前缓存的所有的元素，并且是以实例化的顺序返回，并且是延迟的定位和加载其他剩余的提供者，按照顺序添加到缓存里边，缓存可以通过reload方法清空。<br>【缓存其实就是ServiceLoader的成员变量private LinkedHashMap&lt;String,S&gt; providers &#x3D; new LinkedHashMap&lt;&gt;();】<br>服务的加载总是在调用的时候在安全的上下文进行，信任的系统可以调用类中的代码，迭代器可以从安全的上下文返回。<br><font color="#FF0000"><br>Instances of this class are not safe for use by multiple concurrent threads.<br></font><br>当前类并不是线程安全的一个类<br><font color="#FF0000"><br>Unless otherwise specified, passing a null argument to any method in this class will cause a NullPointerException to be thrown.<br></font><br>除非指定了，否则向这个类的任何一个方法传递null的参数都会导致空指针异常。<br><font color="#FF0000"><br>Example Suppose we have a service type com.example.CodecSet which is intended to represent sets of encoder&#x2F;decoder pairs for some protocol. In this case it is an abstract class with two abstract methods:<br></font><br>举例如果一个服务的类型是 com.example.CodecSet 用来表示某个协议的编解码器的集合，在这种情况下，这个抽象类包含2个方法：<br>   public abstract Encoder getEncoder(String encodingName);<br>   public abstract Decoder getDecoder(String encodingName);</p>
   <font color="#FF0000">
Each method returns an appropriate object or null if the provider does not support the given encoding. Typical providers support more than one encoding.
If com.example.impl.StandardCodecs is an implementation of the CodecSet service then its jar file also contains a file named
   META-INF/services/com.example.CodecSet
   </font>
   每个方法返回合适的对象或者在不支持的情况下返回null，典型的提供者支持多个编码器，如果 com.example.impl.StandardCodecs是CodecSet 的一个具体实现者，那么jar文件就会包含这样的目录 形式：
This file contains the single line:
文件内容包含这样的一行，相当于mysql的驱动：
   com.example.impl.StandardCodecs    # Standard codecs
The CodecSet class creates and saves a single service instance at initialization:
CodecSet 在初始化的时候创建和保存了一个单个的服务实体。
<font color="#FF0000">
   private static ServiceLoader<CodecSet> codecSetLoader = ServiceLoader.load(CodecSet.class);
To locate an encoder for a given encoding name it defines a static factory method which iterates through the known and available providers, returning only when it has located a suitable encoder or has run out of providers.
</font>
通过工厂的方式，接受一个特定编码器的名字，返回对应的编码器，或者遍历完毕之后返回。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static Encoder getEncoder(String encodingName) &#123;</span><br><span class="line">    for (CodecSet cp : codecSetLoader) &#123;</span><br><span class="line">        Encoder enc = cp.getEncoder(encodingName);</span><br><span class="line">        if (enc != null)</span><br><span class="line">            return enc;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="#FF0000">
A getDecoder method is defined similarly.
</font>
getDecoder 方法也是按照类似的方式进行。
<font color="#FF0000">
Usage Note If the class path of a class loader that is used for provider loading includes remote network URLs then those URLs will be dereferenced in the process of searching for provider-configuration files.
</font>
使用说明：如果类加载器的class path用来加载包含网络url，那么这个urls会被解引用，在处理搜索配置文件的时候。
<font color="#FF0000">
This activity is normal, although it may cause puzzling entries to be created in web-server logs. If a web server is not configured correctly, however, then this activity may cause the provider-loading algorithm to fail spuriously.
</font>
这种活动是很常见的，在用于网络加载的时候。
<font color="#FF0000">
A web server should return an HTTP 404 (Not Found) response when a requested resource does not exist. Sometimes, however, web servers are erroneously configured to return an HTTP 200 (OK) response along with a helpful HTML error page in such cases. This will cause a ServiceConfigurationError to be thrown when this class attempts to parse the HTML page as a provider-configuration file. The best solution to this problem is to fix the misconfigured web server to return the correct response code (HTTP 404) along with the HTML error page.
Type parameters:
`<S>` - The type of the service to be loaded by this loader
</font>
泛型S的类型就是服务的类型。
好，上述的doc重点是介绍了第三方的驱动是放在jar包下的META-INF/services下边，并且在java的ServiceLoader里边是写死了：

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class ServiceLoader&lt;S&gt; implements Iterable&lt;S&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    private static final String PREFIX = &quot;META-INF/services/&quot;;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<p>其下的文件名字就是服务的名字，比如数据库驱动的服务是java.sql.Drive，我们在mysql的jar包下可以看到这个文件，文件里边的内容是具体的实现类的全限定名：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8822%EF%BC%89%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%AC%E8%B4%A8%E5%89%96%E6%9E%90%E4%B8%8E%E5%AE%9E%E5%81%9A-ServiceLoader%E5%9C%A8SPI%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E4%BD%9C%E7%94%A8%E5%88%86%E6%9E%90/20180423223716178.png" alt="这里写图片描述"><br>所以我们上面的程序的打印结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">driver: class com.mysql.jdbc.Driverloader: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">driver: class com.mysql.fabric.jdbc.FabricMySQLDriverloader: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure>
<p>ServiceLoader是由启动类加载器加载的，为什么mysql的驱动是由系统类加载器加载呢？。。。。下一章介绍这个知识点。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>线程上下文加载器剖析</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（23）线程上下文类加载器实战分析与难点剖析</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8823%EF%BC%89%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%E4%B8%8E%E9%9A%BE%E7%82%B9%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<p>我们紧接着上一个例子的代码进行：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest26 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ServiceLoader&lt;Driver&gt; serviceLoader = ServiceLoader.load(Driver.class);</span><br><span class="line">        Iterator&lt;Driver&gt; iterator = serviceLoader.iterator();</span><br><span class="line"></span><br><span class="line">        while(iterator.hasNext())&#123;</span><br><span class="line">            Driver driver =  iterator.next();</span><br><span class="line">            System.out.println(&quot;driver: &quot;+driver.getClass() + &quot;loader: &quot;+ driver.getClass().getClassLoader() );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;当前线程上下文类加载器: &quot; + Thread.currentThread().getContextClassLoader());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;ServiceLoader的类加载器: &quot;+ServiceLoader.class.getClassLoader());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先MyTest26的类加载器是系统类加载器，<br>程序运行到【**ServiceLoader<Driver> serviceLoader &#x3D; ServiceLoader.load(Driver.class);**】的时候回去加载ServiceLoader，系统类加载器会根据双亲委托模型往上委派，直到最后ServiceLoader被启动类加载器加载，那么我们看一下ServiceLoader.load()方法的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) &#123;</span><br><span class="line">    ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    return ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 既然ServiceLoader是由启动类加载器加载，那么ServiceLoader里边的类都会用启动类加载器去加载，但是呢我们的mysql驱动不在启动类加载器加载的目录下边，我们的mysql驱动位于classpath下边，无法用启动类加载器加载，这个时候，我们可以看到load方法使用了线程上下文加载器，线程上下文加载器默认是系统类加载器<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d6cTY1Nzg3MDIvYXJ0aWNsZS9kZXRhaWxzLzgwMDU4Mjg2">上一节<i class="fa fa-external-link-alt"></i></span>已经介绍过，所以load方法得到的ClassLoader cl是AppClassLoader，然后将cl传递给ServiceLoader.load(service, cl)方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	//加载器的缓存</span><br><span class="line">    // Cached providers, in instantiation order</span><br><span class="line">    private LinkedHashMap&lt;String,S&gt; providers = new LinkedHashMap&lt;&gt;();</span><br><span class="line">    public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service,ClassLoader loader)</span><br><span class="line">    &#123;</span><br><span class="line">    //调用ServiceLoader构造器</span><br><span class="line">        return new ServiceLoader&lt;&gt;(service, loader);</span><br><span class="line">    &#125;</span><br><span class="line">	//ServiceLoader构造器</span><br><span class="line">    private ServiceLoader(Class&lt;S&gt; svc, ClassLoader cl) &#123;</span><br><span class="line">    //判空</span><br><span class="line">        service = Objects.requireNonNull(svc, &quot;Service interface cannot be null&quot;);</span><br><span class="line">        //加载器判空，空的情况是使用系统类加载器</span><br><span class="line">        loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl;</span><br><span class="line">        //安全相关的</span><br><span class="line">        acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null;</span><br><span class="line">        //调用reload，刷新缓存</span><br><span class="line">        reload();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //刷新缓存</span><br><span class="line">    public void reload() &#123;</span><br><span class="line">    //清空缓存</span><br><span class="line">        providers.clear();</span><br><span class="line">        //LazyIterator是ServiceLoader的私有内部类</span><br><span class="line">        lookupIterator = new LazyIterator(service, loader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//LazyIterator 部分代码</span><br><span class="line">// Private inner class implementing fully-lazy provider lookup</span><br><span class="line">//用来实现懒加载方式 的提供者的查找的私有内部类</span><br><span class="line">    private class LazyIterator implements Iterator&lt;S&gt;</span><br><span class="line">    &#123;</span><br><span class="line">       Class&lt;S&gt; service;</span><br><span class="line">        ClassLoader loader;</span><br><span class="line">        Enumeration&lt;URL&gt; configs = null;</span><br><span class="line">        Iterator&lt;String&gt; pending = null;</span><br><span class="line">        String nextName = null;</span><br><span class="line"></span><br><span class="line">        private LazyIterator(Class&lt;S&gt; service, ClassLoader loader) &#123;</span><br><span class="line">            this.service = service;</span><br><span class="line">            this.loader = loader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> private boolean hasNextService() &#123;</span><br><span class="line"> ....</span><br><span class="line"> &#125;</span><br><span class="line">  private S nextService() &#123;</span><br><span class="line">            if (!hasNextService())</span><br><span class="line">                throw new NoSuchElementException();</span><br><span class="line">            String cn = nextName;</span><br><span class="line">            nextName = null;</span><br><span class="line">            Class&lt;?&gt; c = null;</span><br><span class="line">            try &#123;</span><br><span class="line">            //cn相当于java.sql.Drive文件下的某一行的全限定名，false表示不初始化，loader加载器是我们传递进来的线程上下文类加载器</span><br><span class="line">            //（即，系统类加载器或者应用类加载器）</span><br><span class="line">            //Class.forName()方法见之前的介绍：https://blog.csdn.net/wzq6578702/article/details/79950220</span><br><span class="line">                c = Class.forName(cn, false, loader);</span><br><span class="line">            &#125; catch (ClassNotFoundException x) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     &quot;Provider &quot; + cn + &quot; not found&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     &quot;Provider &quot; + cn  + &quot; not a subtype&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                S p = service.cast(c.newInstance());</span><br><span class="line">                providers.put(cn, p);</span><br><span class="line">                return p;</span><br><span class="line">            &#125; catch (Throwable x) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     &quot;Provider &quot; + cn + &quot; could not be instantiated&quot;,</span><br><span class="line">                     x);</span><br><span class="line">            &#125;</span><br><span class="line">            throw new Error();          // This cannot happen</span><br><span class="line">  &#125;</span><br><span class="line">  public boolean hasNext() &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">  public S next() &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到此为止我们看到的程序的打印结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">driver: class com.mysql.jdbc.Driverloader: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">driver: class com.mysql.fabric.jdbc.FabricMySQLDriverloader: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">当前线程上下文类加载器: sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">ServiceLoader的类加载器: null</span><br></pre></td></tr></table></figure>
<p>前2行driver就是java.sql.Drive文件里边的2行，而上下文类加载器是默认的系统类加载器，ServiceLoader属于rt.jar是由启动类加载器加载。</p>
<p>接下来改一下程序成如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest26 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    //添加这行代码</span><br><span class="line">     Thread.currentThread().setContextClassLoader(MyTest26.class.getClassLoader().getParent());</span><br><span class="line">        ServiceLoader&lt;Driver&gt; serviceLoader = ServiceLoader.load(Driver.class);</span><br><span class="line">        Iterator&lt;Driver&gt; iterator = serviceLoader.iterator();</span><br><span class="line"></span><br><span class="line">        while(iterator.hasNext())&#123;</span><br><span class="line">            Driver driver =  iterator.next();</span><br><span class="line">            System.out.println(&quot;driver: &quot;+driver.getClass() + &quot;loader: &quot;+ driver.getClass().getClassLoader() );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;当前线程上下文类加载器: &quot; + Thread.currentThread().getContextClassLoader());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;ServiceLoader的类加载器: &quot;+ServiceLoader.class.getClassLoader());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当前线程上下文类加载器: sun.misc.Launcher$ExtClassLoader@14ae5a5</span><br><span class="line">ServiceLoader的类加载器: null</span><br></pre></td></tr></table></figure>
<p>可以看到循环没有去执行，上下文类加载器是扩展类加载器没啥问题，因为系统类加载器的上级是扩展类加载器，但是为什么循环是空的呢？原因就是扩展类加载器无法加载classpath下边的类，mysql的jar包是放在classpath下边的。<br>其实加上-XX:+TraceClassLoading启动参数，我们可以显式的看到驱动被加载。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>线程上下文类加载器</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（25）Java字节码文件结构剖析</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8825%EF%BC%89Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<p>编写java文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br><span class="line">public class MyTest1 &#123;</span><br><span class="line">    private int a = 1;</span><br><span class="line"></span><br><span class="line">    public int getA() &#123;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setA(int a) &#123;</span><br><span class="line">        this.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我要要看一下java文件对应的class文件的结构，定位到工程的out\production\classes下边执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javap -c com.twodragonlake.jvm.bytecode.MyTest1</span><br></pre></td></tr></table></figure>
<p>得到字节码文件结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Compiled from &quot;MyTest1.java&quot;</span><br><span class="line">public class com.twodragonlake.jvm.bytecode.MyTest1 &#123;</span><br><span class="line">  public com.twodragonlake.jvm.bytecode.MyTest1();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: aload_0</span><br><span class="line">       5: iconst_1</span><br><span class="line">       6: putfield      #2                  // Field a:I</span><br><span class="line">       9: return</span><br><span class="line"></span><br><span class="line">  public int getA();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: getfield      #2                  // Field a:I</span><br><span class="line">       4: ireturn</span><br><span class="line"></span><br><span class="line">  public void setA(int);</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: iload_1</span><br><span class="line">       2: putfield      #2                  // Field a:I</span><br><span class="line">       5: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用 javap -verbose com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest1<br>打印更多信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Classfile /E:/Study/intelIde/jvm_lecture/out/production/classes/com/twodragonlake/jvm/bytecode/MyTest1.class</span><br><span class="line">  Last modified 2018-7-28; size 507 bytes</span><br><span class="line">  MD5 checksum 372d96fd3e5e97ce3e964e7f9e1e2d67</span><br><span class="line">  Compiled from &quot;MyTest1.java&quot;</span><br><span class="line">public class com.twodragonlake.jvm.bytecode.MyTest1</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #3.#21         // com/twodragonlake/jvm/bytecode/MyTest1.a:I</span><br><span class="line">   #3 = Class              #22            // com/twodragonlake/jvm/bytecode/MyTest1</span><br><span class="line">   #4 = Class              #23            // java/lang/Object</span><br><span class="line">   #5 = Utf8               a</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/twodragonlake/jvm/bytecode/MyTest1;</span><br><span class="line">  #14 = Utf8               getA</span><br><span class="line">  #15 = Utf8               ()I</span><br><span class="line">  #16 = Utf8               setA</span><br><span class="line">  #17 = Utf8               (I)V</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               MyTest1.java</span><br><span class="line">  #20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #21 = NameAndType        #5:#6          // a:I</span><br><span class="line">  #22 = Utf8               com/twodragonlake/jvm/bytecode/MyTest1</span><br><span class="line">  #23 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  public com.twodragonlake.jvm.bytecode.MyTest1();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: aload_0</span><br><span class="line">         5: iconst_1</span><br><span class="line">         6: putfield      #2                  // Field a:I</span><br><span class="line">         9: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 26: 0</span><br><span class="line">        line 27: 4</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      10     0  this   Lcom/twodragonlake/jvm/bytecode/MyTest1;</span><br><span class="line"></span><br><span class="line">  public int getA();</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: getfield      #2                  // Field a:I</span><br><span class="line">         4: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 30: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/twodragonlake/jvm/bytecode/MyTest1;</span><br><span class="line"></span><br><span class="line">  public void setA(int);</span><br><span class="line">    descriptor: (I)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=2</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: iload_1</span><br><span class="line">         2: putfield      #2                  // Field a:I</span><br><span class="line">         5: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 34: 0</span><br><span class="line">        line 35: 5</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       6     0  this   Lcom/twodragonlake/jvm/bytecode/MyTest1;</span><br><span class="line">            0       6     1     a   I</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ok，我们也可以使用二进制文件查看器查看class文件的16进制信息（<span class="exturl" data-url="aHR0cDovL3d3dy54LXdheXMubmV0L3dpbmhleC56aXA=">winhex下载<i class="fa fa-external-link-alt"></i></span>）：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8825%EF%BC%89Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%89%96%E6%9E%90/20180728170150241.png" alt="这里写图片描述"><br>16文件查看器里边第一行的CA 就是一个字节的容量（8位bit）。<br><strong>1、javap -verbos</strong><br>使用javap -verbos 命令分析一个字节码文件时，将会分析该字节码文件的魔数、版本号、常量池、类信息、类的构造方法信息、类变量与成员变量等信息。<br><strong>2、魔数：</strong><br>所有的.class字节码文件的前4个字节都是魔数，魔数值为固定值：0xCAFEBABE  (詹姆斯.高斯林设计的，蕴意：咖啡宝贝，java的图标是咖啡，哈哈哈，因缺思厅~~~很有意思的一件事情)。<br><strong>3、版本号</strong><br>魔数之后的4个字节为版本信息，前2个字节表示minor versio（次版本号），后两个字节表示major version（主版本号）。<br>接下来分析剩下的16进制信息的含义。<br>00 00 00 34 ：版本信息，00 00 （前2个字节）代表是次版本号（minor version），00 34 （后2个字节）代表的是主版本号major version，34是16进制，转换为10进制：3*16+4&#x3D;52，52是jdk8，51是jdk7，50是jdk6，以此类推，可以通过java -version命令来验证这一点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ java -version</span><br><span class="line">java version &quot;1.8.0_111&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_111-b14)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.111-b14, mixed mode)</span><br></pre></td></tr></table></figure>
<p>java version “1.8.0_111” 中1.8是主版本号，0是次版本号，111是更新版本号。<br>这个和javap反编译出来的major version是52是对应的。1.7的jdk不能运行1.8编译出来的class文件。低版本不可以兼容高版本的class文件。<br><strong>4、常量池（constant pool）：</strong><br>紧接着版本号之后的就是常量池入口，一个java类中定义的很多信息就是由常量池来维护和描述的，可以将常量池看作是Class文件的资源仓库，比如说java类中定义的方法与变量信息，都是存储在常量池中。常量池中主要存储两类常量：字面量与符号引用。字面量比如文本字符串，java中声明为final的常量等，而符号引用如类和接口的全局限定名，字段的名称和描述符，方法的名称和描述符等。<br><strong>5、常量池的总体结构：</strong><br>java类所对应的常量池主要由常量池数量与常量池数组这2部分共同构成。常量池数量紧跟在主版本号后面，占据2个字节；常量池数组则紧跟在常量池数量之后。常量池数组与一般的数组不同的是，常量池数组中不同的元素的类型、结构都是不同的；但是每一种元素的第一个数据都是一个u1类型，该字节是个标志位，占据1个字节。jvm在解析常量池时，会根据这个ul类型来获取元素的具体类型。<br>ok那么主版本号之后的2个字节是常量池数量，即 00 34 后边的 00 18 是常量池数量18对应的十进制是1*16+8&#x3D;24，所以常量池的数量书24个。<br>但是我们用javap反编译出来的Constant pool是23个，那是因为常量池中元素的个数&#x3D;常量池数 - 1 （其中0暂时不使用），目的是满足某些常量池索引值的数据在特定情况下需要表达【不引用任何一个常量池】的含义；根本原因在于，索引为0也是一个常量（保留常量），只不过他不位于常量表中，这个常量就对应null值；所以，常量池的索引从1而非0开始。<br>那么我看到的16进制文件中 00 18  后边的就是实际的一个个的元素体，每个常量元素的大小都是不一样的，那么每个元素的结构是怎样的呢？<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8825%EF%BC%89Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%89%96%E6%9E%90/20180728182044938.png" alt="这里写图片描述"><br>00 18 后边是第一个常量，第一个字节是标志位：0A（十进制10），十进制10在java字节码表格中对应的是CONSTANT_Methodref_info常量，那么后边的2个字节00 04 （十进制4）就是U2（第一个index），即指向声明方法的类描述符CONSTANT_Class_info的索引项，而第二个索引（第二个index）00 14（十进制20） 指向名称及类型描述符CONSTANT_NameAndType_info的索引项，到此0A 00 04 00 14表示了第一个常量。那么我们借助反编译工具看一下4和20的索引位置时什么：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> #1 = Methodref          #4.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line"> #2 = Fieldref           #3.#21         // com/twodragonlake/jvm/bytecode/MyTest1.a:I</span><br><span class="line"> #3 = Class              #22            // com/twodragonlake/jvm/bytecode/MyTest1</span><br><span class="line"> #4 = Class              #23            // java/lang/Object</span><br><span class="line"> #5 = Utf8               a</span><br><span class="line"> #6 = Utf8               I</span><br><span class="line"> #7 = Utf8               &lt;init&gt;</span><br><span class="line"> #8 = Utf8               ()V</span><br><span class="line"> #9 = Utf8               Code</span><br><span class="line">#10 = Utf8               LineNumberTable</span><br><span class="line">#11 = Utf8               LocalVariableTable</span><br><span class="line">#12 = Utf8               this</span><br><span class="line">#13 = Utf8               Lcom/twodragonlake/jvm/bytecode/MyTest1;</span><br><span class="line">#14 = Utf8               getA</span><br><span class="line">#15 = Utf8               ()I</span><br><span class="line">#16 = Utf8               setA</span><br><span class="line">#17 = Utf8               (I)V</span><br><span class="line">#18 = Utf8               SourceFile</span><br><span class="line">#19 = Utf8               MyTest1.java</span><br><span class="line">#20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">#21 = NameAndType        #5:#6          // a:I</span><br><span class="line">#22 = Utf8               com/twodragonlake/jvm/bytecode/MyTest1</span><br><span class="line">#23 = Utf8               java/lang/Object</span><br></pre></td></tr></table></figure>
<p>4是【 #4 &#x3D; Class              #23            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object】即指向声明方法的类描述符CONSTANT_Class_info的索引项；<br>4引用的是23，23对应的是 java&#x2F;lang&#x2F;Object，<br>20是【#20 &#x3D; NameAndType        #7:#8          &#x2F;&#x2F; “<code>&lt;init&gt;</code>“:()V】 指向名称及类型描述符CONSTANT_NameAndType_info的索引项；<br>20指向的是索引7和8，7是 <code>&lt;init&gt; </code>，8是()V<br>这个和表格里边是一致的。<br>tip：<br><strong>6、数据类型</strong><br>在JVM规范中，每个变量&#x2F;字段都有描述信息，描述信息主要的作用是描述字段的数据类型，方法的参数列表（包括数量、类型与顺序）与返回值。根据描述符规则，基本数据类型和代表无返回值的void类型都用一个大写字符来表示，对象类型则使用字符L加对象的全限名称来表示。为了压缩字节码文件的体积，对于基本数据类型，JVM基本数据类型，JVM都只是使用一个大写字母来表示，如下所示：B - byte, C - char,D - double,F - float,<br>I - int ,J - long S - short,Z - boolean, V - void ,L - 对象类型，如：Ljava&#x2F;lang.String;<br><strong>7、数组</strong><br>对于数组类型来说，每个维度使用一个前置的[来表示，如int[]被记录为[I, String[][]被记录为[[Ljava&#x2F;lang&#x2F;String;<br><strong>8、描述符</strong><br>用描述符描述方法时，按照先参数列表，后返回值的顺序来描述，参数列表按照参数的严格顺序放在一组（）之内，如方法：String getRealNameByIdAndNickName(int id,String name)的描述符为：(I,Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;</p>
<p>接下来是第二个常量：09 00 03   00 15 ，09是标志位对用的是CONSTANT_Fieldref_info,第一个索引指向的是声明字段的类或接口描述符，CONSTANT_Class_info的索引项。<br>第二个索引：指向字段描述符CONSTANT_NameAndType_info 的索引项。<br>00 03十进制是索引3 ，3对应的是【#22            &#x2F;&#x2F; com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest1】，而22对应的是<br>【#22 &#x3D; Utf8               com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest1】<br>00 15十进制是21，21对应的是【 #21 &#x3D; NameAndType        #5:#6          &#x2F;&#x2F; a:I】，索引5对应的是【 #5 &#x3D; Utf8               a】<br>所用6对应的【#6 &#x3D; Utf8               I】所以第二个常量表示为：【 #3.#21         &#x2F;&#x2F; com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest1.a:I】</p>
<p>接下来是第三个常量：07 00 16：<br>00 16 十进制是22 ，07是常量CONSTANT_CLass_info，只有一个index，指向的是指定权限定名常量项的索引， 00 16 是十进制22，22是【 #22 &#x3D; Utf8               com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest1】</p>
<p>接下来是第四个常量：07 00 17 ，07是常量CONSTANT_CLass_info，只有一个index，指向的是指定权限定名常量项的索引，00 17 十进制是23，<br>23指向的是【#23 &#x3D; Utf8               java&#x2F;lang&#x2F;Object】</p>
<p>接下来是第五个常量：01 00 01 … (后边的字节大小受00 01的约束) ，01 是常量CONSTANT_UTF8_Info,U2是length表示UTF-8编码的字符串的长度（占2个字节），<br>然后能是U1，表示bytes，长度是length的UTF-8编码的字符串长度。<br>所以00 01 是占用2个字节的表示bytes的长度， 00 01 的十进制是1，即后边的一个字节是bytes，后边的一个字节是61，61在asc码表里边是a的索引，即<br>01 00 01 61 表示字母a。就是反编译出来的第五个常量：【#5 &#x3D; Utf8               a】。</p>
<p>第六个常量：01 00 01 ，01 是常量CONSTANT_UTF8_Info长度：00 01（十进制1），后边是1个字节是：49，49对应的十进制4*16+9&#x3D;75，75对应的是字母I，<br>所以第六个常量：【#6 &#x3D; Utf8               I】</p>
<p>第七个常量：01 00 06 ，还是常量CONSTANT_UTF8_Info，长度00 06 是6，往后6个字节：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8825%EF%BC%89Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%89%96%E6%9E%90/20180729150017678.png" alt="这里写图片描述"><br>对应的是<code>&lt;init&gt;</code>,即， 【#7 &#x3D; Utf8               <code>&lt;init&gt;</code>】</p>
<p>第八个常量01 00 03 还是是常量CONSTANT_UTF8_Info，长度00 03 是长度3，往后三个字节是：28 29 56 ，对应的是：() V,即常量：<br>【#8 &#x3D; Utf8               ()V】</p>
<p>第九个常量：01 00 04 是是常量CONSTANT_UTF8_Info，长度00 04是4个字节，往后4个字节是：43 6F 64 65 表示：Code，即常量：<br>【#9 &#x3D; Utf8               Code】</p>
<p>第十个常量：01 00 0F:是常量CONSTANT_UTF8_Info,长度是00 0F（十进制15），往后15个字节：4C 69 6E 65 4E 75 6D 62 65 72 54 61 62 6C 65<br>表示LineNumberTable，即常量：【#10 &#x3D; Utf8               LineNumberTable】，</p>
<p>第十一个常量：01 00 12 是常量CONSTANT_UTF8_Info ，长度00 12 （十进制18），往后18个字节是：4C6F63616C5661726961626C655461626C65<br>对应：LocalVariableTable，即常量：【#11 &#x3D; Utf8               LocalVariableTable】</p>
<p>第十二个常量：01 00 04 是常量CONSTANT_UTF8_Info，长度00 04 （十进制4），往后4个字节：74686973 表示字符串“this”，即常量：【#12 &#x3D; Utf8               this】</p>
<p>第十三个常量：01 00 28 是常量CONSTANT_UTF8_Info，长度00 28（十进制40），往后40个字节：4C636F6D2F74776F647261676F6E6C616B652F6A766D2F62797465636F64652F4D7954657374313B 表示字符串Lcom&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest1;<br>即常量：#13 &#x3D; Utf8               Lcom&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest1;</p>
<p>第十四个变量：01 00 04  常量CONSTANT_UTF8_Info，长度00 04 （十进制4），往后4个字节：67657441 表示字符串”getA”。即，常量 【#14 &#x3D; Utf8               getA】</p>
<p>第十五个变量：01 00 03 是常量CONSTANT_UTF8_Info，长度00 03 （十进制3）往后三个字节：28 29 49 表示字符串”()I”，即，常量：【#15 &#x3D; Utf8               ()I】</p>
<p>14号和15号常量表示了一个方法，表示一个方法：方法的名字和方法的描述法，14号常量时方法的名字，15号常量时方法的描述符（没有参数，但是有一个int的返回值）。</p>
<p>第十六个常量: 01 00 04 常量CONSTANT_UTF8_Info，长度00 04 （十进制4），往后4个字节：73 65 74 41 表示字符串：”setA”,即常量：【#16 &#x3D; Utf8<br>       setA】<br>第十七个常量：01 00 04 常量CONSTANT_UTF8_Info，长度00 04 （十进制4），往后4个字节：28 49 29 56 表示字符串”(I)V”，即常量：【#17 &#x3D; Utf8               (I)V】</p>
<p>16和17号常量表示了一个方法：方法名字setA，方法有一个int类型的入参，但是没有返回值。</p>
<p>第十八个常量：01 00 0A  常量CONSTANT_UTF8_Info，长度00 0A （十进制10），往后10个字节：536F7572636546696C65 表示字符串：”SourceFile”，即，常量：【#18 &#x3D; Utf8               SourceFile】</p>
<p>第十九个常量：01 00 0C 常量CONSTANT_UTF8_Info，长度00 0C（十进制12），往后12个字节：4D7954657374312E6A617661 表示字符串：”MyTest1.java”，即常量【#19 &#x3D; Utf8               MyTest1.java】</p>
<p>18号和19号常量表示当前的class文件是由那个源文件编译出来的。</p>
<p>第20个常量：0c 00 07 常量 CONSTANT_NameAndType_info，此常量拥有2个index，第一个index占2个字节：指向该字段或方法名称常量项的索引；第二个index占2个字节：指向该字段或方法描述符常量项的索引，00 07（十进制7，指向7号常量：【#7 &#x3D; Utf8               <code>&lt;init&gt;</code>】 ,第二个index：00 08 (十进制8)，指向的是8号常量：【#8 &#x3D; Utf8               ()V】，因此，20号常量：【#20 &#x3D; NameAndType        #7:#8          &#x2F;&#x2F; <code>&lt;init&gt;</code>:()V】<br>20号常量表示的是无参的构造方法。</p>
<p>第21号常量：0C 00 05 00 06 常量 CONSTANT_NameAndType_info，第一个index：00 05（十进制5）指向5号常量：【#5 &#x3D; Utf8               a】，第二个索引00 06（十进制6）指向的的是6号常量：【#6 &#x3D; Utf8               I】,因此。21号常量：【#21 &#x3D; NameAndType        #5:#6          &#x2F;&#x2F; a:I】</p>
<p>第22个常量：01 00 26 常量CONSTANT_UTF8_Info，长度00 26 （十进制38），往后38个字节：636F6D2F74776F647261676F6E6C616B652F6A766D2F62797465636F64652F4D795465737431 表示字符串：”com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest1”，即，常量：【#22 &#x3D; Utf8               com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest1】</p>
<p>第23个常量：01 00 10 常量CONSTANT_UTF8_Info，长度00 10 （十进制10），往后16个字节：6A6176612F6C616E672F4F626A656374 表示字符串：”java&#x2F;lang&#x2F;Object”，即常量：【#23 &#x3D; Utf8               java&#x2F;lang&#x2F;Object】表示的是MyTest1的父类全量限定名。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java字节码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（24）通过JDBC驱动加载深刻理解线程上下文类加载器机制</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8824%EF%BC%89%E9%80%9A%E8%BF%87JDBC%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>首先写一段加载jdbc驱动的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br><span class="line">public class MyTest27 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        Connection connection = DriverManager.getConnection(&quot;jdbc://localhost:3306/mytestdb&quot;,&quot;username&quot;,&quot;password&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段程序是加载jdbc驱动的惯用写法，第一行代码【 Class.forName(“com.mysql.jdbc.Driver”);】是将mysql的驱动【com.mysql.jdbc.Driver】注册到jdk的DriverManager上边去，我们跟进一下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static Class&lt;?&gt; forName(String className)</span><br><span class="line">            throws ClassNotFoundException &#123;</span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    return forName0(className, true, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这会引起【com.mysql.jdbc.Driver】的主动调用，因此会初始化com.mysql.jdbc.Driver：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123;</span><br><span class="line">    //</span><br><span class="line">    // Register ourselves with the DriverManager</span><br><span class="line">    //</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //将当前mysql的com.mysql.jdbc.Driver 注册到jdk的java.sql.DriverManager里边去</span><br><span class="line">            java.sql.DriverManager.registerDriver(new Driver());</span><br><span class="line">        &#125; catch (SQLException E) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .....略.....</span><br></pre></td></tr></table></figure>
<p>这个时候会引起java.sql.DriverManager的主动调动，导致java.sql.DriverManager初始化（赋予静态变量正确的初始值），因此这个时候java.sql.DriverManager的静态代码块会被执行，我们到java.sql.DriverManager里边看一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DriverManager &#123;</span><br><span class="line">.....略....</span><br><span class="line">    /**</span><br><span class="line">     * Load the initial JDBC drivers by checking the System property</span><br><span class="line">     * jdbc.properties and then use the &#123;@code ServiceLoader&#125; mechanism</span><br><span class="line">     */</span><br><span class="line">    static &#123;</span><br><span class="line">    调用loadInitialDrivers方法，继续往里跟进。</span><br><span class="line">        loadInitialDrivers();</span><br><span class="line">        println(&quot;JDBC DriverManager initialized&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    .....略....</span><br></pre></td></tr></table></figure>
<p>loadInitialDrivers方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  private static void loadInitialDrivers() &#123;</span><br><span class="line">      String drivers;</span><br><span class="line">      try &#123;</span><br><span class="line">      //寻找系统属性jdbc.drivers有没有值，jdbc.drivers是加载jdbc驱动的另一种方式，了解即可</span><br><span class="line">          drivers = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() &#123;</span><br><span class="line">              public String run() &#123;</span><br><span class="line">                  return System.getProperty(&quot;jdbc.drivers&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125; catch (Exception ex) &#123;</span><br><span class="line">          drivers = null;</span><br><span class="line">      &#125;</span><br><span class="line">      // If the driver is packaged as a Service Provider, load it.</span><br><span class="line">      // Get all the drivers through the classloader</span><br><span class="line">      // exposed as a java.sql.Driver.class service.</span><br><span class="line">      // ServiceLoader.load() replaces the sun.misc.Providers()</span><br><span class="line"></span><br><span class="line">      AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">          public Void run() &#123;</span><br><span class="line">		这个地方是我们之前篇章介绍的,将所有java.sql.Driver驱动的实现全部加载。</span><br><span class="line">              ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">              Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line"></span><br><span class="line">              /* Load these drivers, so that they can be instantiated.</span><br><span class="line">               * It may be the case that the driver class may not be there</span><br><span class="line">               * i.e. there may be a packaged driver with the service class</span><br><span class="line">               * as implementation of java.sql.Driver but the actual class</span><br><span class="line">               * may be missing. In that case a java.util.ServiceConfigurationError</span><br><span class="line">               * will be thrown at runtime by the VM trying to locate</span><br><span class="line">               * and load the service.</span><br><span class="line">               *</span><br><span class="line">               * Adding a try catch block to catch those runtime errors</span><br><span class="line">               * if driver not available in classpath but it&#x27;s</span><br><span class="line">               * packaged as service and that service is there in classpath.</span><br><span class="line">               */</span><br><span class="line">              try&#123;</span><br><span class="line">                  while(driversIterator.hasNext()) &#123;</span><br><span class="line">                      driversIterator.next();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; catch(Throwable t) &#123;</span><br><span class="line">              // Do nothing</span><br><span class="line">              &#125;</span><br><span class="line">              return null;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      println(&quot;DriverManager.initialize: jdbc.drivers = &quot; + drivers);</span><br><span class="line">//如果drivers 是空的，直接返回，在当前我们的程序没有配置【jdbc.drivers】在运行的时候到了这里会直接返回。</span><br><span class="line">      if (drivers == null || drivers.equals(&quot;&quot;)) &#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      String[] driversList = drivers.split(&quot;:&quot;);</span><br><span class="line">      println(&quot;number of Drivers:&quot; + driversList.length);</span><br><span class="line">      for (String aDriver : driversList) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">              println(&quot;DriverManager.Initialize: loading &quot; + aDriver);</span><br><span class="line">              Class.forName(aDriver, true,</span><br><span class="line">                      ClassLoader.getSystemClassLoader());</span><br><span class="line">          &#125; catch (Exception ex) &#123;</span><br><span class="line">              println(&quot;DriverManager.Initialize: load failed: &quot; + ex);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>到了这里做了一件事就是讲jdbc驱动进行了加载（并没有初始化），接下来看一下DriverManager 的registerDriver：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static synchronized void registerDriver(java.sql.Driver driver,</span><br><span class="line">        DriverAction da)</span><br><span class="line">    throws SQLException &#123;</span><br><span class="line"></span><br><span class="line">    /* Register the driver if it has not already been added to our list */</span><br><span class="line">    if(driver != null) &#123;</span><br><span class="line">        registeredDrivers.addIfAbsent(new DriverInfo(driver, da));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // This is for compatibility with the original DriverManager</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(&quot;registerDriver: &quot; + driver);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即，将driver封装成DriverInfo放到registeredDrivers里边，registeredDrivers是一个写时复制的集合：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = new CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>到此为止我们的com.mysql.jdbc.Driver放到了一个集合里边了。<br>我们再来看我们的程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">Connection connection = DriverManager.getConnection(&quot;jdbc://localhost:3306/mytestdb&quot;,&quot;username&quot;,&quot;password&quot;);</span><br></pre></td></tr></table></figure>
<p>第一行是加载com.mysql.jdbc.Driver，然而第二行却没有和com.mysql.jdbc.Driver有丝毫的关系，从表面上看，如果是初学者可能会感到很迷惑，我们就进入getConnection方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static Connection getConnection(String url,</span><br><span class="line">      String user, String password) throws SQLException &#123;</span><br><span class="line">      java.util.Properties info = new java.util.Properties();</span><br><span class="line"></span><br><span class="line">      if (user != null) &#123;</span><br><span class="line">          info.put(&quot;user&quot;, user);</span><br><span class="line">      &#125;</span><br><span class="line">      if (password != null) &#123;</span><br><span class="line">          info.put(&quot;password&quot;, password);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>前边是一些判空逻辑，之后调了重载的getConnection,注意第三个参数【Reflection.getCallerClass()】,得到调用者的类，，在我们的程序里边是【com.twodragonlake.jvm.classloader.MyTest27】：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  private static Connection getConnection( String url, java.util.Properties info, Class&lt;?&gt; caller) throws SQLException &#123;</span><br><span class="line">      /*</span><br><span class="line">       * When callerCl is null, we should check the application&#x27;s</span><br><span class="line">       * (which is invoking this class indirectly)</span><br><span class="line">       * classloader, so that the JDBC driver class outside rt.jar</span><br><span class="line">       * can be loaded from here.</span><br><span class="line">       */</span><br><span class="line">       //如果调用者的类加载器不是null，就用调用者的类加载器加载驱动的实现，否则使用当前线程的上下文类加载器，</span><br><span class="line">       //我们的程序得到的callerCL是系统类加载器。因此synchronized里边的if不会进入执行。</span><br><span class="line">      ClassLoader callerCL = caller != null ? caller.getClassLoader() : null;</span><br><span class="line">      synchronized(DriverManager.class) &#123;</span><br><span class="line">          // synchronize loading of the correct classloader.</span><br><span class="line">          if (callerCL == null) &#123;</span><br><span class="line">              callerCL = Thread.currentThread().getContextClassLoader();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if(url == null) &#123;</span><br><span class="line">          throw new SQLException(&quot;The url cannot be null&quot;, &quot;08001&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      println(&quot;DriverManager.getConnection(\&quot;&quot; + url + &quot;\&quot;)&quot;);</span><br><span class="line"></span><br><span class="line">      // Walk through the loaded registeredDrivers attempting to make a connection.</span><br><span class="line">      // Remember the first exception that gets raised so we can reraise it.</span><br><span class="line">      SQLException reason = null;</span><br><span class="line">//registeredDrivers是我们刚刚分析的，将当前classPath下的com.sql.Driver实现类的集合，当前的程序有2个mysql的驱动实现类。</span><br><span class="line">      for(DriverInfo aDriver : registeredDrivers) &#123;</span><br><span class="line">          // If the caller does not have permission to load the driver then</span><br><span class="line">          // skip it.</span><br><span class="line">          //这个方法很重要，我们进去看一下，即callerCL带进去，即将系统类加载器带进去</span><br><span class="line">          if(isDriverAllowed(aDriver.driver, callerCL)) &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                  println(&quot;    trying &quot; + aDriver.driver.getClass().getName());</span><br><span class="line">                  Connection con = aDriver.driver.connect(url, info);</span><br><span class="line">                  //如果某一个连接返回的不是null，证明这个驱动就是我们要的驱动，就可以返回了。</span><br><span class="line">                  if (con != null) &#123;</span><br><span class="line">                      // Success!</span><br><span class="line">                      println(&quot;getConnection returning &quot; + aDriver.driver.getClass().getName());</span><br><span class="line">                      return (con);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; catch (SQLException ex) &#123;</span><br><span class="line">                  if (reason == null) &#123;</span><br><span class="line">                      reason = ex;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              println(&quot;    skipping: &quot; + aDriver.getClass().getName());</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // if we got here nobody could connect.</span><br><span class="line">      if (reason != null)    &#123;</span><br><span class="line">          println(&quot;getConnection failed: &quot; + reason);</span><br><span class="line">          throw reason;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      println(&quot;getConnection: no suitable driver found for &quot;+ url);</span><br><span class="line">      throw new SQLException(&quot;No suitable driver found for &quot;+ url, &quot;08001&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>isDriverAllowed方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> private static boolean isDriverAllowed(Driver driver, ClassLoader classLoader) &#123;</span><br><span class="line">     boolean result = false;</span><br><span class="line">     if(driver != null) &#123;</span><br><span class="line">         Class&lt;?&gt; aClass = null;</span><br><span class="line">         try &#123;</span><br><span class="line">          //在之前分析知道，在com.mysql.jdbc.Driver初始化的时候，调用了DriverManager的注册方法，</span><br><span class="line">          //会加载java.sql.Driver的实现到DriverManager里边的registeredDrivers集合中;</span><br><span class="line">          //在这里又进行了一次加载，但是不同的是进行了初始化。</span><br><span class="line">             aClass =  Class.forName(driver.getClass().getName(), true, classLoader);</span><br><span class="line">         &#125; catch (Exception ex) &#123;</span><br><span class="line">             result = false;</span><br><span class="line">         &#125;</span><br><span class="line">//这行代码是核心，为什么要进行一次&quot;==&quot;判断呢，这主要是为了避免类加载命名空间的问题，即aClass 和 driver.getClass()是由同一个类加载器加载的，</span><br><span class="line">//不同的加载器可能出现的情况是程序里边使用线程上下文加载器设置的加载器去加载（比如设置了用户自定义的加载器），和原始的加载器命名空间不一样。</span><br><span class="line">//之前的文章介绍过，也举过例子，即便是2个名字完全一样的类，由于类加载器不一样后边使用的时候一定会出现CastException</span><br><span class="line">          result = ( aClass == driver.getClass() ) ? true : false;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     return result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>JDBC驱动 线程上下文类加载器</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（26）字节码访问标志与字段表详解</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8826%EF%BC%89%E5%AD%97%E8%8A%82%E7%A0%81%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97%E4%B8%8E%E5%AD%97%E6%AE%B5%E8%A1%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>先看一下java字节码的结构：<br>图1：</p>
<span id="more"></span>
<p><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8826%EF%BC%89%E5%AD%97%E8%8A%82%E7%A0%81%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97%E4%B8%8E%E5%AD%97%E6%AE%B5%E8%A1%A8%E8%AF%A6%E8%A7%A3/20180804134250848.png" alt="这里写图片描述"><br>图2：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8826%EF%BC%89%E5%AD%97%E8%8A%82%E7%A0%81%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97%E4%B8%8E%E5%AD%97%E6%AE%B5%E8%A1%A8%E8%AF%A6%E8%A7%A3/20180804134458717.png" alt="这里写图片描述"><br>图3：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8826%EF%BC%89%E5%AD%97%E8%8A%82%E7%A0%81%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97%E4%B8%8E%E5%AD%97%E6%AE%B5%E8%A1%A8%E8%AF%A6%E8%A7%A3/20180804134805248.png" alt="这里写图片描述"></p>
<ul>
<li><p>Class字节码中有2中数据结构</p>
</li>
<li><p>字节数据直接量：这是基本的数据类型。共细分为u1、u2、u4、u8四种，分别代表连续的1个字节<br>、2个字节、四个字节、8个字节组成的整体数据。</p>
</li>
<li><p>表（数组）：表示由多个基本数据或其他表，按照既定顺序组成的大的数据集合。表是有结构的，<br>   它的结构体现在：组成表的成分所在的位置和顺序都是已经严格定义好的。<br>   图4：<br>   <img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8826%EF%BC%89%E5%AD%97%E8%8A%82%E7%A0%81%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97%E4%B8%8E%E5%AD%97%E6%AE%B5%E8%A1%A8%E8%AF%A6%E8%A7%A3/20180728182044938.png" alt="这里写图片描述"></p>
</li>
<li><p>上面的表中描述了11种数据类型的结构，其实在jdk1.7之后又增加了3种(CONSTANT_Method_info\CONSTANT_Method_Type\CONSTANT_InvokeDynamic_info).<br>这样一共是14种。</p>
</li>
</ul>
<p>Access_Flag访问标志<br>   访问标志信息包括该Class文件是类还是接口，是否被定义成public，是否是abstract，如果是类<br>   是否被声明成final，通过上面的源代码（MyTest1），我们知道该文件是类并且是public。<br>   图5：<br>   <img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8826%EF%BC%89%E5%AD%97%E8%8A%82%E7%A0%81%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97%E4%B8%8E%E5%AD%97%E6%AE%B5%E8%A1%A8%E8%AF%A6%E8%A7%A3/20180804141459924.png" alt="这里写图片描述"><br>那接下来看一下access_flag：<br>图6：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8826%EF%BC%89%E5%AD%97%E8%8A%82%E7%A0%81%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97%E4%B8%8E%E5%AD%97%E6%AE%B5%E8%A1%A8%E8%AF%A6%E8%A7%A3/20180804141952577.png" alt="这里写图片描述"><br>从00 21 开始就是访问修饰符：00 21 我们去图5里边找不到，那是因为00 21是由0x0001|0x0020&#x3D;0x0021得到的，即，java不会穷举所有的访问修饰组合，而是用并集的方式得到的。当前表示我们的MyTest1是一个acc_public和acc_super。<br>然后是this Class Name，也是占据2个字节：00 03（十进制3） ：对应的是常量池里边的3号常量：<br>【#3 &#x3D; Class              #22            &#x2F;&#x2F; com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest1】<br>接下来是父类的名字，占2个字节，00 04 （十进制4），指向的是常量池的4号常量：【#4 &#x3D; Class              #23            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object】<br>接口:当前MyTest1没有实现人很接口，所以说接口的数量是0，即：00 00 所以接口表就不会再出现了。<br>成员变量：由成员变量数量加成员变量表组成。成员变量数量：00 01 （十进制，即一个成员变量），然后是成员变量表：00 02 (十进制2，即常量池的2号常量)：<br>【#2 &#x3D; Fieldref           #3.#21         &#x2F;&#x2F; com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest1.a:I】<br>字段表集合<strong>重点内容</strong><br>字段表用于描述类和接口中声明的变量。<br>这里的字段包含了类级别变量以及实例变量，但是不包括方法内部声明的局部变量。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes</td>
<td>1</td>
</tr>
</tbody></table>
<p>图7：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8826%EF%BC%89%E5%AD%97%E8%8A%82%E7%A0%81%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97%E4%B8%8E%E5%AD%97%E6%AE%B5%E8%A1%A8%E8%AF%A6%E8%A7%A3/20180804145016193.png" alt="这里写图片描述"><br>所以接下里的00 01 表示的就是属性表的数量，此处表示由有一个字段，然后数量之后是访问标示：  00 02 ，00 02 在图5里边没有列出，表示的是私有的private。<br>紧接着是名字的索引和描述符的索引： 00 05 00 06 分别指向的是常量池的:<br>[#5 &#x3D; Utf8               a]<br>[#6 &#x3D; Utf8               I ]<br>然后是attributes_count  ： 00 00 是0个，所以attributes表就不会出现。<br>ok，字段信息，到此梭哈完毕，下一章搞一下方法表。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>字节码访问标识 字段表</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（27）Java字节码方法表与属性表深度剖析</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8827%EF%BC%89Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%B9%E6%B3%95%E8%A1%A8%E4%B8%8E%E5%B1%9E%E6%80%A7%E8%A1%A8%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<p>上一节说到成员变量，这一节说一下方法表<br>图一：</p>
<span id="more"></span>
<p><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8827%EF%BC%89Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%B9%E6%B3%95%E8%A1%A8%E4%B8%8E%E5%B1%9E%E6%80%A7%E8%A1%A8%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/20180804141952577.png" alt="这里写图片描述"><br>图二：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8827%EF%BC%89Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%B9%E6%B3%95%E8%A1%A8%E4%B8%8E%E5%B1%9E%E6%80%A7%E8%A1%A8%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/20180804141459924.png" alt="这里写图片描述"><br>图三：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8827%EF%BC%89Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%B9%E6%B3%95%E8%A1%A8%E4%B8%8E%E5%B1%9E%E6%80%A7%E8%A1%A8%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/20180804163928599.png" alt="这里写图片描述"><br>行号00000120 开始就是方法表的开始，刚开始2个字节是方法的数量：00 03 是三个方法（无参构造器、变量a的get和set方法）<br>方法表：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<p>每一个方法都是这样的一个结构。<br>00 03后边是 access_flags  （00 01）根据图二表示的是public的修饰，name_index:00 07 ，descriptor_index:00 08 在常量池里边是：[ #7 &#x3D; Utf8               <code>&lt;init&gt;</code>] 、[#8 &#x3D; Utf8               ()V] ;<br>然后就是方法的attributes_count 和attributes ：<br>attributes_count :比如方法执行的字节码是什么？方法的行号表是什么？局部变量表是什么？这些信息的sum。<br>attributes_count :00 01 ，方法只有一个属性，但是attribute_info 的结构是什么呢？为此我们需要知道attribute_info 的结构，如下：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8827%EF%BC%89Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%B9%E6%B3%95%E8%A1%A8%E4%B8%8E%E5%B1%9E%E6%80%A7%E8%A1%A8%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/20180804164820491.png" alt="这里写图片描述"><br>attributes_count :00 01  后边的2个字节就是attribute_name_index:00 09(常量池的【#9 &#x3D; Utf8               Code】).<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8827%EF%BC%89Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%B9%E6%B3%95%E8%A1%A8%E4%B8%8E%E5%B1%9E%E6%80%A7%E8%A1%A8%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/20180804170021549.png" alt="这里写图片描述"><br>attributes_length: 00 00 00 38 (十进制56)<br>info:是后面的真正的属性的内容，即方法的字节码。<br><strong>方法的属性结构：</strong><br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8827%EF%BC%89Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%B9%E6%B3%95%E8%A1%A8%E4%B8%8E%E5%B1%9E%E6%80%A7%E8%A1%A8%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/20180812135910932.png" alt="这里写图片描述"></p>
<ul>
<li>JVM预定义了部分attribute，但是编译器自己也可以实现自己的attribute写入class文件<br>里， 供运行时使用。</li>
<li>不同的attribute通过attribute_name_index来区分。</li>
<li>Code结构：<br> code attribute的作用是保存该方法的结构，如所对应的字节码：<br> Code_attribute{<br>    u2 attribute_name_index; &#x2F;&#x2F;00 09<br>    u2 attribute_length;           &#x2F;&#x2F; 00 00 00 38<br>    u2 max_stack;                   &#x2F;&#x2F;00 02<br>    u2 max_locals;                  &#x2F;&#x2F;00 01<br>    u4 code_length;                 &#x2F;&#x2F;00 00 00 0A<br>    u1 code[code_length];<br>    u2 exception_table_length;<br>    {<br>        u2 start_pc;<br>        u2 end_pc;<br>        u2 handler_pc;<br>        u2 catch_type;<br>    } exception_table[exception_table_length];<br>    u2 attributes_count;<br>    attribute_info attributes[attributes_count];<br>  }<br>attribute_length: 表示attribute所包含的字节数，不包含attribute_name_index和attribute_lenght字段。<br>max_stack表示这个方法运行的任何时刻所能达到的操作数栈的最大深度。<br>max_locals表示方法执行运行期间创建的局部变量的数目，包含用来表示传入的参数的局部变量。<br>code_length表示该方法所包含的字节码的字节数以及具体的指令码<br>具体字节码即是该方法被调动时，虚拟机所执行的字节码。<br>code_length是00 00 00 0A（十进制10），往后数10个字节：<br>2AB700012A04B50002B1<br>如图：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8827%EF%BC%89Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%B9%E6%B3%95%E8%A1%A8%E4%B8%8E%E5%B1%9E%E6%80%A7%E8%A1%A8%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/20180812114532838.png" alt="这里写图片描述"><br>这是个字节对应的就是 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2luZ29rZWdlbC9qY2xhc3NsaWIuZ2l0">jclasslib<i class="fa fa-external-link-alt"></i></span>插件反编译的如下信息：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8827%EF%BC%89Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%B9%E6%B3%95%E8%A1%A8%E4%B8%8E%E5%B1%9E%E6%80%A7%E8%A1%A8%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/20180812115005415.png" alt="这里写图片描述"><br>这里边有很多助记词。助记词和16进制编码在jvm里边有已经定义好的映射关系。<br>单击bytecode里边的load0进入oracle的官方网站，load0在<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2U4L2h0bWwvanZtcy02Lmh0bWwjanZtcy02LjUuYWxvYWRfbg==">doc<i class="fa fa-external-link-alt"></i></span>里边对应的是16进制的0x2a，而在我们的class文件里边也是2A 。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aload_0 = 42 (0x2a)</span><br><span class="line">aload_1 = 43 (0x2b)</span><br><span class="line">aload_2 = 44 (0x2c)</span><br><span class="line">aload_3 = 45 (0x2d)</span><br></pre></td></tr></table></figure>
<p>同样的invokespecial 在<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2U4L2h0bWwvanZtcy02Lmh0bWwjanZtcy02LjUuaW52b2tlc3BlY2lhbA==">doc<i class="fa fa-external-link-alt"></i></span>里边对应的是16进制是0xb7</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">invokespecial = 183 (0xb7)</span><br></pre></td></tr></table></figure>
<p>invokespecial 可以简单理解为调用父类的构造方法，invokespecial 是带有参数的，参数就是invokespecial 后边的2个字节描述的信息：00 01 ，而00 01是常量池里边的某个常量，就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1 = Methodref          #4.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br></pre></td></tr></table></figure>
<p> MyTest1的父类是Object，MyTest1构造器会首先调用父类的构造器，这个和我们对Java学习的理解不谋而合。<br> 然后接下来又是 aload_0  ，以及 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2U4L2h0bWwvanZtcy02Lmh0bWwjanZtcy02LjUuaWNvbnN0X2k=">iconst_1<i class="fa fa-external-link-alt"></i></span> 助记词，在doc里边有7个：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iconst_m1 = 2 (0x2)</span><br><span class="line">iconst_0 = 3 (0x3)</span><br><span class="line">iconst_1 = 4 (0x4)</span><br><span class="line">iconst_2 = 5 (0x5)</span><br><span class="line">iconst_3 = 6 (0x6)</span><br><span class="line">iconst_4 = 7 (0x7)</span><br><span class="line">iconst_5 = 8 (0x8)</span><br></pre></td></tr></table></figure>
<p>我们的iconst_1对应的1进制是0x04 。<br>接下来是putfield，它是带参数的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">putfield = 181 (0xb5)</span><br></pre></td></tr></table></figure>
<p>putfield 对应的16进制是0xb5，我们的二进制文件也是0xb5，没有问题，然后B5后边的是putfield 的参数：00 02 ，00 02在常量池里边的是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 = Fieldref   #3.#21         // com/twodragonlake/jvm/bytecode/MyTest1.a:I</span><br></pre></td></tr></table></figure>
<p>putfield 的作用是 Set field in object 即 赋值，给谁赋值？ 给com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest1.a:I  赋值，赋值为多少？就是推到栈顶的上一个助记词iconst_1。<br>之后是 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2U4L2h0bWwvanZtcy02Lmh0bWwjanZtcy02LjUucmV0dXJu">return<i class="fa fa-external-link-alt"></i></span> 助记词：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return = 177 (0xb1)</span><br></pre></td></tr></table></figure>
<p>return 的1进制是B1，我们的class文件当中也是B1。<br>整个init方法完成了对a的赋值。<br>接下来的00 00 是异常表：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8827%EF%BC%89Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%B9%E6%B3%95%E8%A1%A8%E4%B8%8E%E5%B1%9E%E6%80%A7%E8%A1%A8%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/20180812135630658.png" alt="这里写图片描述"><br>由于构造方法没有异常所以是0。<br>exception_table,这里存放的是处理异常的信息<br>每个exception_table表项由start_pc, end_pc,handler_pc,catch_type组成。<br>start_pc h&#x3D;和end_pc表示在code数组中的从start_pc到end_pc处包含start_pc,不包含end_pc)的指令抛出的异常会由这个表项来处理。<br>handler_pc表示处理异常的代码的开始处，catch_type表示会被处理的异常类型，它指向量池里的一个异常类。当catch_type为0时，表示处理所有的异常。<br>然后是u2 attributes_count; 也就是后边的： 00 02 ，意味着构造方法有2个属性，之后的00 0A（十进制10）是属性的索引，在常量池里边是10号常量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#10 = Utf8               LineNumberTable</span><br></pre></td></tr></table></figure>
<p>即，行号表:<br> <strong>附加属性</strong><br> lineNumberTable:这个属性用来表示code数组中的字节码和java代码行数之间的关系。<br> 这个属性可以用来在调试的时候定位代码行的行数。这是属性在调试的时候比较有用，就是抛出异常的代码的行数。<br> LineNumberTable_attribute{<br> u2 attribute_name_index; &#x2F;&#x2F;00 0A<br> u4 attribute_length;           &#x2F;&#x2F; 00 00 00 0A<br> u2 line_number_table_length;  &#x2F;&#x2F; 00 002 表示2个<br> {<br>     u2 start_pc;<br>     u2 line_number;<br> } line_number_table[line_number_table_length]<br> }</p>
<p> attribute_name_index z 是00 0A ，attribute_length是00 00 00 0A ，也即是说往后数10个字节都是attribute的整体，后边的10个字节是：0002 0000 001A 0004 001B 。0002 是长度，既是2个，后边的0000 001A 0004 001B  2个字节是一对，0000  对应 001A（十进制26） ；0004（十进制4） 对应001B(十进制27)  ；<br> <img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8827%EF%BC%89Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%B9%E6%B3%95%E8%A1%A8%E4%B8%8E%E5%B1%9E%E6%80%A7%E8%A1%A8%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/20180812141751730.png" alt="这里写图片描述"><br>接着后边的是00 0B（十进制11） 对应常量池：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#11 = Utf8               LocalVariableTable</span><br></pre></td></tr></table></figure>
<p>即，局部变量表。<br>局部变量表栈的字节的长度：00 00 00 0C（十进制12），即后边的12个字节就是局部变量表的整体，即：0001 0000 000A 000C 000D 0000<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8827%EF%BC%89Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%B9%E6%B3%95%E8%A1%A8%E4%B8%8E%E5%B1%9E%E6%80%A7%E8%A1%A8%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/20180812142445630.png" alt="这里写图片描述"><br>首先0001是局部变量的个数是1 ；<br>0000 是局部变量的开始位置(start PC)；<br>000A 是局部变量的结束位置(length)；<br>000C 是局部变量对应常量池里边的位置是12，即：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#12 = Utf8               this</span><br></pre></td></tr></table></figure>
<p>构造方法为什么会有this？ this，对于实例方法（非static）是默认隐式传递进来的。实例方法至少有一个局部变量，那就是this。<br>000D是对局部变量的一个描述；即：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#13 = Utf8               Lcom/twodragonlake/jvm/bytecode/MyTest1;</span><br></pre></td></tr></table></figure>
<p>0000 是jdk1.6加入的用来做校验检查的，略过。<br>到此init方法解析完毕；<br><strong>剩下的是getA方法</strong>：<br>00 01 是访问修饰符，是public的。<br>00 0E 名字索引， 即：#14 &#x3D; Utf8               getA<br>00 0F 描述符索引，即：#15 &#x3D; Utf8               ()I<br>00 01 是attributes_count，只有一个。<br>接着是 00 09 : 名字的索引 #9 &#x3D; Utf8              Code<br>00 00 00 2F：属性的长度，十进制是47，后边的47个字节是getA方法Code的整体。<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8827%EF%BC%89Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%B9%E6%B3%95%E8%A1%A8%E4%B8%8E%E5%B1%9E%E6%80%A7%E8%A1%A8%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/20180812145301798.png" alt="这里写图片描述"><br>00 00 00 2F 之后是<br>max_stack : 00 01<br>max_locals : 00 01 局部变量的数目 也是1个，既是this。<br>code_length: 00 00 00 05<br>往后数5个字节：<br>2A（aload_0）<br>B4(<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2U4L2h0bWwvanZtcy02Lmh0bWwjanZtcy02LjUuZ2V0ZmllbGQ=">getfield<i class="fa fa-external-link-alt"></i></span>)<br>00 02  常量 ： #2 &#x3D; Fieldref           #3.#21         &#x2F;&#x2F; com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest1.a:I<br>AC <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2U4L2h0bWwvanZtcy02Lmh0bWwjanZtcy02LjUuaXJldHVybg==">ireturn<i class="fa fa-external-link-alt"></i></span>  ireturn是返回一个整型。<br>2AB40002AC 后边的00 00 是异常表，程序没有抛出异常所以是0。<br>00 02 是属性个数有2个。<br>00 0A 第一个属性指向第十个常量。#10 &#x3D; Utf8               LineNumberTable<br>00 00 00 06 属性长度是6<br>0001 0000 001E ：0001  有一个属性：偏移量0，对应源文件的30行。<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8827%EF%BC%89Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%B9%E6%B3%95%E8%A1%A8%E4%B8%8E%E5%B1%9E%E6%80%A7%E8%A1%A8%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/20180812151412282.png" alt="这里写图片描述"><br>然后是局部变量表：00 0B 常量池的 #11 &#x3D; Utf8               LocalVariableTable<br>00 00 00 0C 是局部变量表字节长度是 13个字节。<br>0001 0000 0005 000C 000D 0000<br>0001 有一个局部变量。<br>0000 开始位置0<br>0005  结束位置5<br>000C  局部变量的名字 #12 &#x3D; Utf8               this<br>000D 是局部变量的描述：#13 &#x3D; Utf8               Lcom&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest1;<br>0000 检验码<br> <strong>最后还有一个setA方法：</strong><br> <img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8827%EF%BC%89Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%B9%E6%B3%95%E8%A1%A8%E4%B8%8E%E5%B1%9E%E6%80%A7%E8%A1%A8%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/20180812152918248.png" alt="这里写图片描述"><br> 00 01 是public 描述符<br> 00 10 名字索引 #16 &#x3D; Utf8               setA<br> 00 11 描述符索引 #17 &#x3D; Utf8               (I)V<br> 00 01 有一个属性<br> 00 09 属性是 #9 &#x3D; Utf8               Code<br> 00 00 00 3E 属性的长度 是62<br>  00 00 00 3E 是code的如下信息：<br>  max_stack : 00 02<br>  max_locals  : 00 02 ,00 02 局部变量的数目 也是2个，既是this和int a<br>  code_length :  00 00 00 06 往后数6个字节：<br>  2A 1B B5 00 02 B1<br>  <img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8827%EF%BC%89Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%B9%E6%B3%95%E8%A1%A8%E4%B8%8E%E5%B1%9E%E6%80%A7%E8%A1%A8%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/20180812154221965.png" alt="这里写图片描述"><br>  laload_0  2A<br>  <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2U4L2h0bWwvanZtcy02Lmh0bWwjanZtcy02LjUuaWxvYWRfbg==">iload_1<i class="fa fa-external-link-alt"></i></span>   1B</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iload_0 = 26 (0x1a)</span><br><span class="line">iload_1 = 27 (0x1b)</span><br><span class="line">iload_2 = 28 (0x1c)</span><br><span class="line">iload_3 = 29 (0x1d)</span><br></pre></td></tr></table></figure>
<p>iload_1的参数(给谁赋值)：00 02 【#2 &#x3D; Fieldref           #3.#21         &#x2F;&#x2F; com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest1.a:I】<br>B1 return<br> 2A 1B B5 00 02 B1 后边的 00 00 是异常表的长度为0。<br> 然后00 02 是方法有2个属性:<br> 00 0A  #10 &#x3D; Utf8               LineNumberTable<br> 0000 000A     属性表长度是10个字节。<br> 即：<br> 0002 0000 0022 0005 0023<br> 0002 ： 有2个对应关系、<br> 0000  0022 ： 偏移量0对应 34行。<br> 0005  0023  ： 偏移量5对应 35行。<br> LineNumberTable  结束.<br> 00 0B  #11 &#x3D; Utf8               LocalVariableTable<br> LocalVariableTable:<br> 00 00 00 16  ：长度， 后面32个字节是LocalVariableTable的整体。<br> 00 02 ： 局部变量表有2个。<br> 第一个局部变量：<br> 00 00 ：开始位置<br> 00 06 ： 长度是6<br> 00 0C ： 局部变量名字 #12 &#x3D; Utf8               this<br> 00 0D ：局部变量描述 #13 &#x3D; Utf8               Lcom&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest1;<br> 0000 检验码<br> 第二个局部变量：<br> 0000 开始位置0<br> 00 06 长度是6<br> 00 05 ： 局部变量名字 #5 &#x3D; Utf8               a<br> 00 06： 局部变量描述 #6 &#x3D; Utf8               I<br> 00 01 : 校验码</p>
<p>剩下的数字节码文件的attributes：<br>00 01 是只有一个属性<br>00 12 是第一个属性名字的索引 十进制18 ： #18 &#x3D; Utf8               SourceFile<br>00 00 00 02长度占据2个字节。<br>最后的00 13的就是不1个字节。<br>00 13  是 19 &#x3D; Utf8               MyTest1.java</p>
<p>至此整个class文件解析完毕。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>字节码，方法表</tag>
        <tag>属性表</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（29）构造方法与静态代码块字节码指令详解</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8829%EF%BC%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>上一节解析完了常量池，接下来是<strong>访问标记</strong>，<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8829%EF%BC%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/20180804134250848.png" alt="这里写图片描述"></p>
<span id="more"></span>
<p>00 21 ： ACC_SUPPER + ACC_PUBLIC<br>紧接着是<strong>类的名字</strong>，2个字节：00 05 是5号常量 【#5 &#x3D; Class              #49            &#x2F;&#x2F; com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest2】<br><strong>父类的名字</strong>，占2个字节：00 0D 是13号常量：【#13 &#x3D; Class              #59            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object】<br><strong>接口的信息</strong>：00 00 没有接口。<br><strong>成员变量信息</strong>：00 03 有三个成员变量。<br>第一个字段：<br>访问标记：00 00 为默认访问标记。<br>名字索引：00 0E 是14号常量：【#14 &#x3D; Utf8               str】<br> 描述符索引：00 0F 是15号常量：【#15 &#x3D; Utf8               Ljava&#x2F;lang&#x2F;String;】<br> 字段属性数量：00 00 没有属性<br> 第二个字段：<br> 访问标记：00 02 私有的，private<br> 名字索引：00 10 是16号常量：【#16 &#x3D; Utf8               x】<br> 描述符索引：00 11 是17号常量：【 #17 &#x3D; Utf8               I】<br> 字段属性数量：00 00 没有字段属性<br> 第三个字段：<br>  访问标记：00 09 是public + static<br>  名字索引：00 12是18号常量：【#18 &#x3D; Utf8               in】<br>  描述符索引：00 13 是19号常量：【#19 &#x3D; Utf8               Ljava&#x2F;lang&#x2F;Integer;】<br>  字段属性数量：00 00 没有<br>然后是方法：<br>方法的数量：00 06 是6个方法：<br>init 、 main、setX、test、test2、clinit（静态代码块）<br>第一方法：<br>访问标记：00 01 是public<br>名字索引：00 14 是20号常量：【#20 &#x3D; Utf8               <code>&lt;init&gt;</code>】<br>描述符索引：00 15 是21号常量：【#21 &#x3D; Utf8               ()V】<br>方法属性数量：00 01 包含一个属性<br>第一个属性：<br>属性名字索引：00 16是22号索引：【#22 &#x3D; Utf8               Code】<br>属性长度：00 00  0 42 为66个长度，默认构造方法完成了成员变量的赋值，注意只是对非静态的赋值：</p>
<p>PS：对于字节码文件来说，在方法区的字节码这里可以不包含任何含有初始化构造方法的字节码，很多人认为java代码如果没有默认的构造器，那么java编译器<br>会生成一个没有参数的构造方法，但是这是错误的，字节码规范里边没有要求，方法区必须要有默认的构造方法，java语言规范和jvm规范是不一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0 aload_0</span><br><span class="line"> 1 invokespecial #1 &lt;java/lang/Object.&lt;init&gt;&gt; 调用父类构造器</span><br><span class="line"> 4 aload_0</span><br><span class="line"> 5 ldc #2 &lt;Welcome&gt;  加载字符串Welcome</span><br><span class="line"> 7 putfield #3 &lt;com/twodragonlake/jvm/bytecode/MyTest2.str&gt;  把字符窜Welcome赋值给str变量</span><br><span class="line">10 aload_0</span><br><span class="line">11 iconst_5  加载整数5</span><br><span class="line">12 putfield #4 &lt;com/twodragonlake/jvm/bytecode/MyTest2.x&gt; 把整数5赋值给x变量</span><br><span class="line">15 return  方法返回</span><br></pre></td></tr></table></figure>
<p>如果我们自己声明一个构造方法，是不是也会存在对成员变量的赋值？我们加入一个有参数的构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public MyTest2()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public MyTest2(int i)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8829%EF%BC%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/2018082613275196.png" alt="这里写图片描述"><br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8829%EF%BC%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/20180826132829940.png" alt="这里写图片描述"></p>
<p>可以看到默认的无参构造器和有参数的构造器字节码是一样的，都会对成员变量进行赋值。<br>其他的方法的字节码解析和之前的程序大致相同，不再熬述。<br>着重说一下test方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0 aload_1</span><br><span class="line"> 1 dup</span><br><span class="line"> 2 astore_2</span><br><span class="line"> 3 monitorenter  </span><br><span class="line"> 4 getstatic #10 &lt;java/lang/System.out&gt;</span><br><span class="line"> 7 ldc #11 &lt;hello world&gt;</span><br><span class="line"> 9 invokevirtual #12 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">12 aload_2</span><br><span class="line">13 monitorexit</span><br><span class="line">14 goto 22 (+8)</span><br><span class="line">17 astore_3</span><br><span class="line">18 aload_2</span><br><span class="line">19 monitorexit</span><br><span class="line">20 aload_3</span><br><span class="line">21 athrow</span><br><span class="line">22 return</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2U4L2h0bWwvanZtcy02Lmh0bWwjanZtcy02LjUubW9uaXRvcmVudGVy">monitorenter<i class="fa fa-external-link-alt"></i></span>  是synchronized的监视器加锁的地方，oracle的官方doc：<br><strong>monitorenter</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Operation</span><br><span class="line">Enter monitor for object</span><br><span class="line">进入对象的监视器</span><br><span class="line">Format</span><br><span class="line"></span><br><span class="line">monitorenter</span><br><span class="line">Forms</span><br><span class="line">monitorenter = 194 (0xc2)</span><br><span class="line"></span><br><span class="line">Operand Stack</span><br><span class="line">..., objectref →</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Description</span><br><span class="line">The objectref must be of type reference.</span><br><span class="line">监视的对象必须是引用类型</span><br><span class="line">Each object is associated with a monitor. A monitor is locked if and only if it has an owner.</span><br><span class="line">The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref,</span><br><span class="line"> as follows:</span><br><span class="line">每一个对象都有一个监视器，如果一个monitor 是拥有者那么它就获得了锁，线程获得monitorenter 的使用权遵循下边的过程：</span><br><span class="line">If the entry count of the monitor associated with objectref is zero,</span><br><span class="line">the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.</span><br><span class="line">如果monitor关联对象的进入次数是0，当前线程进入monitor并且设置进入次数是1，那么接下来这个线程就是这个monitor的拥有者。</span><br><span class="line">If the thread already owns the monitor associated with objectref,</span><br><span class="line"> it reenters the monitor, incrementing its entry count.</span><br><span class="line">如果一个线程已经是关联对象的monitor的拥有者，那么线程再次进入monitor，会使得进入次数加1</span><br><span class="line">If another thread already owns the monitor associated with objectref,</span><br><span class="line"> the thread blocks until the monitor&#x27;s entry count is zero, then tries again to gain ownership.</span><br><span class="line">如果另外一个线程已经是关联对象的monitor 的拥有者，那么当前线程会一直阻塞到进入次数为0，才能再次尝试获取monitor 的使用权。</span><br></pre></td></tr></table></figure>

<p><strong>monitorexit</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">monitorexit</span><br><span class="line">Operation</span><br><span class="line">Exit monitor for object</span><br><span class="line">为了退出对象的monitor</span><br><span class="line">Format</span><br><span class="line"></span><br><span class="line">monitorexit</span><br><span class="line">Forms</span><br><span class="line">monitorexit = 195 (0xc3)</span><br><span class="line"></span><br><span class="line">Operand Stack</span><br><span class="line">..., objectref →</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Description</span><br><span class="line">The objectref must be of type reference.</span><br><span class="line">关联的对象必须是引用类型的。</span><br><span class="line">The thread that executes monitorexit must be the owner of the monitor associated with</span><br><span class="line">the instance referenced by objectref.</span><br><span class="line">当前执行monitorexit 的线程必须是关联对象实例对象的引用上的monitor 的拥有者。</span><br><span class="line">The thread decrements the entry count of the monitor associated with objectref.</span><br><span class="line">If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner.</span><br><span class="line">Other threads that are blocking to enter the monitor are allowed to attempt to do so.</span><br><span class="line">当前线程减1个进入次数，正对与关联对象上的monitor 的进入此时，如果减一之后变成0，那么当前线程退出monitor ，</span><br><span class="line">不再是拥有者，其他阻塞的线程此时可以被允许尝试获取拥有权。</span><br></pre></td></tr></table></figure>

<p>回到我们的字节码，看一下clinit 对静态代码块的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 bipush 10</span><br><span class="line">2 invokestatic #8 &lt;java/lang/Integer.valueOf&gt;</span><br><span class="line">5 putstatic #9 &lt;com/twodragonlake/jvm/bytecode/MyTest2.in&gt; 对静态变量in进行赋值</span><br><span class="line">8 return</span><br></pre></td></tr></table></figure>

<p>如果我们加入一个static代码块，那么clinit 会有什么变化？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    System.out.println(&quot;test&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clinit代码块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0 bipush 10</span><br><span class="line"> 2 invokestatic #8 &lt;java/lang/Integer.valueOf&gt;</span><br><span class="line"> 5 putstatic #9 &lt;com/twodragonlake/jvm/bytecode/MyTest2.in&gt;</span><br><span class="line"> 8 getstatic #10 &lt;java/lang/System.out&gt;</span><br><span class="line">11 ldc #13 &lt;test&gt;</span><br><span class="line">13 invokevirtual #12 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">16 return</span><br></pre></td></tr></table></figure>
<p>可以看到静态的代码块的内容被加到了 clinit里边去了，不管有多少个静态代码块 都会合并到clinit里边去。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>静态方法</tag>
        <tag>构造方法</tag>
        <tag>字节码指令</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（2）常量的本质含义与反编译及助记符详解</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%882%EF%BC%89%E5%B8%B8%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%90%AB%E4%B9%89%E4%B8%8E%E5%8F%8D%E7%BC%96%E8%AF%91%E5%8F%8A%E5%8A%A9%E8%AE%B0%E7%AC%A6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>先运行一段程序：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest2 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(MyParent2.str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class MyParent2&#123;</span><br><span class="line">    public static final String  str =  &quot;hello world &quot;;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;MyParent2 static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果就是 ： hello world<br>注意我们在str变量的修饰上加了final修饰符，如果我们不加final修饰符，那么打印的结果会是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyParent2 static block</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>加了final关键字之后str就会变成常量：<br>常量在编译阶段会存入到调用这个常量方法所在的类的常量池中<br>本质上，调用类并没有直接引用到定义常量的类，因此并不会触发定义常量的类的初始化<br>注意：我们指的是将常量存放到了Mytest2的常量池中，之后Mytest2与MyParent2就没有任何关系了<br>甚至：我们可以将MyParent的class文件删除<br>我们可以试验一下：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%882%EF%BC%89%E5%B8%B8%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%90%AB%E4%B9%89%E4%B8%8E%E5%8F%8D%E7%BC%96%E8%AF%91%E5%8F%8A%E5%8A%A9%E8%AE%B0%E7%AC%A6%E8%AF%A6%E8%A7%A3/20180225165758669.png" alt="这里写图片描述"><br>程序照样输出 ，而且不会报错，这就验证了上边的介绍。<br>我们反编译一下Mytest2：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%882%EF%BC%89%E5%B8%B8%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%90%AB%E4%B9%89%E4%B8%8E%E5%8F%8D%E7%BC%96%E8%AF%91%E5%8F%8A%E5%8A%A9%E8%AE%B0%E7%AC%A6%E8%AF%A6%E8%A7%A3/20180225171208887.png" alt="这里写图片描述"><br>出现一个助记符ldc<br>助记符：<br>ldc:表示将int、float、或是String类型的常量从常量池中推送至栈顶。<br>其实还有其他的助记符：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%882%EF%BC%89%E5%B8%B8%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%90%AB%E4%B9%89%E4%B8%8E%E5%8F%8D%E7%BC%96%E8%AF%91%E5%8F%8A%E5%8A%A9%E8%AE%B0%E7%AC%A6%E8%AF%A6%E8%A7%A3/20180225171559932.png" alt="这里写图片描述"><br>bipush:表示将单字节(-128 ~ 127 )的常量推送到栈顶<br>sipush : 表示将一个短整型常量值(-32768 ~ 32767)推送到栈顶<br>iconst_1 表示将int类型1推送到栈顶(iconst_m1 – iconst_5)<br>这些助记符其实可以在jdk的com.sun.org.apache.bcel.internal.generic里边可以看到对用的类，是从apache基金会吸收过来的。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>常量池 助记词</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（30）通过字节码分析this关键字以及异常表的重要作用&amp;通过字节码分析Java异常处理机制</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8830%EF%BC%89%E9%80%9A%E8%BF%87%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90this%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%BC%82%E5%B8%B8%E8%A1%A8%E7%9A%84%E9%87%8D%E8%A6%81%E4%BD%9C%E7%94%A8-%E9%80%9A%E8%BF%87%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><strong>通过字节码分析this关键字以及异常表的重要作用</strong><br>编写代码：</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest3 &#123;</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            InputStream inputStream = new FileInputStream(&quot;test.text&quot;);</span><br><span class="line">            ServerSocket serverSocket = new ServerSocket(6666);</span><br><span class="line">            serverSocket.accept();</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;catch (Exception ex)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            System.out.println(&quot;finally&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=4 (局部变量是4个), args_size=1 (参数大小是1个，即this)</span><br><span class="line">         0: new           #2                  // class java/io/FileInputStream</span><br><span class="line">         3: dup</span><br><span class="line">         4: ldc           #3                  // String test.text</span><br><span class="line">         6: invokespecial #4                  // Method java/io/FileInputStream.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">         9: astore_1</span><br><span class="line">        10: new           #5                  // class java/net/ServerSocket</span><br><span class="line">        13: dup</span><br><span class="line">        14: sipush        6666</span><br><span class="line">        17: invokespecial #6                  // Method java/net/ServerSocket.&quot;&lt;init&gt;&quot;:(I)V</span><br><span class="line">        20: astore_2</span><br><span class="line">        21: aload_2</span><br><span class="line">        22: invokevirtual #7                  // Method java/net/ServerSocket.accept:()Ljava/net/Socket;</span><br><span class="line">        25: pop</span><br><span class="line">        26: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        29: ldc           #9                  // String finally</span><br><span class="line">        31: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        34: goto          92</span><br><span class="line">        37: astore_1</span><br><span class="line">        38: aload_1</span><br><span class="line">        39: invokevirtual #12                 // Method java/io/FileNotFoundException.printStackTrace:()V</span><br><span class="line">        42: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        45: ldc           #9                  // String finally</span><br><span class="line">        47: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        50: goto          92</span><br><span class="line">        53: astore_1</span><br><span class="line">        54: aload_1</span><br><span class="line">        55: invokevirtual #14                 // Method java/io/IOException.printStackTrace:()V</span><br><span class="line">        58: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        61: ldc           #9                  // String finally</span><br><span class="line">        63: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        66: goto          92</span><br><span class="line">        69: astore_1</span><br><span class="line">        70: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        73: ldc           #9                  // String finally</span><br><span class="line">        75: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        78: goto          92</span><br><span class="line">        81: astore_3</span><br><span class="line">        82: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        85: ldc           #9                  // String finally</span><br><span class="line">        87: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        90: aload_3</span><br><span class="line">        91: athrow</span><br><span class="line">        92: return</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             0    26    37   Class java/io/FileNotFoundException</span><br><span class="line">             0    26    53   Class java/io/IOException</span><br><span class="line">             0    26    69   Class java/lang/Exception</span><br><span class="line">             0    26    81   any</span><br><span class="line">            37    42    81   any</span><br><span class="line">            53    58    81   any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 36: 0</span><br><span class="line">        line 37: 10</span><br><span class="line">        line 38: 21</span><br><span class="line">        line 46: 26</span><br><span class="line">        line 47: 34</span><br><span class="line">        line 39: 37</span><br><span class="line">        line 40: 38</span><br><span class="line">        line 46: 42</span><br><span class="line">        line 47: 50</span><br><span class="line">        line 41: 53</span><br><span class="line">        line 42: 54</span><br><span class="line">        line 46: 58</span><br><span class="line">        line 47: 66</span><br><span class="line">        line 43: 69</span><br><span class="line">        line 46: 70</span><br><span class="line">        line 47: 78</span><br><span class="line">        line 46: 81</span><br><span class="line">        line 49: 92</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">           10      16     1 inputStream   Ljava/io/InputStream;</span><br><span class="line">           21       5     2 serverSocket   Ljava/net/ServerSocket;</span><br><span class="line">           38       4     1     e   Ljava/io/FileNotFoundException;</span><br><span class="line">           54       4     1     e   Ljava/io/IOException;</span><br><span class="line">            0      93     0  this   Lcom/twodragonlake/jvm/bytecode/MyTest3;</span><br><span class="line">      StackMapTable: number_of_entries = 5</span><br><span class="line">        frame_type = 101 /* same_locals_1_stack_item */</span><br><span class="line">          stack = [ class java/io/FileNotFoundException ]</span><br><span class="line">        frame_type = 79 /* same_locals_1_stack_item */</span><br><span class="line">          stack = [ class java/io/IOException ]</span><br><span class="line">        frame_type = 79 /* same_locals_1_stack_item */</span><br><span class="line">          stack = [ class java/lang/Exception ]</span><br><span class="line">        frame_type = 75 /* same_locals_1_stack_item */</span><br><span class="line">          stack = [ class java/lang/Throwable ]</span><br><span class="line">        frame_type = 10 /* same */</span><br></pre></td></tr></table></figure>

<p>字节码中args_size&#x3D;1，意思是方法参数个数是1个，但是在源代码当中test的参数是空的，原因是：<br>     * 对于java类中的每一个实例方法(非static方法)。其在编译后所生成的字节码当中，方法参数的数量总是<br>     * 会比源代码中方法参数的数量多一个（多了this），它位于方法的第一个参数位置处；这样，我们就可以在java<br>     * 的实例方法中使用this来去访问当前对象的属性以及其他方法。<br>     *<br>     * 这个操作是在编译期间完成的，既由javac编译器在编译的时候将对this的访问转化为对一个普通实例方法参数的访问；<br>     * 接下来在运行期间，由jvm在调用实例方法时，自动向实例方法传入该this参数，所以，在实例方法的局部变量表中，<br>     * 至少会有一个指向当前对象的局部变量。</p>
<p>  locals&#x3D;4 有四个局部变量：this、inputStream、serverSocket、最后我们有三个catch，那么java在运行的时候如果抛出异常，那么只有一个catch<br>  可以进入，catch上都有一个ex变量，所有说第四个局部变量就是某一个ex。<br>max_stack:<br>表示这个方法运行的任何时刻所能达到的操作数栈的最大深度。<br>max_locals表示方法执行期间创建的局部变量的数目，包含用来表示传入的参数的局部变量。<br>exception_table:表项由start_pc\end_pc&#x2F;handler_pc&#x2F;catch_type组成。<br>start_pc 和 end_pc表示在code数组中的从start_pc到end_pc处（包含start_pc，不包含end_pc）的指令抛出的异常<br>会由这个表项来处理<br>handler_pc表示处理异常的代码的开始处。<br>catch_type表示会被处理的异常类型，他指向常量池里的一个异常类，当catch_type为时，表示处理所有异常。</p>
<p><strong>通过字节码分析Java异常处理机制</strong><br>在jclasslib插件中我们找到test方法的code的字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 new #2 &lt;java/io/FileInputStream&gt;</span><br><span class="line"> 3 dup</span><br><span class="line"> 4 ldc #3 &lt;test.text&gt;</span><br><span class="line"> 6 invokespecial #4 &lt;java/io/FileInputStream.&lt;init&gt;&gt;</span><br><span class="line"> 9 astore_1 //到此是完成 InputStream inputStream = new FileInputStream(&quot;test.text&quot;);</span><br><span class="line">10 new #5 &lt;java/net/ServerSocket&gt;</span><br><span class="line">13 dup</span><br><span class="line">14 sipush 6666</span><br><span class="line">17 invokespecial #6 &lt;java/net/ServerSocket.&lt;init&gt;&gt;</span><br><span class="line">20 astore_2 到此是完成ServerSocket serverSocket = new ServerSocket(6666);</span><br><span class="line">21 aload_2</span><br><span class="line">22 invokevirtual #7 &lt;java/net/ServerSocket.accept&gt;  到此是 serverSocket.accept();</span><br><span class="line">25 pop</span><br><span class="line">26 getstatic #8 &lt;java/lang/System.out&gt;</span><br><span class="line">29 ldc #9 &lt;finally&gt;</span><br><span class="line">31 invokevirtual #10 &lt;java/io/PrintStream.println&gt;  到此是finally块的打印</span><br><span class="line">34 goto 92 (+58)</span><br><span class="line">37 astore_1</span><br><span class="line">38 aload_1</span><br><span class="line">39 invokevirtual #12 &lt;java/io/FileNotFoundException.printStackTrace&gt;</span><br><span class="line">42 getstatic #8 &lt;java/lang/System.out&gt;</span><br><span class="line">45 ldc #9 &lt;finally&gt;</span><br><span class="line">47 invokevirtual #10 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">50 goto 92 (+42)</span><br><span class="line">53 astore_1</span><br><span class="line">54 aload_1</span><br><span class="line">55 invokevirtual #14 &lt;java/io/IOException.printStackTrace&gt;</span><br><span class="line">58 getstatic #8 &lt;java/lang/System.out&gt;</span><br><span class="line">61 ldc #9 &lt;finally&gt;</span><br><span class="line">63 invokevirtual #10 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">66 goto 92 (+26)</span><br><span class="line">69 astore_1</span><br><span class="line">70 getstatic #8 &lt;java/lang/System.out&gt;</span><br><span class="line">73 ldc #9 &lt;finally&gt;</span><br><span class="line">75 invokevirtual #10 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">78 goto 92 (+14)</span><br><span class="line">81 astore_3</span><br><span class="line">82 getstatic #8 &lt;java/lang/System.out&gt;</span><br><span class="line">85 ldc #9 &lt;finally&gt;</span><br><span class="line">87 invokevirtual #10 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">90 aload_3</span><br><span class="line">91 athrow</span><br><span class="line">92 return</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>行开始会看到有很多goto语句，因为程序在运行的时候才会知道到底跳转到那个catch，所以需要提前罗列出所有的跳转的goto语句，当抛出异常的时候match到某个异常，直接goto到某个catch块。</p>
<p>Exception table:</p>
<table>
<thead>
<tr>
<th>Nr.0</th>
<th>start_pc</th>
<th>end_pc</th>
<th>handler_pc</th>
<th>catch_type</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>26</td>
<td>37</td>
<td>cp_info #11 FileNotFoundException</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>26</td>
<td>49</td>
<td>cp_info #13 IOException</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>26</td>
<td>61</td>
<td>cp_info #15 Exception</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>26</td>
<td>73</td>
<td>cp_info #0</td>
</tr>
</tbody></table>
<p>第一条解释：<br>从第0行到26行（不包含26）所有的代码某一行如果出现异常就会被捕捉到如果是FileNotFoundException就会goto到37条handler，37是【37 astore_1】  <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2U4L2h0bWwvanZtcy02Lmh0bWwjanZtcy02LjUuYXN0b3JlX24=">astore_1<i class="fa fa-external-link-alt"></i></span><br>是赋值 操作，发生异常时，会将异常对象赋值给FileNotFoundException e的e，让e指向这个抛出的异常对象。然后就是到了finally块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">42 getstatic #8 &lt;java/lang/System.out&gt;</span><br><span class="line">45 ldc #9 &lt;finally&gt;</span><br><span class="line">47 invokevirtual #10 &lt;java/io/PrintStream.println&gt;</span><br></pre></td></tr></table></figure>
<p>打印输出，然后紧接着是：50 goto 92 (+42) 跳转到92条，92条是【92 return】 也就是程序方法返回。<br>第二条也是同样的道理，只不过是跳转到IOException 的catch的处理，然后也会执行finally块，然后跳转92条是【92 return】 程序返回。</p>
<p>另外编译器还自动生成了一个Any类型的异常，用于处理其他不可预期的异常处理。同样的这个any类型的也会最终执行finally，然后程序方法返回。即：<br>|3	|0	|26	|73|cp_info #0  |</p>
<ul>
<li>java字节码对于异常的处理方式：</li>
<li>1、统一采用异常表的方式对异常进行处理。</li>
<li>2、在jdk1.4.2之前的版本中，并不是使用异常表的方式来对异常进行处理的，而是采用特定的指令方式。</li>
<li>3、当异常处理在finally语句块时，线代的jvm采取的处理方式是将finally语句块的字节码拼接到每一个catch块后面，</li>
<li>换句换说，程序中存在多少个catch块，就会在每一个catch块后面重复多少个finally语句块的字节码。</li>
</ul>
<p><strong>lineNumberTables:</strong><br>java字节码和java源代码的行号对应关系，用于调试。</p>
<p><strong>localVariableTable</strong></p>
<p>| Nr.0 | start_pc |  length |  index  | name |  descriptor  |<br>| —— | —— | —— | —— | —— |<br>| 0	|10	|16	|1	|cp_info #24	|cp_info #25 inputStream|<br>|1  |21	|5  |2	|cp_info #26	|cp_info #27 serverSocket|<br>|2	|0	|85	|0	|cp_info #21	|cp_info #22 this|<br>三个局部变量this、serverSocket、inputStream 另外的ex的赋值，需要在运行时才能看到，此处是静态编译无法看到。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>this关键字</tag>
        <tag>异常表，字节码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（31）栈帧与操作数栈剖析及符号引用与直接引用的转换</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8831%EF%BC%89%E6%A0%88%E5%B8%A7%E4%B8%8E%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E5%89%96%E6%9E%90%E5%8F%8A%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E4%B8%8E%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>修改一下上一节的程序：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest3 &#123;</span><br><span class="line">    public void test() throws FileNotFoundException,IOException,NullPointerException&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            InputStream inputStream = new FileInputStream(&quot;test.text&quot;);</span><br><span class="line">            ServerSocket serverSocket = new ServerSocket(6666);</span><br><span class="line">            serverSocket.accept();</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;catch (Exception ex)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            System.out.println(&quot;finally&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在test方法上加了throws，throws了三个异常，然后我们在打开jclasslib，会发现多了一个Exceptions的项：<br>里边的内容就是我们throws的三个异常，这个和异常表是不同的2个概念，异常表会更复杂一点在字节码当中。<br>0	cp_info #11	java&#x2F;io&#x2F;FileNotFoundException<br>1	cp_info #12	java&#x2F;io&#x2F;IOException<br>2	cp_info #34	java&#x2F;lang&#x2F;NullPointerException</p>
<p><strong>slot</strong><br>在java虚拟机中，每一个线程都对应一个栈帧，所以说这个是线程安全的，对于栈帧来说；对于栈帧我们举例说明：<br>现在要进行3-2&#x3D;1这样一个运算,首先会把3和2压入栈，然后遇到操作符减号的时候，需要将3和2弹出栈，然后进行计算3-2&#x3D;1，得到结果1，然后将结果1压入栈；<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8831%EF%BC%89%E6%A0%88%E5%B8%A7%E4%B8%8E%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E5%89%96%E6%9E%90%E5%8F%8A%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E4%B8%8E%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E7%9A%84%E8%BD%AC%E6%8D%A2/2018090812263571.png" alt="这里写图片描述"><br>途中在栈中的每一个方格就是一个栈帧，一个栈帧就是一个slot，一个栈帧的大小是依据数据类型来定义的，比如int类型的是3为bit，需要一个栈帧，而long类型的是64个bit，需要2个slot，加载long类型的时候需要加载2个slot，slot可以被复用，举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest4 &#123;</span><br><span class="line">     public void test()&#123;</span><br><span class="line">         int a = 3;</span><br><span class="line">         if(a&lt;4)&#123;</span><br><span class="line">             int b = 4;</span><br><span class="line">             int c = 5;</span><br><span class="line">         &#125;</span><br><span class="line">         int d = 7;</span><br><span class="line">         int e = 9;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码有5个局部变量，a,b,c,d,e，其中c和b的作用域是在if里边，if执行完毕他们就会被虚拟机垃圾回收器回收，但是他们在局部变量表里边是不会体现出他们各自的生命周期的，当c和b被回收之后，他们占用的slot可能会被d和e复用，slot就好比一个坑,这个坑你蹲完了，我可以接着用这个肯去蹲。也可能不会去复用，不同虚拟机实现是不同的。</p>
<p>符号引用怎么转换为直接引用：<br>有些符号引用在加载或者第一次使用的时候就会转换为直接引用，这种成为静态的解析；另外一些符号引用则是在每次运行期转换为直接引用，这种转换为动态链接，这体现为java的多态性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Animal a = new Cat();</span><br><span class="line">a.sleep();</span><br><span class="line">a = new Dog();</span><br><span class="line">a = new Tiger();</span><br><span class="line">a.sleep();</span><br></pre></td></tr></table></figure>
<p>在字节码的角度来看a指向的是Animal 的sleep()，不是Cat，不是Dog，也不是Tiger，挡在运行期间，invokevirtual指令会检查a实际指向的对象，然后将a的sleep的调用转换为实际指向对相关的sleep的调用。这里每次调用都会调用invokevirtual指令，</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>贞栈</tag>
        <tag>操作数栈</tag>
        <tag>符号引用</tag>
        <tag>直接引用</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（28）synchronized关键字所生成的字节码详细分析&amp;&amp;复杂字节码文件的分析过程</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8828%EF%BC%89synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E6%89%80%E7%94%9F%E6%88%90%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-%E5%A4%8D%E6%9D%82%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>前边我们解析了一个字节码文件，现在我们做一个比较复杂的字节码文件的解析，程序如下：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.twodragonlake.jvm.bytecode;</span><br><span class="line"></span><br><span class="line">public class MyTest2 &#123;</span><br><span class="line"></span><br><span class="line">    String str = &quot;Welcome&quot;;</span><br><span class="line"></span><br><span class="line">    private int x = 5;</span><br><span class="line"></span><br><span class="line">    public static Integer in = 10;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        MyTest2 myTest2 = new MyTest2();</span><br><span class="line"></span><br><span class="line">        myTest2.setX(8);</span><br><span class="line"></span><br><span class="line">        in = 20;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void setX(int x)&#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意方法setX是私有的，我们这个时候使用javap -verbose 反编译的字节码不会展示私有方法，命令需要加上参数 -p:<br>javap -verbose -p  com.twodragonlake.jvm.bytecode.MyTest2<br>私有的setX出来的字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void setX(int);</span><br><span class="line">  descriptor: (I)V</span><br><span class="line">  flags: ACC_PRIVATE</span><br><span class="line">  Code:</span><br><span class="line">    stack=2, locals=2, args_size=2</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: iload_1</span><br><span class="line">       2: putfield      #4                  // Field x:I</span><br><span class="line">       5: return</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 20: 0</span><br><span class="line">      line 21: 5</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          0       6     0  this   Lcom/twodragonlake/jvm/bytecode/MyTest2;</span><br><span class="line">          0       6     1     x   I</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后我们在setX方法上加上synchronized关键字，反编译结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private synchronized void setX(int);</span><br><span class="line">   descriptor: (I)V</span><br><span class="line">   flags: ACC_PRIVATE, ACC_SYNCHRONIZED</span><br><span class="line">   Code:</span><br><span class="line">     stack=2, locals=2, args_size=2</span><br><span class="line">        0: aload_0</span><br><span class="line">        1: iload_1</span><br><span class="line">        2: putfield      #4                  // Field x:I</span><br><span class="line">        5: return</span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line 20: 0</span><br><span class="line">       line 21: 5</span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           0       6     0  this   Lcom/twodragonlake/jvm/bytecode/MyTest2;</span><br><span class="line">           0       6     1     x   I</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>synchronized 关键字是为了多线程并发加锁，按照正常的套路应该会出现monitorenter和monitorexit但是反编译出来的结果并没有，只是在方法的声明上边加了ACC_SYNCHRONIZED的标记，这种synchronized的使用方式，加在方法上边，默认是对当前对象加锁，还有一种是对代码块加锁，然后指定加锁对象是指定的一个对象，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private  void test(String str)&#123;</span><br><span class="line">    synchronized (str)&#123;</span><br><span class="line">        System.out.println(&quot;hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们反编译之后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void test(java.lang.String);</span><br><span class="line">  descriptor: (Ljava/lang/String;)V</span><br><span class="line">  flags: ACC_PRIVATE</span><br><span class="line">  Code:</span><br><span class="line">    stack=2, locals=4, args_size=2</span><br><span class="line">       0: aload_1</span><br><span class="line">       1: dup</span><br><span class="line">       2: astore_2</span><br><span class="line">       3: monitorenter                      //加锁</span><br><span class="line">       4: getstatic     #10                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       7: ldc           #11                 // String hello world</span><br><span class="line">       9: invokevirtual #12                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      12: aload_2</span><br><span class="line">      13: monitorexit                        //解锁</span><br><span class="line">      14: goto          22</span><br><span class="line">      17: astore_3</span><br><span class="line">      18: aload_2</span><br><span class="line">      19: monitorexit                         //这一行的目的是为了在 程序抛出异常（21: athrow）之前保证正常的释放锁，如果异常不释放锁，</span><br><span class="line">                                              //那么就会陷入混乱</span><br><span class="line">      20: aload_3</span><br><span class="line">      21: athrow                              //抛出异常</span><br><span class="line">      22: return</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           4    14    17   any</span><br><span class="line">          17    20    17   any</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 24: 0</span><br><span class="line">      line 25: 4</span><br><span class="line">      line 26: 12</span><br><span class="line">      line 27: 22</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          0      23     0  this   Lcom/twodragonlake/jvm/bytecode/MyTest2;</span><br><span class="line">          0      23     1   str   Ljava/lang/String;</span><br><span class="line">    StackMapTable: number_of_entries = 2</span><br><span class="line">      frame_type = 255 /* full_frame */</span><br><span class="line">        offset_delta = 17</span><br><span class="line">        locals = [ class com/twodragonlake/jvm/bytecode/MyTest2, class java/lang/String, class java/lang/Object ]</span><br><span class="line">        stack = [ class java/lang/Throwable ]</span><br><span class="line">      frame_type = 250 /* chop */</span><br><span class="line">        offset_delta = 4</span><br></pre></td></tr></table></figure>
<p>这个时候我们想要的monitorenter 和 monitorexit出现了。<br>monitorenter 入口只有一个，但是monitorexit的出口有多个，因为程序异常也会执行monitorexit<br>synchronized  除了修饰实例方法和代码块之外还可以修饰静态方法，修饰静态方法的时候是给Class加锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private synchronized static void tes2()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static synchronized void tes2();</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNCHRONIZED</span><br><span class="line">  Code:</span><br><span class="line">    stack=0, locals=0, args_size=0</span><br><span class="line">       0: return</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 31: 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个时候 只会在方法的标记一下 ACC_SYNCHRONIZED，因为synchronized 属于class上锁。<br>俺么接下来我们就如下的完整的字节码文件进行解析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.twodragonlake.jvm.bytecode;</span><br><span class="line"></span><br><span class="line">public class MyTest2 &#123;</span><br><span class="line"></span><br><span class="line">    String str = &quot;Welcome&quot;;</span><br><span class="line"></span><br><span class="line">    private int x = 5;</span><br><span class="line"></span><br><span class="line">    public static Integer in = 10;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        MyTest2 myTest2 = new MyTest2();</span><br><span class="line"></span><br><span class="line">        myTest2.setX(8);</span><br><span class="line"></span><br><span class="line">        in = 20;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private  synchronized void setX(int x)&#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private  void test(String str)&#123;</span><br><span class="line">        synchronized (str)&#123;</span><br><span class="line">            System.out.println(&quot;hello world&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private synchronized static void tes2()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>拿到反编译的1进制文件：<br>首先是魔数：CAFEBABE<br>版本号+小版本号：00000034<br>常量池2+n个字节 ： 0046 常量个数：70 （实际69个，其中一个是保留的）<br>第一个常量：0A 是10 代表方法引用，00 0D 是第13号常量，00 2D是第45 号常量，最终汇总出来：#13.#45        &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.”<init>“:()V<br>第二个常量：08 是字符串索引，00 2E是46号常量 字符串：welcome。<br>第三个常量： 09 方法引用，00 05 是5号常量【#5 &#x3D; Class              #49            &#x2F;&#x2F; com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest2】；<br> 00 2f 是47号常量：#47 &#x3D; NameAndType        #14:#15        &#x2F;&#x2F; str:Ljava&#x2F;lang&#x2F;String;所以3号常量是：<br> &#x2F;&#x2F; com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest2.str:Ljava&#x2F;lang&#x2F;String;<br> 第四个常量：09 方法引用，00 05 是5号常量【#5 &#x3D; Class              #49            &#x2F;&#x2F; com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest2】; 00 30 是48号常量<br> 【#48 &#x3D; NameAndType        #16:#17        &#x2F;&#x2F; x:I】  ，所以四号常量是：【#5.#48         &#x2F;&#x2F; com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest2.x:I】<br> 第五个常量： 07 是类的引用，00 31  是49号常量 【#49 &#x3D; Utf8               com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest2】；<br> 第六个常量：0A 是方法引用，00 05 是5号常量【#5 &#x3D; Class              #49            &#x2F;&#x2F; com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest2】；<br>  00 2D 是45号常量【#45 &#x3D; NameAndType        #20:#21        &#x2F;&#x2F; <code>&lt;init&gt;</code>:()V】  所以6号常量是：<br>  【#6 &#x3D; Methodref          #5.#45         &#x2F;&#x2F; com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest2.<code>&lt;init&gt;</code>:()V】<br>  第七个常量：0A 是 方法引用 ，00 05 ， 00 32 分别是5号和50号常量： 【#7 &#x3D; Methodref          #5.#50         &#x2F;&#x2F; com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest2.setX:(I)V】<br>  第八个常量：0A 是方法引用，00 33 00 34 分别是51和52号常量：【#8 &#x3D; Methodref          #51.#52        &#x2F;&#x2F; java&#x2F;lang&#x2F;Integer.valueOf:(I)Ljava&#x2F;lang&#x2F;Integer;】<br>  第九个常量：09 是字段引用，00 05 00 35 分别是5号和53号常量：【#9 &#x3D; Fieldref           #5.#53         &#x2F;&#x2F; com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest2.in:Ljava&#x2F;lang&#x2F;Integer;】<br>  第十个常量：09 是字段引用，00 36  00 37 分别是54和55号常量：【#10 &#x3D; Fieldref           #54.#55        &#x2F;&#x2F; java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;】<br>  第十一个常量：08字符串引用，00 38 是56号常量：【 #56 &#x3D; Utf8               hello world】<br>  是十二号常量：0A是方法引用，00 39 和 00 3A分别是57号和58号常量：【#12 &#x3D; Methodref          #57.#58        &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V】<br>第十三号常量：07 是类引用，00 3B是59号常量：【#13 &#x3D; Class              #59            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object】<br>第十四号常量：01 字符串信息，00 03 是三个utf-8字节码长度，73 74 72 是对应的utf编码的 str。<br>第十五号常量：01是字符串引用，00 12 是18个utf-8编码的长度， 4C6A6176612F6C616E672F537472696E673B 是 【Ljava&#x2F;lang&#x2F;String;】字符串<br>第十六号常量：01 是字符串 引用，00 01 是一个长度，78 是字符串x。<br>第十七号常量：01 是字符串，00 01一个长度，49是I。<br>第十八号常量：01 是字符串，00 02是2个长度，69 6E in<br>第十九号常量：01是字符串，00 13 是19个长度，4C6A6176612F6C616E672F496E74656765723B 是Ljava&#x2F;lang&#x2F;Integer;<br>第二十号常量：01 是字符串，00 06是6个长度，3C696E69743E 是 <code>&lt;init&gt;</code><br>第二十一号常量：01 是字符串， 00 03 是三个长度，28 29 56是()V<br>第二十二号常量：01是字符串， 00 04 是4个长度，436F6465 是 Code<br>第二十三号常量：01 是字符串，00 0F是15个长度，4C696E654E756D6265725461626C65 是LineNumberTable<br>第二十四号常量：01是字符串，00 12 是18个长度，4C6F63616C5661726961626C655461626C65  是LocalVariableTable<br>第二十五号常量：01 是字符串，00 04 是四个长度， 74 68 69 73 是字符串：this<br>第二十六号常量：01 是字符串 00 28 是40个长度，4C636F6D2F74776F647261676F6E6C616B652F6A766D2F62797465636F64652F4D7954657374323B 是字符串：Lcom&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest2;<br>第二十七号常量：01是字符串，00 04 是四个长度，6D 61 69 6E是字符串：main<br> 第二十八号常量：01是字符串 ，0016 是38个长度，285B4C6A6176612F6C616E672F537472696E673B2956 是字符串：([Ljava&#x2F;lang&#x2F;String;)V<br> 第二十九号常量：01 是字符串，00 04 是四个长度，61 72 67 73 字符串args<br> 第三十号常量：01是字符串，00 13 是18个长度，5B4C6A6176612F6C616E672F537472696E673B 是字符串[Ljava&#x2F;lang&#x2F;String;<br> 第三十一号常量：01是字符串，00 07是7个长度，6D795465737432 是字符串：myTest2<br> 第三十二号常量：01 是字符串，00 04 是4个长度，73 65 74 58是字符串：setX<br> 第三十三号常量：01是字符串 00 04是4个长度，28 49 29 56 是字符串：(I)V<br> 第三十四 号常量：01是字符串，00 04 是四个长度，74 65 73 74 是字符串：test<br> 第三十五个常量：01 是字符串，00 15 是21个长度，284C6A6176612F6C616E672F537472696E673B2956 是字符串：(Ljava&#x2F;lang&#x2F;String;)V<br> 第三十六常量：01是字符串， 00 0D，是13个长度，537461636B4D61705461626C65  是字符串：StackMapTable<br> 第三十七个常量：07 是类引用信息，00 31 是49号常量【#49 &#x3D; Utf8               com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest2】；<br> 第三十八号常量：07是类信息，00 3C 60号常量 【#38 &#x3D; Class              #60            &#x2F;&#x2F; java&#x2F;lang&#x2F;String】<br> 第三十九号常量：07是类信息，00 3B是59号常量：【 #39 &#x3D; Class              #59            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object】<br> 第四十号常量：07是类信息，00 3D是61号常量【#40 &#x3D; Class              #61            &#x2F;&#x2F; java&#x2F;lang&#x2F;Throwable】<br> 第四十一号常量：01是字符串，00 04 是四个长度，74 65 73 32 是字符串test2<br> 第四十二号常量：01 是字符串，00 08 是8个长度，3C636C696E69743E 是字符串    【<code>&lt;clinit&gt;</code>】<br> 第四十三号常量：01是字符串，00 0A，是10个长度，536F7572636546696C65 是字符串：【SourceFile】<br> 第四十四号常量：01是字符串。00 0C 是12个长度，4D7954657374322E6A617661 是字符串：【MyTest2.java】<br> 第四十五号常量：0C 名称和类型的引用，00 14 是20号常量，00 15 是21号常量：【#20:#21        &#x2F;&#x2F;<code> &quot;&lt;init&gt;&quot;</code>:()V】<br> 第四十六号常量：01是字符串，00 07 是7个长度，57656C636F6D65 是字符串：【Welcome】<br> 第四十七号常量：0C 名称和类型的引用,00 0E 是14号常量，00 0F是15号常量，所以汇总是：【#47 &#x3D; NameAndType        #14:#15        &#x2F;&#x2F; str:Ljava&#x2F;lang&#x2F;String;】<br> 第四十八号常量：0C是名称和类型的引用，00 10 00 11 分别是16和17号常量：【#48 &#x3D; NameAndType        #16:#17        &#x2F;&#x2F; x:I】<br> 第四十九号常量：01 是字符串，00 26是38个长度，636F6D2F74776F647261676F6E6C616B652F6A766D2F62797465636F64652F4D795465737432 是字符串：<br> 【com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;MyTest2】<br> 第五十号常量：0C是名称和类型的引用，00 20 是32号常量，0021是33号常量，汇总：【#50 &#x3D; NameAndType        #32:#33        &#x2F;&#x2F; setX:(I)V】<br> 第五十一号常量：07 类引用信息，00 3E是62号常量：汇总：【#51 &#x3D; Class              #62            &#x2F;&#x2F; java&#x2F;lang&#x2F;Integer】<br> 第五十二号常量：0C是名称和类型的引用， 00 3F是63号常量，00 40是64号常量，汇总：【#52 &#x3D; NameAndType        #63:#64        &#x2F;&#x2F; valueOf:(I)Ljava&#x2F;lang&#x2F;Integer;】<br> 第五十三号常量：0C 是名称和类型的引用，00 12是18号常量，00 13是19号常量，汇总【#53 &#x3D; NameAndType   #18:#19    &#x2F;&#x2F; in:Ljava&#x2F;lang&#x2F;Integer;】<br> 第五十四号常量：07是类引用信息，0041是6号常量：【#54 &#x3D; Class              #65            &#x2F;&#x2F; java&#x2F;lang&#x2F;System】<br> 第五十五号常量：0C 是 名称和类型的引用， 0042 是66号常量，0042 是67号常量汇总；【#55 &#x3D; NameAndType        #66:#67        &#x2F;&#x2F; out:Ljava&#x2F;io&#x2F;PrintStream;】<br> 第五十六号常量：01是字符串，00 0B 是11个长度，68656C6C6F20776F726C64是字符串：【hello world】<br> 第五十七号常量：07 是类引用信息，00 44 是68号常量：【#57 &#x3D; Class              #68            &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream】<br> 第五十八号常量：0C 是 名称和类型的引用，  00 45 是69号常量，00 23是35号常量，汇总：【#58 &#x3D; NameAndType        #69:#35        &#x2F;&#x2F; println:(Ljava&#x2F;lang&#x2F;String;)V】<br> 第五十九号常量：01 是字符串，00 10 是16个长度，6A6176612F6C616E672F4F626A656374 字符串是：【java&#x2F;lang&#x2F;Object】<br> 第六十号常量：01 是字符串，00 10 是1个长度，6A6176612F6C616E672F537472696E67 是字符串 【java&#x2F;lang&#x2F;String】<br> 第六十一号常量：01 是字符串，00 13是35个长度，6A6176612F6C616E672F5468726F7761626C65 是字符串：java&#x2F;lang&#x2F;Throwable<br> 第六十二号常量：01是字符串，00 11 是17个长度，6A6176612F6C616E672F496E7465676572 是字符串：java&#x2F;lang&#x2F;Integer<br> 第六十三号常量：01 是字符串， 00 07是7个长度，76616C75654F66 是字符串：valueOf<br> 第六十四号常量：01时候字符串，00 16是22个长度，2849294C6A6176612F6C616E672F496E74656765723B 是字符串：(I)Ljava&#x2F;lang&#x2F;Integer;<br> 第六十五号常量：01 是字符串，00 10是16个长度，6A6176612F6C616E672F53797374656D是字符串：java&#x2F;lang&#x2F;System<br> 第六十六号常量：01 是字符串，00 03 是三个长度，6F  75 74 是字符串：out<br> 第六十七号常量：01 是字符串， 00 15是21个长度，4C6A6176612F696F2F5072696E7453747265616D3B 是字符串：Ljava&#x2F;io&#x2F;PrintStream;<br> 第六十八号常量：01是字符串，00 13是19个长度，6A6176612F696F2F5072696E7453747265616D 是字符窜：java&#x2F;io&#x2F;PrintStream<br> 第六十九号常量：01是字符串，00 07 是7个长度，7072696E746C6E 是字符串：println<br> 为此常量池到此结束：<br> <img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8828%EF%BC%89synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E6%89%80%E7%94%9F%E6%88%90%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-%E5%A4%8D%E6%9D%82%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/20180825222723769.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>synchronize</tag>
        <tag>字节码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（32）方法重载与invokevirtual字节码指令的关系</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8832%EF%BC%89%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E4%B8%8Einvokevirtual%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<ul>
<li>1、invokeinterface:调用接口中的方法，实际上是在运行期决定的，决定到底调用实现该接口的那个对象的特定方法。4</li>
<li>2、invokestatic : 调用静态方法<span id="more"></span></li>
<li>3、invokespecial: 调用自己的私有方法，构造方法(<init>)以及父类的方法。</li>
<li>4、invokevirtual: 调用虚方法，运行期动态查找的过程。</li>
<li>5、invokedynamic: 动态调用方法。</li>
</ul>
<p><strong>invokestatic</strong><br>写一段调用invokestatic 的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest4 &#123;</span><br><span class="line">    public static void test()&#123;</span><br><span class="line">        System.out.println(&quot;test invoked&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       test();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开jclasslib可以看到main方法会有invokestatic 的调用：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8832%EF%BC%89%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E4%B8%8Einvokevirtual%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%9A%84%E5%85%B3%E7%B3%BB/20180915090702298.png" alt="这里写图片描述"></p>
<p><strong>方法的静态分派（invokevirtual ）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest5 &#123;</span><br><span class="line">   //方法的重载是一种静态的行为，在编译期就可以完全确定。</span><br><span class="line">   public void test(GrandPa grandPa)&#123;</span><br><span class="line">       System.out.println(&quot;grandpa&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void test(Father father)&#123;</span><br><span class="line">       System.out.println(&quot;father&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void test(Son son)&#123;</span><br><span class="line">       System.out.println(&quot;son&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       GrandPa grandPa1 = new Father();</span><br><span class="line">       GrandPa grandPa2 = new Son();</span><br><span class="line">       MyTest5 myTest5 = new MyTest5();</span><br><span class="line">       myTest5.test(grandPa1);</span><br><span class="line">       myTest5.test(grandPa2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class GrandPa&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Father extends GrandPa&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Father&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grandpa</span><br><span class="line">grandpa</span><br></pre></td></tr></table></figure>

<ul>
<li>GrandPa g1 &#x3D; new Father();</li>
<li>以上代码，g1的静态类型是Gandpa，而g1的实际类型（真正指向的类型）是Father。调用test方法的时候会根据g1的静态类型（Gandpa）去寻找重载的具体的方法。</li>
<li>我们可以得出这样的结论：变量的静态类型是不会发生变化的，而变量的实际类型则是可以发生变化的（多态的一种体现），实际类型是在运行期方可确定。<br>看一下main方法的字节码：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 new #7 &lt;com/twodragonlake/jvm/bytecode/Father&gt;</span><br><span class="line">3 dup</span><br><span class="line">4 invokespecial #8 &lt;com/twodragonlake/jvm/bytecode/Father.&lt;init&gt;&gt;</span><br><span class="line">7 astore_1</span><br><span class="line">8 new #9 &lt;com/twodragonlake/jvm/bytecode/Son&gt;</span><br><span class="line">11 dup</span><br><span class="line">12 invokespecial #10 &lt;com/twodragonlake/jvm/bytecode/Son.&lt;init&gt;&gt;</span><br><span class="line">15 astore_2</span><br><span class="line">16 new #11 &lt;com/twodragonlake/jvm/bytecode/MyTest5&gt;</span><br><span class="line">19 dup</span><br><span class="line">20 invokespecial #12 &lt;com/twodragonlake/jvm/bytecode/MyTest5.&lt;init&gt;&gt;</span><br><span class="line">23 astore_3</span><br><span class="line">24 aload_3</span><br><span class="line">25 aload_1</span><br><span class="line">26 invokevirtual #13 &lt;com/twodragonlake/jvm/bytecode/MyTest5.test&gt;</span><br><span class="line">29 aload_3</span><br><span class="line">30 aload_2</span><br><span class="line">31 invokevirtual #13 &lt;com/twodragonlake/jvm/bytecode/MyTest5.test&gt;</span><br><span class="line">34 return</span><br></pre></td></tr></table></figure>
<p>可以看到2个 test方法的调用使用的是invokevirtual 指令。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>方法重载</tag>
        <tag>invokevirtual指令</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（33）通过字节码分析Java方法的静态分派与动态分派机制(invokevirtual 指令)</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8833%EF%BC%89%E9%80%9A%E8%BF%87%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90Java%E6%96%B9%E6%B3%95%E7%9A%84%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%E4%B8%8E%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE%E6%9C%BA%E5%88%B6-invokevirtual-%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>编写代码：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest6 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Fruit apple = new Apple();</span><br><span class="line">        Fruit orange = new Orange();</span><br><span class="line">        apple.test();</span><br><span class="line">        orange.test();</span><br><span class="line"></span><br><span class="line">        apple = new Orange();</span><br><span class="line">        apple.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fruit&#123;</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        System.out.println(&quot;fruit&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Apple extends  Fruit&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        System.out.println(&quot;apple&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Orange extends Fruit&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        System.out.println(&quot;orange&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apple</span><br><span class="line">orange</span><br><span class="line">orange</span><br></pre></td></tr></table></figure>
<p>看一下main方法的字节码指令:</p>
<p> 0 new #2 &lt;com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;Apple&gt;  &#x2F;&#x2F;new指令在堆里边创建一个对象<br> 3 dup  &#x2F;&#x2F;压入栈顶<br> 4 invokespecial #3 &lt;com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;Apple.<code>&lt;init&gt;</code>&gt; &#x2F;&#x2F;invokespecial 指令调用父类的构造器<br> 7 astore_1  &#x2F;&#x2F;返回对象引用赋值给apple<br> 8 new #4 &lt;com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;Orange&gt;<br>11 dup<br>12 invokespecial #5 &lt;com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;Orange.<code>&lt;init&gt;&gt;</code><br>15 astore_2<br>16 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2U4L2h0bWwvanZtcy02Lmh0bWwjanZtcy02LjUuYWxvYWRfbg==">aload_1<i class="fa fa-external-link-alt"></i></span><br>&#x2F;&#x2F;从局部变量加载一个引用 aload1是加载索引为1的引用（apple），局部变量有三个（0：args; 1 :apple ; 2 :orange）<br>17 invokevirtual #6 &lt;com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;Fruit.test&gt; &#x2F;&#x2F;invokevirtual 指令，注意参数是Fruit.test，不是Apple.test<br>20 aload_2 &#x2F;&#x2F;加载引用orange<br>21 invokevirtual #6 &lt;com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;Fruit.test&gt; &#x2F;&#x2F;调用invokevirtual 指令，注意参数是Fruit.test，不是orange.test<br>24 new #4 &lt;com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;Orange&gt;  &#x2F;&#x2F;堆里边创建一个对象<br>27 dup  &#x2F;&#x2F;推到栈顶<br>28 invokespecial #5 &lt;com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;Orange.<code>&lt;init&gt;&gt;</code>  &#x2F;&#x2F;调用对象的构造器<br>31 astore_1  &#x2F;&#x2F;将对应的引用赋值给apple<br>32 aload_1   &#x2F;&#x2F;加载引用apple<br>33 invokevirtual #6 &lt;com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode&#x2F;Fruit.test&gt; &#x2F;&#x2F;invokevirtual 指令，调用引用apple的test，注意参数是Fruit.test，不是apple.test<br>36 return &#x2F;&#x2F;返回</p>
<p>ok，ok~~到现在为止这个程序的在字节码层面我们已经知道是怎么走的了，，还有一个invokevirtual ，在字节码层面指向的是Fruit.test的但是运行的时候是具体事例的方法，这个问题需要解释一下。</p>
<p> invokevirtual 运行期执行的时候首先：<br> 找到操作数栈顶的第一个元素它所指向对象的实际类型，在这个类型里边，然后查找和常量里边Fruit的方法描述符和方法名称都一致的<br> 方法，如果在这个类型下，常量池里边找到了就会返回实际对象方法的直接引用。</p>
<p> 如果找不到，就会按照继承体系由下往上(Apple–&gt;Fruit–&gt;Object)查找，查找匹配的方式就是<br> 上面描述的方式，一直找到位为止。如果一直找不到就会抛出异常。</p>
<p> 比较方法重载（overload）和方法重写（overwrite），我们可以得出这样的结论：<br>  方法重载是静态的，是编译器行为；方法重写是动态的，是运行期行为。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>静态分派</tag>
        <tag>动态分派</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（34）虚方法表与动态分派机制详解</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8834%EF%BC%89%E8%99%9A%E6%96%B9%E6%B3%95%E8%A1%A8%E4%B8%8E%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>编写代码：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest7 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Animal animal = new Animal();</span><br><span class="line">        Animal dog = new Dog();</span><br><span class="line"></span><br><span class="line">        animal.test(&quot;hello&quot;);</span><br><span class="line">        dog.test(new Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal&#123;</span><br><span class="line">    public void test(String str)&#123;</span><br><span class="line">        System.out.println(&quot;animal str&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test(Date date)&#123;</span><br><span class="line">        System.out.println(&quot;animal date&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void test(Date date) &#123;</span><br><span class="line">        System.out.println(&quot;dog date&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void test(String str) &#123;</span><br><span class="line">        System.out.println(&quot;dog str&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">animal str</span><br><span class="line">dog date</span><br></pre></td></tr></table></figure>
<p><strong>方法表：</strong><br>  针对方法调用动态分派的过程，虚拟机会在类的方法区建立一个虚拟方法表的数据结构(virtual method table,vtable),<br> 针对于invokeinterface指令来说，虚拟机会建立一个叫做接口方法表的数据结构(interface method table,itable)</p>
<p>方法表会在类的连接阶段初始化，方法表存储的是该类方法入口的一个映射，比如父类的方法A的索引号是1，方法B的索引号是2。。。<br>如果子类继承了父类，但是某个父类的方法没有被子类重写，那么在子类的方法表里边该方法指向的是父类的方法的入口，子类并不会重新生成一个方法，然后让方法表去指向这个生成的，这样做是没有意义的。还有一点，如果子类重写了父类的方法，那么子类这个被重写的方法的索引和父类的该方法的索引是一致。比如父类<br>A的test方法被子类C重写了，那么子类C的test方法的索引和父类A的test方法的索引都是1（打个比方），这样做的目的是为了快速查找，比如说在子类里边找不到一个方法索引为1的方法，那么jvm会直接去父类查找方法索引为1的方法，不需要重新在父类里边遍历。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>虚方法</tag>
        <tag>动态分配机制</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（35）基于栈的指令集与基于寄存器的指令集详细比对&amp;执行栈指令集实例剖析</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%8835%EF%BC%89%E5%9F%BA%E4%BA%8E%E6%A0%88%E7%9A%84%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E5%9F%BA%E4%BA%8E%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E9%9B%86%E8%AF%A6%E7%BB%86%E6%AF%94%E5%AF%B9&amp;%E6%89%A7%E8%A1%8C%E6%A0%88%E6%8C%87%E4%BB%A4%E9%9B%86%E5%AE%9E%E4%BE%8B%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<h1 id="基于栈的指令集与基于寄存器的指令集详细比对"><a href="#基于栈的指令集与基于寄存器的指令集详细比对" class="headerlink" title="基于栈的指令集与基于寄存器的指令集详细比对"></a>基于栈的指令集与基于寄存器的指令集详细比对</h1><span id="more"></span>

<p> 现代JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</p>
<p> 所谓解释之行，就是通过解释器来读取字节码，遇到相应的指令就去执行该指令。<br> 所谓编译执行，就是通过即时编译器(just in time jit)将字节码转换为本地机器码执行，现代jvm会根据代码热点生成相应的本地机器码。</p>
<p> 执行的方式有基于栈的和基于寄存器的执行方式：<br> 基于栈: 移植性好，java是基于栈的指令集，为了可移植性。由于栈是在内存里边出栈入栈，相比cpu寄存器，速度比较慢。<br> 完成相同的操作，基于栈的指令集要比基于寄存器的指令集所需要的指令数量要多。<br> 基于寄存器: 寄存器和硬件架构绑定在一块，因此移植性不ok，但是执行速度快。基于寄存器的指令集是在寄存器里边执行的，速度很快。<br> 虽然虚拟机可以采取一些优化手段，但总体来说，基于栈的指令集的执行速度要慢一些。</p>
<p> 比如我们要运算2-1，就会有如下的入栈出栈操作：</p>
<ol>
<li>iconst_1 &#x2F;&#x2F;1入栈</li>
<li>iconst_2 &#x2F;&#x2F;2入栈</li>
<li>isub     &#x2F;&#x2F;(1)将栈顶元素出栈，栈顶元素下边的元素出栈;(2)栈顶元素减去栈顶下边的元素;(3)将结果放入栈顶; isub完成了是3个操作。</li>
<li>istore_0 &#x2F;&#x2F;将结果放在slot0处,slot0处可能是一个变量，方法返回的时候，可以把这个变量返回。</li>
</ol>
<p>如果是基于寄存器去运算这个减法，第一步就是把2放到一个寄存器上，然后cpu执行减一，然后把结果直接放在原来的寄存器上。过程很简单。</p>
<h1 id="执行栈指令集实例剖析"><a href="#执行栈指令集实例剖析" class="headerlink" title="执行栈指令集实例剖析"></a>执行栈指令集实例剖析</h1><p>编写一个很简单的程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.twodragonlake.jvm.bytecode;</span><br><span class="line">public class MyTest8 &#123;</span><br><span class="line">    public int myCalulate()&#123;</span><br><span class="line">        int a =1;</span><br><span class="line">        int b =2;</span><br><span class="line">        int c =3;</span><br><span class="line">        int d =4;</span><br><span class="line"></span><br><span class="line">        int result = (a + b - c) * d;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>javap反编译：<br>javap -verbose -p com&#x2F;twodragonlake&#x2F;jvm&#x2F;bytecode.MyTest8</p>
<p>找到myCalulate的字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Code:</span><br><span class="line">  stack=2, locals=6, args_size=1 //栈最大深度是2；栈最大的局部变量是6个；myCalulate方法的参数个数是1个(this)</span><br><span class="line">     0: iconst_1 //将1入栈</span><br><span class="line">     1: istore_1 //将1出栈，然后将1放在slot索引为1的位置的slot上(slot索引为0是this)</span><br><span class="line">     2: iconst_2 //将2入栈</span><br><span class="line">     3: istore_2 //将2出栈，然后将2放到slot索引为2的slot位置上</span><br><span class="line">     4: iconst_3 //将3入栈</span><br><span class="line">     5: istore_3 //将3出栈，然后放在索引为3的slot上</span><br><span class="line">     6: iconst_4 //将4入栈</span><br><span class="line">     7: istore        4  //将4出栈，然后放到索引为4的slot上，注意不是istore_4 因为istore_X最多到istore_3</span><br><span class="line">     目前的状态如下：</span><br><span class="line">         栈                 方法的局部变量表   </span><br><span class="line">     ===========            ==============</span><br><span class="line">     |         |            |     this    |</span><br><span class="line">     -----------            ---------------</span><br><span class="line">     |         |            |      1      |</span><br><span class="line">     -----------            ---------------</span><br><span class="line">                            |      2      |</span><br><span class="line">                            ---------------</span><br><span class="line">                            |      3      |</span><br><span class="line">                            ---------------</span><br><span class="line">                            |      4      |</span><br><span class="line">                            ---------------   </span><br><span class="line">                            |             |</span><br><span class="line">                            ---------------                             </span><br><span class="line"></span><br><span class="line">     9: iload_1 //将局部变量表索引为1的元素的值，推到栈顶</span><br><span class="line">    10: iload_2 //将局部变量表索引为2的元素的值，推到栈顶</span><br><span class="line">     目前的状态如下：</span><br><span class="line">    栈                 方法的局部变量表   </span><br><span class="line">===========            ==============</span><br><span class="line">|    2    |            |     this    |</span><br><span class="line">-----------            ---------------</span><br><span class="line">|    1    |            |      1      | 已入栈</span><br><span class="line">-----------            ---------------</span><br><span class="line">                       |      2      | 已入栈</span><br><span class="line">                       ---------------</span><br><span class="line">                       |      3      |</span><br><span class="line">                       ---------------</span><br><span class="line">                       |      4      |</span><br><span class="line">                       ---------------   </span><br><span class="line">                       |             |</span><br><span class="line">                       ---------------  </span><br><span class="line"></span><br><span class="line">    11: iadd //将2和1弹出栈，然后相加（2+1=3），得到结果3，将三压入栈顶</span><br><span class="line">    栈                 方法的局部变量表   </span><br><span class="line">===========            ==============</span><br><span class="line">|         |            |     this    |</span><br><span class="line">-----------            ---------------</span><br><span class="line">|    3    |            |      1      | 已入栈</span><br><span class="line">-----------            ---------------</span><br><span class="line">                       |      2      | 已入栈</span><br><span class="line">                       ---------------</span><br><span class="line">                       |      3      |</span><br><span class="line">                       ---------------</span><br><span class="line">                       |      4      |</span><br><span class="line">                       ---------------   </span><br><span class="line">                       |             |</span><br><span class="line">                       ---------------  </span><br><span class="line"></span><br><span class="line">    12: iload_3 //将局部变量表索引为3的位置的元素推送到栈顶</span><br><span class="line">    栈                 方法的局部变量表   </span><br><span class="line">===========            ==============</span><br><span class="line">|    3    |            |     this    |</span><br><span class="line">-----------            ---------------</span><br><span class="line">|    3    |            |      1      | 已入栈</span><br><span class="line">-----------            ---------------</span><br><span class="line">                       |      2      | 已入栈</span><br><span class="line">                       ---------------</span><br><span class="line">                       |      3      | 已入栈</span><br><span class="line">                       ---------------</span><br><span class="line">                       |      4      |</span><br><span class="line">                       ---------------   </span><br><span class="line">                       |             |</span><br><span class="line">                       ---------------  </span><br><span class="line">    13: isub    //将栈顶元素弹出，相减（3-3=0），得到结果推送到栈顶</span><br><span class="line">    栈                 方法的局部变量表   </span><br><span class="line">===========            ==============</span><br><span class="line">|    0    |            |     this    |</span><br><span class="line">-----------            ---------------</span><br><span class="line">|         |            |      1      | 已入栈</span><br><span class="line">-----------            ---------------</span><br><span class="line">                       |      2      | 已入栈</span><br><span class="line">                       ---------------</span><br><span class="line">                       |      3      | 已入栈</span><br><span class="line">                       ---------------</span><br><span class="line">                       |      4      |</span><br><span class="line">                       ---------------   </span><br><span class="line">                       |             |</span><br><span class="line">                       ---------------</span><br><span class="line">    14: iload         4 //将局部变量表索引为4的变量的值推送到栈顶</span><br><span class="line">    栈                 方法的局部变量表   </span><br><span class="line">===========            ==============</span><br><span class="line">|    4    |            |     this    |</span><br><span class="line">-----------            ---------------</span><br><span class="line">|    0    |            |      1      | 已入栈</span><br><span class="line">-----------            ---------------</span><br><span class="line">                       |      2      | 已入栈</span><br><span class="line">                       ---------------</span><br><span class="line">                       |      3      | 已入栈</span><br><span class="line">                       ---------------</span><br><span class="line">                       |      4      | 已入栈</span><br><span class="line">                       ---------------   </span><br><span class="line">                       |             |</span><br><span class="line">                       ---------------</span><br><span class="line">    16: imul //栈顶2个元素弹出，执行乘法（0*4=0），得到的结果推送到栈顶</span><br><span class="line">    栈                 方法的局部变量表   </span><br><span class="line">===========            ==============</span><br><span class="line">|    0    |            |     this    |</span><br><span class="line">-----------            ---------------</span><br><span class="line">|         |            |      1      | 已入栈</span><br><span class="line">-----------            ---------------</span><br><span class="line">                       |      2      | 已入栈</span><br><span class="line">                       ---------------</span><br><span class="line">                       |      3      | 已入栈</span><br><span class="line">                       ---------------</span><br><span class="line">                       |      4      | 已入栈</span><br><span class="line">                       ---------------   </span><br><span class="line">                       |             |</span><br><span class="line">                       ---------------</span><br><span class="line">    17: istore        5  //栈顶元素出栈，然后将索引为5的slot的设置的值为栈顶元素。就是局部变量表5的位置赋值为栈顶元素</span><br><span class="line">    栈                 方法的局部变量表   </span><br><span class="line">===========            ==============</span><br><span class="line">|         |            |     this    |</span><br><span class="line">-----------            ---------------</span><br><span class="line">|         |            |      1      | 已入栈</span><br><span class="line">-----------            ---------------</span><br><span class="line">                       |      2      | 已入栈</span><br><span class="line">                       ---------------</span><br><span class="line">                       |      3      | 已入栈</span><br><span class="line">                       ---------------</span><br><span class="line">                       |      4      | 已入栈</span><br><span class="line">                       ---------------   </span><br><span class="line">                       |      0      |</span><br><span class="line">                       ---------------</span><br><span class="line">    19: iload         5  //将局部变量表5的位置推送到栈顶</span><br><span class="line">    栈                 方法的局部变量表   </span><br><span class="line">===========            ==============</span><br><span class="line">|    0    |            |     this    |</span><br><span class="line">-----------            ---------------</span><br><span class="line">|         |            |      1      | 已入栈</span><br><span class="line">-----------            ---------------</span><br><span class="line">                       |      2      | 已入栈</span><br><span class="line">                       ---------------</span><br><span class="line">                       |      3      | 已入栈</span><br><span class="line">                       ---------------</span><br><span class="line">                       |      4      | 已入栈</span><br><span class="line">                       ---------------   </span><br><span class="line">                       |      0      | 已入栈</span><br><span class="line">                       ---------------</span><br><span class="line">    21: ireturn  //方法将栈顶元素返回</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="iconst"><a href="#iconst" class="headerlink" title="iconst"></a>iconst</h2><p>第一个指令是iconst_1，我们到oracle的官方网站看一下他的说明：<br><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2U4L2h0bWwvanZtcy02Lmh0bWwjanZtcy02LjUuaWNvbnN0X2k=">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.iconst_i<i class="fa fa-external-link-alt"></i></span></p>
<p>iconst_<i><br>Operation<br>Push int constant<br>将一个常量入栈<br>Format<br>iconst_<i><br>Forms<br>iconst_m1 &#x3D; 2 (0x2) &#x2F;&#x2F;-1入栈<br>iconst_0 &#x3D; 3 (0x3)  &#x2F;&#x2F;0入栈<br>iconst_1 &#x3D; 4 (0x4)  &#x2F;&#x2F;….<br>iconst_2 &#x3D; 5 (0x5)<br>iconst_3 &#x3D; 6 (0x6)<br>iconst_4 &#x3D; 7 (0x7)<br>iconst_5 &#x3D; 8 (0x8)</p>
<p>Operand Stack<br>… →</p>
<p>…, <i></p>
<p>Description<br>Push the int constant <i> (-1, 0, 1, 2, 3, 4 or 5) onto the operand stack.<br>将(-1, 0, 1, 2, 3, 4 or 5)压入到栈顶</p>
<p>Notes<br>Each of this family of instructions is equivalent to bipush <i> for the respective value of <i>, except that the operand <i> is implicit.<br>每个指令等价于bipush <i>， <i>就等于iconst后边的数字，只不过操作数是隐式的。</p>
<h2 id="istore"><a href="#istore" class="headerlink" title="istore"></a>istore</h2><p>istore指令，<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2U4L2h0bWwvanZtcy02Lmh0bWwjanZtcy02LjUuaXN0b3JlX24=">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.istore_n<i class="fa fa-external-link-alt"></i></span><br>Operation<br>Store int into local variable<br>将一个整数村存储到一个变量里边</p>
<p>Format<br>istore_<n></p>
<p>Forms<br>istore_0 &#x3D; 59 (0x3b)<br>istore_1 &#x3D; 60 (0x3c)<br>istore_2 &#x3D; 61 (0x3d)<br>istore_3 &#x3D; 62 (0x3e)</p>
<p>Operand Stack<br>…, value →</p>
<p>…</p>
<p>Description<br>The <n> must be an index into the local variable array of the current frame (§2.6). The value on the top of the operand stack must be of type int. It is popped from the operand stack, and the value of the local variable at <n> is set to value.<br>n 必须是局部变量表里边的一个索引，操作数栈的栈顶元素必须是整数类型，弹出栈顶元素，将这个元素放在局部变量n的位置</p>
<p>Notes<br>Each of the istore_<n> instructions is the same as istore with an index of <n>, except that the operand <n> is implicit.<br>每个istore_<n>等价于 istore指令 带上一个索引n，只不过n是隐式的。</p>
<h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2U4L2h0bWwvanZtcy02Lmh0bWwjanZtcy02LjUuaXN0b3Jl">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.istore<i class="fa fa-external-link-alt"></i></span><br>Operation<br>Store int into local variable<br>将一个整型放到局部变量里边<br>Format</p>
<p>istore<br>index</p>
<p>Forms<br>istore &#x3D; 54 (0x36)</p>
<p>Operand Stack<br>…, value →</p>
<p>…</p>
<p>Description<br>The index is an unsigned byte that must be an index into the local variable array of the current frame (§2.6). The value on the top of the operand stack must be of type int. It is popped from the operand stack, and the value of the local variable at index is set to value.</p>
<p>index必须是无符号（0–255）的，并且存在于局部变量表里边的一个索引，值是栈帧的顶部的元素，必须是整型的，将栈的顶部元素设置到局部变量表索引为index的位置。</p>
<p>Notes<br>The istore opcode can be used in conjunction with the wide instruction (§wide) to access a local variable using a two-byte unsigned index.</p>
<h2 id="iload"><a href="#iload" class="headerlink" title="iload"></a>iload</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2U4L2h0bWwvanZtcy02Lmh0bWwjanZtcy02LjUuaWxvYWRfbg==">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.iload_n<i class="fa fa-external-link-alt"></i></span></p>
<p>Operation<br>Load int from local variable<br>从局部变量表加载一个整型数据<br>Format<br>iload_<n></p>
<p>Forms<br>iload_0 &#x3D; 26 (0x1a)<br>iload_1 &#x3D; 27 (0x1b)<br>iload_2 &#x3D; 28 (0x1c)<br>iload_3 &#x3D; 29 (0x1d)</p>
<p>Operand Stack<br>… →</p>
<p>…, value</p>
<p>Description<br>The <n> must be an index into the local variable array of the current frame (§2.6). The local variable at <n> must contain an int. The value of the local variable at <n> is pushed onto the operand stack.<br>n必须是局部变量表的一个索引，值是一个整型类型，将索引n处的值push到栈顶<br>Notes<br>Each of the iload_<n> instructions is the same as iload with an index of <n>, except that the operand <n> is implicit.<br>每个iload_<n>指令等价于 iload 跟上一个参数n，只不过iload_<n>的n是隐式的。</p>
<h2 id="iadd"><a href="#iadd" class="headerlink" title="iadd"></a>iadd</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2U4L2h0bWwvanZtcy02Lmh0bWwjanZtcy02LjUuaWFkZA==">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.iadd<i class="fa fa-external-link-alt"></i></span></p>
<p>Operation<br>Add int<br>整数相加<br>Format<br>iadd<br>Forms</p>
<p>iadd &#x3D; 96 (0x60)</p>
<p>Operand Stack<br>…, value1, value2 →</p>
<p>…, result</p>
<p>Description<br>Both value1 and value2 must be of type int. The values are popped from the operand stack. The int result is value1 + value2. The result is pushed onto the operand stack.</p>
<p>The result is the 32 low-order bits of the true mathematical result in a sufficiently wide two’s-complement format, represented as a value of type int. If overflow occurs, then the sign of the result may not be the same as the sign of the mathematical sum of the two values.</p>
<p>Despite the fact that overflow may occur, execution of an iadd instruction never throws a run-time exception.</p>
<p>value1和value2必须是整型的，这些整数来自于操作数栈，即从操作数栈弹出来，整型的结果是value1加value2，然后将结果推送到栈顶。</p>
<p>结果是底位排序的整型类型，如果相加之后溢出，那么得到的结果不是数学意义上的结果，尽管会有溢出的可能，但是即使溢出了，也不会抛出运行时异常</p>
<h2 id="ireturn"><a href="#ireturn" class="headerlink" title="ireturn"></a>ireturn</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2U4L2h0bWwvanZtcy02Lmh0bWwjanZtcy02LjUuaXJldHVybg==">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.ireturn<i class="fa fa-external-link-alt"></i></span></p>
<p>Operation<br>Return int from method<br>方法返回<br>Format</p>
<p>ireturn<br>Forms<br>ireturn &#x3D; 172 (0xac)</p>
<p>Operand Stack<br>…, value →</p>
<p>[empty]</p>
<p>Description<br>The current method must have return type boolean, byte, short, char, or int. The value must be of type int. If the current method is a synchronized method, the monitor entered or reentered on invocation of the method is updated and possibly exited as if by execution of a monitorexit instruction (§monitorexit) in the current thread. If no exception is thrown, value is popped from the operand stack of the current frame (§2.6) and pushed onto the operand stack of the frame of the invoker. Any other values on the operand stack of the current method are discarded.<br>当前方法必须返回一个Boolean、 byte, short, char, 或者 int的类型的值，如果方法是synchronized修饰的，那么进入monitor或者冲进入monitor，之后会有monitorexit就会方法退出，如果没有异常，返回值就是栈顶弹出的元素，返回的元素在调用者的栈帧里边会被推送到栈顶，当前方法的栈帧里边的其他所有元素都会被丢弃掉。</p>
<p>The interpreter then returns control to the invoker of the method, reinstating the frame of the invoker.</p>
<p>Run-time Exceptions<br>If the Java Virtual Machine implementation does not enforce the rules on structured locking described in §2.11.10, then if the current method is a synchronized method and the current thread is not the owner of the monitor entered or reentered on invocation of the method, ireturn throws an IllegalMonitorStateException. This can happen, for example, if a synchronized method contains a monitorexit instruction, but no monitorenter instruction, on the object on which the method is synchronized.</p>
<p>Otherwise, if the Java Virtual Machine implementation enforces the rules on structured locking described in §2.11.10 and if the first of those rules is violated during invocation of the current method, then ireturn throws an IllegalMonitorStateException.</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>指令集</tag>
        <tag>栈</tag>
        <tag>寄存器</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（36）透过字节码生成审视Java动态代理运作机制</title>
    <url>/2018/10/05/jvm%E5%8E%9F%E7%90%86%EF%BC%8836%EF%BC%89%E9%80%8F%E8%BF%87%E5%AD%97%E8%8A%82%E7%A0%81%E7%94%9F%E6%88%90%E5%AE%A1%E8%A7%86Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%BF%90%E4%BD%9C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>我们在使用spring这类框架的时候，基于动态代理的使用，比如AOP，会使得开发更加灵活，那么在字节码的层面动态代理是什么样子的呢，生成出来的代理类结构是什么，本次我们首先写一个动态代理的例子，然后得到生成的动态代理类。<br>定义接口：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface SubJect &#123;</span><br><span class="line">    void request();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义实现类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class RealSubJect implements SubJect &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        System.out.println(&quot;method calling&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义动态代理类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DynamicSubject implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    private Object sub;</span><br><span class="line"></span><br><span class="line">    public DynamicSubject(Object obj)&#123;</span><br><span class="line">        this.sub = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;befor method call&quot;);</span><br><span class="line">        method.invoke(sub,args);</span><br><span class="line">        System.out.println(&quot;after method call&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        RealSubJect realSubJect = new RealSubJect();</span><br><span class="line">        InvocationHandler invocationHandler = new DynamicSubject(realSubJect);</span><br><span class="line">        SubJect subJect = (SubJect) Proxy.newProxyInstance(realSubJect.getClass().getClassLoader(),realSubJect.getClass().getInterfaces(),invocationHandler);</span><br><span class="line">        subJect.request();</span><br><span class="line">        System.out.println(subJect.getClass());//打印动态代理类的class</span><br><span class="line">        System.out.println(subJect.getClass().getSuperclass()); //打印父类</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行客户端得到结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">befor method call</span><br><span class="line">method calling</span><br><span class="line">after method call</span><br><span class="line">class com.sun.proxy.$Proxy0</span><br><span class="line">class java.lang.reflect.Proxy</span><br></pre></td></tr></table></figure>

<p>那么这个com.sun.proxy.$Proxy0是怎么出来的呢，这个需要进入到Proxy.newProxyInstance()里边看一下他的逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Proxy.newProxyInstance()</span><br><span class="line">  --&gt;getProxyClass0()</span><br><span class="line">     --&gt;proxyClassCache.get()[通过ProxyClassFactory获取]</span><br><span class="line">        --&gt;WeakCache.Factory.get()</span><br><span class="line">          --&gt;valueFactory.apply(key, parameter)</span><br><span class="line">             --&gt;Proxy.apply()</span><br><span class="line">               --&gt;byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</span><br><span class="line">                  --&gt;byte[] proxyClassFile = ProxyGenerator.generateClassFile();</span><br></pre></td></tr></table></figure>
<p>ProxyGenerator是 sun.misc包里边的，我们得到的代码是ide反编译的结果，我们贴出来，var4是生成出来的字节数组，然后<br>saveGeneratedFiles是一个开关，如果为true就会把class文件输出到磁盘</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static byte[] generateProxyClass(final String var0, Class&lt;?&gt;[] var1, int var2) &#123;</span><br><span class="line">    ProxyGenerator var3 = new ProxyGenerator(var0, var1, var2);</span><br><span class="line">    final byte[] var4 = var3.generateClassFile();//返回最终的字节数组</span><br><span class="line">    if (saveGeneratedFiles) &#123;</span><br><span class="line">        AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">            public Void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    int var1 = var0.lastIndexOf(46);</span><br><span class="line">                    Path var2;</span><br><span class="line">                    if (var1 &gt; 0) &#123;</span><br><span class="line">                        Path var3 = Paths.get(var0.substring(0, var1).replace(&#x27;.&#x27;, File.separatorChar));</span><br><span class="line">                        Files.createDirectories(var3);</span><br><span class="line">                        var2 = var3.resolve(var0.substring(var1 + 1, var0.length()) + &quot;.class&quot;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        var2 = Paths.get(var0 + &quot;.class&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Files.write(var2, var4, new OpenOption[0]);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125; catch (IOException var4x) &#123;</span><br><span class="line">                    throw new InternalError(&quot;I/O exception saving generated file: &quot; + var4x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return var4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>saveGeneratedFiles的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static final boolean saveGeneratedFiles =</span><br><span class="line">((Boolean)AccessController.doPrivileged(new GetBooleanAction(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;))).booleanValue();</span><br></pre></td></tr></table></figure>
<p>ok 我们设置一下sun.misc.ProxyGenerator.saveGeneratedFiles就可以得到class文件。下边这行代码放在Client main方法的第一行，提前设置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;,&quot;true&quot;);</span><br></pre></td></tr></table></figure>
<p>运行Client,然后在我们的工程里边就会出现一个目录<br>com.sun.proxy.$Proxy0<br>这个就是动态代理类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.sun.proxy;</span><br><span class="line"></span><br><span class="line">import com.twodragonlake.jvm.bytecode.SubJect;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line">public final class $Proxy0 extends Proxy implements SubJect &#123;</span><br><span class="line">    private static Method m1;</span><br><span class="line">    private static Method m2;</span><br><span class="line">    private static Method m3;</span><br><span class="line">    private static Method m0;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    构造方法</span><br><span class="line">    这个构造方法在Proxy类的newProxyInstance方法里边，有一个地方是获取代理类的构造器：</span><br><span class="line">     Class&lt;?&gt; cl = getProxyClass0(loader, intfs); //代理类</span><br><span class="line">     final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);//获取代理类的构造器</span><br><span class="line">     return cons.newInstance(new Object[]&#123;h&#125;);//实例化代理类；</span><br><span class="line">     h是InvocationHandler，InvocationHandler是我们定义的DynamicSubject的接口，这个时候就会调用当前的这个构造方法</span><br><span class="line">     动态代理类的父类Proxy持有InvocationHandler的引用，完成这个引用的赋值。</span><br><span class="line">    */</span><br><span class="line">    public $Proxy0(InvocationHandler var1) throws  &#123;</span><br><span class="line">        super(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object var1) throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          /**</span><br><span class="line">            调用Proxy的InvocationHandler的invoke方法，其实就是调用DynamicSubject的invoke方法，</span><br><span class="line">            因为DynamicSubject实现了InvocationHandler，m1是Object类的equals方法，new Object[]&#123;var1&#125;是equals的方法参数</span><br><span class="line">            如果DynamicSubject重新了equals方法就会转发到DynamicSubject的equals方法，否则就是调用Object的equals方法</span><br><span class="line">          */</span><br><span class="line">            return ((Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;)).booleanValue();</span><br><span class="line">        &#125; catch (RuntimeException | Error var3) &#123;</span><br><span class="line">            throw var3;</span><br><span class="line">        &#125; catch (Throwable var4) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    和equals方法道理了一样</span><br><span class="line">    */</span><br><span class="line">    public final String toString() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (String)super.h.invoke(this, m2, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void request() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, m3, (Object[])null);</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    和equals方法道理了一样</span><br><span class="line">    */</span><br><span class="line">    public final int hashCode() throws  &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue();</span><br><span class="line">        &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125; catch (Throwable var3) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          //类加载的时候，将Object类的是个方法拿出来</span><br><span class="line">            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));</span><br><span class="line">            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;);</span><br><span class="line">            m3 = Class.forName(&quot;com.twodragonlake.jvm.bytecode.SubJect&quot;).getMethod(&quot;request&quot;);</span><br><span class="line">            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;);</span><br><span class="line">        &#125; catch (NoSuchMethodException var2) &#123;</span><br><span class="line">            throw new NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; catch (ClassNotFoundException var3) &#123;</span><br><span class="line">            throw new NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了equals、toString、hashCode的其他的Object的方法，都不会得到代理类的转发，原来是什么样子的，代理后也还是什么样子的，不会发生变化。<br>好，到目前为止我们分析了动态代理类的源码，那回到client的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SubJect subJect = (SubJect) Proxy.newProxyInstance(realSubJect.getClass().getClassLoader(),realSubJect.getClass().getInterfaces(),invocationHandler);</span><br></pre></td></tr></table></figure>
<p>subJect返回的是一个动态代理类，这个类的名字是$Proxy0，$Proxy0的父类是Proxy，父类持有InvocationHandler的引用，也就是持有DynamicSubject的引用，同时$Proxy0实现了SubJect接口，$Proxy0里边生成了DynamicSubject里边所声明的方法，并且转发到了DynamicSubject里边。当我们调用subJect.request();<br>的时候就是调用了$Proxy0.request();$Proxy0将方法的调用通过父类Proxy持有的InvocationHandler的引用，即【super.h.invoke(this, m0, (Object[])null))】进行了转发，转发到DynamicSubject的invoke方法。所以说DynamicSubject的invoke方法的第一个参数是proxy，接下里就会打印：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">befor method call</span><br><span class="line">method calling</span><br><span class="line">after method call</span><br></pre></td></tr></table></figure>
<p>动态代理的优势：<br>代理对象可以在没有真实对象不存在的情况下提前生成代理对象，代理对象可以代理多种真实对象，而且jdk的动态代理是面向接口的。<br> cglib：<br> 面向继承的代理，子类可以重写父类的实现，同时代理类可以调用父类的方法（jdk动态代理没有这个优势，因为jdk动态代理是面向接口的）</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
        <tag>字节码</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（37）JVM内存空间划分与作用详解</title>
    <url>/2018/10/13/jvm%E5%8E%9F%E7%90%86%EF%BC%8837%EF%BC%89JVM%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86%E4%B8%8E%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>JVM内存区域分了如下几个区域：</p>
<h1 id="虚拟机栈-Stack-Frame"><a href="#虚拟机栈-Stack-Frame" class="headerlink" title="虚拟机栈(Stack Frame)"></a>虚拟机栈(Stack Frame)</h1><span id="more"></span>
<p>在执行一个方法的时候，会有一个栈帧，用来存储，方法里边的操作数的出栈入栈，当java文件编译完成的时候，max_stack(栈最大的深度),max_local(最大局部变量表有多少个元素)等都是确定的。</p>
<h1 id="程序计数器-Program-Counter"><a href="#程序计数器-Program-Counter" class="headerlink" title="程序计数器(Program Counter)"></a>程序计数器(Program Counter)</h1><p>记录方法执行的位置，线程切换回来之后继续从这个位置执行。</p>
<h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><p>主要执行本地方法，native 方法</p>
<h1 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆(Heap)"></a>堆(Heap)</h1><p>所有进程共享的。<br>我们子啊操作对象的时候，是使用引用的方式去操作对象的，引用放在栈帧里边，对象放在堆里边。<br>那么引用指向的对象在对里边存储有一下2种方式：<br><img src="/2018/10/13/jvm%E5%8E%9F%E7%90%86%EF%BC%8837%EF%BC%89JVM%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86%E4%B8%8E%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3/2018101301.png" alt="都是指针"><br><img src="/2018/10/13/jvm%E5%8E%9F%E7%90%86%EF%BC%8837%EF%BC%89JVM%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86%E4%B8%8E%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3/2018101302.png" alt="一半是对象数据，一半类型指针"></p>
<h2 id="都是指针"><a href="#都是指针" class="headerlink" title="都是指针"></a>都是指针</h2><p>栈指向堆里边的那块区域分成2部分，每一部分都是存储的一个指针。一个指针指向实际的对象数据，另一个指向<br>元数据区的class数据。</p>
<h2 id="一半是对象数据，一半类型指针"><a href="#一半是对象数据，一半类型指针" class="headerlink" title="一半是对象数据，一半类型指针"></a>一半是对象数据，一半类型指针</h2><p>栈指向堆里边的那块区域分成2部分，一部分直接就是存储的对象数据。另一部分是一个指针，指向元数据区的类，也就是class数据。</p>
<p>和堆相关的是垃圾收集器，垃圾收集器目前最常用的收集算法是分代收集算法，所以堆空间也会根据这一点进行划分：新生代，老年代。<br>Eden空间、From Survivor空间、To survivor空间，java的堆空间既可以是连续存放的，也可以是不连续存放的，大部分情况是不连续的。</p>
<p>oracle的hospot用的是一半是对象数据，一半数类型指针这种方式。<br>为什么采用这种方式？<br>在堆里边很对对象都会因为垃圾收集算法，对象地址也伴随着移动，这种对象的移动是很频繁的，如果用第一种方式<br>每次对象的移动，对象的地址就会发生变化，那么指向它的指针也要跟着变化，这样是很繁琐的，而第二种栈里边指向的区域，第一部分就是直接是对象的数据，而第二部分是class的数据，class的数据一般不会发生变化。这样就相对于第一种方式减少了指针地址变化的次数。</p>
<h1 id="方法区-Method-area"><a href="#方法区-Method-area" class="headerlink" title="方法区(Method area)"></a>方法区(Method area)</h1><p>存储元信息，class对象，常量等<br>永久代(Permanent Genaration)和方法区不是完全等价的，jdk1.8开始彻底去掉了永久代，jdk8使用元空间(meta space)</p>
<h1 id="运行时的常量池"><a href="#运行时的常量池" class="headerlink" title="运行时的常量池"></a>运行时的常量池</h1><p>是方法区的一部分，存放常量，就是class字节码的常量池。</p>
<h1 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h1><p>不是jvm管理的内存区域，DirectBuffer申请的，这部分内存是os管理。与java NIO密切相关，jvm是通过堆上的DirectByteBuffer来操作直接内存。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm内存划分</tag>
        <tag>虚拟机栈</tag>
        <tag>程序计数器</tag>
        <tag>堆</tag>
        <tag>方法区</tag>
        <tag>运行时的常量池</tag>
        <tag>直接内存</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（38）JVM堆空间用途分析与划分依据</title>
    <url>/2019/04/13/jvm%E5%8E%9F%E7%90%86%EF%BC%8838%EF%BC%89Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8E%9F%E7%90%86%E4%B8%8E%E5%B8%83%E5%B1%80%E4%BB%A5%E5%8F%8Ajvisualvm%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="关于java对象创建的过程："><a href="#关于java对象创建的过程：" class="headerlink" title="关于java对象创建的过程："></a>关于java对象创建的过程：</h3><span id="more"></span>
<p>new 关键字创建对象的三个步骤：</p>
<ul>
<li>在堆内存中创建出对象的实例。</li>
<li>为对象的实例成员变量赋初值。</li>
<li>将对象的引用返回。</li>
</ul>
<h4 id="指针碰撞"><a href="#指针碰撞" class="headerlink" title="指针碰撞"></a>指针碰撞</h4><p>  在堆里边，内存分为2部分，一部分是被占用的，另一部分是未占用的，他们各自都是连续的，我们在未被占用的区域创建对象后，指针就会向下移动，<br>  这就是指针碰撞(前提是堆空间通过一个指针进行分割，一侧是已经被占用的空间，另一侧是未被占用的空间)</p>
<h4 id="空闲列表"><a href="#空闲列表" class="headerlink" title="空闲列表"></a>空闲列表</h4><p>  堆内存里边的空间不是连续的，占用和未被占用的空间都掺杂在一起，这个时候虚拟机会维护一个空闲区域的列表，记录空闲区域的地址以及他的容量，以及那些空间是已经使用的，<br>  然后给对象分配内存的时候会从维护的列表里边找一个能容纳对象的一个区域把对象放进去，这就是空闲链表(前提是堆内存空间中已被使用与未被使用的空间交叉在一起的，这是，虚拟机<br>  就需要通过一个列表记录那些空间是可以使用的，那些空间是已经被使用的，接下来找出可以容纳下新创建对象的且未被使用的空间，在此空间存放该对象，同时还要<br>  修改该列表上的记录)</p>
<h4 id="对象在内存中的布局："><a href="#对象在内存中的布局：" class="headerlink" title="对象在内存中的布局："></a>对象在内存中的布局：</h4><p>  1 . 对象头<br>  2. 实例数据(即我们在一个类中所声明的各项信息)<br>  3. 对齐填充(可选)</p>
<h4 id="引用访问对象的方式："><a href="#引用访问对象的方式：" class="headerlink" title="引用访问对象的方式："></a>引用访问对象的方式：</h4><ol>
<li>使用句柄的方式。</li>
<li>使用直接指针的方式。</li>
</ol>
<h4 id="实战："><a href="#实战：" class="headerlink" title="实战："></a>实战：</h4><p>设置-Xms5m -Xmx5m -XX:+HeapDumpOnOutOfMemoryError然后run。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest1 &#123;</span><br><span class="line">    //-Xms5m -Xmx5m -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;MyTest1&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        for(;;)&#123;</span><br><span class="line">            list.add(new MyTest1());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class="line">Dumping heap to java_pid6640.hprof ...</span><br><span class="line">Heap dump file created [8974002 bytes in 0.029 secs]</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class="line">	at com.twodragonlake.jvm.memory.MyTest1.main(MyTest1.java:94)</span><br></pre></td></tr></table></figure>

<p>OutOfMemoryError的继承体系：<br>public class OutOfMemoryError extends VirtualMachineError</p>
<p>abstract public class VirtualMachineError extends Error<br>可以看到OutOfMemoryError是一个错误，出现这种问题都是大问题，虚拟机直接就挂掉了。</p>
<h4 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h4><p>打开之后选择：文件–》装入，选择刚才dump出来的文件。<br><img src="/2019/04/13/jvm%E5%8E%9F%E7%90%86%EF%BC%8838%EF%BC%89Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8E%9F%E7%90%86%E4%B8%8E%E5%B8%83%E5%B1%80%E4%BB%A5%E5%8F%8Ajvisualvm%E4%BD%BF%E7%94%A8/jvisualvm.png" alt="jvisualvm"></p>
<p>可以看到内存溢出的对象数很多：<br><img src="/2019/04/13/jvm%E5%8E%9F%E7%90%86%EF%BC%8838%EF%BC%89Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8E%9F%E7%90%86%E4%B8%8E%E5%B8%83%E5%B1%80%E4%BB%A5%E5%8F%8Ajvisualvm%E4%BD%BF%E7%94%A8/jvisualvm1.png" alt="jvisualvm"></p>
<p><img src="/2019/04/13/jvm%E5%8E%9F%E7%90%86%EF%BC%8838%EF%BC%89Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8E%9F%E7%90%86%E4%B8%8E%E5%B8%83%E5%B1%80%E4%BB%A5%E5%8F%8Ajvisualvm%E4%BD%BF%E7%94%A8/jvisualvm2.png" alt="jvisualvm"></p>
<p>我们在修改下程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(;;)&#123;</span><br><span class="line">    list.add(new MyTest1());</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候我们运行程序的时候就不会出现oom的错误。<br>此时我们打开jvisualvm可以看到动态的数据：<br><img src="/2019/04/13/jvm%E5%8E%9F%E7%90%86%EF%BC%8838%EF%BC%89Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8E%9F%E7%90%86%E4%B8%8E%E5%B8%83%E5%B1%80%E4%BB%A5%E5%8F%8Ajvisualvm%E4%BD%BF%E7%94%A8/jvisualvm3.png" alt="jvisualvm"><br>程序的堆平稳在2M的层次上。</p>
<p>好，现在我们修改下jvm的启动参数为：  -Xms1m -Xmx1m -XX:+HeapDumpOnOutOfMemoryError 运行，<br>然后我们的程序出现了内存溢出，缩小为1M，这个时候在观察jvisualvm。意味着回收的速度赶不上创建的速度。</p>
<h5 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc();"></a>System.gc();</h5><p>Runs the garbage collector.<br>Calling the gc method suggests that the Java Virtual Machine expend effort toward recycling unused objects in order to make the memory they currently occupy available for quick reuse.<br> When control returns from the method call, the Java Virtual Machine has made a best effort to reclaim space from all discarded objects.<br>The call System.gc() is effectively equivalent to the call:<br>       Runtime.getRuntime().gc()</p>
<p>调用垃圾收集器。<br>调用垃圾收集器建议虚拟机花费一些努力来对不用的对象进行回收，为了使占用的空间得到再次利用，当gc调用返回的时候，java虚拟机将会最尽最大努力去回收不用的对象。</p>
<p>实际开发中不鼓励使用这个方法，虚拟机会自动调用，在合适的时机。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm内存划分</tag>
        <tag>虚拟机栈</tag>
        <tag>程序计数器</tag>
        <tag>堆</tag>
        <tag>方法区</tag>
        <tag>运行时的常量池</tag>
        <tag>直接内存</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（39）线程栈溢出监控与分析详解以及死锁检测</title>
    <url>/2019/04/21/jvm%E5%8E%9F%E7%90%86%EF%BC%8839%EF%BC%89%E7%BA%BF%E7%A8%8B%E6%A0%88%E6%BA%A2%E5%87%BA%E7%9B%91%E6%8E%A7%E4%B8%8E%E5%88%86%E6%9E%90%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h3 id="java-lang-StackOverflowError"><a href="#java-lang-StackOverflowError" class="headerlink" title="java.lang.StackOverflowError"></a>java.lang.StackOverflowError</h3><span id="more"></span>
<p>编写程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//配置jvm参数：-Xss160k</span><br><span class="line">public class MyTest2 &#123;</span><br><span class="line"></span><br><span class="line">    private int length;</span><br><span class="line"></span><br><span class="line">    public int getLength() &#123;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test()&#123;</span><br><span class="line">        this.length++;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyTest2 myTest2 = new MyTest2();</span><br><span class="line">        try &#123;</span><br><span class="line">            myTest2.test();</span><br><span class="line">        &#125;catch (Throwable throwable)&#123;</span><br><span class="line">            System.out.println(myTest2.getLength());</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1743</span><br><span class="line">java.lang.StackOverflowError</span><br><span class="line">	at com.twodragonlake.jvm.memory.MyTest2.test(MyTest2.java:35)</span><br></pre></td></tr></table></figure>
<p>即到了1743次递归的时候出现了错误。</p>
<p>现在我们使用jvisualvm体现下线程的堆栈日志：<br>为了延迟出现StackOverflowError我们在test方法里边加了线程延迟：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void test() throws InterruptedException &#123;</span><br><span class="line">    this.length++;</span><br><span class="line">    Thread.sleep(300);</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后打开jvisualvm：<br><img src="/2019/04/21/jvm%E5%8E%9F%E7%90%86%EF%BC%8839%EF%BC%89%E7%BA%BF%E7%A8%8B%E6%A0%88%E6%BA%A2%E5%87%BA%E7%9B%91%E6%8E%A7%E4%B8%8E%E5%88%86%E6%9E%90%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B/jstack1.png" alt="jstack1"><br>可以看到很多线程。其中就有main线程。<br><img src="/jstack2.png" alt="jstack1"><br>线程dump之后会出现当前所有线程的日志。</p>
<h3 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h3><p>我们在运行MyTest2的时候，使用jconsole命令可以打开jconsole的界面：<br>我们连接MyTest2<br><img src="/2019/04/21/jvm%E5%8E%9F%E7%90%86%EF%BC%8839%EF%BC%89%E7%BA%BF%E7%A8%8B%E6%A0%88%E6%BA%A2%E5%87%BA%E7%9B%91%E6%8E%A7%E4%B8%8E%E5%88%86%E6%9E%90%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B/jconsole1.png" alt="jconsole"><br>在线程tab里边点开main线程，右边出现的等待次数就是Thread.sleep(300);的次数，每次刷新都会变化的。<br><img src="/2019/04/21/jvm%E5%8E%9F%E7%90%86%EF%BC%8839%EF%BC%89%E7%BA%BF%E7%A8%8B%E6%A0%88%E6%BA%A2%E5%87%BA%E7%9B%91%E6%8E%A7%E4%B8%8E%E5%88%86%E6%9E%90%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B/jconsole2.png" alt="jconsole"><br>实际工作中我们可以使用jvisualvm和jconsole配合使用。<br>下边有一个按钮是“检测死锁”，我们点了一下提示没有检测到死锁。这个功能在做底层开发的时候会使用到。</p>
<h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>编写一个产生死锁的程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DeadLock &#123;</span><br><span class="line">    private static Object lock1 = new Object();</span><br><span class="line">    private static  Object lock2 = new Object();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread thread1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                synchronized (lock1)&#123;</span><br><span class="line">                    System.out.println(&quot;get lock1&quot;);</span><br><span class="line">                    synchronized (lock2)&#123;</span><br><span class="line">                        System.out.println(&quot;get lock2&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                synchronized (lock2)&#123;</span><br><span class="line">                    System.out.println(&quot;get lock2&quot;);</span><br><span class="line">                    synchronized (lock1)&#123;</span><br><span class="line">                        System.out.println(&quot;get lock1&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开jconsole，执行“检测死锁”这个时候我们检测到了死锁的结果。<br><img src="/2019/04/21/jvm%E5%8E%9F%E7%90%86%EF%BC%8839%EF%BC%89%E7%BA%BF%E7%A8%8B%E6%A0%88%E6%BA%A2%E5%87%BA%E7%9B%91%E6%8E%A7%E4%B8%8E%E5%88%86%E6%9E%90%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B/deadlock1.png" alt="deadlock"><br><img src="/2019/04/21/jvm%E5%8E%9F%E7%90%86%EF%BC%8839%EF%BC%89%E7%BA%BF%E7%A8%8B%E6%A0%88%E6%BA%A2%E5%87%BA%E7%9B%91%E6%8E%A7%E4%B8%8E%E5%88%86%E6%9E%90%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B/deadlock2.png" alt="deadlock"></p>
<p>Thread-0持有锁java.lang.Object@59307d92， 状态是BLOCK，证明是在java.lang.Object@3818ced5上阻塞。但是java.lang.Object@3818ced5的拥有者是Thread-1。<br>Thread-1持有锁java.lang.Object@3818ced5， 状态是BLOCK，证明是在java.lang.Object@59307d92上阻塞，但是java.lang.Object@59307d92的拥有者是Thread-0。<br>这就是死锁。</p>
<p>另外我们没有看到main线程的影子，其实执行完 thread1.start(); thread2.start();之后面线程就退出了，如果想让main出现可以在thread1.start(); thread2.start();加一句：<br> Thread.sleep(40000);main就会出现，如图：<br><img src="/2019/04/21/jvm%E5%8E%9F%E7%90%86%EF%BC%8839%EF%BC%89%E7%BA%BF%E7%A8%8B%E6%A0%88%E6%BA%A2%E5%87%BA%E7%9B%91%E6%8E%A7%E4%B8%8E%E5%88%86%E6%9E%90%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B/deadlock3.png" alt="deadlock">  </p>
<p>现在我们jvisualvm检测一下：<br><img src="/2019/04/21/jvm%E5%8E%9F%E7%90%86%EF%BC%8839%EF%BC%89%E7%BA%BF%E7%A8%8B%E6%A0%88%E6%BA%A2%E5%87%BA%E7%9B%91%E6%8E%A7%E4%B8%8E%E5%88%86%E6%9E%90%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B/deadlock4.png" alt="deadlock"><br>之后打开dump的日志，在日志底部会打印：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">&quot;thread2&quot;:</span><br><span class="line">  waiting to lock monitor 0x000000001c6b3608 (object 0x000000076b327330, a java.lang.Object),</span><br><span class="line">  which is held by &quot;thread1&quot;</span><br><span class="line">&quot;thread1&quot;:</span><br><span class="line">  waiting to lock monitor 0x000000001e7c9f78 (object 0x000000076b327340, a java.lang.Object),</span><br><span class="line">  which is held by &quot;thread2&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">&quot;thread2&quot;:</span><br><span class="line">	at com.twodragonlake.jvm.memory.DeadLock$2.run(DeadLock.java:48)</span><br><span class="line">	- waiting to lock &lt;0x000000076b327330&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;0x000000076b327340&gt; (a java.lang.Object)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br><span class="line">&quot;thread1&quot;:</span><br><span class="line">	at com.twodragonlake.jvm.memory.DeadLock$1.run(DeadLock.java:37)</span><br><span class="line">	- waiting to lock &lt;0x000000076b327340&gt; (a java.lang.Object)</span><br><span class="line">	- locked &lt;0x000000076b327330&gt; (a java.lang.Object)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>死锁</tag>
        <tag>jconsole</tag>
        <tag>jvisualvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（3）编译期常量与运行期常量的区别及数组创建本质分析</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%883%EF%BC%89%E7%BC%96%E8%AF%91%E6%9C%9F%E5%B8%B8%E9%87%8F%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA%E6%9C%AC%E8%B4%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>上一个<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3pxNjU3ODcwMi9hcnRpY2xlL2RldGFpbHMvNzkzNzAxNDk=">例子<i class="fa fa-external-link-alt"></i></span>我们用的final是一个字面量“hello world”，这次我们改一下使用UUID为常量赋值，注意：UUID是多少只有在运行期间才会被确定。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(MyParent3.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyParent3&#123;</span><br><span class="line">    public static final String str =UUID.randomUUID().toString();</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;Myparnet3 static bloack&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Myparnet3 static bloack</span><br><span class="line">04d27b8c-5480-497d-83cc-8b924e5889a5</span><br></pre></td></tr></table></figure>

<p>当一个常量的值并非编译期可以确定的，那么其值就不会被放到调用类的常量池中，<br>这时的程序运行时，会导致主动使用这个常量所在的类，显然会导致这个类被初始化。</p>
<p>接下来看一下数组的形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest4 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       // MyParent4 myParent4 = new MyParent4(); 毫无疑问这个会触发初始化，属于主动调用</span><br><span class="line">        MyParent4 [] myParent4s =  new MyParent4[1];</span><br><span class="line">        System.out.println(myParent4s.getClass());</span><br><span class="line">        System.out.println(myParent4s.getClass().getSuperclass());</span><br><span class="line">        MyParent4 [][] myParent4s1 =  new MyParent4[1][1];</span><br><span class="line">        System.out.println(myParent4s1.getClass());</span><br><span class="line">        System.out.println(myParent4s1.getClass().getSuperclass());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;==============&quot;);</span><br><span class="line">        int [] ints = new int[1];</span><br><span class="line">        System.out.println(ints.getClass());</span><br><span class="line">        System.out.println(ints.getClass().getSuperclass());</span><br><span class="line"></span><br><span class="line">        byte [] bytes = new byte[1];</span><br><span class="line">        System.out.println(bytes.getClass());</span><br><span class="line">        System.out.println(bytes.getClass().getSuperclass());</span><br><span class="line"></span><br><span class="line">        short [] shorts = new short[1];</span><br><span class="line">        System.out.println(shorts.getClass());</span><br><span class="line">        System.out.println(shorts.getClass().getSuperclass());</span><br><span class="line"></span><br><span class="line">        boolean [] booleans =new boolean[1];</span><br><span class="line">        System.out.println(booleans.getClass());</span><br><span class="line">        System.out.println(booleans.getClass().getSuperclass());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyParent4&#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;MyParent4 static bloack&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class [Lcom.twodragonlake.jvm.classloader.MyParent4;</span><br><span class="line">class java.lang.Object</span><br><span class="line">class [[Lcom.twodragonlake.jvm.classloader.MyParent4;</span><br><span class="line">class java.lang.Object</span><br><span class="line">==============</span><br><span class="line">class [I</span><br><span class="line">class java.lang.Object</span><br><span class="line">class [B</span><br><span class="line">class java.lang.Object</span><br><span class="line">class [S</span><br><span class="line">class java.lang.Object</span><br><span class="line">class [Z</span><br><span class="line">class java.lang.Object</span><br></pre></td></tr></table></figure>

<p>对于数组实例来说，其类型是由JVM在运行期间动态生成的，<br>表示为[Lcom.twodragonlake.jvm.classloader.MyParent4这种形式。<br>动态生成的类型（类似于动态代理），其父类型就是Object</p>
<p>对于数组来说，JavaDoc经常讲构成数组的元素称为Component，实际上就是将数组降低一个维度后的类型。<br>    助记词：<br>    anewarray : 表示创建一个引用类型的(如类、接口、数组)数组，并将其引用值压入栈顶<br>    newarray : 表示创建一个指定的原始类型（如int、float、char等）的数组，并将其压入栈顶</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>编译期常量 运行期常量</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（40）JVM元空间深度解析</title>
    <url>/2019/04/21/jvm%E5%8E%9F%E7%90%86%EF%BC%8840%EF%BC%89JVM%E5%85%83%E7%A9%BA%E9%97%B4%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h3 id="metaspace"><a href="#metaspace" class="headerlink" title="metaspace"></a>metaspace</h3><p>jdk8当中class的元数据放在元空间里边，元空间是os的一部分内存，对元空间的管理会存在元空间不够会动态扩容，如果扩容还不够就会oomm异常，为了模拟这种错误，我们可以限制metaspace的大小，下面是</p>
<span id="more"></span>
<p>测试代码，我们使用cglib的api不断的动态生成class,限制metaspace的大小是10兆：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 引入cglib：&quot;cglib:cglib:3.2.8&quot;</span><br><span class="line"> * 方法区产生内存溢出的情况。.</span><br><span class="line"> * 指定metaspace大小：-XX:MaxMetaspaceSize=10m</span><br><span class="line"> * @author : CeaserWang</span><br><span class="line"> * @version : 1.0</span><br><span class="line"> * @since : 2019/4/21 21:34</span><br><span class="line"> */</span><br><span class="line">public class MyTest4 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for(;;)&#123;</span><br><span class="line">            Enhancer enhancer = new Enhancer();</span><br><span class="line">            enhancer.setSuperclass(MyTest4.class);</span><br><span class="line">            enhancer.setUseCache(false);</span><br><span class="line">            enhancer.setCallback((MethodInterceptor)(obj, method, args1, proxy) -&gt; proxy.invokeSuper(obj,args));</span><br><span class="line">            System.out.println(&quot;hello world&quot;);</span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">Exception in thread &quot;main&quot;</span><br><span class="line">Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread &quot;main&quot;</span><br></pre></td></tr></table></figure>
<p>现在修改-XX:MaxMetaspaceSize&#x3D;200m运行，打开jvisualvm监控类的和metasapce的曲线：<br><img src="/2019/04/21/jvm%E5%8E%9F%E7%90%86%EF%BC%8840%EF%BC%89JVM%E5%85%83%E7%A9%BA%E9%97%B4%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/metaspace.png" alt="metaspace"><br>metaspace是一直上升的，等程序出现oom的时候，会看到metaspace的上升停止了：<br><img src="/2019/04/21/jvm%E5%8E%9F%E7%90%86%EF%BC%8840%EF%BC%89JVM%E5%85%83%E7%A9%BA%E9%97%B4%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/metaspace1.png" alt="metaspace"><br>验证了MaxMetaspaceSize的作用。<br>目前我们通过程序和监控的方式知道metaspace会出现oom，那么metaspace到底是什么呢？通过这篇文章：<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5mb3EuY24vYXJ0aWNsZS9KYXZhLVBFUk1HRU4tUmVtb3ZlZA==">Java 永久代去哪儿了<i class="fa fa-external-link-alt"></i></span> 我们就能知道。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>meta space</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（41）jmap_jstat_jcmd_jmc_jhat讲解与实战</title>
    <url>/2019/04/30/jvm%E5%8E%9F%E7%90%86%EF%BC%8841%EF%BC%89jmap-jstat-jcmd-jmc-jhat%E8%AE%B2%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><span id="more"></span>
<p>jmap命令的doc如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;jmap</span><br><span class="line">Usage:</span><br><span class="line">    jmap [option] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jmap [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to remote debug server)</span><br><span class="line"></span><br><span class="line">where &lt;option&gt; is one of:</span><br><span class="line">    &lt;none&gt;               to print same info as Solaris pmap</span><br><span class="line">    -heap                to print java heap summary</span><br><span class="line">    -histo[:live]        to print histogram of java object heap; if the &quot;live&quot;</span><br><span class="line">                         suboption is specified, only count live objects</span><br><span class="line">    -clstats             to print class loader statistics</span><br><span class="line">    -finalizerinfo       to print information on objects awaiting finalization</span><br><span class="line">    -dump:&lt;dump-options&gt; to dump java heap in hprof binary format</span><br><span class="line">                         dump-options:</span><br><span class="line">                           live         dump only live objects; if not specified,</span><br><span class="line">                                        all objects in the heap are dumped.</span><br><span class="line">                           format=b     binary format</span><br><span class="line">                           file=&lt;file&gt;  dump heap to &lt;file&gt;</span><br><span class="line">                         Example: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;</span><br><span class="line">    -F                   force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; or -histo</span><br><span class="line">                         to force a heap dump or histogram when &lt;pid&gt; does not</span><br><span class="line">                         respond. The &quot;live&quot; suboption is not supported</span><br><span class="line">                         in this mode.</span><br><span class="line">    -h | -help           to print this help message</span><br><span class="line">    -J&lt;flag&gt;             to pass &lt;flag&gt; directly to the runtime system</span><br></pre></td></tr></table></figure>

<h4 id="jmap-clstats-PID"><a href="#jmap-clstats-PID" class="headerlink" title="jmap -clstats PID"></a>jmap -clstats PID</h4><p>jmap -clstats PID :打印类加载器的数据。<br>现在我们写一个死循环的程序，然后用jmap测试一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest5 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (;;)&#123;</span><br><span class="line">            System.out.println(&quot;hello world&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用jmap查询类加载器的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;jps</span><br><span class="line">16064 Jps</span><br><span class="line">19216</span><br><span class="line">9524 Launcher</span><br><span class="line">4184 RemoteMavenServer</span><br><span class="line">4536 Launcher</span><br><span class="line">6444 MyTest5</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jmap -clstats 6444</span><br><span class="line">Attaching to process ID 6444, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.111-b14</span><br><span class="line">finding class loader instances ..done.</span><br><span class="line">computing per loader stat ..done.</span><br><span class="line">please wait.. computing liveness...liveness analysis may be inaccurate ...</span><br><span class="line">class_loader    classes bytes   parent_loader   alive?  type</span><br><span class="line"></span><br><span class="line">&lt;bootstrap&gt;     567     1071357   null          live    &lt;internal&gt;</span><br><span class="line">0x00000006c140a808      24      71712   0x00000006c140a878      live    sun/misc/Launcher$AppClassLoader@0x00000007c000f6a0</span><br><span class="line">0x00000006c140a878      0       0         null          live    sun/misc/Launcher$ExtClassLoader@0x00000007c000fa48</span><br><span class="line"></span><br><span class="line">total = 3       591     1143069     N/A         alive=3, dead=0     N/A</span><br></pre></td></tr></table></figure>

<h4 id="jstat-gcutil-pid-3000"><a href="#jstat-gcutil-pid-3000" class="headerlink" title="jstat -gcutil pid 3000"></a>jstat -gcutil pid 3000</h4><p>用来查看当前线程的young gc、full gc的频率<br>参数3000是多少时间刷新一次</p>
<h4 id="jmap-histo-live-pid"><a href="#jmap-histo-live-pid" class="headerlink" title="jmap -histo:live pid"></a>jmap -histo:live pid</h4><p>查看当前线程持有的对象及其数量。</p>
<h4 id="jmap-heap"><a href="#jmap-heap" class="headerlink" title="jmap -heap"></a>jmap -heap</h4><p>打印当前进程堆的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;jmap -heap 6444</span><br><span class="line">Attaching to process ID 6444, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.111-b14</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 8 thread(s) 【使用的GC收集器，8个线程】</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 0</span><br><span class="line">   MaxHeapFreeRatio         = 100</span><br><span class="line">   MaxHeapSize              = 4273995776 (4076.0MB)</span><br><span class="line">   NewSize                  = 89128960 (85.0MB)</span><br><span class="line">   MaxNewSize               = 1424490496 (1358.5MB)</span><br><span class="line">   OldSize                  = 179306496 (171.0MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 31981568 (30.5MB)</span><br><span class="line">   used     = 5756808 (5.490119934082031MB)</span><br><span class="line">   free     = 26224760 (25.00988006591797MB)</span><br><span class="line">   18.000393226498463% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 524288 (0.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 524288 (0.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 524288 (0.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 524288 (0.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = 179306496 (171.0MB)</span><br><span class="line">   used     = 798896 (0.7618865966796875MB)</span><br><span class="line">   free     = 178507600 (170.2381134033203MB)</span><br><span class="line">   0.4455477173565424% used</span><br><span class="line"></span><br><span class="line">1782 interned Strings occupying 158912 bytes.</span><br></pre></td></tr></table></figure>

<h4 id="jmap-dump"><a href="#jmap-dump" class="headerlink" title="jmap -dump"></a>jmap -dump</h4><p>输出当前堆的快照到文件：<br>jmap -dump:format&#x3D;b,file&#x3D;e:dump.hprof 6444<br>这样会生成当前堆的一个快照，之后用jvisualvm加载快照进行可视化分析。</p>
<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>命令的doc说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;jstat</span><br><span class="line">invalid argument count</span><br><span class="line">Usage: jstat -help|-options</span><br><span class="line">       jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span><br><span class="line"></span><br><span class="line">Definitions:</span><br><span class="line">  &lt;option&gt;      An option reported by the -options option</span><br><span class="line">  &lt;vmid&gt;        Virtual Machine Identifier. A vmid takes the following form:</span><br><span class="line">                     &lt;lvmid&gt;[@&lt;hostname&gt;[:&lt;port&gt;]]</span><br><span class="line">                Where &lt;lvmid&gt; is the local vm identifier for the target</span><br><span class="line">                Java virtual machine, typically a process id; &lt;hostname&gt; is</span><br><span class="line">                the name of the host running the target Java virtual machine;</span><br><span class="line">                and &lt;port&gt; is the port number for the rmiregistry on the</span><br><span class="line">                target host. See the jvmstat documentation for a more complete</span><br><span class="line">                description of the Virtual Machine Identifier.</span><br><span class="line">  &lt;lines&gt;       Number of samples between header lines.</span><br><span class="line">  &lt;interval&gt;    Sampling interval. The following forms are allowed:</span><br><span class="line">                    &lt;n&gt;[&quot;ms&quot;|&quot;s&quot;]</span><br><span class="line">                Where &lt;n&gt; is an integer and the suffix specifies the units as</span><br><span class="line">                milliseconds(&quot;ms&quot;) or seconds(&quot;s&quot;). The default units are &quot;ms&quot;.</span><br><span class="line">  &lt;count&gt;       Number of samples to take before terminating.</span><br><span class="line">  -J&lt;flag&gt;      Pass &lt;flag&gt; directly to the runtime system.</span><br></pre></td></tr></table></figure>

<h4 id="jvmstat-gc"><a href="#jvmstat-gc" class="headerlink" title="jvmstat -gc"></a>jvmstat -gc</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;jstat -gc 6444</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">512.0  512.0   0.0    0.0   31232.0  14367.0   175104.0    780.2    4864.0 3519.5 512.0  386.2     788    0.479   0      0.000    0.479</span><br></pre></td></tr></table></figure>
<p>MC:分配的元空间的大小。<br>MU:已经使用的元空间的大小。<br>因为我们的程序是一个死循环，不会对元空间进行动态增加，现在我们使用上一节的如下程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest4 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for(;;)&#123;</span><br><span class="line">            Enhancer enhancer = new Enhancer();</span><br><span class="line">            enhancer.setSuperclass(MyTest4.class);</span><br><span class="line">            enhancer.setUseCache(false);</span><br><span class="line">            enhancer.setCallback((MethodInterceptor)(obj, method, args1, proxy) -&gt; proxy.invokeSuper(obj,args));</span><br><span class="line">            System.out.println(&quot;hello world&quot;);</span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>jstat打印一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;jps</span><br><span class="line">19216</span><br><span class="line">21892 MyTest4</span><br><span class="line">4740 Main</span><br><span class="line">3320 Jps</span><br><span class="line">4184 RemoteMavenServer</span><br><span class="line">4536 Launcher</span><br><span class="line">17916 Launcher</span><br><span class="line">我们的测试类是MyTest4【pid：21892】，然后我们多次打印，得到如下列表：</span><br><span class="line">C:\Users\Administrator&gt;jstat -gc 21892</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">7168.0 13312.0 6816.0  0.0   1234944.0 1160712.2  219136.0   29834.2   71576.0 71320.5 5800.0 5705.9     18    0.112   3      0.228    0.340</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jstat -gc 21892</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">14336.0 15872.0 13344.0  0.0   1359360.0 353416.7  219136.0   29834.2   83864.0 83342.1 6824.0 6643.2     20    0.130   3      0.228    0.357</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jstat -gc 21892</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">15872.0 21504.0 15856.0  0.0   1348096.0 647073.4  219136.0   33642.2   95256.0 94760.5 7720.0 7533.6     22    0.154   3      0.228    0.381</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jstat -gc 21892</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">23040.0 23040.0 2784.0  0.0   1345024.0 106901.6  321024.0   51215.3   103576.0 103289.6 8360.0 8198.3     24    0.167   4      0.397    0.564</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jstat -gc 21892</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">22528.0 5632.0  0.0   5472.0 1345024.0 1232187.7  321024.0   51215.3   108312.0 108021.3 8744.0 8567.5     25    0.172   4      0.397    0.568</span><br><span class="line">C:\Users\Administrator&gt;jstat -gc 21892</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">32256.0 33280.0 21856.0  0.0   1324544.0 715254.8  418304.0   86847.4   203544.0 203157.8 16168.0 15985.9     56    0.509   5      0.730    1.239</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jstat -gc 21892</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">35328.0 35328.0  0.0    64.0  1320448.0   0.0     910848.0   40670.6   204800.0 204569.1 16168.0 16093.9     61    0.532  10      1.586    2.119</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jstat -gc 21892</span><br><span class="line">21892 not found 【到达200m程序退出】</span><br></pre></td></tr></table></figure>
<p>可以很明显的看到MC和MU在一直增加。<br>由于MyTest4设置-XX:MaxMetaspaceSize&#x3D;200m  等程序的MC和MU到达200m的时候程序就会出现溢出而终止。</p>
<h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>jps的doc:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;jps -help</span><br><span class="line">usage: jps [-help]</span><br><span class="line">       jps [-q] [-mlvV] [&lt;hostid&gt;]</span><br><span class="line"></span><br><span class="line">Definitions:</span><br><span class="line">    &lt;hostid&gt;:      &lt;hostname&gt;[:&lt;port&gt;]</span><br></pre></td></tr></table></figure>
<p>jsp -mlvV个ps -ef | grep java 效果是差不多的，打印了大部分的数据，jps -l是经常用的，以为jps -l会打印类的包名和线程id。</p>
<h3 id="jcmd"><a href="#jcmd" class="headerlink" title="jcmd"></a>jcmd</h3><p>doc：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;jcmd -help</span><br><span class="line">Usage: jcmd &lt;pid | main class&gt; &lt;command ...|PerfCounter.print|-f file&gt;</span><br><span class="line">   or: jcmd -l</span><br><span class="line">   or: jcmd -h</span><br><span class="line"></span><br><span class="line">  command must be a valid jcmd command for the selected jvm.</span><br><span class="line">  Use the command &quot;help&quot; to see which commands are available.</span><br><span class="line">  If the pid is 0, commands will be sent to all Java processes.</span><br><span class="line">  The main class argument will be used to match (either partially</span><br><span class="line">  or fully) the class used to start Java.</span><br><span class="line">  If no options are given, lists Java processes (same as -p).</span><br><span class="line"></span><br><span class="line">  PerfCounter.print display the counters exposed by this process</span><br><span class="line">  -f  read and execute commands from the file</span><br><span class="line">  -l  list JVM processes on the local machine</span><br><span class="line">  -h  this help</span><br></pre></td></tr></table></figure>

<h4 id="查看当前jvm的启动参数："><a href="#查看当前jvm的启动参数：" class="headerlink" title="查看当前jvm的启动参数："></a>查看当前jvm的启动参数：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;jps</span><br><span class="line">11744 MyTest5</span><br><span class="line">19216</span><br><span class="line">4740 Main</span><br><span class="line">11192 Jps</span><br><span class="line">21176 Launcher</span><br><span class="line">4184 RemoteMavenServer</span><br><span class="line">4536 Launcher</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jcmd 11744 VM.flags</span><br><span class="line">11744:</span><br><span class="line">-XX:CICompilerCount=4 -XX:InitialHeapSize=268435456 -XX:MaxHeapSize=4273995776 -XX:MaxNewSize=1424490496 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=89128960 -XX:OldSize=179306496 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br></pre></td></tr></table></figure>

<h4 id="jcmd-help"><a href="#jcmd-help" class="headerlink" title="jcmd help"></a>jcmd help</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;jps</span><br><span class="line">12048 MyTest5</span><br><span class="line">19216</span><br><span class="line">19620 Launcher</span><br><span class="line">21044 Jps</span><br><span class="line">4740 Main</span><br><span class="line">4184 RemoteMavenServer</span><br><span class="line">4536 Launcher</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jcmd 12048 help</span><br><span class="line">12048:</span><br><span class="line">The following commands are available:</span><br><span class="line">JFR.stop 【JFR：java fly recoder java飞行记录器】</span><br><span class="line">JFR.start</span><br><span class="line">JFR.dump</span><br><span class="line">JFR.check</span><br><span class="line">VM.native_memory</span><br><span class="line">VM.check_commercial_features</span><br><span class="line">VM.unlock_commercial_features</span><br><span class="line">ManagementAgent.stop</span><br><span class="line">ManagementAgent.start_local</span><br><span class="line">ManagementAgent.start</span><br><span class="line">GC.rotate_log</span><br><span class="line">Thread.print</span><br><span class="line">GC.class_stats</span><br><span class="line">GC.class_histogram</span><br><span class="line">GC.heap_dump</span><br><span class="line">GC.run_finalization</span><br><span class="line">GC.run</span><br><span class="line">VM.uptime</span><br><span class="line">VM.flags</span><br><span class="line">VM.system_properties</span><br><span class="line">VM.command_line</span><br><span class="line">VM.version</span><br><span class="line">help</span><br></pre></td></tr></table></figure>

<h4 id="查看某一个命令有哪些参数："><a href="#查看某一个命令有哪些参数：" class="headerlink" title="查看某一个命令有哪些参数："></a>查看某一个命令有哪些参数：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;jps</span><br><span class="line">12048 MyTest5</span><br><span class="line">19216</span><br><span class="line">19620 Launcher</span><br><span class="line">21044 Jps</span><br><span class="line">4740 Main</span><br><span class="line">4184 RemoteMavenServer</span><br><span class="line">4536 Launcher</span><br><span class="line"></span><br><span class="line">查看JFR.dump有哪些参数：</span><br><span class="line">C:\Users\Administrator&gt;jcmd 12048 help JFR.dump</span><br><span class="line">12048:</span><br><span class="line">JFR.dump</span><br><span class="line">Copies contents of a JFR recording to file. Either the name or the recording id must be specified.</span><br><span class="line"></span><br><span class="line">Impact: Low</span><br><span class="line"></span><br><span class="line">Permission: java.lang.management.ManagementPermission(monitor)</span><br><span class="line"></span><br><span class="line">Syntax : JFR.dump [options]</span><br><span class="line"></span><br><span class="line">Options: (options must be specified using the &lt;key&gt; or &lt;key&gt;=&lt;value&gt; syntax)</span><br><span class="line">        name : [optional] Recording name, e.g. \&quot;My Recording\&quot; (STRING, no default value)</span><br><span class="line">        recording : [optional] Recording number, use JFR.check to list available recordings (JLONG, -1)</span><br><span class="line">        filename :  Copy recording data to file, i.e \&quot;C:\Users\user\My Recording.jfr\&quot; (STRING, no default value)</span><br><span class="line">        compress : [optional] GZip-compress &quot;filename&quot; destination (BOOLEAN, false)</span><br></pre></td></tr></table></figure>

<h4 id="查看当前进程jvm性能相关的参数："><a href="#查看当前进程jvm性能相关的参数：" class="headerlink" title="查看当前进程jvm性能相关的参数："></a>查看当前进程jvm性能相关的参数：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;jps</span><br><span class="line">12048 MyTest5</span><br><span class="line">19216</span><br><span class="line">19620 Launcher</span><br><span class="line">21044 Jps</span><br><span class="line">4740 Main</span><br><span class="line">4184 RemoteMavenServer</span><br><span class="line">4536 Launcher</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jcmd 12048 PerfCounter.print</span><br><span class="line">12048:</span><br><span class="line">java.ci.totalTime=1663910</span><br><span class="line">java.cls.loadedClasses=571</span><br><span class="line">java.cls.sharedLoadedClasses=0</span><br><span class="line">java.cls.sharedUnloadedClasses=0</span><br><span class="line">java.cls.unloadedClasses=0</span><br><span class="line">.... 略 ....</span><br><span class="line">sun.rt.threadInterruptSignaled=0</span><br><span class="line">sun.rt.vmInitDoneTime=1556598418866</span><br><span class="line">sun.threads.vmOperationTime=1543651</span><br><span class="line">sun.urlClassLoader.readClassBytesTime=11464600</span><br><span class="line">sun.zip.zipFile.openTime=7540600</span><br><span class="line">sun.zip.zipFiles=17</span><br></pre></td></tr></table></figure>

<h4 id="jcmd-pid-VM-uptime-查看当前jvm进程启动时长-启动到现在的时长-。"><a href="#jcmd-pid-VM-uptime-查看当前jvm进程启动时长-启动到现在的时长-。" class="headerlink" title="jcmd pid VM.uptime 查看当前jvm进程启动时长(启动到现在的时长)。"></a>jcmd pid VM.uptime 查看当前jvm进程启动时长(启动到现在的时长)。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;jps</span><br><span class="line">12048 MyTest5</span><br><span class="line">19216</span><br><span class="line">19620 Launcher</span><br><span class="line">21044 Jps</span><br><span class="line">4740 Main</span><br><span class="line">4184 RemoteMavenServer</span><br><span class="line">4536 Launcher</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jcmd 12048 VM.uptime</span><br><span class="line">12048:</span><br><span class="line">15334.690 s</span><br></pre></td></tr></table></figure>

<h4 id="jcmd-12048-GC-class-histogram-查看系统中类的统计信息。"><a href="#jcmd-12048-GC-class-histogram-查看系统中类的统计信息。" class="headerlink" title="jcmd 12048 GC.class_histogram 查看系统中类的统计信息。"></a>jcmd 12048 GC.class_histogram 查看系统中类的统计信息。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;jps</span><br><span class="line">12048 MyTest5</span><br><span class="line">19216</span><br><span class="line">19620 Launcher</span><br><span class="line">21044 Jps</span><br><span class="line">4740 Main</span><br><span class="line">4184 RemoteMavenServer</span><br><span class="line">4536 Launcher</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jcmd 12048 GC.class_histogram</span><br><span class="line">12048:</span><br><span class="line"></span><br><span class="line"> num     #instances         #bytes  class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:          2661         362216  [C</span><br><span class="line">   2:           653          74544  java.lang.Class</span><br><span class="line">   3:          2511          60264  java.lang.String</span><br><span class="line">   4:           608          35104  [Ljava.lang.Object;</span><br><span class="line">   .....略.....</span><br><span class="line">   Total         10031         702888</span><br></pre></td></tr></table></figure>

<p>由于MyTest5是一个死循环，他的类的信息没有变化，如果使用MyTest4(使用osgi动态创建类)那么jcmd pid GC.class_histogram的最后一列<br>【 Total         10031         702888】会一直变化的。<br>测试如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;jps</span><br><span class="line">19216</span><br><span class="line">7456 Jps</span><br><span class="line">4740 Main</span><br><span class="line">4536 Launcher</span><br><span class="line">872 Launcher</span><br><span class="line">1884 MyTest4</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jcmd 1884 GC.class_histogram</span><br><span class="line">....略....</span><br><span class="line">Total        802230       39909584</span><br><span class="line">....略....</span><br><span class="line">C:\Users\Administrator&gt;jcmd 1884 GC.class_histogram</span><br><span class="line">....略....</span><br><span class="line">Total        928340       46179936</span><br><span class="line">....略....</span><br><span class="line">C:\Users\Administrator&gt;jcmd 1884 GC.class_histogram</span><br><span class="line">....略....</span><br><span class="line">Total       1066484       53092096</span><br></pre></td></tr></table></figure>


<h4 id="jcmd-pid-Thread-print打印线程信息"><a href="#jcmd-pid-Thread-print打印线程信息" class="headerlink" title="jcmd pid Thread.print打印线程信息"></a>jcmd pid Thread.print打印线程信息</h4><p>其实在jconsole或者jvisualvm也可以看到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;jps</span><br><span class="line">1312 Launcher</span><br><span class="line">19216</span><br><span class="line">4740 Main</span><br><span class="line">4536 Launcher</span><br><span class="line">3324 MyTest5</span><br><span class="line">7228 Jps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jcmd 3324 Thread.print</span><br><span class="line">3324:</span><br><span class="line">2019-04-30 16:57:16</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.111-b14 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;Service Thread&quot; #11 daemon prio=9 os_prio=0 tid=0x000000001f080800 nid=0x26e4 runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C1 CompilerThread3&quot; #10 daemon prio=9 os_prio=2 tid=0x000000001efd2800 nid=0x1b68 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C2 CompilerThread2&quot; #9 daemon prio=9 os_prio=2 tid=0x000000001efcf800 nid=0x52a4 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C2 CompilerThread1&quot; #8 daemon prio=9 os_prio=2 tid=0x000000001efcd000 nid=0x43f4 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C2 CompilerThread0&quot; #7 daemon prio=9 os_prio=2 tid=0x000000001efc9000 nid=0x36f4 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;Monitor Ctrl-Break&quot; #6 daemon prio=5 os_prio=0 tid=0x000000001efc7800 nid=0x4af4 runnable [0x000000001f6ae000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at java.net.SocketInputStream.socketRead0(Native Method)</span><br><span class="line">        at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)</span><br><span class="line">        at java.net.SocketInputStream.read(SocketInputStream.java:170)</span><br><span class="line">        at java.net.SocketInputStream.read(SocketInputStream.java:141)</span><br><span class="line">        at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284)</span><br><span class="line">        at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326)</span><br><span class="line">        at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178)</span><br><span class="line">        - locked &lt;0x00000006c14089e8&gt; (a java.io.InputStreamReader)</span><br><span class="line">        at java.io.InputStreamReader.read(InputStreamReader.java:184)</span><br><span class="line">        at java.io.BufferedReader.fill(BufferedReader.java:161)</span><br><span class="line">        at java.io.BufferedReader.readLine(BufferedReader.java:324)</span><br><span class="line">        - locked &lt;0x00000006c14089e8&gt; (a java.io.InputStreamReader)</span><br><span class="line">        at java.io.BufferedReader.readLine(BufferedReader.java:389)</span><br><span class="line">        at com.intellij.rt.execution.application.AppMainV2$1.run(AppMainV2.java:64)</span><br><span class="line"></span><br><span class="line">&quot;Attach Listener&quot; #5 daemon prio=5 os_prio=2 tid=0x000000001ef3d800 nid=0x3180 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;Signal Dispatcher&quot; #4 daemon prio=9 os_prio=2 tid=0x000000001eee9000 nid=0x4180 runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;Finalizer&quot; #3 daemon prio=8 os_prio=1 tid=0x0000000003559800 nid=0x2f04 in Object.wait() [0x000000001f3af000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x00000006c1406d08&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)</span><br><span class="line">        - locked &lt;0x00000006c1406d08&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)</span><br><span class="line">        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)</span><br><span class="line"></span><br><span class="line">&quot;Reference Handler&quot; #2 daemon prio=10 os_prio=2 tid=0x0000000003558000 nid=0x3a0 in Object.wait() [0x000000001eeae000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x00000006c1406d48&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">        at java.lang.Object.wait(Object.java:502)</span><br><span class="line">        at java.lang.ref.Reference.tryHandlePending(Reference.java:191)</span><br><span class="line">        - locked &lt;0x00000006c1406d48&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)</span><br><span class="line"></span><br><span class="line">&quot;main&quot; #1 prio=5 os_prio=0 tid=0x0000000003462800 nid=0x28bc runnable [0x000000000328f000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at java.io.FileOutputStream.writeBytes(Native Method)</span><br><span class="line">        at java.io.FileOutputStream.write(FileOutputStream.java:326)</span><br><span class="line">        at java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:82)</span><br><span class="line">        at java.io.BufferedOutputStream.flush(BufferedOutputStream.java:140)</span><br><span class="line">        - locked &lt;0x00000006c141bf30&gt; (a java.io.BufferedOutputStream)</span><br><span class="line">        at java.io.PrintStream.write(PrintStream.java:482)</span><br><span class="line">        - locked &lt;0x00000006c140a1e8&gt; (a java.io.PrintStream)</span><br><span class="line">        at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:221)</span><br><span class="line">        at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:291)</span><br><span class="line">        at sun.nio.cs.StreamEncoder.flushBuffer(StreamEncoder.java:104)</span><br><span class="line">        - locked &lt;0x00000006c140a1a0&gt; (a java.io.OutputStreamWriter)</span><br><span class="line">        at java.io.OutputStreamWriter.flushBuffer(OutputStreamWriter.java:185)</span><br><span class="line">        at java.io.PrintStream.write(PrintStream.java:527)</span><br><span class="line">        - eliminated &lt;0x00000006c140a1e8&gt; (a java.io.PrintStream)</span><br><span class="line">        at java.io.PrintStream.print(PrintStream.java:669)</span><br><span class="line">        at java.io.PrintStream.println(PrintStream.java:806)</span><br><span class="line">        - locked &lt;0x00000006c140a1e8&gt; (a java.io.PrintStream)</span><br><span class="line">        at com.twodragonlake.jvm.memory.MyTest5.main(MyTest5.java:34)</span><br><span class="line"></span><br><span class="line">&quot;VM Thread&quot; os_prio=2 tid=0x000000001cfb9800 nid=0x2ffc runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#0 (ParallelGC)&quot; os_prio=0 tid=0x0000000003478800 nid=0x21b4 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#1 (ParallelGC)&quot; os_prio=0 tid=0x000000000347a000 nid=0x5498 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#2 (ParallelGC)&quot; os_prio=0 tid=0x000000000347b800 nid=0x3928 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#3 (ParallelGC)&quot; os_prio=0 tid=0x000000000347d000 nid=0x2fb8 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#4 (ParallelGC)&quot; os_prio=0 tid=0x0000000003480800 nid=0x2a00 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#5 (ParallelGC)&quot; os_prio=0 tid=0x0000000003481800 nid=0x4678 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#6 (ParallelGC)&quot; os_prio=0 tid=0x0000000003484800 nid=0x3d50 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#7 (ParallelGC)&quot; os_prio=0 tid=0x0000000003486000 nid=0x20b0 runnable</span><br><span class="line"></span><br><span class="line">&quot;VM Periodic Task Thread&quot; os_prio=2 tid=0x000000001f0ed800 nid=0x24c0 waiting on condition</span><br><span class="line"></span><br><span class="line">JNI global references: 19</span><br></pre></td></tr></table></figure>

<h5 id="jcmd-pid-Thread-print-检测死锁"><a href="#jcmd-pid-Thread-print-检测死锁" class="headerlink" title="jcmd pid Thread.print 检测死锁"></a>jcmd pid Thread.print 检测死锁</h5><p>【在jconsole或者jvisualvm也可以看到】<br>运行程序com.twodragonlake.jvm.memory.DeadLock</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;jps</span><br><span class="line">19216</span><br><span class="line">4740 Main</span><br><span class="line">21592 Jps</span><br><span class="line">4536 Launcher</span><br><span class="line">14044 DeadLock</span><br><span class="line">14332 Launcher</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jcmd 14044 Thread.print</span><br><span class="line">14044:</span><br><span class="line">2019-04-30 17:00:02</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.111-b14 mixed mode):</span><br><span class="line"></span><br><span class="line">....略....</span><br><span class="line"></span><br><span class="line">【检测到死锁】</span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">&quot;thread2&quot;:</span><br><span class="line">  waiting to lock monitor 0x000000001c6b35f8 (object 0x000000076b345af0, a java.lang.Object),</span><br><span class="line">  which is held by &quot;thread1&quot;</span><br><span class="line">&quot;thread1&quot;:</span><br><span class="line">  waiting to lock monitor 0x000000001e801e68 (object 0x000000076b345b00, a java.lang.Object),</span><br><span class="line">  which is held by &quot;thread2&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">&quot;thread2&quot;:</span><br><span class="line">        at com.twodragonlake.jvm.memory.DeadLock$2.run(DeadLock.java:48)</span><br><span class="line">        - waiting to lock &lt;0x000000076b345af0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000076b345b00&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:745)</span><br><span class="line">&quot;thread1&quot;:</span><br><span class="line">        at com.twodragonlake.jvm.memory.DeadLock$1.run(DeadLock.java:37)</span><br><span class="line">        - waiting to lock &lt;0x000000076b345b00&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000076b345af0&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="查看堆栈信息："><a href="#查看堆栈信息：" class="headerlink" title="查看堆栈信息："></a>查看堆栈信息：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;jps</span><br><span class="line">19216</span><br><span class="line">19940 Launcher</span><br><span class="line">21700 Jps</span><br><span class="line">4740 Main</span><br><span class="line">3400 MyTest5</span><br><span class="line">4536 Launcher</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jcmd  3400   GC.heap_dump  e:dump.hprof</span><br><span class="line">3400:</span><br><span class="line">Heap dump file created</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>转储文件可以在jvisualvm里边查看。</p>
<h4 id="jcmd-PID-VM-system-properties-查看系统属性信息"><a href="#jcmd-PID-VM-system-properties-查看系统属性信息" class="headerlink" title="jcmd PID VM.system_properties 查看系统属性信息"></a>jcmd PID VM.system_properties 查看系统属性信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;jps</span><br><span class="line">19216</span><br><span class="line">3776 Jps</span><br><span class="line">19940 Launcher</span><br><span class="line">4740 Main</span><br><span class="line">3400 MyTest5</span><br><span class="line">4536 Launcher</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jcmd 3400 VM.system_properties</span><br><span class="line">3400:</span><br><span class="line">#Tue Apr 30 17:12:32 CST 2019</span><br><span class="line">java.runtime.name=Java(TM) SE Runtime Environment</span><br><span class="line">sun.boot.library.path=C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\bin</span><br><span class="line">java.vm.version=25.111-b14</span><br><span class="line">java.vm.vendor=Oracle Corporation</span><br><span class="line">java.vendor.url=http\://java.oracle.com/</span><br><span class="line">path.separator=;</span><br><span class="line">java.vm.name=Java HotSpot(TM) 64-Bit Server VM</span><br><span class="line">file.encoding.pkg=sun.io</span><br><span class="line">user.script=</span><br><span class="line">user.country=CN</span><br><span class="line">sun.java.launcher=SUN_STANDARD</span><br><span class="line">sun.os.patch.level=</span><br><span class="line">java.vm.specification.name=Java Virtual Machine Specification</span><br><span class="line">user.dir=E\:\\Study\\intelIde\\jvm_lecture</span><br><span class="line">java.runtime.version=1.8.0_111-b14</span><br><span class="line">java.awt.graphicsenv=sun.awt.Win32GraphicsEnvironment</span><br><span class="line">java.endorsed.dirs=C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\endorsed</span><br><span class="line">os.arch=amd64</span><br><span class="line">java.io.tmpdir=C\:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\</span><br><span class="line">line.separator=\r\n</span><br><span class="line">java.vm.specification.vendor=Oracle Corporation</span><br><span class="line">user.variant=</span><br><span class="line">os.name=Windows 10</span><br><span class="line">sun.jnu.encoding=GBK</span><br><span class="line">java.library.path=C\:\\Program Files\\Java\\jdk1.8.0_111\\bin;C\:\\WINDOWS\\Sun\\Java\\bin;C\:\\WINDOWS\\system32;C\:\\WINDOWS;C\:\\ProgramData\\DockerDesktop\\version-bin;C\:\\Program Files\\Docker\\Docker\\Resources\\bin;D\:\\Python\\Scripts\\;D\:\\Python\\;C\:\\ProgramData\\Oracle\\Java\\javapath;D\:\\SecureCRT\\;D\:\\apache-maven-3.3.9\\bin;C\:\\Program Files\\Java\\jdk1.8.0_111\\bin;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\bin;D\:\\RationalRose2007\\common;C\:\\windows\\system32\\;D\:\\UltraEdit;D\:\\firefox;C\:\\WINDOWS\\system32;C\:\\WINDOWS;C\:\\WINDOWS\\System32\\Wbem;C\:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;D\:\\Source Program\\gradle-3.2.1-bin\\gradle-3.2.1\\bin;D\:\\Anaconda;D\:\\Anaconda\\Scripts;D\:\\Anaconda\\Library\\bin;D\:\\Source Program\\nexus-2.14.3-02-bundle\\nexus-2.14.3-02\\bin\\jsw\\windows-x86-64;D\:\\protoc-3.3.0\\bin;D\:\\thrift0.10.0;D\:\\Git\\cmd;D\:\\nodejs\\;D\:\\kotlinc\\bin;C\:\\WINDOWS\\System32\\OpenSSH\\;D\:\\geth;D\:\\blockchain\\web3j-3.4.0\\bin;D\:\\Ruby22-x64\\bin;C\:\\Users\\Administrator\\AppData\\Local\\Microsoft\\WindowsApps;C\:\\Users\\Administrator\\AppData\\Local\\atom\\bin;C\:\\Users\\Administrator\\AppData\\Roaming\\npm;C\:\\Users\\Administrator\\AppData\\Local\\Microsoft\\WindowsApps;D\:\\Microsoft VS Code\\bin;.</span><br><span class="line">java.specification.name=Java Platform API Specification</span><br><span class="line">java.class.version=52.0</span><br><span class="line">sun.management.compiler=HotSpot 64-Bit Tiered Compilers</span><br><span class="line">os.version=10.0</span><br><span class="line">user.home=C\:\\Users\\Administrator</span><br><span class="line">user.timezone=</span><br><span class="line">java.awt.printerjob=sun.awt.windows.WPrinterJob</span><br><span class="line">file.encoding=UTF-8</span><br><span class="line">java.specification.version=1.8</span><br><span class="line">java.class.path=C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\charsets.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\deploy.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\ext\\access-bridge-64.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\ext\\cldrdata.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\ext\\dnsns.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\ext\\jaccess.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\ext\\jfxrt.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\ext\\localedata.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\ext\\nashorn.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\ext\\sunec.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\ext\\sunjce_provider.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\ext\\sunmscapi.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\ext\\sunpkcs11.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\ext\\zipfs.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\javaws.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\jce.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\jfr.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\jfxswt.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\jsse.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\management-agent.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\plugin.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\resources.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\rt.jar;E\:\\Study\\intelIde\\jvm_lecture\\out\\production\\classes;D\:\\gradlerepo\\caches\\modules-2\\files-2.1\\mysql\\mysql-connector-java\\5.1.34\\46deba4adbdb4967367b013cbc67b7f7373da60a\\mysql-connector-java-5.1.34.jar;D\:\\gradlerepo\\caches\\modules-2\\files-2.1\\cglib\\cglib\\3.2.8\\331c90f8cd3be5b2ee225354bed68862ba0fd3c8\\cglib-3.2.8.jar;D\:\\gradlerepo\\caches\\modules-2\\files-2.1\\org.ow2.asm\\asm\\6.2.1\\c01b6798f81b0fc2c5faa70cbe468c275d4b50c7\\asm-6.2.1.jar;D\:\\gradlerepo\\caches\\modules-2\\files-2.1\\org.apache.ant\\ant\\1.10.3\\88becdeb77cdd2457757b7268e1a10666c03d382\\ant-1.10.3.jar;D\:\\gradlerepo\\caches\\modules-2\\files-2.1\\org.apache.ant\\ant-launcher\\1.10.3\\9dd5189e7f561ca19833b4e3672720b9bc5cb2fe\\ant-launcher-1.10.3.jar;D\:\\IntelliJ IDEA 2018.2.4\\lib\\idea_rt.jar</span><br><span class="line">user.name=Administrator</span><br><span class="line">java.vm.specification.version=1.8</span><br><span class="line">sun.java.command=com.twodragonlake.jvm.memory.MyTest5</span><br><span class="line">java.home=C\:\\Program Files\\Java\\jdk1.8.0_111\\jre</span><br><span class="line">sun.arch.data.model=64</span><br><span class="line">user.language=zh</span><br><span class="line">java.specification.vendor=Oracle Corporation</span><br><span class="line">awt.toolkit=sun.awt.windows.WToolkit</span><br><span class="line">java.vm.info=mixed mode</span><br><span class="line">java.version=1.8.0_111</span><br><span class="line">java.ext.dirs=C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\ext;C\:\\WINDOWS\\Sun\\Java\\lib\\ext</span><br><span class="line">sun.boot.class.path=C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\resources.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\rt.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\sunrsasign.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\jsse.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\jce.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\charsets.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\lib\\jfr.jar;C\:\\Program Files\\Java\\jdk1.8.0_111\\jre\\classes</span><br><span class="line">java.vendor=Oracle Corporation</span><br><span class="line">file.separator=\\</span><br><span class="line">java.vendor.url.bug=http\://bugreport.sun.com/bugreport/</span><br><span class="line">sun.io.unicode.encoding=UnicodeLittle</span><br><span class="line">sun.cpu.endian=little</span><br><span class="line">sun.desktop=windows</span><br><span class="line">sun.cpu.isalist=amd64</span><br></pre></td></tr></table></figure>

<h4 id="查看jvm运行的版本信息：jcmd-PID-VM-version"><a href="#查看jvm运行的版本信息：jcmd-PID-VM-version" class="headerlink" title="查看jvm运行的版本信息：jcmd PID VM.version"></a>查看jvm运行的版本信息：jcmd PID VM.version</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;jps</span><br><span class="line">19216</span><br><span class="line">19940 Launcher</span><br><span class="line">4740 Main</span><br><span class="line">19688 Jps</span><br><span class="line">3400 MyTest5</span><br><span class="line">4536 Launcher</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jcmd 3400 VM.version</span><br><span class="line">3400:</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM version 25.111-b14</span><br><span class="line">JDK 8.0_111</span><br></pre></td></tr></table></figure>

<h4 id="jcmd-pid-VM-command-line-查看jvm启动命令行参数信息"><a href="#jcmd-pid-VM-command-line-查看jvm启动命令行参数信息" class="headerlink" title="jcmd pid VM.command_line 查看jvm启动命令行参数信息"></a>jcmd pid VM.command_line 查看jvm启动命令行参数信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;jps</span><br><span class="line">19216</span><br><span class="line">19940 Launcher</span><br><span class="line">4740 Main</span><br><span class="line">19688 Jps</span><br><span class="line">3400 MyTest5</span><br><span class="line">4536 Launcher</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jcmd 3400 VM.command_line</span><br><span class="line">3400:</span><br><span class="line">VM Arguments:</span><br><span class="line">jvm_args: -javaagent:D:\IntelliJ IDEA 2018.2.4\lib\idea_rt.jar=13535:D:\IntelliJ IDEA 2018.2.4\bin -Dfile.encoding=UTF-8</span><br><span class="line">java_command: com.twodragonlake.jvm.memory.MyTest5</span><br><span class="line">java_class_path (initial): C:\Program Files\Java\jdk1.8.0_111\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\jaccess.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\jfxrt.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\localedata.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\nashorn.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\sunec.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\sunjce_provider.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\sunmscapi.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\sunpkcs11.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\ext\zipfs.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\javaws.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\jfxswt.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\management-agent.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\plugin.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar;E:\Study\intelIde\jvm_lecture\out\production\classes;D:\gradlerepo\caches\modules-2\files-2.1\mysql\mysql-connector-java\5.1.34\46deba4adbdb4967367b013cbc67b7f7373da60a\mysql-connector-java-5.1.34.jar;D:\gradlerepo\caches\modules-2\files-2.1\cglib\cglib\3.2.8\331c90f8cd3be5b2ee225354bed68862ba0fd3c8\cglib-3.2.8.jar;D:\gradlerepo\caches\modules-2\files-2.1\org.ow2.asm\asm\6.2.1\c01b6798f81b0fc2c5faa70cbe468c275d4b50c7\asm-6.2.1.jar;D:\gradlerepo\caches\modules-2\files-2.1\org.apache.ant\ant\1.10.3\88becdeb77cdd2457757b7268e1a10666c03d382\ant-1.10.3.jar;D:\gradlerepo\caches\modules-2\files-2.1\org.apache.ant\ant-launcher\1.10.3\9dd5189e7f561ca</span><br><span class="line">Launcher Type: SUN_STANDARD</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="jstack-专门用来查看或者导出java线程堆栈的信息"><a href="#jstack-专门用来查看或者导出java线程堆栈的信息" class="headerlink" title="jstack 专门用来查看或者导出java线程堆栈的信息"></a>jstack 专门用来查看或者导出java线程堆栈的信息</h3><h4 id="用jstack检测死锁"><a href="#用jstack检测死锁" class="headerlink" title="用jstack检测死锁"></a>用jstack检测死锁</h4><p>运行程序com.twodragonlake.jvm.memory.DeadLock</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;jps</span><br><span class="line">1280 Jps</span><br><span class="line">19216</span><br><span class="line">10900 DeadLock</span><br><span class="line">4740 Main</span><br><span class="line">16840 Launcher</span><br><span class="line">4536 Launcher</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jstack 10900</span><br><span class="line">2019-04-30 17:26:40</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.111-b14 mixed mode):</span><br><span class="line"></span><br><span class="line">.... 略 ....</span><br><span class="line">【检测到死锁】</span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">&quot;thread2&quot;:</span><br><span class="line">  waiting to lock monitor 0x000000001ef45148 (object 0x000000076b345af0, a java.lang.Object),</span><br><span class="line">  which is held by &quot;thread1&quot;</span><br><span class="line">&quot;thread1&quot;:</span><br><span class="line">  waiting to lock monitor 0x000000001cdb34b8 (object 0x000000076b345b00, a java.lang.Object),</span><br><span class="line">  which is held by &quot;thread2&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">&quot;thread2&quot;:</span><br><span class="line">        at com.twodragonlake.jvm.memory.DeadLock$2.run(DeadLock.java:48)</span><br><span class="line">        - waiting to lock &lt;0x000000076b345af0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000076b345b00&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:745)</span><br><span class="line">&quot;thread1&quot;:</span><br><span class="line">        at com.twodragonlake.jvm.memory.DeadLock$1.run(DeadLock.java:37)</span><br><span class="line">        - waiting to lock &lt;0x000000076b345b00&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000076b345af0&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="jmc-Java-Mission-control-图形化展示"><a href="#jmc-Java-Mission-control-图形化展示" class="headerlink" title="jmc(Java Mission control)图形化展示"></a>jmc(Java Mission control)图形化展示</h3><p>执行jmc，左侧选择MyTest5的MBean服务器。右侧展示：<br><img src="/2019/04/30/jvm%E5%8E%9F%E7%90%86%EF%BC%8841%EF%BC%89jmap-jstat-jcmd-jmc-jhat%E8%AE%B2%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98/jmc1.png" alt="jmc1"><br>左侧选择飞行记录器，右侧展示：<br><img src="/2019/04/30/jvm%E5%8E%9F%E7%90%86%EF%BC%8841%EF%BC%89jmap-jstat-jcmd-jmc-jhat%E8%AE%B2%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98/jmc2.png" alt="jmc2"><br>jmc相比局isualvm和jconsole具有展示更多的系统信息，更加丰富。</p>
<p>我们运行MyTest4的程序(不断创建class的程序)，然后使用jmc观察meatspace的变化：<br><img src="/2019/04/30/jvm%E5%8E%9F%E7%90%86%EF%BC%8841%EF%BC%89jmap-jstat-jcmd-jmc-jhat%E8%AE%B2%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98/jmc3.png" alt="jmc3"><br>meatspace是一直在攀升的，当到达-XX:MaxMetaspaceSize&#x3D;200m设置的200m时，变化也就会停止。</p>
<h3 id="jhat-对转储文件进行展示分析"><a href="#jhat-对转储文件进行展示分析" class="headerlink" title="jhat 对转储文件进行展示分析"></a>jhat 对转储文件进行展示分析</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jhat e:dump.hprof</span><br><span class="line">Reading from e:dump.hprof...</span><br><span class="line">Dump file created Tue Apr 30 11:41:21 CST 2019</span><br><span class="line">Snapshot read, resolving...</span><br><span class="line">Resolving 257676 objects...</span><br><span class="line">Chasing references, expect 51 dots...................................................</span><br><span class="line">Eliminating duplicate references...................................................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 7000</span><br><span class="line">Server is ready.</span><br></pre></td></tr></table></figure>
<p>jhat启动了一个server，端口是7000，因此我们打开浏览器就能对齐进行访问看到我们要的结果。<br>打开<span class="exturl" data-url="aHR0cDovLzEyNy4wLjAuMTo3MDAwLw==">http://127.0.0.1:7000/<i class="fa fa-external-link-alt"></i></span> ，单击【class com.twodragonlake.jvm.memory.MyTest5下边的信息 】就可以打开MyTest5下边的信息<br>【Execute Object Query Language (OQL) query】可以使用OQL查询各种类或者对象的信息，比如【 select s from java.lang.String s where s.value.length &gt;&#x3D; 100】</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jmap jstat jcmd jmc jhat</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（42）JVM垃圾回收重要理论剖析以及算法分析与演示</title>
    <url>/2019/05/01/jvm%E5%8E%9F%E7%90%86%EF%BC%8842%EF%BC%89JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%87%8D%E8%A6%81%E7%90%86%E8%AE%BA%E5%89%96%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E6%BC%94%E7%A4%BA/</url>
    <content><![CDATA[<h3 id="内存区域的回顾"><a href="#内存区域的回顾" class="headerlink" title="内存区域的回顾"></a>内存区域的回顾</h3><p>垃圾收集器和java的内存分布有着紧密的联系，因此我们要对jvm的内存布局回顾一下，jvm的内存布局大致分为如下：</p>
<span id="more"></span>
<p><img src="/2019/05/01/jvm%E5%8E%9F%E7%90%86%EF%BC%8842%EF%BC%89JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%87%8D%E8%A6%81%E7%90%86%E8%AE%BA%E5%89%96%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E6%BC%94%E7%A4%BA/memarea.png" alt="memarea"><br><img src="/2019/05/01/jvm%E5%8E%9F%E7%90%86%EF%BC%8842%EF%BC%89JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%87%8D%E8%A6%81%E7%90%86%E8%AE%BA%E5%89%96%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E6%BC%94%E7%A4%BA/memarea1.png" alt="memarea1"></p>
<p>JVM运行时数据区域-例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void method()&#123;</span><br><span class="line">  Object obj = new Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>生成了2个部分的内存区域，1）obj这个引用变量，因为是方法内的变量，放到JVM Stack里面，2）真正Object class的实例对象，放到Heap里面。</li>
<li>上述的new 语句一共消耗12个bytes，JVM规定引用占用4个bytes（在JVM stack），而空对象是8个bytes（在 Heap）</li>
<li>方法结束后，对应Stack中的变量马上回收，但是Heap中的对象要等到GC来回收。</li>
</ul>
<h3 id="垃圾判断算法"><a href="#垃圾判断算法" class="headerlink" title="垃圾判断算法"></a>垃圾判断算法</h3><h4 id="引用计数算法（Reference-Counting）"><a href="#引用计数算法（Reference-Counting）" class="headerlink" title="引用计数算法（Reference Counting）"></a>引用计数算法（Reference Counting）</h4><ul>
<li>给对象添加一个引用计数器，当有一个地方引用它，计数器加1，当引用失效，计数器减一，任何时刻计数器为0的对象就是不可能再被使用的。</li>
<li>引用计数器算法无法解决对象循环引用的问题。<br><img src="/2019/05/01/jvm%E5%8E%9F%E7%90%86%EF%BC%8842%EF%BC%89JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%87%8D%E8%A6%81%E7%90%86%E8%AE%BA%E5%89%96%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E6%BC%94%E7%A4%BA/countreference.png" alt="countreference"><br>上图所示，A引用B，B引用A，但是外界引用都断了，不存在对“环”的引用，但是他们的引用计数器都是1，引用计数算法就不会对他们进行回收，会一直在内存中。</li>
</ul>
<h4 id="根搜索算法（Root-Tracing）"><a href="#根搜索算法（Root-Tracing）" class="headerlink" title="根搜索算法（Root Tracing）"></a>根搜索算法（Root Tracing）</h4><ul>
<li><p>在实际的生产语言中（java、C#等）都是使用根搜索算法判定对象是否存活</p>
</li>
<li><p>算法基本思路 就是通过一系列的称为“GC Roots”的点作为起始进行向下搜索，当一个对象到GC Roots没有任何引用链（<br>Reference Chain）相连，则证明此对象是不可用的</p>
</li>
<li><p>在java语言中，GCRoots 包括</p>
<ul>
<li>在JVM栈(帧中的本地变量)中的引用</li>
<li>方法区中的静态引用</li>
<li>JNI(即一般说的Native方法)中的引用</li>
</ul>
</li>
</ul>
<h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><ul>
<li>java虚拟机规范表示可以不要求虚拟机在这区实现GC，这区GC的“性价比”一般比较低。</li>
<li>在堆中，尤其是在新生代，常规应用进行一次GC一般可以回收70%-95%的空间，而方法区的FC效率远小于此。</li>
<li>当前的商业JVM都有实现方法区的GC，主要回收两部分内容：废弃常量与无用类。</li>
<li>类回收需要满足如下三个条件<ul>
<li>该类所有的实例都已经被GC，也就是JVM中不存在该Class的任何实例</li>
<li>加载该类的ClassLoader已经被GC</li>
<li>该类对应的java.lang.Class对象没有在任何地方呗引用，如不能在任何地方通过反射访问该类的方法。</li>
<li>在大量使用反射、冬天代理、CGlib等字节码框架、动态生成jsp以及OSGI这类频繁自定义一ClassLoader的场景都需要<br>JVM具备类卸载的支持以保证方法区不会溢出。</li>
</ul>
</li>
</ul>
<h3 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h3><ul>
<li>标记 -清楚算法(Mark-Sweep)</li>
<li>标记-整理算法(Mark-Compact)</li>
<li>复制算法(Copying)</li>
<li>分代算法(Generational)</li>
</ul>
<h4 id="标记-清楚算法-Mark-Sweep"><a href="#标记-清楚算法-Mark-Sweep" class="headerlink" title="标记 -清楚算法(Mark-Sweep)"></a>标记 -清楚算法(Mark-Sweep)</h4><ul>
<li><p>算法分为“标记”和”清除” 两个阶段，首先标记出所有需要回收的对象，然后回收所有需要回收的对象。</p>
</li>
<li><p>缺点</p>
<ul>
<li>效率问题，标记和清理两个过程效率都不高</li>
<li>空间问题，标记清理之后会产生大量不连续的内存碎片，空间碎片太多可能会导致后续使用中无法找到足够的连续内存而提前<br>触发另一次的垃圾搜索集动作。<br><img src="/2019/05/01/jvm%E5%8E%9F%E7%90%86%EF%BC%8842%EF%BC%89JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%87%8D%E8%A6%81%E7%90%86%E8%AE%BA%E5%89%96%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E6%BC%94%E7%A4%BA/runtimeStack-Heap.png" alt="runtimeStack-Heap.png"><br><img src="/2019/05/01/jvm%E5%8E%9F%E7%90%86%EF%BC%8842%EF%BC%89JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%87%8D%E8%A6%81%E7%90%86%E8%AE%BA%E5%89%96%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E6%BC%94%E7%A4%BA/runtimeStack-Heap1.png" alt="runtimeStack-Heap1.png"><br><img src="/2019/05/01/jvm%E5%8E%9F%E7%90%86%EF%BC%8842%EF%BC%89JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%87%8D%E8%A6%81%E7%90%86%E8%AE%BA%E5%89%96%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E6%BC%94%E7%A4%BA/runtimeStack-Heap2.png" alt="runtimeStack-Heap2.png"><br><img src="/2019/05/01/jvm%E5%8E%9F%E7%90%86%EF%BC%8842%EF%BC%89JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%87%8D%E8%A6%81%E7%90%86%E8%AE%BA%E5%89%96%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E6%BC%94%E7%A4%BA/runtimeStack-Heap3.png" alt="runtimeStack-Heap3.png"><br><img src="/2019/05/01/jvm%E5%8E%9F%E7%90%86%EF%BC%8842%EF%BC%89JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%87%8D%E8%A6%81%E7%90%86%E8%AE%BA%E5%89%96%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E6%BC%94%E7%A4%BA/runtimeStack-Heap4.png" alt="runtimeStack-Heap4.png"><br>最后阴影部分被回收掉，F、J、M不能被root trace到，因此也会被回收。</li>
</ul>
</li>
<li><p>效率不高，需要扫描所有对象，堆越大，GC越大。碎片越严重。</p>
</li>
<li><p>存在内存碎片问题，GC次数越多，</p>
</li>
</ul>
<h4 id="复制-Coping-搜集算法"><a href="#复制-Coping-搜集算法" class="headerlink" title="复制(Coping)搜集算法"></a>复制(Coping)搜集算法</h4><ul>
<li>将可用内存划分为两块，每次只是用其中的一块，当半区内存用完了，仅将还存活的对象复制到另外一块上面，然后就把原来的整块内存空间一次性清理掉</li>
<li>这样使得每次内存回收都是对整个半区的回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针、按顺序分配内存<br>就可以了，实现简单，运行效率高。<br>只是这种算法的代价是将内存缩小为原来的一半，代价昂贵。</li>
<li>现在的商业虚拟机中都是用了这一种收集算法回收新生代。</li>
<li>将内存分为一块较大的eden空间和快较少的survival空间，每次使用eden和其中一块survivor，当回收时将eden和survivor还存活的对象一次性<br>拷贝到另外一块survival空间上，然后清理掉eden和用过的survivor：</li>
<li>Oracle Hotspot虚拟机默认eden和survivor的大小比例是8:1，也就是每次只有10% 的内存是”浪费”的。</li>
<li>复制收集算法在对象存活率高的时候，效率有所下降。</li>
<li>如果不想浪费50%的空间，就需要有额外的空间进行分配担保用于应付半区内存中所有对象都有100%存活的极端情况，所以在老年代一般不能直接选用这种算法。<br><img src="/2019/05/01/jvm%E5%8E%9F%E7%90%86%EF%BC%8842%EF%BC%89JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%87%8D%E8%A6%81%E7%90%86%E8%AE%BA%E5%89%96%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E6%BC%94%E7%A4%BA/coping1.png" alt="coping1.png"><br><img src="/2019/05/01/jvm%E5%8E%9F%E7%90%86%EF%BC%8842%EF%BC%89JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%87%8D%E8%A6%81%E7%90%86%E8%AE%BA%E5%89%96%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E6%BC%94%E7%A4%BA/coping2.png" alt="coping2.png"><br><img src="/2019/05/01/jvm%E5%8E%9F%E7%90%86%EF%BC%8842%EF%BC%89JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%87%8D%E8%A6%81%E7%90%86%E8%AE%BA%E5%89%96%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E6%BC%94%E7%A4%BA/coping3.png" alt="coping3.png"><br><img src="/2019/05/01/jvm%E5%8E%9F%E7%90%86%EF%BC%8842%EF%BC%89JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%87%8D%E8%A6%81%E7%90%86%E8%AE%BA%E5%89%96%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E6%BC%94%E7%A4%BA/coping4.png" alt="coping4.png"><br><img src="/2019/05/01/jvm%E5%8E%9F%E7%90%86%EF%BC%8842%EF%BC%89JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%87%8D%E8%A6%81%E7%90%86%E8%AE%BA%E5%89%96%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E6%BC%94%E7%A4%BA/coping5.png" alt="coping5.png"></li>
<li>只需要扫描存活的对象，效率更高</li>
<li>不会产生碎片</li>
<li>需要浪费额外的内存作为复制区</li>
<li>复制的算法非常适合生命周期比较短的对象，每次GC总能回收大部分的对象，复制的开销比较小</li>
<li>根据IBM的专门研究，98%的java对象只会存活一个GC周期，对这些对象很适合用复制算法。而且不用1:1的划分工作区和复制区的空间</li>
</ul>
<h4 id="标记整理算法-Mark-Compact"><a href="#标记整理算法-Mark-Compact" class="headerlink" title="标记整理算法(Mark-Compact)"></a>标记整理算法(Mark-Compact)</h4><ul>
<li>标记过程仍然一样，但后续步骤不是进行直接清理，而是令所有存活的对象一端移动，然后直接清理掉这端边界以外的内存。<br><img src="/2019/05/01/jvm%E5%8E%9F%E7%90%86%EF%BC%8842%EF%BC%89JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%87%8D%E8%A6%81%E7%90%86%E8%AE%BA%E5%89%96%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E6%BC%94%E7%A4%BA/mark-compact1.png" alt="mark-compact1.png"></li>
<li>没有内存碎片</li>
<li>比Mark-Sweep耗费更多的时间进行compact</li>
</ul>
<h4 id="分代收集算法-Genaratinal-Collecting"><a href="#分代收集算法-Genaratinal-Collecting" class="headerlink" title="分代收集算法(Genaratinal Collecting)"></a>分代收集算法(Genaratinal Collecting)</h4><ul>
<li>当前商业虚拟机的垃圾收集都是采用“分代收集”算法根据对象不同存活周期将内存划分为几块</li>
<li>一般是把java堆分作新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法，譬如新生代每次GC都有大批量对象死去，<br>只有少量存活，那就选用复制算法只需要付出少量存活对象的复制成本就可以完成收集。</li>
</ul>
<p>综合前面几种GC算法的优缺点，针对不同生命周期的对象采用不同的GC算法。<br><img src="/2019/05/01/jvm%E5%8E%9F%E7%90%86%EF%BC%8842%EF%BC%89JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%87%8D%E8%A6%81%E7%90%86%E8%AE%BA%E5%89%96%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E6%BC%94%E7%A4%BA/choice.png" alt="choice.png"></p>
<ul>
<li><p>Hotspot JVM 6(jdk8之前)中共划分为三个代：年轻代(Ypung Generation)\老年代(Old Generation)和永久代(Permanent Generation)<br><img src="/2019/05/01/jvm%E5%8E%9F%E7%90%86%EF%BC%8842%EF%BC%89JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%87%8D%E8%A6%81%E7%90%86%E8%AE%BA%E5%89%96%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E6%BC%94%E7%A4%BA/choice1.png" alt="choice1.png"></p>
</li>
<li><p>年轻代</p>
<ul>
<li>新生代的对象都放在新生代，年轻代用复制算法进行GC（理论上年轻代的对象的生命周期非常短，所以适合复制算法）</li>
<li>年轻代分三个区。一个Eden区，两个Survivor区（可以通过参数设置Survivor个数）。对象在Eden区中生成，当Eden区满时，<br>此区的存活对象被复制到另外一个survivor区，当第二个Survivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制到老年代，2个Survivor<br>是完全对称，轮流替换。</li>
<li>Eden和2个Survivor的缺省比例是8:1:1，也就是10%的空间会被浪费，可以根据GC log的信息调整大小的比例。</li>
</ul>
</li>
<li><p>老年代</p>
<ul>
<li>存放了经过一次或多次GC还存活的对象</li>
<li>一般采用Mark-Sweep或者Mark-Compact算法进行GC</li>
<li>有多种垃圾收集器可以选择。每种垃圾收集器可以看作一个GC算法的具体实现。可以根据具体应用的需求选用合适的垃圾收集器<br>(追求吞吐量？追求最短的响应时间？)</li>
</ul>
</li>
<li><p><del>永久代</del></p>
<ul>
<li>比不属于堆(Heap)但是GC也会涉及到这个区域</li>
<li>存放了每个Class的结构信息，包括常量池、字段描述、方法描述、与垃圾收集要收集的对象关系不大。</li>
</ul>
<p><img src="/2019/05/01/jvm%E5%8E%9F%E7%90%86%EF%BC%8842%EF%BC%89JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%87%8D%E8%A6%81%E7%90%86%E8%AE%BA%E5%89%96%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E6%BC%94%E7%A4%BA/memstruct.png" alt="memstruct.png"></p>
</li>
</ul>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><ol>
<li>堆上分配<br>大多数情况在eden上分配，偶尔会直接在old上分配</li>
<li>栈上分配<br>原子类型的局部变量</li>
</ol>
<h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><ul>
<li>GC要做的是将那些dead的对象所占用的内存回收掉<ul>
<li>hotspot认为没有引用的对象是dead的</li>
<li>hotspot将引用分为四种：Strong、Soft、Week、Phantom<ul>
<li>Strong即默认通过Object o &#x3D; newObject()这种方式赋值的引用‘</li>
<li>Soft、Week、Phantom这三种则都是继承Reference</li>
</ul>
</li>
</ul>
</li>
<li>在Full GC时会对Reference类型的引用进行特殊处理<ul>
<li>Soft：内存不够时一定会被GC、长期不用也会被GC</li>
<li>Week：一定会被GC，当被mark为dead，会在ReferenceQueue中通知</li>
<li>Phantom：贝莱就没有引用，当jvm heap中释放时会通知</li>
</ul>
</li>
</ul>
<p>###垃圾收集算法<br><img src="/2019/05/01/jvm%E5%8E%9F%E7%90%86%EF%BC%8842%EF%BC%89JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%87%8D%E8%A6%81%E7%90%86%E8%AE%BA%E5%89%96%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E6%BC%94%E7%A4%BA/Recycling_algorithm.png" alt="Recycling_algorithm.png"></p>
<h3 id="GC的时机"><a href="#GC的时机" class="headerlink" title="GC的时机"></a>GC的时机</h3><ul>
<li>在分代模型的基础上，GC从时机上分为两种：scavenge GC和Full GC</li>
<li>Scavenge GC(Minor GC)<ul>
<li>触发时机：新对象生成时，Eden空间满了</li>
<li>理论上Eden区大多数对象会在Scavenge GC回收，复制算法的执行效率会很高，Scavenge GC时间比较短。</li>
</ul>
</li>
<li>Full GC<ul>
<li>对整个JVM进行整理，包括Young、Old和Perm</li>
<li>主要的触发时机：1）、old满了 2）Perm满了 3）system.gc()</li>
<li>效率很低，尽量减少Full GC。</li>
</ul>
</li>
</ul>
<h3 id="垃圾回收器的实现和选择"><a href="#垃圾回收器的实现和选择" class="headerlink" title="垃圾回收器的实现和选择"></a>垃圾回收器的实现和选择</h3><h4 id="垃圾回收器的实现和选择-1"><a href="#垃圾回收器的实现和选择-1" class="headerlink" title="垃圾回收器的实现和选择"></a>垃圾回收器的实现和选择</h4><ul>
<li>分代模型：GC的宏观愿景；</li>
<li>垃圾回收器：GC的具体实现</li>
<li>Hotspot JVM提供多种垃圾回收器，我们需要根据具体应用的需要采用不同的回收器</li>
<li>没有万能的垃圾回收器，每种垃圾回收器都有自己的适合场景</li>
</ul>
<h4 id="垃圾收集器的“并行”和“并发”"><a href="#垃圾收集器的“并行”和“并发”" class="headerlink" title="垃圾收集器的“并行”和“并发”"></a>垃圾收集器的“并行”和“并发”</h4><ul>
<li>并行(Parallel)：指多个收集器的线程同时工作，但是用户线程处于等待状态</li>
<li>并发(Concurrent):指收集器工作的同时，可以允许用户线程工作。<ul>
<li>并发不代表解决了GC停顿的问题，在关键的步骤还是要停顿。比如在收集器标记垃圾的时候但在清除垃圾的时候，用户线程可以和<br>GC线程并发执行。</li>
</ul>
</li>
</ul>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><ul>
<li>单线程收集器，收集时会暂停所有的工作线程(Stop The world，简称STW)，使用复制收集算法，虚拟机运行在client模式时的默认新生代收集器。</li>
<li>最早的收集器，单线程进行GC</li>
<li>new和Old Generation都可以使用</li>
<li>在新生代，采用复制算法；在老年代，采用Mark-comopact算法</li>
<li>因为是单线程GC，没有多线程切换的额外开销，简单实用</li>
<li>Hotspot Client模式缺省的收集器<br><img src="/2019/05/01/jvm%E5%8E%9F%E7%90%86%EF%BC%8842%EF%BC%89JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%87%8D%E8%A6%81%E7%90%86%E8%AE%BA%E5%89%96%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E6%BC%94%E7%A4%BA/serial.png" alt="serial.png"></li>
</ul>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><ul>
<li>ParNew收集器就是Serial的多线程版本，除了使用多个收集器线程外，其余行为包括算法、stw、对象分配规则、回收策略等都与serial收集器一模一样。</li>
<li>对应的这种收集器是虚拟机运行在Server模式的默认新生代收集器，在单CPU的环境中，ParNew收集器并不会比Serial<br>收集器有更好的效果。</li>
<li>使用复制算法(因为针对新生代)</li>
<li>只有在多CPU的环境下，效率才会比Serial收集器高</li>
<li>可以通过-XX:ParallelGCThreads来控制GC线程数的多少。需要结合具体CPU的个数</li>
<li>Server模式下新生代的缺省收集器</li>
</ul>
<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><ul>
<li>Parallel Scavenge收集器也是单线程收集器，也是使用复制算法，但它的对象分配规则与回收策略都与ParNew收集器<br>有所不同，它是以吞吐量最大化(即GC时间占用运行时间最小)为目标的收集器实现，它允许较长时间的STW换取总吞吐量最大化。</li>
</ul>
<h4 id="serial-Old收集器"><a href="#serial-Old收集器" class="headerlink" title="serial Old收集器"></a>serial Old收集器</h4><ul>
<li>serial Old是单线程收集器，使用标记-整理算法，是老年代的收集器</li>
</ul>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><ul>
<li>老年代版本吞吐量优先收集器，使用多线程和标记-整理算法，JVM 1.6提供，在此之前，新生代使用PS收集器的话，老年代除<br>serial OLd外别无选择，因为PS无法与CMS收集器配合工作</li>
<li>Parallel Scavenge在老年代的实现</li>
<li>在、具名 1.6才出现Parallel Old</li>
<li>采用多线程，Mark-compact算法</li>
<li>更注重吞吐量</li>
<li>Parallel Scavenge + Parallel Old &#x3D; 高吞吐量，但GC停顿可能不理想。<br><img src="/2019/05/01/jvm%E5%8E%9F%E7%90%86%EF%BC%8842%EF%BC%89JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%87%8D%E8%A6%81%E7%90%86%E8%AE%BA%E5%89%96%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E6%BC%94%E7%A4%BA/parallel_old.png" alt="parallel_old.png"></li>
</ul>
<h4 id="CMS收集器-Concurrent-Mark-Sweep"><a href="#CMS收集器-Concurrent-Mark-Sweep" class="headerlink" title="CMS收集器(Concurrent Mark Sweep)"></a>CMS收集器(Concurrent Mark Sweep)</h4><ul>
<li><p>CMS是一种以最短停顿时间为目标的收集器，使用CMS并不能达到GC效率最高(总体GC时间最小)，但它能尽可能降低GC时<br>服务的停顿时间，CMS收集器使用的是标记-清除算法</p>
</li>
<li><p>CMS以牺牲CPU资源的代价来减少用户线程的停顿。当CPU个数少的时候，有可能对吞吐量影响非常大。</p>
</li>
<li><p>CMS在并发清理的过程中，用户线程还在跑，这时候需要预留一部分空间给用户线程。</p>
</li>
<li><p>CMS用Mark-Sweep，会带来碎片问题，碎片过多的时候会容易频繁触发Ful GC</p>
</li>
</ul>
<h3 id="java内存泄露的经典原因"><a href="#java内存泄露的经典原因" class="headerlink" title="java内存泄露的经典原因"></a>java内存泄露的经典原因</h3><ul>
<li>对象定义在错误的范围内</li>
<li>异常(Exception)处理不当。</li>
<li>集合数据管理不当</li>
</ul>
<h4 id="对象定义在错误的范围-wrong-scope"><a href="#对象定义在错误的范围-wrong-scope" class="headerlink" title="对象定义在错误的范围(wrong scope)"></a>对象定义在错误的范围(wrong scope)</h4><ul>
<li><p>如果Foo实例对象的生命较长，会导致临时性内存泄露。（这里指的names变量其实只有临时作用）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line">  private String[] names;</span><br><span class="line">  public void doit(int length)&#123;</span><br><span class="line">    if(names == null || names.length &lt; length)</span><br><span class="line">      names = new String[length];</span><br><span class="line">    populate(names);</span><br><span class="line">    print(names);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>JVM 喜欢生命周期短的对象，这样做已经足够高效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Foo&#123;</span><br><span class="line"></span><br><span class="line">  public void doit(int length)&#123;</span><br><span class="line">      private String[] names =  new String[length];</span><br><span class="line">      populate(names);</span><br><span class="line">      print(names);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="异常处理不当"><a href="#异常处理不当" class="headerlink" title="异常处理不当"></a>异常处理不当</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Connection con = new DriverManager.getConnection(url,name,passwd);</span><br><span class="line">try&#123;</span><br><span class="line">  String sql = &quot;do a query sql&quot;;</span><br><span class="line">  PrepareStatement stmt = conn.PrepareStatement(sql);</span><br><span class="line">  ResultStatment rs = stmt.executeQuery();</span><br><span class="line">  while(re.next())&#123;</span><br><span class="line">    doSomeStuff();</span><br><span class="line">  &#125;</span><br><span class="line">  rs.close();</span><br><span class="line">  conn.close();</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">  //如果doSomeStuff()抛出异常</span><br><span class="line">  //rs.close和conn.close()不会被调用，</span><br><span class="line">  //会导致内存泄露和db连接泄露</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="集合数据管理不当"><a href="#集合数据管理不当" class="headerlink" title="集合数据管理不当"></a>集合数据管理不当</h4><ul>
<li>当使用Array-based的数据结构(ArrayList,HashMap等)时，尽量减少resize<ul>
<li>比如new ArrayList时，尽量估算size，在创建的时候把size确定</li>
<li>减少resize可以避免没有必要的array coping，gc碎片等问题</li>
</ul>
</li>
<li>如果一个List只需要顺序访问，不需要随机访问(Random Access),用LingkList代替ArrayList<ul>
<li>LinkList本质是是链表，不需要resize，但是适用于顺序访问。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>垃圾收集器</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（43）垃圾回收日志与算法深度解读</title>
    <url>/2019/05/12/jvm%E5%8E%9F%E7%90%86%EF%BC%8843%EF%BC%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%97%A5%E5%BF%97%E4%B8%8E%E7%AE%97%E6%B3%95%E6%B7%B1%E5%BA%A6%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<p>编写测试程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br><span class="line">/**</span><br><span class="line">jvm参数：</span><br><span class="line">* -verbose:gc 输出打印详细的GC日志</span><br><span class="line">* -Xms20M     堆空间最小值</span><br><span class="line">* -Xmx20M     堆空间最大值</span><br><span class="line">* -Xmn10M     堆空间新生代的大小</span><br><span class="line">* -XX:+PrintGCDetails  打印GC的详细的信息</span><br><span class="line">* -XX:SurvivorRatio=8  eden和survivor的比例是8:1</span><br><span class="line">*/</span><br><span class="line">public class MyTest1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int size = 1024 * 1024;</span><br><span class="line">        byte[] myAlloc1 = new byte[3 * size];</span><br><span class="line">        byte[] myAlloc2 = new byte[3 * size];</span><br><span class="line">        byte[] myAlloc3 = new byte[3 * size];</span><br><span class="line">        //byte[] myAlloc4 = new byte[3 * size];</span><br><span class="line">        System.out.println(&quot;hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 5431K-&gt;840K(9216K)] 5431K-&gt;3920K(19456K), 0.0027228 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">hello world</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 9216K, used 7304K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 8192K, 78% used [0x00000000ff600000,0x00000000ffc50230,0x00000000ffe00000)</span><br><span class="line">  from space 1024K, 82% used [0x00000000ffe00000,0x00000000ffed2020,0x00000000fff00000)</span><br><span class="line">  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)</span><br><span class="line"> ParOldGen       total 10240K, used 3080K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  object space 10240K, 30% used [0x00000000fec00000,0x00000000fef02010,0x00000000ff600000)</span><br><span class="line"> Metaspace       used 3471K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 384K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>** [GC (Allocation Failure) [PSYoungGen: 5431K-&gt;840K(9216K)] 5431K-&gt;3920K(19456K), 0.0027228 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] **<br>GC:表示是minor gc，如果是full gc就会显示“FULL GC”<br>Allocation Failure：表示失败原因，这里指的是内存分配失败，导致的GC<br>PSYoungGen：Parallel Scavenge 在新生代的收集器。<br> 5431K-&gt;840K(9216K)：垃圾回收之前在新生代存活的对象占据的空间是5431K -&gt; 垃圾回收之后在新生代存活对象所占据的容量是840K(新生代总的空间是9216K,即9M，一个eden是8M + 一个survivor是1M &#x3D; 9M)<br> 5431K-&gt;3920K(19456K)： 执行GC之前总的堆里边存活对象占据的大小是5431K -&gt; GC执行完之后整个堆存活对象占据的大小是3920K(整个堆的容量是19456K，即19M，新生代浪费了一个survivor，所以是20M - 1M  &#x3D; 19M)。<br>0.0027228 secs：指的是本次执行GC耗费的时间是  0.0027228秒。<br>[Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs]：用户空间用了0.00秒，内核空间用了0.00秒，实际用的时间是0.00秒。</p>
<p>** PSYoungGen      total 9216K, used 7304K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) **</p>
<p>Parallel Scavenge 在新生代，一共新生代的大小是9216K，已经使用了7304K。</p>
<p>** eden space 8192K, 78% used [0x00000000ff600000,0x00000000ffc50230,0x00000000ffe00000) **<br>eden空间是8192K，使用了78%的eden空间。</p>
<p>** from space 1024K, 82% used [0x00000000ffe00000,0x00000000ffed2020,0x00000000fff00000) **<br>from空间是1024K，使用了82%的from survivor空间。</p>
<p>** to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000) **<br>to空间是1024K，使用了0%的to survivor空间。</p>
<p>**  ParOldGen       total 10240K, used 3080K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) **<br>老年代的收集器Parallel old，parOld收集器，老年代占据的空间是10240K，即10M，已经使用了3080K。<br>5431K - 840K &#x3D; 4591K &#x2F;&#x2F;指的是新生代释放的空间<br>5431K - 3920K &#x3D; 1511K &#x2F;&#x2F;指的是整个堆释放的空间，1511K是真正从整个堆里边彻底消失的的空间。</p>
<p>4591K -  1511K &#x3D; 3080K， 3080K就是ParOldGen已经使用的空间大小，新生代释放的空间4591K一部分是彻底从堆里边消失的，另一部分去了老年代，那我们用新生代释放的空间4591K减去彻底从堆里边释放的1511K剩下的就是从新生代晋升到老年代的对象，这部分晋升的对象占据的空间就是老年代的使用空间3080K。</p>
<p>打开注释的【byte[] myAlloc4 &#x3D; new byte[3 * size];】运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 5431K-&gt;840K(9216K)] 5431K-&gt;3920K(19456K), 0.0028338 secs] [Times: user=0.08 sys=0.02, real=0.00 secs]</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 7222K-&gt;792K(9216K)] 10302K-&gt;10016K(19456K), 0.0051217 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 792K-&gt;0K(9216K)] [ParOldGen: 9224K-&gt;9894K(10240K)] 10016K-&gt;9894K(19456K), [Metaspace: 3438K-&gt;3438K(1056768K)], 0.0064424 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]</span><br><span class="line">hello world</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 9216K, used 3501K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 8192K, 42% used [0x00000000ff600000,0x00000000ff96b7e8,0x00000000ffe00000)</span><br><span class="line">  from space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)</span><br><span class="line">  to   space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)</span><br><span class="line"> ParOldGen       total 10240K, used 9894K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  object space 10240K, 96% used [0x00000000fec00000,0x00000000ff5a9a48,0x00000000ff600000)</span><br><span class="line"> Metaspace       used 3460K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 383K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>** [Full GC (Ergonomics) [PSYoungGen: 792K-&gt;0K(9216K)] [ParOldGen: 9224K-&gt;9894K(10240K)] 10016K-&gt;9894K(19456K), [Metaspace: 3438K-&gt;3438K(1056768K)], 0.0064424 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] **</p>
<p>Ergonomics:失败原因是Ergonomics。<br>PSYoungGen：新生代的收集器。<br>[PSYoungGen: 792K-&gt;0K(9216K)]：新生代收集之前对象占用的空间是792K，回收之后对象占用的空间是0K，新生代一共9216K(9M)。<br>[ParOldGen: 9224K-&gt;9894K(10240K)]：老年代的收集器ParOldGen，回收之前老年代对象占用空间是9224K，回收之后老年代对象占用空间是<br>  9894K(没有减少反而增多，是因为新生代晋升到老年代的对象)，老年代总共的大小是10240K(10M)。<br>10016K-&gt;9894K(19456K)：整个堆空间里边回收之前对象占用的空间是10016K，回收之后对象占用的空间是9894K，整个堆大小是19456K。<br>[Metaspace: 3438K-&gt;3438K(1056768K)]：元空间回收之前对象占用空间是3438K，回收之后占用的空间是3438K，即没有变化，元空间总共大小是1056768K。<br> 0.0064424 secs：本次 Full GC执行花费时间是 0.0064424 secs。</p>
<p>**  ParOldGen       total 10240K, used 9894K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) **<br>老年的收集器，总共空间是10240K，已经使用了9894K，和上面的Full GC收集完毕之后对象占用的空间9894K是一致的。</p>
<p>现在我们修改下程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * -verbose:gc 输出打印详细的GC日志</span><br><span class="line"> * -Xms20M     堆空间最小值</span><br><span class="line"> * -Xmx20M     堆空间最大值</span><br><span class="line"> * -Xmn10M     堆空间新生代的大小</span><br><span class="line"> * -XX:+PrintGCDetails  打印GC的详细的信息</span><br><span class="line"> * -XX:SurvivorRatio=8  eden和survivor的比例是8:1</span><br><span class="line"> *</span><br><span class="line"> * @author : CeaserWang</span><br><span class="line"> * @version : 1.0</span><br><span class="line"> * @since : 2019/5/12 14:26</span><br><span class="line"> */</span><br><span class="line">public class MyTest1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int size = 1024 * 1024;</span><br><span class="line">        byte[] myAlloc1 = new byte[3 * size];</span><br><span class="line">        byte[] myAlloc2 = new byte[3 * size];</span><br><span class="line">        byte[] myAlloc3 = new byte[4 * size];</span><br><span class="line">        byte[] myAlloc4 = new byte[4 * size];</span><br><span class="line">        System.out.println(&quot;hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>myAlloc3和myAlloc4改成4倍的size(之前是倍的size)，然后运行程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 5431K-&gt;872K(9216K)] 5431K-&gt;3952K(19456K), 0.0024476 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">hello world</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 9216K, used 8360K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 8192K, 91% used [0x00000000ff600000,0x00000000ffd50230,0x00000000ffe00000)</span><br><span class="line">  from space 1024K, 85% used [0x00000000ffe00000,0x00000000ffeda020,0x00000000fff00000)</span><br><span class="line">  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)</span><br><span class="line"> ParOldGen       total 10240K, used 7176K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  object space 10240K, 70% used [0x00000000fec00000,0x00000000ff302020,0x00000000ff600000)</span><br><span class="line"> Metaspace       used 3488K, capacity 4498K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 387K, capacity 390K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>我们加大了内存申请的大小反而没有出现Full GC，如果是3倍的size会出现Full GC，这是什么原因？</p>
<p>myAlloc1、myAlloc2如果能在新生代存放，新生代是10M的空间，这时候myAlloc3来了，之前已被myAlloc1和myAlloc2占据了6M的新生代空间，<br>这次4M的myAlloc3肯定无法在新生代存放，这种情况JVM的策略是把myAlloc3直接放到老年代，myAlloc3加myAlloc4是8M空间，老年代是10M的<br>空间大小，是能够存放的。所以没有发生Full GC。</p>
<p>另外jdk1.8新生代和老年代默认收集器：<br>PSYoungGen: Parallel Scavenge(新生代垃圾收集器)<br>ParOldGen：Parallel Old (老年代垃圾收集器)</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>垃圾收集器日志</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（44）阈值和垃圾收集器类型对于对象分配的影响实战分析</title>
    <url>/2019/05/18/jvm%E5%8E%9F%E7%90%86%EF%BC%8844%EF%BC%89%E9%98%88%E5%80%BC%E5%92%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%B1%BB%E5%9E%8B%E5%AF%B9%E4%BA%8E%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E7%9A%84%E5%BD%B1%E5%93%8D%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="命令介绍："><a href="#命令介绍：" class="headerlink" title="命令介绍："></a>命令介绍：</h3><p>java -XX:+PrintCommandLineFlags -version</p>
<span id="more"></span>

<p>打印jvm默认启动参数，以及jvm的版本号<br>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:InitialHeapSize=267006656 -XX:MaxHeapSize=4272106496 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br><span class="line">java version &quot;1.8.0_111&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_111-b14)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.111-b14, mixed mode)</span><br></pre></td></tr></table></figure>

<p>-XX:InitialHeapSize&#x3D;267006656：初始的堆大小是267006656，单位是字节。<br>-XX:MaxHeapSize&#x3D;4272106496:最大的堆大小是4272106496字节。<br>-XX:+PrintCommandLineFlags：命令本身。<br>-XX:+UseCompressedClassPointers：使用压缩的类指针。<br>-XX:+UseCompressedOops：表示从32位的jvm迁移到64位的jvm的时候会有指针膨胀，如果开启这个参数，会对一些指针不去膨胀，减少空间的占用<br>-XX:+UseParallelGC：当我们不去指定新生代和老年代的收集器的时候，新生代垃圾收集器默认是 Parallel Scavenge，老年代垃圾收集器是Parallel Old。</p>
<h4 id="程序演示"><a href="#程序演示" class="headerlink" title="程序演示"></a>程序演示</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> -verbose:gc</span><br><span class="line"> -Xms20M</span><br><span class="line"> -Xmx20M</span><br><span class="line"> -Xmn10M</span><br><span class="line"> -XX:+PrintGCDetails</span><br><span class="line"> -XX:SurvivorRatio=8</span><br><span class="line"> -XX:PretenureSizeThreshold=4194304 当在新生代创建的对象大小是</span><br><span class="line"> 4M的时候，对象直接在老年代分配。</span><br><span class="line"> */</span><br><span class="line">public class MyTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int size = 1024 * 1024;</span><br><span class="line">        byte[] myAlloc1 = new byte[5 * size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 9216K, used 7643K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 8192K, 93% used [0x00000000ff600000,0x00000000ffd76f38,0x00000000ffe00000)</span><br><span class="line">  from space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)</span><br><span class="line">  to   space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)</span><br><span class="line"> ParOldGen       total 10240K, used 0K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  object space 10240K, 0% used [0x00000000fec00000,0x00000000fec00000,0x00000000ff600000)</span><br><span class="line"> Metaspace       used 3482K, capacity 4498K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 387K, capacity 390K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>我们可以看到我们分配了一个4M大小的对象，具名参数-XX:PretenureSizeThreshold&#x3D;4194304 表示对象大小超过4M直接进入老年代，但是我们程序运行的jvm日志表示的是【PSYoungGen      total 9216K, used 7643K】和【ParOldGen       total 10240K, used 0K】，对象还是在新生代，对象没有直接进入老年代。</p>
<p>其实这里PretenureSizeThreshold参数需要搭配串行收集器，需要指定收集器为-XX:UseSerialGC。现在程序的jvm参数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-verbose:gc</span><br><span class="line">-Xms20M</span><br><span class="line">-Xmx20M</span><br><span class="line">-Xmn10M</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:SurvivorRatio=8</span><br><span class="line">-XX:PretenureSizeThreshold=4194304</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行程序结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 2523K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,  30% used [0x00000000fec00000, 0x00000000fee76f28, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</span><br><span class="line"> tenured generation   total 10240K, used 5120K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,  50% used [0x00000000ff600000, 0x00000000ffb00010, 0x00000000ffb00200, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 3475K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 385K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>**  tenured generation   total 10240K, used 5120K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) **<br>5120K就是myAlloc1的大小，PretenureSizeThreshold参数生效。因此PretenureSizeThreshold参数要和串行收集器使用。</p>
<p>现在去掉【-XX:+UseSerialGC】启动参数，然后修改程序为：</p>
<figure class="highlight plaintext"><figcaption><span>class MyTest2 &#123;</span></figcaption><table><tr><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int size = 1024 * 1024;</span><br><span class="line">        byte[] myAlloc1 = new byte[8 * size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 2523K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,  30% used [0x00000000fec00000, 0x00000000fee76f28, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</span><br><span class="line"> tenured generation   total 10240K, used 8192K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,  80% used [0x00000000ff600000, 0x00000000ffe00010, 0x00000000ffe00200, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 3489K, capacity 4498K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 387K, capacity 390K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>即创建一个8M的数组，eden是8M，肯定无法存放，这个时候对象会直接进入老年代(注意不是PretenureSizeThreshold的作用)，可以看到【 tenured generation】的已使用空间是8192K(8M).</p>
<p>接下来我们把程序修改为：</p>
<figure class="highlight plaintext"><figcaption><span>class MyTest2 &#123;</span></figcaption><table><tr><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int size = 1024 * 1024;</span><br><span class="line">        byte[] myAlloc1 = new byte[10 * size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对象大小改为10M运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [Tenured: 0K-&gt;705K(10240K), 0.0056446 secs] 2359K-&gt;705K(19456K), [Metaspace: 3374K-&gt;3374K(1056768K)], 0.0057131 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]</span><br><span class="line">[Full GC (Allocation Failure) [Tenured: 705K-&gt;687K(10240K), 0.0016112 secs] 705K-&gt;687K(19456K), [Metaspace: 3374K-&gt;3374K(1056768K)], 0.0016357 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at com.twodragonlake.jvm.gc.MyTest2.main(MyTest2.java:32)</span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 410K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,   5% used [0x00000000fec00000, 0x00000000fec66800, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</span><br><span class="line"> tenured generation   total 10240K, used 687K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,   6% used [0x00000000ff600000, 0x00000000ff6abf30, 0x00000000ff6ac000, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 3483K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 387K, capacity 390K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>从运行结果上看最终是对象分配失败，出现了oom，这个对象在新生代和老年代都是无法存放的。</p>
<p>修改程序的jvm参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-verbose:gc</span><br><span class="line">-Xms20M</span><br><span class="line">-Xmx20M</span><br><span class="line">-Xmn10M</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:SurvivorRatio=8</span><br><span class="line">-XX:PretenureSizeThreshold=4194304</span><br><span class="line">-XX:+UseSerialGC</span><br></pre></td></tr></table></figure>
<p>程序也做修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int size = 1024 * 1024;</span><br><span class="line">        byte[] myAlloc1 = new byte[5 * size];</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加入线程程等待是为了我们在运行程序之后要运行jvisualvm。<br>然后运行jvisualvm。<br><img src="/2019/05/18/jvm%E5%8E%9F%E7%90%86%EF%BC%8844%EF%BC%89%E9%98%88%E5%80%BC%E5%92%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%B1%BB%E5%9E%8B%E5%AF%B9%E4%BA%8E%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E7%9A%84%E5%BD%B1%E5%93%8D%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90/gc1.png" alt="gc1.png"><br>由于jvisualvm的监听要在jvm里边消耗内存，所以我们的程序会打印minor gc日志：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 8192K-&gt;1024K(9216K), 0.0108187 secs] 13312K-&gt;6888K(19456K), 0.0108706 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]</span><br><span class="line">[GC (Allocation Failure) [DefNew: 9216K-&gt;511K(9216K), 0.0091469 secs] 15080K-&gt;7397K(19456K), 0.0091785 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]</span><br><span class="line">[GC (Allocation Failure) [DefNew: 8703K-&gt;489K(9216K), 0.0019780 secs] 15589K-&gt;7375K(19456K), 0.0020053 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">[GC (Allocation Failure) [DefNew: 8681K-&gt;622K(9216K), 0.0024485 secs] 15567K-&gt;7508K(19456K), 0.0024825 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">[GC (Allocation Failure) [DefNew: 8814K-&gt;379K(9216K), 0.0038152 secs] 15700K-&gt;7627K(19456K), 0.0038642 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">[GC (Allocation Failure) [DefNew: 8571K-&gt;514K(9216K), 0.0017876 secs] 15819K-&gt;7762K(19456K), 0.0018148 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></table></figure>
<p>对应的jvisualvm的堆曲线会发生下跌。</p>
<h4 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc();"></a>System.gc();</h4><p>通知jvm是时候进行垃圾回收了，但是jvm不一定去执行垃圾回收，哪System.gc()的意义是什么呢？垃圾回收是只有在进行对象创建的时候jvm才会去进行垃圾回收，而System.gc()是在jvm中没有对象正在创建的时间点去执行垃圾回收，这个时候调用System.gc()jvm也会去进行响应，这就是System.gc()的作用所在。</p>
<h4 id="jmc"><a href="#jmc" class="headerlink" title="jmc"></a>jmc</h4><p>上面程序运行的时候我们可以使用jmc查看jvm的使用情况：<br><img src="/2019/05/18/jvm%E5%8E%9F%E7%90%86%EF%BC%8844%EF%BC%89%E9%98%88%E5%80%BC%E5%92%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%B1%BB%E5%9E%8B%E5%AF%B9%E4%BA%8E%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E7%9A%84%E5%BD%B1%E5%93%8D%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90/gc2.png" alt="gc2.png"><br>从图中可以看到metaspace的使用量快满了的时候jvm会进行一次gc。<br>同时也可以可以查看jvm的启动参数：<br><img src="/2019/05/18/jvm%E5%8E%9F%E7%90%86%EF%BC%8844%EF%BC%89%E9%98%88%E5%80%BC%E5%92%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%B1%BB%E5%9E%8B%E5%AF%B9%E4%BA%8E%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E7%9A%84%E5%BD%B1%E5%93%8D%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90/gc3.png" alt="gc3.png"></p>
<h4 id="jmc的飞行器"><a href="#jmc的飞行器" class="headerlink" title="jmc的飞行器"></a>jmc的飞行器</h4><p><img src="/2019/05/18/jvm%E5%8E%9F%E7%90%86%EF%BC%8844%EF%BC%89%E9%98%88%E5%80%BC%E5%92%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%B1%BB%E5%9E%8B%E5%AF%B9%E4%BA%8E%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E7%9A%84%E5%BD%B1%E5%93%8D%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90/gc4.png" alt="gc4.png"><br><img src="/2019/05/18/jvm%E5%8E%9F%E7%90%86%EF%BC%8844%EF%BC%89%E9%98%88%E5%80%BC%E5%92%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%B1%BB%E5%9E%8B%E5%AF%B9%E4%BA%8E%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E7%9A%84%E5%BD%B1%E5%93%8D%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90/gc5.png" alt="gc5.png"></p>
<h4 id="jcmd查看jvm启动参数"><a href="#jcmd查看jvm启动参数" class="headerlink" title="jcmd查看jvm启动参数"></a>jcmd查看jvm启动参数</h4> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;jps</span><br><span class="line">10612 Jps</span><br><span class="line">4324 Launcher</span><br><span class="line">17820</span><br><span class="line">8860 RemoteMavenServer</span><br><span class="line">9884</span><br><span class="line">9932 MyTest2</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;jcmd 9932 VM.flags</span><br><span class="line">9932:</span><br><span class="line">-XX:CICompilerCount=4 -XX:InitialHeapSize=20971520 -XX:MaxHeapSize=20971520 -XX:MaxNewSize=10485760 -XX:MinHeapDeltaBytes=196608 -XX:NewSize=10485760 -XX:OldSize=10485760 -XX:PretenureSizeThreshold=4194304 -XX:+PrintGC -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:-UseLargePagesIndividualAllocation -XX:+UseSerialGC</span><br></pre></td></tr></table></figure>

<h3 id="MaxTenuringThreshold与阈值的动态调整详解"><a href="#MaxTenuringThreshold与阈值的动态调整详解" class="headerlink" title="MaxTenuringThreshold与阈值的动态调整详解"></a>MaxTenuringThreshold与阈值的动态调整详解</h3><p>编写程序:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * jvm参数：</span><br><span class="line"> -verbose:gc</span><br><span class="line"> -Xms20M</span><br><span class="line"> -Xmx20M</span><br><span class="line"> -Xmn10M</span><br><span class="line"> -XX:+PrintGCDetails</span><br><span class="line"> -XX:+PrintCommandLineFlags</span><br><span class="line"> -XX:MaxTenuringThreshold=5 在可以自动调节对象晋升(promote)到老年代阈值的GC中，设置该阈值的最大值， 对象晋升到老年代的最大存活年龄</span><br><span class="line"> 这里是理想的情况下，当对象年龄达到6的时候，对象晋升到 老年代，但是jvm会根据当前新生代的情况可能在对象年龄到了2就会晋升到老年代</span><br><span class="line"> jvm会有一个自动调节的机制。但是最大年龄不会超过5的，对象年龄大于5的肯定会被晋升到老年代，但是小于5也有可能会被提前晋升到老年代。</span><br><span class="line"> 该参数默认值是15，CMS中默认值是6，G1中默认值是15(在JJVM中，，该数值是由4个bit来表示的，所以最大值是1111，即15)</span><br><span class="line"></span><br><span class="line"> -XX:+PrintTenuringDistribution 打印的作用，打印年龄为1的对象的是那些，对象年龄为2的是那些等信息的打印。</span><br><span class="line"></span><br><span class="line"> 经历过多次GC，存活的对象会在From Survivor和To Survivor之间来回存放，</span><br><span class="line"> 而这里面的一个前提是这两个空间有足够得到大小来存放这些数据，在GC算法中会计算每个对象年龄的大小，如果达到某个年龄后发现总大小</span><br><span class="line"> 已经大于Survivor（其中一个Survivor）空间的50%，这个时候就需要调整阈值，不能再继续等到默认的15次后才完成晋升，因为这样会导致Survivor空间不足，所以</span><br><span class="line"> 需要调整阈值，让这些存活对象尽快完成晋升。</span><br><span class="line"> */</span><br><span class="line">public class MyTest3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int size = 1024 * 1024;</span><br><span class="line">        byte[] myAlloc1 = new byte[2 * size];</span><br><span class="line">        byte[] myAlloc2 = new byte[2 * size];</span><br><span class="line">        byte[] myAlloc3 = new byte[2 * size];</span><br><span class="line">        byte[] myAlloc4 = new byte[2 * size];</span><br><span class="line">        byte[] myAlloc5 = new byte[2 * size];</span><br><span class="line">        byte[] myAlloc6 = new byte[2 * size];</span><br><span class="line">        System.out.println(&quot;hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序得到结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:InitialHeapSize=20971520 -XX:InitialTenuringThreshold=5 -XX:MaxHeapSize=20971520 -XX:MaxNewSize=10485760 -XX:MaxTenuringThreshold=5 -XX:NewSize=10485760 -XX:+PrintCommandLineFlags -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintTenuringDistribution -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br><span class="line">【PrintCommandLineFlags参数启用打印上述信息】</span><br><span class="line">[GC (Allocation Failure)</span><br><span class="line">Desired survivor size 1048576 bytes, new threshold 5 (max 5)</span><br><span class="line">[PSYoungGen: 6455K-&gt;840K(9216K)] 6455K-&gt;4944K(19456K), 0.0036345 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">[GC (Allocation Failure) --[PSYoungGen: 7223K-&gt;7223K(9216K)] 11327K-&gt;15423K(19456K), 0.0039655 secs] [Times: user=0.11 sys=0.00, real=0.00 secs]</span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 7223K-&gt;2728K(9216K)] [ParOldGen: 8200K-&gt;8193K(10240K)] 15423K-&gt;10921K(19456K), [Metaspace: 3467K-&gt;3467K(1056768K)], 0.0059518 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]</span><br><span class="line">hello world</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 9216K, used 5216K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 8192K, 63% used [0x00000000ff600000,0x00000000ffb181b0,0x00000000ffe00000)</span><br><span class="line">  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)</span><br><span class="line">  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)</span><br><span class="line"> ParOldGen       total 10240K, used 8193K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  object space 10240K, 80% used [0x00000000fec00000,0x00000000ff400500,0x00000000ff600000)</span><br><span class="line"> Metaspace       used 3476K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 385K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>** Desired survivor size 1048576 bytes, new threshold 5 (max 5) **<br> new threshold 5 是动态计算出来的，max 5是参数-XX:MaxTenuringThreshold&#x3D;5的设定。</p>
<p>** Desired survivor size 1048576 bytes **<br>1048576是1M，因为我们的设置的survivor的大小就是1M。</p>
<p>**  ParOldGen       total 10240K, used 8193K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) **<br>代表新生代已经有对象晋升到老年代了。</p>
<h4 id="MaxTenuringThreshold实例讲解"><a href="#MaxTenuringThreshold实例讲解" class="headerlink" title="MaxTenuringThreshold实例讲解"></a>MaxTenuringThreshold实例讲解</h4><p>编程程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> -verbose:gc</span><br><span class="line"> -Xmx200M</span><br><span class="line"> -Xmn50M</span><br><span class="line"> -XX:TargetSurvivorRatio=60 表示Survivor空间存活的对象超过60%的时候，就会重新计算阈值 MaxTenuringThreshold</span><br><span class="line"> -XX:+PrintTenuringDistribution</span><br><span class="line"> -XX:+PrintGCDetails</span><br><span class="line"> -XX:+PrintGCDateStamps 打印GC的时间戳</span><br><span class="line"> -XX:+UseConcMarkSweepGC 老年代使用CMS收集器</span><br><span class="line"> -XX:+UseParNewGC 新生代使用Paralle new GC</span><br><span class="line"> -XX:MaxTenuringThreshold=3  阈值设置为3，理想情况对象超过三代就会晋升到老年代</span><br><span class="line"> * @author : CeaserWang</span><br><span class="line"> * @version : 1.0</span><br><span class="line"> * @since : 2019/5/18 17:43</span><br><span class="line"> */</span><br><span class="line">public class MyTest4 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        byte [] byte_1 = new byte[1024 * 1024];</span><br><span class="line">        byte [] byte_2 = new byte[1024 * 1024];</span><br><span class="line">        myGc();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        System.out.println(&quot;111111------------------------------------------------------------&quot;);</span><br><span class="line">        myGc();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        System.out.println(&quot;222222------------------------------------------------------------&quot;);</span><br><span class="line">        myGc();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        System.out.println(&quot;333333------------------------------------------------------------&quot;);</span><br><span class="line">        myGc();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        System.out.println(&quot;444444------------------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        byte [] byte_3 = new byte[1024 * 1024];</span><br><span class="line">        byte [] byte_4 = new byte[1024 * 1024];</span><br><span class="line">        byte [] byte_5 = new byte[1024 * 1024];</span><br><span class="line"></span><br><span class="line">        myGc();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        System.out.println(&quot;555555------------------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        myGc();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        System.out.println(&quot;666666------------------------------------------------------------&quot;);</span><br><span class="line">        System.out.println(&quot;hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private static void myGc()&#123;</span><br><span class="line">        for(int i= 0;i &lt;= 40;i++)&#123;</span><br><span class="line">            byte [] byteArray = new byte[ 1024 * 1024];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>程序运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2019-05-18T18:06:40.235+0800: [GC (Allocation Failure) 2019-05-18T18:06:40.235+0800: [ParNew</span><br><span class="line">Desired survivor size 3145728 bytes, new threshold 3 (max 3)</span><br><span class="line">- age   1:    2831800 bytes,    2831800 total</span><br><span class="line">: 39973K-&gt;2814K(46080K), 0.0017638 secs] 39973K-&gt;2814K(199680K), 0.0019458 secs] [Times: user=0.00 sys=0.02, real=0.00 secs]</span><br><span class="line">111111------------------------------------------------------------</span><br><span class="line">【解释】：</span><br><span class="line">[ParNew Desired survivor size 3145728 bytes：3145728 bytes 是3M，新生代空间是0M，eden：from: to = 40 : 5 : 5 ,由于我们的程序指定了-XX:TargetSurvivorRatio=60，所以 5M * 60% ≈ 3M。</span><br><span class="line">- age   1:    2831800 bytes,    2831800 total： 年龄是1的对象个数是2831800个。</span><br><span class="line">后面的是回收的处理， 39973K-&gt;2814K(46080K)，其中46080K是大约45M，eden是40M，survivor是5M，加起来一共是45M。</span><br><span class="line"></span><br><span class="line">2019-05-18T18:06:41.240+0800: [GC (Allocation Failure) 2019-05-18T18:06:41.240+0800: [ParNew</span><br><span class="line">Desired survivor size 3145728 bytes, new threshold 3 (max 3)</span><br><span class="line">- age   1:        352 bytes,        352 total</span><br><span class="line">- age   2:    2823392 bytes,    2823744 total</span><br><span class="line">: 43544K-&gt;2974K(46080K), 0.0020563 secs] 43544K-&gt;2974K(199680K), 0.0020936 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">222222------------------------------------------------------------</span><br><span class="line">【解释】：</span><br><span class="line">[ParNew Desired survivor size 3145728 bytes, new threshold 3 (max 3)：新计算出来的threshold是3，但是我们现存的最大的年龄才是2，因此他们不会晋升到老年代。同时年龄为1的变成了2.新来的age是1.</span><br><span class="line">后面是进行的一系列的垃圾回收。</span><br><span class="line"></span><br><span class="line">2019-05-18T18:06:42.244+0800: [GC (Allocation Failure) 2019-05-18T18:06:42.244+0800: [ParNew</span><br><span class="line">Desired survivor size 3145728 bytes, new threshold 3 (max 3)</span><br><span class="line">- age   1:        176 bytes,        176 total</span><br><span class="line">- age   2:        352 bytes,        528 total</span><br><span class="line">- age   3:    2819312 bytes,    2819840 total</span><br><span class="line">: 43497K-&gt;3050K(46080K), 0.0007877 secs] 43497K-&gt;3050K(199680K), 0.0008376 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">333333------------------------------------------------------------</span><br><span class="line">【解释】：</span><br><span class="line">这次threshold重新计算的是3，同时对象年龄是2的年龄变成了3，年龄是1的变成了2，3已经是上限了。</span><br><span class="line"></span><br><span class="line">2019-05-18T18:06:43.247+0800: [GC (Allocation Failure) 2019-05-18T18:06:43.247+0800: [ParNew</span><br><span class="line">Desired survivor size 3145728 bytes, new threshold 3 (max 3)</span><br><span class="line">- age   1:     339624 bytes,     339624 total</span><br><span class="line">- age   2:        176 bytes,     339800 total</span><br><span class="line">- age   3:        352 bytes,     340152 total</span><br><span class="line">: 43776K-&gt;854K(46080K), 0.0056892 secs] 43776K-&gt;3629K(199680K), 0.0057258 secs] [Times: user=0.03 sys=0.00, real=0.01 secs]</span><br><span class="line">444444------------------------------------------------------------</span><br><span class="line">【解释】：</span><br><span class="line">第四次垃圾回收，这个时候第三个垃圾回收存活的对象到了第四次垃圾回收年龄会变成4,4已经是阈值上限了，因此就会被晋升到老年代，这里只存在年龄到3的，没有哦年龄到4的。</span><br><span class="line"></span><br><span class="line">2019-05-18T18:06:44.258+0800: [GC (Allocation Failure) 2019-05-18T18:06:44.258+0800: [ParNew</span><br><span class="line">Desired survivor size 3145728 bytes, new threshold 1 (max 3)</span><br><span class="line">- age   1:    3145952 bytes,    3145952 total</span><br><span class="line">- age   2:     339208 bytes,    3485160 total</span><br><span class="line">- age   3:        176 bytes,    3485336 total</span><br><span class="line">: 41571K-&gt;3484K(46080K), 0.0024575 secs] 44345K-&gt;6258K(199680K), 0.0025451 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">555555------------------------------------------------------------</span><br><span class="line">【解释】：</span><br><span class="line">这里new threshold已经变成了1，计算的方式是取当前age和max的最小值，最小值肯定就是1了，这样的在下次垃圾回收age为1、age为2、age为3的都会晋升到老年代。</span><br><span class="line"></span><br><span class="line">2019-05-18T18:06:45.265+0800: [GC (Allocation Failure) 2019-05-18T18:06:45.265+0800: [ParNew</span><br><span class="line">Desired survivor size 3145728 bytes, new threshold 3 (max 3)</span><br><span class="line">- age   1:        176 bytes,        176 total</span><br><span class="line">: 44209K-&gt;39K(46080K), 0.0027207 secs] 46983K-&gt;6239K(199680K), 0.0027832 secs] [Times: user=0.06 sys=0.01, real=0.00 secs]</span><br><span class="line">666666------------------------------------------------------------</span><br><span class="line">【解释】：</span><br><span class="line">这次回收把上次剩下的age为1、age为2、age3为都被晋升到老年代，已经卡看不到了，但是新生代还会有新的对象涌入，所以出现了新涌入的对象，他们的age为1.这次重新调整了threshold为3，但是永远不会超过MaxTenuringThreshold=3.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hello world</span><br><span class="line">Heap</span><br><span class="line"> par new generation   total 46080K, used 25818K [0x00000000f3800000, 0x00000000f6a00000, 0x00000000f6a00000)</span><br><span class="line">  eden space 40960K,  62% used [0x00000000f3800000, 0x00000000f512cf48, 0x00000000f6000000)</span><br><span class="line">  from space 5120K,   0% used [0x00000000f6000000, 0x00000000f6009c10, 0x00000000f6500000)</span><br><span class="line">  to   space 5120K,   0% used [0x00000000f6500000, 0x00000000f6500000, 0x00000000f6a00000)</span><br><span class="line"> concurrent mark-sweep generation total 153600K, used 6200K [0x00000000f6a00000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 3993K, capacity 4568K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 447K, capacity 460K, committed 512K, reserved 1048576K</span><br><span class="line">【解释】：</span><br><span class="line">老年代已经使用了6200K。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>阈值 jvm 垃圾收集器</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（45）安全点与安全区域详解</title>
    <url>/2019/05/19/jvm%E5%8E%9F%E7%90%86%EF%BC%8845%EF%BC%89%E5%AE%89%E5%85%A8%E7%82%B9%E4%B8%8E%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>concurrent mark sweep</p>
<span id="more"></span>

<h4 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h4><ul>
<li>当执行系统停顿下来后，并不需要一个不漏的检查完所有执行上下文呵呵全局的引用位置，虚拟机应当是由办法直接得知那些地方存放着对象引用。在hotspot<br>的实现中，是使用一组称为OopMap的数据结构来达到这个目的的。</li>
</ul>
<h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><p>-在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来，可能导致引用关系变化，或者说OopMap内容变化的指令<br>非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得更高。</p>
<ul>
<li>实际上，HotSpot并没  有为每条指令都生成OopMap，而是只在“特定的位置”记录了这些信息，这些位置称为“安全点(safepoint)”，即程序执行时并非<br>所有地方都能停顿下来开始GC，只有在达到安全点时才能暂停。</li>
<li>Safepoint的选定既不能太少以至于GC等待时间太长，也不能过于频繁以至于过分增大运行时的负载，所以，安全点的选定基本上是以“是否具有程序长时间执行的特征”<br>为标准选定的—因为每条指令执行的时间非常短暂，程序不可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列<br>复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。</li>
<li>对于safepoint，另一个需要考虑的问题是如何在GC发生时让所有线程(这里不包括执行jni调用的线程)都“跑”到最近的安全点上再停顿下来：抢占式中断<br>(Preemtive Suspension)和主动式中断(voluntary suspension)<br>-抢占式中断：他不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果有线程中断的地方不在安全点上，就恢复线程，让它“跑”<br>在安全点上。</li>
<li>主动式中断：当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就<br>自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</li>
<li>现在几乎没有虚拟机采用抢占式中断来暂停线程而响应GC事件。</li>
</ul>
<h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><ul>
<li><p>在使用safepoint似乎已经完美地解决了如何进入GC的问题，但实际上情况却并不一定。safepoint机制保证了程序执行时，在太长的时间内就会遇到<br>可进入GC的safepoint。但是如果程序在“不执行”的时候呢？所谓程序不执行就是没有分配CPU时间，典型的例子就是处于sleep状态或者blocked状态，<br>这时候程序无法响应jvm的中断请求，jvm也显然不可能等待线程重新分配cpu时间，对于这种情况，就需要安全区域(saferegin)来解决。</p>
</li>
<li><p>在线程执行到saferegion中的代码时，首先标示自己已经进入safe region，那样，当在这段时间里jvm要发起GC时，就不用标示自己为safe region状态的<br>状态的线程了，在线程要离开safe region时，他要检查系统是否已经完成了根节点枚举（或者整个gc过程），如果完成了，那线程就继续执行，<br>否则他就必须等待直到收到可以安全离开safe region的信号为止。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>安全点 安全区域</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（46）CMS垃圾收集器深入讲解</title>
    <url>/2019/05/19/jvm%E5%8E%9F%E7%90%86%EF%BC%8846%EF%BC%89CMS%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><ul>
<li><p>CMS (concurrent mark sweep)收集器，以获取最短回收停顿时间为目标，多数应用于互联网站或者b&#x2F;s系统的服务器上。</p>
<span id="more"></span></li>
<li><p>cms是基于“标记-清除”算法实现的，整个过程分为4个步骤：</p>
<ul>
<li>初始标记(cms initial mark)</li>
<li>并发标记(cms concurrent mark)</li>
<li>重新标记(cms remark)</li>
<li>并发清除(cms concurrent sweep)</li>
</ul>
</li>
<li><p>其中，初始标记、重新标记这两个步骤需要stw（stop the world）</p>
</li>
<li><p>初始标记只是标记一下GC root能直接关联到的对象速度很快</p>
</li>
<li><p>并发标记阶段就是进行Gc roots tracing的过程。<br> 重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致的标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般<br> 会比初始标记阶段稍长一些，但远比并发标记的时间短。</p>
</li>
<li><p>cms收集器的运作步骤哦如下图所示，在整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，因此，从总体上看，cms收集器的内存回收过程是与用户线程一起并发执行的。<br><img src="/2019/05/19/jvm%E5%8E%9F%E7%90%86%EF%BC%8846%EF%BC%89CMS%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3/cms1.png" alt="cms1.png"></p>
</li>
<li><p>优点</p>
</li>
<li><p>并发收集、低停顿，oracle公司的一些官方文档中也称之为并发底停顿(concurrent low pause collector)</p>
</li>
<li><p>缺点</p>
</li>
<li><p>cms收集器对cpu资源非常敏感</p>
</li>
<li><p>cms收集器无法处理浮动垃圾(floating garbage)，可能出现“concurrent mode failure”失败而导致另一次full gc的产生，如果在应用中<br>  老年代增长不是太快，可以适当调高参数-XX：CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能，要是cms运行期间预留的百分比无法满足程序需要时，这样停顿时间就很长了。所以说参数-XX：CMSInitiatingOccupancyFraction设置得太高容易很容易导致大量”concurrent mode Failure”失败，性能反而降低</p>
</li>
<li><p>收集结束会有大量空间碎片产生，空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前进行一次full gc。cms收集器提供了一个-XX:UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在cms收集器顶不住要进行full gc时开启内存碎片的合并整理过程，内存整理的过程无法并发的，空间碎片问题就没有了，但是停顿时间不得不边长。</p>
</li>
</ul>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><ul>
<li>在发生minor gc之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么minor gc可以确保是安全的。当大量对象在minor gc后仍然存活，就需要老年代进行空间分配担保，把survivor无法容纳的对象直接进入老年代。如果老年代判断到剩余空间不足（根据以往每一次回收晋升到老年代对象容量的平均值作为经验），则进行一次full gc。</li>
</ul>
<h4 id="cms收集器收集步骤"><a href="#cms收集器收集步骤" class="headerlink" title="cms收集器收集步骤"></a>cms收集器收集步骤</h4><ul>
<li>phase1：initial mark</li>
<li>phase2：concurrent mark</li>
<li>phase3：concurrent preclean</li>
<li>phase4：concurrent abortable Preclean</li>
<li>phase5：final remark</li>
<li>phase6：concurrent sweep</li>
<li>phase7：concurrent reset</li>
</ul>
<h4 id="phase1-initial-mark"><a href="#phase1-initial-mark" class="headerlink" title="phase1 initial mark"></a>phase1 initial mark</h4><ul>
<li>这个是cms两次stop-the-world事件的其中一次，这个阶段的目标是：标记那些直接被gc root引用或者被年轻代存活对象所引用的所有对象。<br><img src="/2019/05/19/jvm%E5%8E%9F%E7%90%86%EF%BC%8846%EF%BC%89CMS%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3/cms2.png" alt="cms2.png"></li>
</ul>
<h4 id="phase2：concurrent-mark"><a href="#phase2：concurrent-mark" class="headerlink" title="phase2：concurrent mark"></a>phase2：concurrent mark</h4><ul>
<li>在这个阶段garbage collecor会遍历老年代，然后标记所存活的对象，他会根据上个阶段找到gc roots遍历查找，并发标记阶段，她会与用户的应用程序并发运行。并不是老年代所有的存活对象会被标记，因为在标记期间用户的程序可能会改变一些引用<br><img src="/2019/05/19/jvm%E5%8E%9F%E7%90%86%EF%BC%8846%EF%BC%89CMS%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3/cms3.png" alt="cms3.png"><br>在上面的图中，与阶段一的图进行比对，就会发现有一个对象的引用已经发生了变化。</li>
</ul>
<h4 id="phase3：concurrent-preclean"><a href="#phase3：concurrent-preclean" class="headerlink" title="phase3：concurrent preclean"></a>phase3：concurrent preclean</h4><ul>
<li>这也是一个并发阶段，与应用的线程并发运行，并不会stop应用的线程，在并发运行的过程中，一些对象的引用可能会发生变化，但是这种情况发生时，jvm会将包含这个对象的区域(card)标记为Dirty，这也是Card Marking</li>
<li>在pre-clean阶段，那些能够从Dirty对象到达的对象也会被标记，这个标记做完之后，dirty card标记就会被清除了<br><img src="/2019/05/19/jvm%E5%8E%9F%E7%90%86%EF%BC%8846%EF%BC%89CMS%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3/cms4.png" alt="cms4.png"></li>
</ul>
<h4 id="phase4：concurrent-abortable-Preclean"><a href="#phase4：concurrent-abortable-Preclean" class="headerlink" title="phase4：concurrent abortable Preclean"></a>phase4：concurrent abortable Preclean</h4><ul>
<li>这也是一个并发阶段，但是同样不会影响用户的应用线程，这个阶段就是为了尽量承担stw中最终标记阶段的工作。这个阶段持续时间依赖于很多的<br>因素，由于这个阶段是在重复做相同的工作，直接满足一些条件（比如：重复迭代的次数、完成的工作量或时钟时间等）</li>
</ul>
<h4 id="phase5：final-remark"><a href="#phase5：final-remark" class="headerlink" title="phase5：final remark"></a>phase5：final remark</h4><ul>
<li>这个是第二个stw阶段，也是cms中的最后一个，这个阶段的目标是标记老年代所有的存活对象，由于之前的阶段是并发执行的，gc线程可能跟不上<br>应用程序的变化，为了完成标记老年代所有存活对象的目标，stw就非常油必要了。</li>
<li>通常cms的final remark阶段会在年轻代尽可能干净的时候运行，目的是为了减少连续stw发生的可能性（年轻代存活对象多的话，也会导致老年代涉及的存活对象会很多），这个阶段会比前面的几个阶段更复杂一些</li>
</ul>
<h4 id="标记阶段完成"><a href="#标记阶段完成" class="headerlink" title="标记阶段完成"></a>标记阶段完成</h4><ul>
<li>经历过五个阶段之后，老年代所有存活对象都被标记过了，现在可以通过清楚算法去清理那些老年代不再使用的对象。</li>
</ul>
<h4 id="phase6：concurrent-sweep"><a href="#phase6：concurrent-sweep" class="headerlink" title="phase6：concurrent sweep"></a>phase6：concurrent sweep</h4><ul>
<li>这里不需要stw，它是与用户的应用程序并发运行，这个阶段是：清除那些不再使用的对象，回收它们的占用空间将来使用。<br><img src="/2019/05/19/jvm%E5%8E%9F%E7%90%86%EF%BC%8846%EF%BC%89CMS%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3/cms5.png" alt="cms5.png"></li>
</ul>
<h4 id="phase7：concurrent-reset"><a href="#phase7：concurrent-reset" class="headerlink" title="phase7：concurrent reset"></a>phase7：concurrent reset</h4><ul>
<li>这个阶段也是并发执行的，它会重设cms内部的数据结构，为了下次的gc做准备。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>cms通过将大量的工作分散到并发处理阶段来减少stw时间，在这块做得非常优秀，但是cms也有一些其他的问题。</li>
<li>cms收集器无法处理浮动垃圾（floating garbage），可能出现“concurrent mode failure”失败而导致一次full gc的产生，可能引发串行full gc；</li>
<li>空间碎片，导致无法分配大对象，cms收集器提供了一个-XX:+UseCMSCompactAtCollection 开关参数（默认就是开启的），用于在cms收集器顶不住要进行full gc时开启内存碎片的合并整理过滤，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。</li>
<li>对于堆比较大应用，gc的时间难以预估。</li>
</ul>
<h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>编写程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> -verbose:gc</span><br><span class="line"> -Xms20M</span><br><span class="line"> -Xmx20M</span><br><span class="line"> -Xmn10M</span><br><span class="line"> -XX:+PrintGCDetails</span><br><span class="line"> -XX:SurvivorRatio=8</span><br><span class="line"> -XX:+UseConcMarkSweepGC</span><br><span class="line"> * @author : CeaserWang</span><br><span class="line"> * @version : 1.0</span><br><span class="line"> * @since : 2019/5/25 13:33</span><br><span class="line"> */</span><br><span class="line">public class MyTest5 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int size = 1024 * 1024;</span><br><span class="line">        byte[] myAlloc1 = new byte[5 * size];</span><br><span class="line">        System.out.println(&quot;111111&quot;);</span><br><span class="line">        byte[] myAlloc2 = new byte[5 * size];</span><br><span class="line">        System.out.println(&quot;22222&quot;);</span><br><span class="line">        byte[] myAlloc3 = new byte[2 * size];</span><br><span class="line">        System.out.println(&quot;333333&quot;);</span><br><span class="line">        byte[] myAlloc4 = new byte[3 * size];</span><br><span class="line">        System.out.println(&quot;444444&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">111111</span><br><span class="line">[GC (Allocation Failure) [ParNew: 7479K-&gt;727K(9216K), 0.0041447 secs] 7479K-&gt;5849K(19456K), 0.0042252 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">22222</span><br><span class="line">333333</span><br><span class="line">[GC (Allocation Failure) [ParNew: 8135K-&gt;8135K(9216K), 0.0000160 secs][CMS: 5122K-&gt;5120K(10240K), 0.0037131 secs] 13257K-&gt;12996K(19456K), [Metaspace: 3484K-&gt;3484K(1056768K)], 0.0037862 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">[GC (CMS Initial Mark) [1 CMS-initial-mark: 8192K(10240K)] 16068K(19456K), 0.0007341 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">解释：</span><br><span class="line">cms收集器的第一步初始标记，8192K老年代存活对象占用的空间大小，10240K是老年代总的大小10M，16068K是整个堆存活对象占用的空间，</span><br><span class="line">19456K是整个堆的大小。</span><br><span class="line"></span><br><span class="line">[CMS-concurrent-mark-start]</span><br><span class="line">444444[CMS-concurrent-mark: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">解释：</span><br><span class="line">cms的第二步并发标记。</span><br><span class="line"></span><br><span class="line">[CMS-concurrent-preclean-start]</span><br><span class="line"></span><br><span class="line">[CMS-concurrent-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">解释：cms的第三步，预清理阶段</span><br><span class="line"></span><br><span class="line">[CMS-concurrent-abortable-preclean-start]</span><br><span class="line">[CMS-concurrent-abortable-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">解释：</span><br><span class="line">cms的第四步清理步骤abortable-preclean</span><br><span class="line"></span><br><span class="line">[GC (CMS Final Remark) [YG occupancy: 8192 K (9216 K)][Rescan (parallel) , 0.0005659 secs][weak refs processing, 0.0000219 secs][class unloading, 0.0002576 secs][scrub symbol table, 0.0003794 secs][scrub string table, 0.0000947 secs][1 CMS-remark: 8192K(10240K)] 16384K(19456K), 0.0013843 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">解释：</span><br><span class="line">cms的最第五步，最终标重新记阶段，</span><br><span class="line">[YG occupancy: 8192 K (9216 K)]：表示新生代存活对象占用的空间是 8192 K，新生代总的大小是9216 K，</span><br><span class="line">Rescan (parallel)：要做最终标记需要进行的重新扫描。</span><br><span class="line">[weak refs processing, 0.0000219 secs]：弱引用的处理。</span><br><span class="line">[class unloading, 0.0002576 secs]：类的卸载。</span><br><span class="line">[scrub symbol table, 0.0003794 secs]：符号表的处理。</span><br><span class="line">[scrub string table, 0.0000947 secs]：字符串表的处理。</span><br><span class="line"></span><br><span class="line">[CMS-concurrent-sweep-start]</span><br><span class="line">解释：cms的并发清除开始</span><br><span class="line"></span><br><span class="line">由于程序demo的原因这里还有一步是[CMS-concurrent-concurrent reset]的步骤。</span><br><span class="line"></span><br><span class="line">[GC (Allocation Failure) [ParNew: 8192K-&gt;8192K(9216K), 0.0000165 secs][CMS[CMS-concurrent-sweep: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line"> (concurrent mode failure): 8192K-&gt;707K(10240K), 0.0024162 secs] 16384K-&gt;707K(19456K), [Metaspace: 3485K-&gt;3485K(1056768K)], 0.0024779 secs] [Times: user=0.02 sys=0.00, real=0.00 secs]</span><br><span class="line">Heap</span><br><span class="line"> par new generation   total 9216K, used 82K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,   1% used [0x00000000fec00000, 0x00000000fec14938, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line"> concurrent mark-sweep generation total 10240K, used 707K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 3491K, capacity 4498K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 387K, capacity 390K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>通过上面程序的例子就能反证出cms收集器的一些收集的过程。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>CMS</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（47）G1垃圾收集器系列深入讲解</title>
    <url>/2019/06/07/jvm%E5%8E%9F%E7%90%86%EF%BC%8847%EF%BC%89G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%B3%BB%E5%88%97%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>Garage First Collector</p>
<span id="more"></span>

<h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><ul>
<li>吞吐量关注的是，在一个指定的时间内，最大化一个应用的工作量。</li>
<li>如下方式衡量一个系统吞吐量的好坏；<ul>
<li>在一小时内同一个事物（或者任务、请求）完成的次数（tps）</li>
<li>数据库一小时可以完成多少次查询</li>
</ul>
</li>
<li>对于关注吞吐量的系统，卡顿是可以接受的，因为这个系统关注长时间的大量任务的执行能力，，单词快速的响应并不值得考虑。</li>
</ul>
<h4 id="响应能力"><a href="#响应能力" class="headerlink" title="响应能力"></a>响应能力</h4><ul>
<li>响应能力指一个程序或者系统对请求是否能够及时响应，比如：<ul>
<li>一个桌面UI能对快地响应一个事件</li>
<li>一个网站能够对快返回一个页面请求</li>
<li>数据库能够多块返回查询数据</li>
</ul>
</li>
<li>对于这类对响应能力敏感的场景，长时间的停顿是无法接受的。</li>
</ul>
<h4 id="Garage-First-Collector"><a href="#Garage-First-Collector" class="headerlink" title="Garage First Collector"></a>Garage First Collector</h4><ul>
<li>g1收集器是一个面向服务端的垃圾收集器，，适用于多核处理器、大内存容量的服务器系统。</li>
<li>他满足短时间gc停顿的同时达到一个较高的吞吐量。</li>
<li>jdk7以上版本适用。</li>
</ul>
<h4 id="G1收集器的设计目标"><a href="#G1收集器的设计目标" class="headerlink" title="G1收集器的设计目标"></a>G1收集器的设计目标</h4><ul>
<li>与应用线程同时工作，几乎不需要同时 stop the word（与cms类似）</li>
<li>整理剩余空间，不产生内存碎片（cms只能在full gc时，用stop the world整理内存碎片）</li>
<li>GC的停顿更加可控；</li>
<li>不牺牲系统的吞吐量；</li>
<li>gc不需要额外的内存空间（cms需要预留空间存储浮动垃圾）;</li>
</ul>
<p>ps：举例，老年代50G，新生代30G，使用cms收集器收集垃圾的时候，他会在std的时候把老年代的50G和新生代的30G全部清理；<br>但是G1收集器不会这样，g1收集器可以设置std的时间，即要求g1的std的时间是多少秒，然后g1会对内存区域进行评估，在设定的时间内完成最大空间的释放，只回收部分区域，并不会收集所有的空间。</p>
<h4 id="G1的设计规划是要替换掉cms"><a href="#G1的设计规划是要替换掉cms" class="headerlink" title="G1的设计规划是要替换掉cms"></a>G1的设计规划是要替换掉cms</h4><ul>
<li>G1在某些方面弥补了cms的不足，比如，cms使用的是mark-sweep算法，自然会产生内存碎片，然后g1基于copying算法，高效的整理剩余内存，而不需要管理内存碎片。</li>
<li>另外，g1提供更多手段，以达到对gc停顿时间的可控。</li>
</ul>
<h4 id="HotPot虚拟机主要构成"><a href="#HotPot虚拟机主要构成" class="headerlink" title="HotPot虚拟机主要构成"></a>HotPot虚拟机主要构成</h4><p><img src="/2019/06/07/jvm%E5%8E%9F%E7%90%86%EF%BC%8847%EF%BC%89G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%B3%BB%E5%88%97%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3/jvm-construct.png" alt="jvm-construct.png"></p>
<h4 id="传统垃圾收集器堆结构"><a href="#传统垃圾收集器堆结构" class="headerlink" title="传统垃圾收集器堆结构"></a>传统垃圾收集器堆结构</h4><p><img src="/2019/06/07/jvm%E5%8E%9F%E7%90%86%EF%BC%8847%EF%BC%89G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%B3%BB%E5%88%97%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3/jvm-men-construct.png" alt="jvm-men-construct.png"></p>
<h4 id="G1收集器堆结构"><a href="#G1收集器堆结构" class="headerlink" title="G1收集器堆结构"></a>G1收集器堆结构</h4><p><img src="/2019/06/07/jvm%E5%8E%9F%E7%90%86%EF%BC%8847%EF%BC%89G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%B3%BB%E5%88%97%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3/jvm-g1-construct.png" alt="jvm-g1-construct.png"></p>
<p>图中的每个区域，比如O区域，在随着时间的推移和内存的使用，可能会被定义为E或者S区域。<br>但是这三种类型是固定的，也是为了延续之前老的内存结构的概念名字。</p>
<ul>
<li>heap被划分为一个个的相等的不连续的内存区域（regions），每个region都有一个分代角色，eden，survivor、old。</li>
<li>对每个角色的数量并没有强制的限定，也就是说对于每种分代内存大小，可以动态变化。</li>
<li>g1最大的特点就是高效的执行回收，优先去执行那些大量对象可回收的区域（region）</li>
<li>G1使用了G1停顿可预测的模型，来满足用户设定的gc停顿时间，根据用户设定的目标时间，g1会自动化地选择那些region要清除，一次清除多少个region。</li>
<li>g1从多个region中复制存活的对象，然后集中放入一个region中，同时整理，清除内存（copying收集算法）<br>比如对2个E进行回收，然后每个E都可能会有存活的对象，那么他们存活的对象就会移动到一个survivor区域，原有的2个E被置位空闲区域。4</li>
</ul>
<h4 id="G1-vs-CMS"><a href="#G1-vs-CMS" class="headerlink" title="G1 vs CMS"></a>G1 vs CMS</h4><ul>
<li>对比使用mark-sweep的CMS，G1使用的copying算法不会造成内存碎片；</li>
<li>对比Parallel Scavange（基于copying）、Parallel Old收集器（基于mark-compact-sweep），Parallel会对整个区域做整理导致 gc停顿时间会比较长，而g1只是特定地整理几个region。</li>
<li>G1并不是一个实时的收集器，与parallel Scanvenge一样，对gc停顿时间的设置并不会绝对生效，只是g1有较高的几率保证不超过设定的gc停顿时间，与之前的gc收集器对比，g1会根据用户设定的gc停顿时间，智能评估那几个region需要被回收可以满足用户的设定。</li>
</ul>
<h4 id="G1重要概念"><a href="#G1重要概念" class="headerlink" title="G1重要概念"></a>G1重要概念</h4><ul>
<li>分区（region）：g1采用不同的策略来解决并行，串行和cms收集器的碎片、暂定时间不可空等问题—–g1将整个堆分成相同大小的分区（region）</li>
<li>每个分区都可能是年轻代也可能是老年代，但是在同一个时刻只能属于某个代。年轻代、幸存区、老年代这些概念还存在，成为逻辑上的概念，<br>这样方便复用之前分代框架的逻辑。</li>
<li>在物理上不需要连续，则带来额外的好处———有的分区内垃圾对象特别多，有的分区垃圾对象很少，g1会优先回收垃圾对象特别多的分区，<br>这样可以花费较少的时间来回收这些分区的垃圾，这也就是g1名字的由来，即首先收集垃圾最多的分区。</li>
<li>依然是在新生代满了的时候，对整个新生代进行回收———-整个新生代的对象，要么被回收，要么晋级，至于新生代也采取分区机制的原因，则是因为这样跟老年代的策略统一，方便调整整代的大小。</li>
<li>g1还是一种带压缩的收集器，在回收老年代的分区时，是将存活的对象从一个分区拷贝到另一个分区，这个拷贝的过程就实现了局部的压缩。</li>
<li>收集集合（CSet）：一组可被回收的分区的集合，在Cset中存活的数据会被GC过程中被移动到另一个可用分区，CSet中的分区可以来自eden空间、survivor空间、或者老年代。</li>
<li>记忆集合（RSet）：RSet记录了其他Region中的对象引用本region中对象的关系，属于point-into结构（谁引用了我的对象）。RSet的价值在于使用垃圾收集器不需要扫描整个堆找到谁引用了当前分区中的对象，只需要扫描RSet即可。</li>
<li>Region1和Region3中的对象引用了Region2中的对象，因此在Region2的Rset中记录了这两个引用。<br><img src="/2019/06/07/jvm%E5%8E%9F%E7%90%86%EF%BC%8847%EF%BC%89G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%B3%BB%E5%88%97%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3/g1-Rset.png" alt="g1-Rset.png"></li>
<li>G1 GC是在point-out的card table之上再加了一层结构来构成point-into Rset：每个region会记录下到底哪些别的region有指向自己的指针，而这些指针分别在哪些card的范围内。</li>
<li>这个Rset其实是一个hash table，key是别的region的起始地址，value是一个集合，里面元素是card table的index。举例来说，如果region A的Rset里有一项的key是regionB，value里有index为1234的card，它的意思就是regionB的一个card里有引用指向region A。所以对regionA来说，该Rset记录的是point-into的关系；而card table仍然记录了point-out的关系。</li>
<li>Snapshot-At-The-Begining（SATB）：<br>SATB是G1 GC在并发标记阶段使用的增量式的标记算法（存在浮动垃圾）。</li>
<li>并发标记是并发多线程的，但并发线程在同一时刻只扫描一个分区。</li>
</ul>
<h4 id="G1相对于CMS的优势"><a href="#G1相对于CMS的优势" class="headerlink" title="G1相对于CMS的优势"></a>G1相对于CMS的优势</h4><ul>
<li>G1在压缩空间方面有优势</li>
<li>G1通过将内存空间分片成区域（Region）的方式避免内存碎片问题</li>
<li>Eden、Survivor、Old区不在固定，在内存使用效率上来说更灵活。</li>
<li>G1可以通过设置停顿时间（Pause Time）来控制垃圾收集时间，避免应用雪崩现象。</li>
<li>G1在回收内存后会马上同时做合并空内存的工作，而CCMS默认是在STW的时候做。</li>
<li>G1会在Young GC中使用，而CMS只能在O区使用。</li>
</ul>
<h4 id="G1的适合场景"><a href="#G1的适合场景" class="headerlink" title="G1的适合场景"></a>G1的适合场景</h4><ul>
<li>服务端多核CPU，kvm内存占用较大的应用</li>
<li>应用子啊运行过程中会产生大量内存碎片、需要经常压缩空间</li>
<li>想要更可控、可预测的GC停顿周期：防止高并发下应用的雪崩现象。</li>
</ul>
<h4 id="G1-GC模式"><a href="#G1-GC模式" class="headerlink" title="G1 GC模式"></a>G1 GC模式</h4><ul>
<li><p>G1提供了两种模式，Young GC和Mixed GC两种都是完全stop the world的</p>
</li>
<li><p>Young GC：选定所有年轻代里 的Region。通过控制年轻代的Region个数，即年轻代内存大小，来控制Young GC的时间开销。</p>
</li>
<li><p>Mixed GC：选定所有年轻代里的Region，外加根据Global concurent marking统计得出收集收益高的若干老年代Region。在用户指的开销<br>目标范围内尽可能选择收益高的老年代Region。</p>
</li>
<li><p>Mixed GC不是Full GC，它只能回收部分老年代的region，如果Mixed GC实在无法跟上程序分配内存的速度，导致老年代填满无法继续进行mixed GC，就会使用serial old GC（full Gc）来收集整个GC heap所以本质上，G1是不提供full gc的。</p>
</li>
</ul>
<h4 id="gloabal-concurrent-marking"><a href="#gloabal-concurrent-marking" class="headerlink" title="gloabal concurrent marking"></a>gloabal concurrent marking</h4><ul>
<li><p>gloabal concurrent marking的执行过程类似于cms，但是不同的是，在G1 GC中，它主要是为Mixed GC提供标记服务的，并不是一次GC的一个必要环节</p>
</li>
<li><p>gloabal concurrent marking的执行过程分为四个步骤。</p>
</li>
<li><p>初始标记（initial mark ,stw）：它标记了从GC root开始直接可达的对象</p>
</li>
<li><p>开发标记（Concurrent Marking）：这个阶段从GC root开始对heap中的对象进行标记，标记线程与应用程序线程并发执行，并且收集各个Region的存活对象信息。</p>
</li>
<li><p>重新标记（Remark ，Stw）：标记那些在并发标记阶段发生变化的对象，将被回收。</p>
</li>
<li><p>清理（cleanUp）：清除空Region（没有存活对象的），加入到free list。</p>
</li>
<li><p>第一阶段initial mark是共用了 Young GC的暂停，只是因为他们可以复用root scan操作，所以可以说gloabal concurrent marking是伴随<br>young Gc 而发生的。</p>
</li>
<li><p>第四阶段Cleanup只是回收了没有存活对象的Region，所以它并不需要STW。</p>
</li>
</ul>
<h4 id="G1在运行过程中主要模式"><a href="#G1在运行过程中主要模式" class="headerlink" title="G1在运行过程中主要模式"></a>G1在运行过程中主要模式</h4><ul>
<li>YGC（不同于CMS）</li>
<li>并发阶段 (为混合阶段提供数据支持，对区域进行标记)</li>
<li>混合阶段 （首先进行YGC，然后根据并发阶段标记出来的区域进行最优化回收）</li>
<li>Full GC（一般是G1出现问题时发生，G1出现问题时发生）</li>
<li>G1 YGC在Eden充满时触发，在回收后所有之前属于Eden的区块全部变成空白，即不属于任何一个分区（Eden、Survivor、old）</li>
</ul>
<h4 id="Mixed-GC"><a href="#Mixed-GC" class="headerlink" title="Mixed GC"></a>Mixed GC</h4><ul>
<li><p>什么时候触发Mixed GC?</p>
</li>
<li><p>由一些参数控制，另外也控制着那些老年代Region会被选入CSet（收集集合）</p>
</li>
<li><p>G1HeapWastePercent：在global concurrent marking结束之后，我们可以知道old gen regions中有多少空间要被回收，在每次YGC之后和再次发生Mixed GC之前，会检查垃圾占比是否达到此参数，只要达到了，下次才会发生Mixed GC</p>
</li>
<li><p>G1MixedGCLiveThresholdPercent：old generation region中的存活对象的占比，只有在此参数之下，才会被选入Cset（活着的对象比较少，就是垃圾比较多，才会纳入收集集合）。</p>
</li>
<li><p>G1MixedGCCountTarget：一次global concurrent marking之后，最多执行mixed gc的次数。</p>
</li>
<li><p>G1OldCSetRegionThresoldPercent：一次mixed Gc中能被选入CSet的最多old generation region数量。</p>
</li>
<li><p>G1 GC其他的参数<br><img src="/2019/06/07/jvm%E5%8E%9F%E7%90%86%EF%BC%8847%EF%BC%89G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%B3%BB%E5%88%97%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3/g1-params.png" alt="g1-params.png"></p>
</li>
</ul>
<h4 id="G1-Oracle官方doc"><a href="#G1-Oracle官方doc" class="headerlink" title="G1 Oracle官方doc"></a>G1 Oracle官方doc</h4><p><span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS90ZWNobmV0d29yay90dXRvcmlhbHMvdHV0b3JpYWxzLTE4NzY1NzQuaHRtbA==">https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="G1收集概览"><a href="#G1收集概览" class="headerlink" title="G1收集概览"></a>G1收集概览</h4><ul>
<li>G1算法将 堆划分为若干个区域（region）。它仍然是属于分代收集器，不过，这些区域的一部分包含新生代，新生代的垃圾收集器依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间。老年代也分成很多区域，G1收集器通过将对象从一个区域复制到另外一个区域，完成清理工作。这就意味着，在正常的处理过程中，G1完成了堆压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片的问题的存在了。</li>
</ul>
<h4 id="Humongous区域"><a href="#Humongous区域" class="headerlink" title="Humongous区域"></a>Humongous区域</h4><ul>
<li>在G1中，还有一种特殊的区域，叫 Humongous区域。如果一个对象占用的空间达到或是超过了分区容量50%以上，G1收集器就会认为是一个巨型对象。这些巨型对象，默认直接会被分配在老年代，但是如果它是一个短暂存在的巨型对象，就会垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个 Humongous区，它用来专门存放巨型对象，如果一个H区装不下一个巨型对象，那么G1会寻找连续的H区来存储。为了能找打连续的H区，有时候不得不启动Full GC</li>
</ul>
<h4 id="G1-Young-GC"><a href="#G1-Young-GC" class="headerlink" title="G1 Young GC"></a>G1 Young GC</h4><ul>
<li><p>Young GC 主要是对Eden区进行GC，，它在Eden空间耗尽时会被触发。这种情况下，Eden空间的数据移动到Survivor空间中，如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。survivor区的数据移动到新的Survivor区中，也有部分数据晋升到老年代空间中。最终Eden空间的数据为空，GC完成工作，应用线程继续执行（ Young GC 会STW）。</p>
</li>
<li><p>如果仅仅GC回收新生代对象，我们如何找到所有的根对象呢？老年代的所有对象都是根么？那这样扫描下来会耗费大量的时间。于是，G1引进了Rset的概念。它的全称是Remembered SET，作用是跟踪指向某个heap区内的对象引用。<br><img src="/g1-Rset2.png" alt="g1-Rset2.png"></p>
</li>
<li><p>在CMS中，也有Rset的概念，在老年代中有一块区域用来记录指向新生代的引用。这是一种point-out，在进行Young GC时，扫描根时，仅仅需要扫描这一块区域，，而不需要扫描整个老年代。</p>
</li>
<li><p>但是G1中，并没有使用point-out，这是由于一个分区太小，分区数量太多，如果是用point-out的话，会造成大量的扫描浪费，有些根本不需要GC的分区引用也扫描了。</p>
</li>
<li><p>于是G1中使用point-in来解决，point-in的意思是那些分区引用了当前分区中的对象。这样，仅仅将这些对象当做根来扫描就避免了无效的扫描。</p>
</li>
<li><p>由于新生代有多个，那么我们需要在新生代之间记录引用吗？这是不必要的，原因在于每次GC时，所有新生代都会被扫描，所以只需要记录老年代到新生代之间的引用即可。</p>
</li>
<li><p>需要注意的是，如果引用的对象很多，赋值器需要对每个引用处理，赋值器开销很很大，为了解决赋值器开销这个问题，在G1中又引入另外一个概念，卡表（Card Table）。一个Card Table将一个分区在逻辑上划分为固定大小的连续区域，每个区域称为卡。卡通通常较小，介于128到512字节之间。card table通常为字节数组，由card的索引（即，数组下标）来标示每个分区的空间地址</p>
</li>
<li><p>默认情况下，每个卡都未被引用，当一个地址空间被引用时，这个地址空间对应的数组索引的值被标记为0，即标记为脏被引用，此外RSet也将这个数组下标记录下来，一般情况下，这个RSet其实是一个Hash Table，Key是别的Region的起始地址，Value是一个集合，里面的元素是Card Tabella的Index。</p>
<h4 id="G1-Young-GC-1"><a href="#G1-Young-GC-1" class="headerlink" title="G1 Young GC"></a>G1 Young GC</h4></li>
<li><p>阶段1：根扫描</p>
<ul>
<li>静态和本地对象被扫描</li>
</ul>
</li>
<li><p>阶段2：更新RS</p>
<ul>
<li>处理dirty card队列更新RS</li>
</ul>
</li>
<li><p>阶段3：处理RS</p>
<ul>
<li>检测从年轻代指向老年代的对象</li>
</ul>
</li>
<li><p>阶段4：对象拷贝</p>
<ul>
<li>拷贝存活的对象到survivor&#x2F;old区域</li>
</ul>
</li>
<li><p>阶段5：处理引用队列</p>
<ul>
<li>软引用，弱引用，虚引用处理</li>
</ul>
</li>
</ul>
<h4 id="再谈Mised-GC"><a href="#再谈Mised-GC" class="headerlink" title="再谈Mised GC"></a>再谈Mised GC</h4><ul>
<li>mixed GC不仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的老年代分区。</li>
<li>它的GC步骤分为2步：<ul>
<li>全局的并发标记(gloabal concurrrent marking)</li>
<li>拷贝存活对象(evacuation)</li>
</ul>
</li>
<li>在G1中，gloabal concurrrent marking主要的是为mised gc提供标记服务，并不是一次过程gc过程的一个必要环节，blobal concurrent marking的执行过程分为四个步骤。</li>
</ul>
<h4 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a>三色标记算法</h4><ul>
<li>提到并发标记算法，我们不得不了解并发标记的三色标记算法。它是描述追踪式回收的一种有效的方法，利用它可以推演回收器的正确性。</li>
</ul>
<h5 id="三色标记算法-1"><a href="#三色标记算法-1" class="headerlink" title="三色标记算法"></a>三色标记算法</h5><ul>
<li>我们将对象分成三种类型：<ul>
<li>黑色：根对象，或者该对象与它的子对象都被扫描过（对象被标记了，且它的所有filed也被标记完了）</li>
<li>灰色：对象本身被扫描，但还没有扫描完该对象中的子对象（它的field还没有被标记或标记完）</li>
<li>白色：未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象（对象没有被标记到）</li>
</ul>
</li>
</ul>
<p><img src="/2019/06/07/jvm%E5%8E%9F%E7%90%86%EF%BC%8847%EF%BC%89G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%B3%BB%E5%88%97%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3/three-color.png" alt="three-color.png"></p>
<p><img src="/2019/06/07/jvm%E5%8E%9F%E7%90%86%EF%BC%8847%EF%BC%89G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%B3%BB%E5%88%97%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3/three-color1.png" alt="three-color1.png"></p>
<p><img src="/2019/06/07/jvm%E5%8E%9F%E7%90%86%EF%BC%8847%EF%BC%89G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%B3%BB%E5%88%97%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3/three-color2.png" alt="three-color2.png"></p>
<p>但是如果在标记过程中，应用程序也运行，那么对象的指针就有可能改变。这样的话，我们就会遇到一个问题：对象丢失问题。</p>
<ul>
<li>当垃圾收集器扫描到下面情况时<br> <img src="/2019/06/07/jvm%E5%8E%9F%E7%90%86%EF%BC%8847%EF%BC%89G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%B3%BB%E5%88%97%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3/three-color3.png" alt="three-color3.png"></li>
<li>这时候应用程序执行了以下操作：<ul>
<li>A.c &#x3D; C</li>
<li>B.c &#x3D; null</li>
</ul>
</li>
<li>这样，对象的状态图变成如下情形：<br> <img src="/2019/06/07/jvm%E5%8E%9F%E7%90%86%EF%BC%8847%EF%BC%89G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%B3%BB%E5%88%97%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3/three-color4.png" alt="three-color4.png"><br> 这时候垃圾收集器再标记扫描的时候就会变成下图这样<br><img src="/2019/06/07/jvm%E5%8E%9F%E7%90%86%EF%BC%8847%EF%BC%89G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%B3%BB%E5%88%97%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3/three-color5.png" alt="three-color5.png"><br>这个时候A和C是矛盾的，A是黑色的，意味着他自己和他下面的也扫描完了，这样C会被认为是垃圾，但是A指向了C，如果回收了C是严重的不对。</li>
<li>很显然，此时C是白色，被认为是垃圾需要清理掉，显然这是不合理的，出现了漏标。</li>
</ul>
<h3 id="SATB"><a href="#SATB" class="headerlink" title="SATB"></a>SATB</h3><ul>
<li><p>在G1中，使用的是STAB(Snapsshot-At-The-Beginning)的方式，删除的时候记录所有的对象</p>
</li>
<li><p>它有3个步骤</p>
<ul>
<li>在开始标记的时候生成一个快照图，标记存活对象</li>
<li>在并发标记的时候所有被改变的对象入队(在write barrier里把所有旧的引用所指向的对象都变成非白色的)</li>
<li>可能存在浮动垃圾，将在下次被收集</li>
</ul>
<p>按照这个步骤，上面的三张图（ABC的关系图）C会标记为灰色，这样就避免了C成为垃圾的命运，因为只有白色的才会被回收。</p>
</li>
</ul>
<h3 id="G1混合式回收"><a href="#G1混合式回收" class="headerlink" title="G1混合式回收"></a>G1混合式回收</h3><ul>
<li>G1到现在可以知道哪些老的分区可回收垃圾最多，当全局并发标记完成后，在某个时刻，就开始了Mixed GC。这些垃圾回收被称作“混合式”是因为他们不仅仅进行正常的新生代垃圾回收，同时也回收部分后台扫描线程标记的分区</li>
<li>混合式GC也是采用的复制清理策略，当GC完成后，会重新释放空间。<h3 id="G1的分代算法"><a href="#G1的分代算法" class="headerlink" title="G1的分代算法"></a>G1的分代算法</h3></li>
<li>为老年代设置分区的目的是老年代里有的分区垃圾多，有的分区垃圾少，这样在回收的时候可以专注于收集垃圾多的分区，这也是G1名称的由来。</li>
<li>不过这个算法并不适合新生代垃圾收集，因为新生代的垃圾收集算法是复制算法，但是新生代也使用了分区机制主要是因为便于代大小的调整</li>
</ul>
<h3 id="SATB详解"><a href="#SATB详解" class="headerlink" title="SATB详解"></a>SATB详解</h3><ul>
<li><p>SATB是维持并发GC的一种手段，G1并发的基础就是SATB。SATB可以理解成在GC开始之前对堆内内存里的对象做一次快照，此时活的对象就认为是活的，从而形成一个对象图。</p>
</li>
<li><p>在GC收集的时候，新生代的对象也认为是活的对象，除此之外其他不可达的对象都认为是垃圾对象。</p>
</li>
<li><p>如何找到在GC过程中分配的对象呢？每个region记录着两个top-at-mark-start(TAMS)指针，分别为preTAMS和nextTAMS。在TAMS以上的对象就是新分配的，因而被视为隐式marked。</p>
</li>
<li><p>通过这种方式我们就找到了在GC过程中新分配的对象，并把这些对象认为是活的对象。</p>
</li>
<li><p>解决了对象在GC过程中分配的问题，那么在GC过程中引发变化的问题怎么解决呢？</p>
</li>
<li><p>G1 给出的解决办法是通过Write Barrier。Write Barrier就是对引用字段进行赋值做了额外处理。通过Write Barrier就可以了解到那些引用对象发生了什么样的变化（简单的理解就是在对象赋值的时候将赋值的对象变为非白色的）。</p>
</li>
<li><p>mark的过程就是遍历heap标记live object的过程，采用的是三色标记算法，这三种颜色为write（表示还未访问到）、gray（访问到但是它用到的引用还没有完全扫描）、black（访问到而且其用到的引用已经完全扫描完）</p>
</li>
<li><p>整个三色标记算法就是从GC roots出发遍历heap，针对可达对象先标记whrite 为gray，然后再标记gray为black：遍历完成之后所有可达对象都是black的，所有white都是可以被回收的。</p>
</li>
<li><p>SATB仅仅对于在marking开始阶段进行snapshot（marked all reachable at mark start），但是concurrent的时候并发修改可能造成对象漏标记。</p>
</li>
<li><p>对black新引用了一个white对象，然后又从gray对象中删除了对该white对象的引用，这样会造成了该white对象漏标记</p>
</li>
<li><p>对black新引用了一个white对象，然后从gray对象删除了一个引用该white对象的white对象，这样也造成了该white对象漏标记</p>
</li>
<li><p>对black新引用了一个刚new出来的white对象，没有其他gray对象引用该white对象，这样也会造成了该white对象漏标记。</p>
</li>
<li><p>对于三色算法在concurrent的时候可能产生的漏标记问题，SATB的marking阶段中，对于从gray对象移除的目标引用对象标记为gray，对于black引用的新产生的对象标记为black；由于是在开始的时候进行snapshot，因而可能存在Floating Garbage</p>
</li>
<li><p>漏标与误标</p>
<ul>
<li>误标没什么关系，顶多造成浮动垃圾，在下次gc还是可以回收的，但是漏标的后果是致命的，把本应该存活的对象给回收了，从而影响的程序的正确性。</li>
</ul>
</li>
<li><p>漏标情况只会发生在白色对象中，且满足以下任意一个条件</p>
<ul>
<li>并发标记时，应用线程给一个黑色对象的引用类型字段赋值了该白色对象（黑色对象意味着自己和孩子都被扫描了，而黑色下边挂白色的，白色会被认为是垃圾）</li>
<li>并发标记时，应用线程删除所有灰色对象到该白色对象的引用（灰色的意味着孩子还没有被扫描，此时删除孩子的引用）。<br>  <img src="/2019/06/07/jvm%E5%8E%9F%E7%90%86%EF%BC%8847%EF%BC%89G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%B3%BB%E5%88%97%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3/three-color6.png" alt="three-color6.png"><br>  三个灰色对象都指向一个白色对象，此时删除三个灰色对象到白色对象的引用，此时我们可能认为W会被当做垃圾回收，但是存在一种情况是一个黑色对象也引用了白色对象，这样 就回到了第一种情况。</li>
</ul>
</li>
<li><p>对于第一种情况，利用post-write- barrier，记录所有新增得引用关系，然后根据这些引用关系为根重新扫描一遍</p>
</li>
<li><p>对于第二种情况，利用pre-write barrier，将所有即将删除的引用关系的旧引用记录下来，最后以这些引用为根重新扫描一遍。</p>
</li>
</ul>
<h3 id="停顿预测模型"><a href="#停顿预测模型" class="headerlink" title="停顿预测模型"></a>停顿预测模型</h3><ul>
<li>G1收集器突出表现出来的一点是通过一个停顿预测模型根据用户配置的停顿时间来选择CSet的大小，从而达到用户期待的应用程序停顿时间。</li>
<li>通过-XX：MaxGCPauseMillis参数来设置。这一点有点类似于ParallelScanvenge收集器。关于停顿时间的设置并不是越短越好。</li>
<li>设置的时间越短意味着 每次收集的CSet越小，导致垃圾逐步积累变多，最终不得不退化成Serial GC；停顿时间设置的过长，那么会导致每次都会产生长时间的停顿，影响了程序对外的响应时间。</li>
</ul>
<h3 id="G1的收集模式"><a href="#G1的收集模式" class="headerlink" title="G1的收集模式"></a>G1的收集模式</h3><ul>
<li><p>Young GC：收集年轻代里的Region+</p>
</li>
<li><p>Mixed gc :年轻代的所有Region + 全局并发标记阶段选出的收益高的Regionold（old Region）</p>
</li>
<li><p>无无论是Young GC还是Mixed GC都只是并发拷贝的阶段。</p>
</li>
<li><p>分代G1的模式下选择CSet有两种子模式，分别对应Young GC和Mixed GC</p>
</li>
<li><p>Young GC：CSet就是所有年轻代里面的Region</p>
</li>
<li><p>Mixed GC：CSet是所有年轻代里的Region加上全局并发标记阶段标记出来的收益高的Region</p>
</li>
<li><p>G1的运行过程是这样的：会在Young GC和Mixed GC之间不断地切换运行，同时定期地做全局并发标记，在实在赶不上对象创建速度的情况下使用Full GC（Serial GC）</p>
</li>
<li><p>初始标记是在YoungGC上执行的，在进行全局并发标记的时候不会做Mixed GC，在做Mixed GC的时候也不会启动初始标记阶段。</p>
</li>
<li><p>当Mixed GC赶不上对象创建产生的速度的时候就会退化成Full GC，这一点需要重点调优的地方。</p>
</li>
</ul>
<h3 id="G1最佳实践"><a href="#G1最佳实践" class="headerlink" title="G1最佳实践"></a>G1最佳实践</h3><ul>
<li><p>不断调优暂停实践指标</p>
<ul>
<li>通过-XX：MaxGCPauseMillis&#x3D;x可以设置启动应用程序暂停的时间，G1在运行的时候根据这个参数选择CSet来满足响应时间的设置。一般情况下这个值设置到100ms或者200ms都是可以的（不同情况会不一样），但如果设置成50ms就不太合理。暂停时间设置的太短，就会导致出现G1跟不上垃圾产生的速度，最终退化成full GC，所以对这个参数的调优是一个持续的过程，逐步调整到最佳状态。</li>
</ul>
</li>
<li><p>不要设置新生代和老年代的大小</p>
<ul>
<li>G1收集器再运行的时候会调整新生代和老年代的大小，通过改变代的大小来调整对象晋升的速度以及晋升年龄，从而达到我们为收集器设置的暂停时间目标</li>
<li>设置了新生代大小相当于放弃了G1为我们做的自动调优，我们需要做的只是设置整个堆内存的大小，剩下的交给G1自己去分配各个代的大小即可。</li>
</ul>
</li>
<li><p>关注Evacuation Failure</p>
<ul>
<li>Evacuation Failure 类似于CMS里面的晋升失败，堆空间的垃圾太多导致无法完成Region之间的拷贝，于是不得不退化成Ful GC来做一次全局范围内的垃圾收集。</li>
</ul>
</li>
</ul>
<h3 id="G1实例讲解"><a href="#G1实例讲解" class="headerlink" title="G1实例讲解"></a>G1实例讲解</h3><p>  编写程序：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">-verbose:gc</span><br><span class="line">-Xms10m</span><br><span class="line">-Xmx10m</span><br><span class="line">-XX:+UseG1GC</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-XX:MaxGCPauseMillis=200m</span><br><span class="line">*/</span><br><span class="line">public class MyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int size = 1024 * 1024;</span><br><span class="line">        byte[] myAlloc1 = new byte[size];</span><br><span class="line">        byte[] myAlloc2 = new byte[size];</span><br><span class="line">        byte[] myAlloc3 = new byte[size];</span><br><span class="line">        byte[] myAlloc4 = new byte[size];</span><br><span class="line">        System.out.println(&quot;hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>  运行结果：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2019-07-21T09:56:58.080+0800: [GC pause (G1 Humongous Allocation) (young) (initial-mark), 0.0022068 secs]</span><br><span class="line">【解释】：</span><br><span class="line">Humongous大对象空间的申请，因为我们创建了一个1M大小的字节数组。</span><br><span class="line">同时开始一次young GC，young GC会有一次初始标记。</span><br><span class="line">   [Parallel Time: 1.4 ms, GC Workers: 8]</span><br><span class="line">   【解释】：</span><br><span class="line">   并发时间是1.4 ms，一共有8个线程执行</span><br><span class="line">      [GC Worker Start (ms): Min: 293.7, Avg: 293.8, Max: 294.1, Diff: 0.4]</span><br><span class="line">      [Ext Root Scanning (ms): Min: 0.2, Avg: 0.7, Max: 1.3, Diff: 1.1, Sum: 5.9]</span><br><span class="line">      [Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class="line">         [Processed Buffers: Min: 0, Avg: 0.0, Max: 0, Diff: 0, Sum: 0]</span><br><span class="line">      [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class="line">      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span><br><span class="line">      [Object Copy (ms): Min: 0.0, Avg: 0.3, Max: 0.7, Diff: 0.7, Sum: 2.7]</span><br><span class="line">      [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum: 0.4]</span><br><span class="line">         [Termination Attempts: Min: 1, Avg: 4.5, Max: 9, Diff: 8, Sum: 36]</span><br><span class="line">      【解释】：</span><br><span class="line">      以上五个步骤对应之前的young GC理论;</span><br><span class="line">      - 阶段1：根扫描</span><br><span class="line">        - 静态和本地对象被扫描</span><br><span class="line">      - 阶段2：更新RS</span><br><span class="line">        - 处理dirty card队列更新RS</span><br><span class="line">      - 阶段3：处理RS</span><br><span class="line">        - 检测从年轻代指向老年代的对象</span><br><span class="line">      - 阶段4：对象拷贝</span><br><span class="line">        - 拷贝存活的对象到survivor/old区域</span><br><span class="line">      - 阶段5：处理引用队列</span><br><span class="line">        - 软引用，弱引用，虚引用处理        </span><br><span class="line"></span><br><span class="line">      [GC Worker Other (ms): Min: 0.0, Avg: 0.1, Max: 0.1, Diff: 0.1, Sum: 0.5]</span><br><span class="line">      [GC Worker Total (ms): Min: 1.0, Avg: 1.2, Max: 1.3, Diff: 0.4, Sum: 9.5]</span><br><span class="line">      [GC Worker End (ms): Min: 295.0, Avg: 295.0, Max: 295.0, Diff: 0.0]</span><br><span class="line">      【解释】：</span><br><span class="line">      GC线程在其他任务花费的时间，一些统计信息。</span><br><span class="line">   [Code Root Fixup: 0.0 ms]</span><br><span class="line">   [Code Root Purge: 0.0 ms]</span><br><span class="line">   [Clear CT: 0.2 ms]</span><br><span class="line">   【解释】：</span><br><span class="line">   CT：card table</span><br><span class="line">   [Other: 0.5 ms]</span><br><span class="line">      [Choose CSet: 0.0 ms]</span><br><span class="line">      【解释】：回收集合，选择那些回收集合</span><br><span class="line">      [Ref Proc: 0.2 ms]</span><br><span class="line">      【解释】：软引用，弱引用等花费的时间</span><br><span class="line">      [Ref Enq: 0.0 ms]</span><br><span class="line">      【解释】：引用的信息进入到队列当中</span><br><span class="line">      [Redirty Cards: 0.2 ms]</span><br><span class="line">      [Humongous Register: 0.0 ms]</span><br><span class="line">      [Humongous Reclaim: 0.0 ms]</span><br><span class="line">      [Free CSet: 0.0 ms]</span><br><span class="line">      【解释】：对回收集合进行释放，回收</span><br><span class="line">   [Eden: 3072.0K(4096.0K)-&gt;0.0B(2048.0K) Survivors: 0.0B-&gt;1024.0K Heap: 4291.8K(10.0M)-&gt;2900.1K(10.0M)]</span><br><span class="line">   【解释】：执行完young gc之后整个堆的一个状态；</span><br><span class="line">   Eden空间有原来的3072.0K变成了0，Survivors有原来的0变成了1024K，证明里边多了一个对象的大小，整个对象来自于eden，</span><br><span class="line">   Heap是堆的大小是10M，我们jvm参数指定的，释放完之后现在的大小是2900.1K</span><br><span class="line"> [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">2019-07-21T09:56:58.083+0800: [GC concurrent-root-region-scan-start]</span><br><span class="line">2019-07-21T09:56:58.085+0800: [GC concurrent-root-region-scan-end, 0.0016524 secs]</span><br><span class="line">2019-07-21T09:56:58.085+0800: [GC concurrent-mark-start]</span><br><span class="line">【解释】：</span><br><span class="line">并发的一些处理，root scan的开始和结束</span><br><span class="line">并发标记的开始</span><br><span class="line">hello world</span><br><span class="line">2019-07-21T09:56:58.085+0800: [GC concurrent-mark-end, 0.0000945 secs]</span><br><span class="line">2019-07-21T09:56:58.085+0800: [GC remark 2019-07-21T09:56:58.085+0800: [Finalize Marking, 0.0002648 secs] 2019-07-21T09:56:58.085+0800: [GC ref-proc, 0.0004676 secs] 2019-07-21T09:56:58.086+0800: [Unloading, 0.0004559 secs], 0.0015282 secs]</span><br><span class="line"> [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">2019-07-21T09:56:58.087+0800: [GC cleanup 5009K-&gt;5009K(10M), 0.0011514 secs]</span><br><span class="line"> [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">Heap</span><br><span class="line"> garbage-first heap   total 10240K, used 4948K [0x00000000ff600000, 0x00000000ff700050, 0x0000000100000000)</span><br><span class="line">  region size 1024K, 2 young (2048K), 1 survivors (1024K)</span><br><span class="line"> Metaspace       used 3491K, capacity 4498K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 387K, capacity 390K, committed 512K, reserved 1048576K</span><br><span class="line">  【解释】：</span><br><span class="line">  G1收集器，堆大小10240K，已经使用4948K，region的大小是1024K，这个很重要，同时也说明了为什么会创建Humongous，因为1024K超出了region的一半的大小，2个young，有2个region是young，一个survivors是1024K，其他就是old区域。</span><br><span class="line">  Metaspace是元空间的一些情况。</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>G1，G1垃圾收集器</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（48）强引用-软引用-弱引用-虚引用-ThreadLocal</title>
    <url>/2020/03/08/jvm%E5%8E%9F%E7%90%86%EF%BC%8848%EF%BC%89%E5%BC%BA%E5%BC%95%E7%94%A8-%E8%BD%AF%E5%BC%95%E7%94%A8-%E5%BC%B1%E5%BC%95%E7%94%A8-%E8%99%9A%E5%BC%95%E7%94%A8-ThreadLocal/</url>
    <content><![CDATA[<h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><ul>
<li><p>我们日常开发中所遇到的绝大多数引用均是强引用</p>
</li>
<li><p>如果对象拥有强引用，就表示它是可达的，那么垃圾收集器就不会将其回收。</p>
<span id="more"></span></li>
<li><p>如果将某个强引用显式置位null，就表示该引用不再指向对象，若该对象没有其他引用指向它，那么在适当时机就会被垃圾收集器回收。</p>
</li>
<li><p>参考ArrayList类的源代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Removes all of the elements from this list.  The list will</span><br><span class="line"> * be empty after this call returns.</span><br><span class="line"> */</span><br><span class="line">public void clear() &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    // clear to let GC do its work</span><br><span class="line">    for (int i = 0; i &lt; size; i++)</span><br><span class="line">        elementData[i] = null;//显式将引用置为null</span><br><span class="line"></span><br><span class="line">    size = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="其他三种类型的引用"><a href="#其他三种类型的引用" class="headerlink" title="其他三种类型的引用"></a>其他三种类型的引用</h3><ul>
<li>软引用(soft Reference)</li>
<li>弱引用(waek reference)</li>
<li>虚引用(phantom reference)</li>
<li>Reference 抽象类是这些引用的父类</li>
<li>具体参见Reference类的JavaDoc文档</li>
<li>ReferenceQueue</li>
</ul>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>java.lang.ref public abstract class Reference<T><br>extends Object<br>Abstract base class for reference objects. This class defines the operations common to all reference objects. Because reference objects are implemented in close cooperation with the garbage collector, this class may not be subclassed directly.<br>Reference是引用对象的父类，这个类定义了一些适用于所有引用对象的操作，因为引用对象他的实现和垃圾收集器是紧密相关的，所以这个类是不可以被子类化的。<br>他的构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Reference(T referent) &#123;</span><br><span class="line">    this(referent, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Reference(T referent, ReferenceQueue&lt;? super T&gt; queue) &#123;</span><br><span class="line">    this.referent = referent;</span><br><span class="line">    this.queue = (queue == null) ? ReferenceQueue.NULL : queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Reference的构造器不是public的，子类无法去super调用，而SoftReference、WeakReference、PhantomReference都是和Reference<br>同一个包下边，我们自己定义的类是无法去继承Reference的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class Reference&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /* A Reference instance is in one of four possible internal states:</span><br><span class="line">     *</span><br><span class="line">     *     Active: Subject to special treatment by the garbage collector.  Some</span><br><span class="line">     *     time after the collector detects that the reachability of the</span><br><span class="line">     *     referent has changed to the appropriate state, it changes the</span><br><span class="line">     *     instance&#x27;s state to either Pending or Inactive, depending upon</span><br><span class="line">     *     whether or not the instance was registered with a queue when it was</span><br><span class="line">     *     created.  In the former case it also adds the instance to the</span><br><span class="line">     *     pending-Reference list.  Newly-created instances are Active.</span><br><span class="line">     *</span><br><span class="line">     *     Pending: An element of the pending-Reference list, waiting to be</span><br><span class="line">     *     enqueued by the Reference-handler thread.  Unregistered instances</span><br><span class="line">     *     are never in this state.</span><br><span class="line">     *</span><br><span class="line">     *     Enqueued: An element of the queue with which the instance was</span><br><span class="line">     *     registered when it was created.  When an instance is removed from</span><br><span class="line">     *     its ReferenceQueue, it is made Inactive.  Unregistered instances are</span><br><span class="line">     *     never in this state.</span><br><span class="line">     *</span><br><span class="line">     *     Inactive: Nothing more to do.  Once an instance becomes Inactive its</span><br><span class="line">     *     state will never change again.</span><br><span class="line">     *</span><br><span class="line">     * The state is encoded in the queue and next fields as follows:</span><br><span class="line">     *</span><br><span class="line">     *     Active: queue = ReferenceQueue with which instance is registered, or</span><br><span class="line">     *     ReferenceQueue.NULL if it was not registered with a queue; next =</span><br><span class="line">     *     null.</span><br><span class="line">     *</span><br><span class="line">     *     Pending: queue = ReferenceQueue with which instance is registered;</span><br><span class="line">     *     next = this</span><br><span class="line">     *</span><br><span class="line">     *     Enqueued: queue = ReferenceQueue.ENQUEUED; next = Following instance</span><br><span class="line">     *     in queue, or this if at end of list.</span><br><span class="line">     *</span><br><span class="line">     *     Inactive: queue = ReferenceQueue.NULL; next = this.</span><br><span class="line">     *</span><br><span class="line">     * With this scheme the collector need only examine the next field in order</span><br><span class="line">     * to determine whether a Reference instance requires special treatment: If</span><br><span class="line">     * the next field is null then the instance is active; if it is non-null,</span><br><span class="line">     * then the collector should treat the instance normally.</span><br><span class="line">     *</span><br><span class="line">     * To ensure that a concurrent collector can discover active Reference</span><br><span class="line">     * objects without interfering with application threads that may apply</span><br><span class="line">     * the enqueue() method to those objects, collectors should link</span><br><span class="line">     * discovered objects through the discovered field. The discovered</span><br><span class="line">     * field is also used for linking Reference objects in the pending list.</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    private T referent;         /* Treated specially by GC */</span><br><span class="line"></span><br><span class="line">    volatile ReferenceQueue&lt;? super T&gt; queue;</span><br><span class="line"></span><br><span class="line">    /* When active:   NULL 还没有入队</span><br><span class="line">     *     pending:   this 表示也还没有入队，只是指向自己</span><br><span class="line">     *    Enqueued:   next reference in queue (or this if last) 入队，next指向是队列的下一个元素</span><br><span class="line">     *    Inactive:   this 他自己</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&quot;rawtypes&quot;)</span><br><span class="line">    Reference next;</span><br><span class="line"></span><br><span class="line">    /* When active:   next element in a discovered reference list maintained by GC (or this if last)</span><br><span class="line">     *     pending:   next element in the pending list (or null if last)</span><br><span class="line">     *   otherwise:   NULL</span><br><span class="line">     */</span><br><span class="line">    transient private Reference&lt;T&gt; discovered;  /* used by VM */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* Object used to synchronize with the garbage collector.  The collector</span><br><span class="line">     * must acquire this lock at the beginning of each collection cycle.  It is</span><br><span class="line">     * therefore critical that any code holding this lock complete as quickly</span><br><span class="line">     * as possible, allocate no new objects, and avoid calling user code.</span><br><span class="line">     */</span><br><span class="line">    static private class Lock &#123; &#125;</span><br><span class="line">    private static Lock lock = new Lock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* List of References waiting to be enqueued.  The collector adds</span><br><span class="line">     * References to this list, while the Reference-handler thread removes</span><br><span class="line">     * them.  This list is protected by the above lock object. The</span><br><span class="line">     * list uses the discovered field to link its elements.</span><br><span class="line">     */</span><br><span class="line">    private static Reference&lt;Object&gt; pending = null;</span><br><span class="line"></span><br><span class="line">    /* High-priority thread to enqueue pending References</span><br><span class="line">     */</span><br><span class="line">    private static class ReferenceHandler extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        private static void ensureClassInitialized(Class&lt;?&gt; clazz) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Class.forName(clazz.getName(), true, clazz.getClassLoader());</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                throw (Error) new NoClassDefFoundError(e.getMessage()).initCause(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static &#123;</span><br><span class="line">            // pre-load and initialize InterruptedException and Cleaner classes</span><br><span class="line">            // so that we don&#x27;t get into trouble later in the run loop if there&#x27;s</span><br><span class="line">            // memory shortage while loading/initializing them lazily.</span><br><span class="line">            ensureClassInitialized(InterruptedException.class);</span><br><span class="line">            ensureClassInitialized(Cleaner.class);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class="line">            super(g, name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                tryHandlePending(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Try handle pending &#123;@link Reference&#125; if there is one.&lt;p&gt;</span><br><span class="line">     * Return &#123;@code true&#125; as a hint that there might be another</span><br><span class="line">     * &#123;@link Reference&#125; pending or &#123;@code false&#125; when there are no more pending</span><br><span class="line">     * &#123;@link Reference&#125;s at the moment and the program can do some other</span><br><span class="line">     * useful work instead of looping.</span><br><span class="line">     *</span><br><span class="line">     * @param waitForNotify if &#123;@code true&#125; and there was no pending</span><br><span class="line">     *                      &#123;@link Reference&#125;, wait until notified from VM</span><br><span class="line">     *                      or interrupted; if &#123;@code false&#125;, return immediately</span><br><span class="line">     *                      when there is no pending &#123;@link Reference&#125;.</span><br><span class="line">     * @return &#123;@code true&#125; if there was a &#123;@link Reference&#125; pending and it</span><br><span class="line">     *         was processed, or we waited for notification and either got it</span><br><span class="line">     *         or thread was interrupted before being notified;</span><br><span class="line">     *         &#123;@code false&#125; otherwise.</span><br><span class="line">     */</span><br><span class="line">    static boolean tryHandlePending(boolean waitForNotify) &#123;</span><br><span class="line">        Reference&lt;Object&gt; r;</span><br><span class="line">        Cleaner c;</span><br><span class="line">        try &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                if (pending != null) &#123;</span><br><span class="line">                    r = pending;</span><br><span class="line">                    // &#x27;instanceof&#x27; might throw OutOfMemoryError sometimes</span><br><span class="line">                    // so do this before un-linking &#x27;r&#x27; from the &#x27;pending&#x27; chain...</span><br><span class="line">                    c = r instanceof Cleaner ? (Cleaner) r : null;</span><br><span class="line">                    // unlink &#x27;r&#x27; from &#x27;pending&#x27; chain</span><br><span class="line">                    pending = r.discovered;</span><br><span class="line">                    r.discovered = null;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // The waiting on the lock may cause an OutOfMemoryError</span><br><span class="line">                    // because it may try to allocate exception objects.</span><br><span class="line">                    if (waitForNotify) &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    // retry if waited</span><br><span class="line">                    return waitForNotify;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (OutOfMemoryError x) &#123;</span><br><span class="line">            // Give other threads CPU time so they hopefully drop some live references</span><br><span class="line">            // and GC reclaims some space.</span><br><span class="line">            // Also prevent CPU intensive spinning in case &#x27;r instanceof Cleaner&#x27; above</span><br><span class="line">            // persistently throws OOME for some time...</span><br><span class="line">            Thread.yield();</span><br><span class="line">            // retry</span><br><span class="line">            return true;</span><br><span class="line">        &#125; catch (InterruptedException x) &#123;</span><br><span class="line">            // retry</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Fast path for cleaners</span><br><span class="line">        if (c != null) &#123;</span><br><span class="line">            c.clean();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ReferenceQueue&lt;? super Object&gt; q = r.queue;</span><br><span class="line">        if (q != ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class="line">        for (ThreadGroup tgn = tg;</span><br><span class="line">             tgn != null;</span><br><span class="line">             tg = tgn, tgn = tg.getParent());</span><br><span class="line">        Thread handler = new ReferenceHandler(tg, &quot;Reference Handler&quot;);</span><br><span class="line">        /* If there were a special system-only priority greater than</span><br><span class="line">         * MAX_PRIORITY, it would be used here</span><br><span class="line">         */</span><br><span class="line">        handler.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        handler.setDaemon(true);</span><br><span class="line">        handler.start();</span><br><span class="line"></span><br><span class="line">        // provide access in SharedSecrets</span><br><span class="line">        SharedSecrets.setJavaLangRefAccess(new JavaLangRefAccess() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean tryHandlePendingReference() &#123;</span><br><span class="line">                return tryHandlePending(false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* -- Referent accessor and setters -- */</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns this reference object&#x27;s referent.  If this reference object has</span><br><span class="line">     * been cleared, either by the program or by the garbage collector, then</span><br><span class="line">     * this method returns &lt;code&gt;null&lt;/code&gt;.</span><br><span class="line">     *</span><br><span class="line">     * @return   The object to which this reference refers, or</span><br><span class="line">     *           &lt;code&gt;null&lt;/code&gt; if this reference object has been cleared</span><br><span class="line">     */</span><br><span class="line">    public T get() &#123;</span><br><span class="line">        return this.referent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Clears this reference object.  Invoking this method will not cause this</span><br><span class="line">     * object to be enqueued.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; This method is invoked only by Java code; when the garbage collector</span><br><span class="line">     * clears references it does so directly, without invoking this method.</span><br><span class="line">     */</span><br><span class="line">     调用这个方法并不会将对象入队。</span><br><span class="line">     当垃圾收集器清理的时候它会直接清理，而不会调用这个方法。</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        this.referent = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* -- Queue operations -- */</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Tells whether or not this reference object has been enqueued, either by</span><br><span class="line">     * the program or by the garbage collector.  If this reference object was</span><br><span class="line">     * not registered with a queue when it was created, then this method will</span><br><span class="line">     * always return &lt;code&gt;false&lt;/code&gt;.</span><br><span class="line">     *</span><br><span class="line">     * @return   &lt;code&gt;true&lt;/code&gt; if and only if this reference object has</span><br><span class="line">     *           been enqueued</span><br><span class="line">     */</span><br><span class="line">    public boolean isEnqueued() &#123;</span><br><span class="line">        return (this.queue == ReferenceQueue.ENQUEUED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Adds this reference object to the queue with which it is registered,</span><br><span class="line">     * if any.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; This method is invoked only by Java code; when the garbage collector</span><br><span class="line">     * enqueues references it does so directly, without invoking this method.</span><br><span class="line">     *</span><br><span class="line">     * @return   &lt;code&gt;true&lt;/code&gt; if this reference object was successfully</span><br><span class="line">     *           enqueued; &lt;code&gt;false&lt;/code&gt; if it was already enqueued or if</span><br><span class="line">     *           it was not registered with a queue when it was created</span><br><span class="line">     */</span><br><span class="line">    public boolean enqueue() &#123;</span><br><span class="line">        return this.queue.enqueue(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* -- Constructors -- */</span><br><span class="line"></span><br><span class="line">    Reference(T referent) &#123;</span><br><span class="line">        this(referent, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Reference(T referent, ReferenceQueue&lt;? super T&gt; queue) &#123;</span><br><span class="line">        this.referent = referent;</span><br><span class="line">        this.queue = (queue == null) ? ReferenceQueue.NULL : queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReferenceQueue java doc：<br>Reference queues, to which registered reference objects are appended by the garbage collector after the appropriate reachability changes are detected.<br>引用队列，当垃圾收集器检测到引用对象的可达性发生变化后，会把引用对象放到引用队列当中。</p>
<p>一个引用实例可以是如下四种内部状态的其中之一：</p>
<ul>
<li>活跃状态<br>  他会被垃圾收集器进行一种特殊的对待 当垃圾收集器检测到被引用的对象的可达性达到一种恰当的状态的一段时间之后，就会改变实例的状态，要么变成pending或者inactive，这个取决于这个实例在注册的时候是否被注册到一个队列上面。在前者这种状态下（pending）实例会被添加到pending引用列表当中， 而新创建的总是活动状态。</li>
<li>挂起状态<br>  引用队列里边的一个元素，等待引用处理线程将其入队，未注册的实例永远不会有这种状态。</li>
<li>入队状态<br>  当一个实例创建的时候被注册了，那么实例将会作为队列的一个元素，当一个实例从他的引用队列中移除时，它会变成inactive状态，未注册的实例永远不会处于这种状态。</li>
<li>不活跃状态<br>  没什么对它可做的，一个实例处于inactive，他的状态永远不会发生变化。</li>
</ul>
<p> 引用的状态在队列里边会被编码，next 成员变量是如下的逻辑：<br>    Active: quene &#x3D; ReferenceQueue 他里边的实例是已经注册，或者ReferenceQueue.NULL 它没有被注册到引用队列里边去，next &#x3D; null<br>    pending：quene &#x3D; ReferenceQueue，next &#x3D; this<br>    enquene：quene &#x3D; ReferenceQueue.ENQUEUED;next &#x3D; 队列中的下一个元素，或者是this，前提是位于列表的最末端.<br>    inactive:queue &#x3D; ReferenceQueue.NULL;next &#x3D; this.</p>
<pre><code>在这种模式下，垃圾收集器就可以通过next成员变量判断引用实例是否需要特殊对待，如果next实例是null，那么实例就是活动状态，如果不是null，那么收集器就以正常的实例对待它。

为了确保并发收集器能够探测到活动的引用对象，而不需要介入线程，应用可以使用enqueue()方法对待这些对象，收集器应该将发现的对象通过discovered变量连接起来，discovered变量也是用于在pending列表当中连接引用对象。

观察构造器：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Reference(T referent, ReferenceQueue&lt;? super T&gt; queue) &#123;</span><br><span class="line">    this.referent = referent;</span><br><span class="line">    this.queue = (queue == null) ? ReferenceQueue.NULL : queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
引用新创建的时候，是活动状态，Reference的queue = ReferenceQueue.NULL(如果没有传递引用队列的情况)，ReferenceQueue.NULL是什么？
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ReferenceQueue&lt;T&gt; &#123;</span><br><span class="line">  private static class Null&lt;S&gt; extends ReferenceQueue&lt;S&gt; &#123;</span><br><span class="line">  boolean enqueue(Reference&lt;? extends S&gt; r) &#123;</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  static ReferenceQueue&lt;Object&gt; NULL = new Null&lt;&gt;();</span><br><span class="line">  static ReferenceQueue&lt;Object&gt; ENQUEUED = new Null&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
ReferenceQueue.NULL是ReferenceQueue里边的一个私有子类对象，他的enqueue()总是返回false。next并没有被复制，因此next是null。
</code></pre>
<h4 id="SoftReference"><a href="#SoftReference" class="headerlink" title="SoftReference"></a>SoftReference</h4><p>首先编写一个实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Date date=  new Date();</span><br><span class="line">        SoftReference&lt;Date&gt; softReference = new SoftReference(date);</span><br><span class="line">        Date date1 = softReference.get();</span><br><span class="line">        //这里一定要判空，因为不一定什么时刻内存不够了，软引用就会被清理掉。</span><br><span class="line">        if(null != date1)&#123;</span><br><span class="line">            System.out.println(&quot;hello&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            System.out.println(&quot;world&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;=========&quot;);</span><br><span class="line">        softReference.clear();</span><br><span class="line">        Date date2 = softReference.get();</span><br><span class="line">        System.out.println(date2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>hello<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>null</p>
<p>那么接下来看一下SoftReference的文档：<br>Soft reference objects, which are cleared at the discretion of the garbage collector in response to memory demand. Soft references are most often used to implement memory-sensitive caches.<br>Suppose that the garbage collector determines at a certain point in time that an object is softly reachable. At that time it may choose to clear atomically all soft references to that object and all soft references to any other softly-reachable objects from which that object is reachable through a chain of strong references. At the same time or at some later time it will enqueue those newly-cleared soft references that are registered with reference queues.<br>All soft references to softly-reachable objects are guaranteed to have been cleared before the virtual machine throws an OutOfMemoryError. Otherwise no constraints are placed upon the time at which a soft reference will be cleared or the order in which a set of such references to different objects will be cleared. Virtual machine implementations are, however, encouraged to bias against clearing recently-created or recently-used soft references.<br>Direct instances of this class may be used to implement simple caches; this class or derived subclasses may also be used in larger data structures to implement more sophisticated caches. As long as the referent of a soft reference is strongly reachable, that is, is actually in use, the soft reference will not be cleared. Thus a sophisticated cache can, for example, prevent its most recently used entries from being discarded by keeping strong referents to those entries, leaving the remaining entries to be discarded at the discretion of the garbage collector.<br>软引用对象 当垃圾收集器去响应一些内存需求的时候软引用会被清理掉，软引用经常用于实现内存敏感的缓存。</p>
<p>假如垃圾收集器检测到在某个时间点软引用是可达的（一个对象只有软引用指向它），他可以选择原子性的清理对象的所有的软引用，以及对于任何其他从这对象开始的，通过软引用链条可达的对象也会别清理，在这个时候或者这之后的某个时间，他会将新创建的被清理掉过的软引用入队列，这个队列是创建的时候注册的。</p>
<p>所有软引用以及通过软引用链条可达的对象 可以确保在jvm抛出OOM错误之前被清理掉。</p>
<p>这个类的直接事例就是实现简单的缓存，或者它延伸的子类可以用于在比较大的数据结构当中实现更为复杂的缓存，只要软引用里边的reference在实际使用当中是强可达的，那么软引用本身就不会被清理掉。 这样我们就可以设计一种复杂的缓存，可以避免最近被使用的实体被清除，通过对这些实体保持强引用就可以实现。</p>
<h5 id="ReferenceQueue"><a href="#ReferenceQueue" class="headerlink" title="ReferenceQueue"></a>ReferenceQueue</h5><p>ReferenceQueue引用队列的设计目的是在于让我们能够知道或者是识别出垃圾收集器所执行的动作.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTests2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Date date=  new Date();</span><br><span class="line">        ReferenceQueue&lt;Date&gt; referenceQueue = new ReferenceQueue&lt;&gt;();</span><br><span class="line">        SoftReference&lt;Date&gt; softReference = new SoftReference(date,referenceQueue);</span><br><span class="line"></span><br><span class="line">        System.out.println(softReference.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<br>Tue Mar 10 21:10:09 CST 2020</p>
<p>时间可以正常得到，证明date并没有被回收，因为内存还没到紧急的时刻，还没到OOM之前的时刻，我们修改程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTests2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Date date=  new Date();</span><br><span class="line">        ReferenceQueue&lt;Date&gt; referenceQueue = new ReferenceQueue&lt;&gt;();</span><br><span class="line">        SoftReference&lt;Date&gt; softReference = new SoftReference(date,referenceQueue);</span><br><span class="line">        date = null;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(softReference.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br>Wed Mar 11 20:21:18 CST 2020</p>
<p>虽然我们将强引用去掉，但是软引用里边的referent还是没有被回收，因为没到内存吃紧的时候。只有在内存吃紧的时候，软引用才会被执行回收。</p>
<h4 id="WeakReference"><a href="#WeakReference" class="headerlink" title="WeakReference"></a>WeakReference</h4><p>Weak reference objects, which do not prevent their referents from being made finalizable, finalized, and then reclaimed. Weak references are most often used to implement canonicalizing mappings.<br>Suppose that the garbage collector determines at a certain point in time that an object is weakly reachable. At that time it will atomically clear all weak references to that object and all weak references to any other weakly-reachable objects from which that object is reachable through a chain of strong and soft references. At the same time it will declare all of the formerly weakly-reachable objects to be finalizable. At the same time or at some later time it will enqueue those newly-cleared weak references that are registered with reference queues.</p>
<p>弱引用对象，它不会阻止它里边的reference被回收掉，他经常用于映射。<br>假设垃圾收集器在某个时间点认为一个对象是弱引用可达的，这个时候会原子性的清除弱引用和弱引用可达的其他对象，她会声明之前的弱引用是可以回收的，同时或者过一段时间后这些新的被清理掉的引用背会入队到创建的时候注册的队列里边。</p>
<p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTests3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Date date = new Date();</span><br><span class="line">        WeakReference&lt;Date&gt; weakReference = new WeakReference&lt;&gt;(date);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br>Tue Mar 10 21:10:09 CST 2020</p>
<p>如果一个对象指向它的引用最强的引用是弱引用并且是弱引用可达的，那么这个对象会在下一次垃圾收集周期当中被回收。<br>如果是软引用可能还会存活几个收集周期。</p>
<p>但是这个要和内存的使用情况来分析，比如如下的使用，并不一定会被回收：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTests3 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Date date = new Date();</span><br><span class="line">        WeakReference&lt;Date&gt; weakReference = new WeakReference&lt;&gt;(date);</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(5000);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br>Tue Mar 10 21:28:16 CST 2020</p>
<p>为什么没有被回收，原因其实是Date date &#x3D; new Date();这个地方存在一个强引用，如果我们修改下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTests3 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Date date = new Date();</span><br><span class="line">        WeakReference&lt;Date&gt; weakReference = new WeakReference&lt;&gt;(date);</span><br><span class="line">        date = null;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(5000);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br>null</p>
<h4 id="PhantomReference"><a href="#PhantomReference" class="headerlink" title="PhantomReference"></a>PhantomReference</h4><p>Phantom reference objects, which are enqueued after the collector determines that their referents may otherwise be reclaimed. Phantom references are most often used for scheduling pre-mortem(在真正的清除之前) cleanup actions in a more flexible way than is possible with the Java finalization mechanism.<br>If the garbage collector determines at a certain point in time that the referent of a phantom reference is phantom reachable, then at that time or at some later time it will enqueue the reference.<br>In order to ensure that a reclaimable object remains so, the referent of a phantom reference may not be retrieved: The get method of a phantom reference always returns null.<br>Unlike soft and weak references, phantom references are not automatically cleared by the garbage collector as they are enqueued. An object that is reachable via phantom references will remain so until all such references are cleared or themselves become unreachable.<br>虚引用引用的对象，当垃圾收集器确定它们的引用可以被回收的情况下，会被入队,虚引用经常用于调度这种清除的动作，这个要比java的finalization的方式更加灵活，即在对象在被真正清理之前执行一些特殊的逻辑。<br>在垃圾收集器再确定的时间点可以确定虚引用包装对象里边的referent是虚引用可达的，在这个时刻或者之后的某个时刻，就会将这个引用执行入队操作。<br>为了确保一个可回收的对象遵守这样的规则，phantom reference 里边的referent就应该不应该被获取到，因此phantom reference 的get方法总是返回null。<br>试想，如果get方法能够被获取到，那么在外部我们可以使用强引用关联上这个referent，那么对象就不可能被回收掉，对象无法回收掉，就无法实现上面描述的规则，无法得到通知。<br>和弱引用软引用不用的是，对象入队的时候，虚引用的对象并不会被垃圾收集器自动清理掉，一个对象如果是虚引用可达的，它会依然保留，直到所有这样的引用都被清理掉或者它们自身都不可达的，才会被清理掉，虚引用的主要作用是虚引用的对象在被垃圾回收的时候，我们会收到一个通知。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PhantomReference&lt;T&gt; extends Reference&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">  //get方法直接返回null</span><br><span class="line">  public T get() &#123;</span><br><span class="line">         return null;</span><br><span class="line">  &#125;</span><br><span class="line"> //构造方法让使用者必须传递一个引用队列。</span><br><span class="line">  public PhantomReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123;</span><br><span class="line">      super(referent, q);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTests4 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Date date = new Date();</span><br><span class="line">        PhantomReference&lt;Date&gt; phantomReference = new PhantomReference(date, new ReferenceQueue&lt;&gt;());</span><br><span class="line">        System.out.println(phantomReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br>null</p>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ul>
<li>为什么PhantomReference的get方法直接返回null?</li>
<li>为什么PhantomReference的构造器只有接受2个参数(referent与queue)的这一种形式，而没有只接收referent这唯一参数的构造器?</li>
</ul>
<p>当我们将一个对象封装到PhantomReference中时，这就意味着我们永远也无法再访问到这个对象了，因为PhantomReference的get方法永远会返回null；PhantomReference的主要作用并不在于可以让我们获取到其中封装的referent，而是在于当垃圾收集器回收其referent时，这个PhantomReference会被放置到与其关联的队列中，并且得到相应的通知，这就是PhantomReference存在的唯一目的。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).<br>For example, the class below generates unique identifiers local to each thread. A thread’s id is assigned the first time it invokes ThreadId.get() and remains unchanged on subsequent calls.<br>   import java.util.concurrent.atomic.AtomicInteger;</p>
<p>   public class ThreadId {<br>       &#x2F;&#x2F; Atomic integer containing the next thread ID to be assigned<br>       private static final AtomicInteger nextId &#x3D; new AtomicInteger(0);</p>
<pre><code>   // Thread local variable containing each thread&#39;s ID
   private static final ThreadLocal&lt;Integer&gt; threadId =
       new ThreadLocal&lt;Integer&gt;() &#123;
           @Override protected Integer initialValue() &#123;
               return nextId.getAndIncrement();
       &#125;
   &#125;;

   // Returns the current thread&#39;s unique ID, assigning it if necessary
   public static int get() &#123;
       return threadId.get();
   &#125;
</code></pre>
<p>   }</p>
<p>Each thread holds an implicit reference to its copy of a thread-local variable as long as the thread is alive and the ThreadLocal instance is accessible; after a thread goes away, all of its copies of thread-local instances are subject to garbage collection (unless other references to these copies exist).</p>
<p>这个类提供一个 thread-local变量，不同的线程得到的这个值是不一样的。通过set和get方法设置和读取 thread-local变量，每个线程都有一个它自己的对这个变量的副本，ThreadLocal通常被定义成 private static 的成员变量。<br>下边这个实例会生成一个标识符，这个标识符归属一个线程，线程的id是首次调用get方法的时候初始化一个值，并且以后的流程中不会被修改</p>
<p>每个线程都有持有一个thread-local副本的隐式引用，只要这个线程是存活的并且ThreadLocal是可以被访问，当一个线程消亡了，所有的thread-local的实例的副本都会被垃圾回收掉，除非有其他引用关联到这个副本。</p>
<p>重要方法-get：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Returns the value in the current thread&#x27;s copy of this</span><br><span class="line">   * thread-local variable.  If the variable has no value for the</span><br><span class="line">   * current thread, it is first initialized to the value returned</span><br><span class="line">   * by an invocation of the &#123;@link #initialValue&#125; method.</span><br><span class="line">   *</span><br><span class="line">   * @return the current thread&#x27;s value of this thread-local</span><br><span class="line">   */</span><br><span class="line">  public T get() &#123;</span><br><span class="line">      Thread t = Thread.currentThread();</span><br><span class="line">      ThreadLocalMap map = getMap(t);</span><br><span class="line">      if (map != null) &#123;</span><br><span class="line">          ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">          if (e != null) &#123;</span><br><span class="line">              @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">              T result = (T)e.value;</span><br><span class="line">              return result;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return setInitialValue();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Sets the current thread&#x27;s copy of this thread-local variable</span><br><span class="line">   * to the specified value.  Most subclasses will have no need to</span><br><span class="line">   * override this method, relying solely on the &#123;@link #initialValue&#125;</span><br><span class="line">   * method to set the values of thread-locals.</span><br><span class="line">   *</span><br><span class="line">   * @param value the value to be stored in the current thread&#x27;s copy of</span><br><span class="line">   *        this thread-local.</span><br><span class="line">   */</span><br><span class="line">  public void set(T value) &#123;</span><br><span class="line">      Thread t = Thread.currentThread();</span><br><span class="line">      ThreadLocalMap map = getMap(t);</span><br><span class="line">      if (map != null)</span><br><span class="line">          map.set(this, value);</span><br><span class="line">      else</span><br><span class="line">          createMap(t, value);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>get()方法：<br>获取到当前线程的thread-local副本的值，如果这个线程的变量的值不存在，那么initialValue()方法初始化的值会被返回。<br>set方法首先得到当前线程，然后调用getMap方法，那么getMap方法做了什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Get the map associated with a ThreadLocal. Overridden in</span><br><span class="line"> * InheritableThreadLocal.</span><br><span class="line"> *</span><br><span class="line"> * @param  t the current thread</span><br><span class="line"> * @return the map</span><br><span class="line"> */</span><br><span class="line"> 获取到ThreadLocal关联的map对象</span><br><span class="line">ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">    return t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到Thread的threadLocals,进入到Thread类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="line"> * by the ThreadLocal class. */</span><br><span class="line"> 属于当前线程的ThreadLocal的值，这个map被ThreadLocal维护</span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = null;</span><br></pre></td></tr></table></figure>
<p>ThreadLocalMap是ThreadLocal的一个内部类。<br>回到ThreadLocal的set方法，得到map之后做了一个判断，map!&#x3D;null,那么紧接着将value设置到map里边去，key是ThreadLocal，value就是set方法的参数value。<br>如果map是空的，那么就是执行  createMap(t, value)方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">    t.threadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接创建一个ThreadLocalMap对象赋值给了Thread的成员变量threadLocals，构造器参数是ThreadLocal和将要设置的value。</p>
<p>get方法里边也是首先得到当前线程，通过当前线程得到ThreadLocalMap，如果map不是空的，就从ThreadLocalMap里边get一个Entry，<br>getEntry的key是ThreadLocal，那么ThreadLocalMap.Entry是什么？<br>ThreadLocalMap.Entry是ThreadLocalMap内部静态类，看定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    /** The value associated with this ThreadLocal. */</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        super(k);//key是弱引用的reference</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Entry继承了WeakReference。<br>我们设置的value存储在ThreadLocalMap.Entry里边，得到ThreadLocalMap.Entry之后，得到里边的value。然后get方法返回。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest5 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();</span><br><span class="line">        threadLocal.set(&quot;hello&quot;);</span><br><span class="line">        threadLocal.set(&quot;world&quot;);</span><br><span class="line">        System.out.println(threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br>world</p>
<h4 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h4><p><img src="/2020/03/08/jvm%E5%8E%9F%E7%90%86%EF%BC%8848%EF%BC%89%E5%BC%BA%E5%BC%95%E7%94%A8-%E8%BD%AF%E5%BC%95%E7%94%A8-%E5%BC%B1%E5%BC%95%E7%94%A8-%E8%99%9A%E5%BC%95%E7%94%A8-ThreadLocal/ThreadLocal.png" alt="ThreadLocal.png"><br><img src="/2020/03/08/jvm%E5%8E%9F%E7%90%86%EF%BC%8848%EF%BC%89%E5%BC%BA%E5%BC%95%E7%94%A8-%E8%BD%AF%E5%BC%95%E7%94%A8-%E5%BC%B1%E5%BC%95%E7%94%A8-%E8%99%9A%E5%BC%95%E7%94%A8-ThreadLocal/ThreadLocal2.png" alt="ThreadLocal2.png"></p>
<p>Entry为什么是WeakReference,是因为当线程执行完run方法之后，就会处于消亡的状态，也不会指向ThreadLocal对象，那么这个时候应该被回收，否则就会出现内存泄露。</p>
<p>为什么Entry的key是一个弱引用，这样设计的目的是什么呢？<br>我们从2个方向分别论证：</p>
<ul>
<li>假如key指向的ThreadLocal对象的引用是强引用，那么当栈里边的指向ThreadLocal对象的引用消失的时候，这个时候ThreadLocal对象还不能被GC，因为Entry的Key还有强引用指向它，但是这个ThreadLocal对象再也没法被访问到，Entry里边只会越来越大，最后会造成内存泄露。</li>
<li>假如key指向的ThreadLocal对象的引用是弱引用，那么当栈里边的指向ThreadLocal对象的引用消失的时候，此时ThreadLocal对象只有Entry的key指向它，并且是弱引用，那么此时ThreadLocal对象就会被回收，不会造成内存泄露。</li>
</ul>
<p>综上所述，使用Entry使用弱引用是合理的。</p>
<p>另外还有一个地方需要知道，key指向的ThreadLocal对象如果被回收或者被置成了null，那么这个key-value对就无法被访问，一直存在这个threadLocals数组里边，这种情况也会被造成内存泄露，因此针对于这种情况也需要进行特殊处理：</p>
<ul>
<li>在ThreadLocal的set或者get方法都会有一个清理的过程，这个方法是：expungeStaleEntry，这个方法会对key为null的键值对进行清除。</li>
<li>ThreadLocal的remove方法，显式的删除key-value对，但是也会调用expungeStaleEntry方法。</li>
</ul>
<p>应用程序开发角度：<br>我们经常定义ThreadLocal：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line"></span><br><span class="line">private static final ThreadLocal&lt;String&gt; tl = new ThreadLocal();</span><br><span class="line"></span><br><span class="line">  //不需要ThreadLocal的时候的使用方式</span><br><span class="line">  try&#123;</span><br><span class="line">    .....</span><br><span class="line">  &#125;catch()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;finally&#123;</span><br><span class="line">    //显式移除，防止内存泄露</span><br><span class="line">    tl.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>强引用、软引用、弱引用、虚引用</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（49）ThreadLocal内存泄露问题本质分析与推导</title>
    <url>/2020/04/01/jvm%E5%8E%9F%E7%90%86%EF%BC%8849%EF%BC%89ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98%E6%9C%AC%E8%B4%A8%E5%88%86%E6%9E%90%E4%B8%8E%E6%8E%A8%E5%AF%BC/</url>
    <content><![CDATA[<h3 id="threadLocal内存溢出分析"><a href="#threadLocal内存溢出分析" class="headerlink" title="threadLocal内存溢出分析"></a>threadLocal内存溢出分析</h3><p><img src="/2020/04/01/jvm%E5%8E%9F%E7%90%86%EF%BC%8849%EF%BC%89ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98%E6%9C%AC%E8%B4%A8%E5%88%86%E6%9E%90%E4%B8%8E%E6%8E%A8%E5%AF%BC/threadlocal-stack-heap.png" alt="threadlocal-stack-heap.png"></p>
<span id="more"></span>
<p>我们使用ThreadLocal的方式一般是static的。<br>public static ThreadLocal<String> threadlocal &#x3D; new ThreadLocal();</p>
<p>假设：<br>entry的key指向的threadlocal的引用是强引用，那么如果栈里边的threadlocal &#x3D; null;，此时由于key指向ThreadLocal的对象是强引用，无法回收，此时出现内存泄露。</p>
<p>那么如果将key指向ThreadLocal的对象改成弱引用，那么threadlocal &#x3D; null;的时候，现在只有key指向ThreadLocal，而且是弱引用，那么下次gc，ThreadLocal会被回收掉。</p>
<p>还有一种情况是是key指向的ThreadLocal被置成null，key指向null，那么value还没有被回收，这种情况也是内存泄露，对于这种情况ThreadLocal的实现里边做了规避。即在get和set方法里边调用了expungeStaleEntry()方法。</p>
<h3 id="防止内存泄露"><a href="#防止内存泄露" class="headerlink" title="防止内存泄露"></a>防止内存泄露</h3><p>使用完毕之后调用一下set和get，或者remove方法，清除key为null的entry。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>ThreadLocal、存泄露</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（4）接口初始化规则与类加载器准备阶段和初始化阶段的重要意义</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E6%8E%A5%E5%8F%A3%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A7%84%E5%88%99%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5%E7%9A%84%E9%87%8D%E8%A6%81%E6%84%8F%E4%B9%89/</url>
    <content><![CDATA[<p>先看一段代码：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class MyTest5 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(MyChild5.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface MyParent5&#123;</span><br><span class="line">    public static final int a = 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface MyChild5 extends  MyParent5&#123;</span><br><span class="line">    public static final int b = 6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码相信运行结果大家都能一目了然，那么父接口MyParent5和MyChild5 是否会初始化呢？由于在接口当中不能定义静态代码块， 因此我们把MyParent5的class文件删除再去运行:<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E6%8E%A5%E5%8F%A3%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A7%84%E5%88%99%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5%E7%9A%84%E9%87%8D%E8%A6%81%E6%84%8F%E4%B9%89/20180226203540320.png" alt="这里写图片描述"><br>由此得出<strong>当一个接口初始化时并不要求其父接口完成了初始化</strong><br>我们在进一步，这时删除MyChild5 再去运行：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E6%8E%A5%E5%8F%A3%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A7%84%E5%88%99%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5%E7%9A%84%E9%87%8D%E8%A6%81%E6%84%8F%E4%B9%89/20180226203917865.png" alt="这里写图片描述"><br>再接着我们这样写代码，然后删除父接口：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E6%8E%A5%E5%8F%A3%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A7%84%E5%88%99%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5%E7%9A%84%E9%87%8D%E8%A6%81%E6%84%8F%E4%B9%89/20180226204806352.png" alt="这里写图片描述"><br>由此就可以得出，子接口的常量只有在运行期间才能确定的，并不会放到调用类的常量池当中，这时会触发父接口的初始化。</p>
<p>我们再次反过来实验：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E6%8E%A5%E5%8F%A3%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A7%84%E5%88%99%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5%E7%9A%84%E9%87%8D%E8%A6%81%E6%84%8F%E4%B9%89/20180226205349612.png" alt="这里写图片描述"><br>这次我们删除了子接口，但是父接口的常量只有在运行期间才会确认，这个时候会触发子类的初始化。<br>还有下边这种情况：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E6%8E%A5%E5%8F%A3%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A7%84%E5%88%99%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5%E7%9A%84%E9%87%8D%E8%A6%81%E6%84%8F%E4%B9%89/20180226211138725.png" alt="这里写图片描述"><br>总结：<br><strong>当一个接口初始化时并不要求其父接口完成了初始化<br>只有在真正用到父接口的时候（如引用接口中定义的常量时），才会初始化。</strong> 而类不是这样的，原因就是借口中的变量本来就是final的。</p>
<p>接着我们把MyChild5改为Class的形式，然后删除MyParent5：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E6%8E%A5%E5%8F%A3%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A7%84%E5%88%99%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5%E7%9A%84%E9%87%8D%E8%A6%81%E6%84%8F%E4%B9%89/20180303133036525.png" alt="这里写图片描述"><br>发现MyParent5找不到，因此补充结论：<br>只有使用类的常量的时候不会去加载接口，一般的静态变量，非常量都会加载接口。因为非常量都不会纳入到MyTest5的常量池当中，因此导致接口的初始化。<br>类加载器准备阶段很初始化阶段的重要意义：<br>我们写一个单例模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest6 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line">        System.out.println(Singleton.counter1);</span><br><span class="line">        System.out.println(Singleton.counter2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Singleton&#123;</span><br><span class="line">    public static int counter1;</span><br><span class="line">    public static int counter2=0;</span><br><span class="line">    private static Singleton singleton = new Singleton();</span><br><span class="line">    private Singleton()&#123;</span><br><span class="line">        counter1++;</span><br><span class="line">        counter2++;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>毫无悬念肯定是1 1 。<br>接下来我们改一下程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest6 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line">        System.out.println(Singleton.counter1);</span><br><span class="line">        System.out.println(Singleton.counter2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Singleton&#123;</span><br><span class="line">    public static int counter1;</span><br><span class="line">    private static Singleton singleton = new Singleton();</span><br><span class="line">    private Singleton()&#123;</span><br><span class="line">        counter1++;</span><br><span class="line">        counter2++;</span><br><span class="line">    &#125;</span><br><span class="line">    public static int counter2=0;</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们把counter2的位置改变了，那么运行结果是什么呢：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>这个例子能充分体现类的加载阶段和初始化阶段的重要性，我们用<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3pxNjU3ODcwMi9hcnRpY2xlL2RldGFpbHMvNzkzNjk0NjA=">第一篇<i class="fa fa-external-link-alt"></i></span>的过程分析一波：<br>加载：查找并加载类的二进制数据【这个不说了，就是把Singleton的二进制文件放入内存】<br>连接：<br>验证：确保被加载类的正确性。【这个也不说了】<br>准备：为类的静态变量分配内存，并将其初始化为默认值。【此时Singleton的counter1赋予初始化值为0，singleton赋值为null，counter2赋值为0】<br>解析：把类中的符号引用装换为直接引用。【不说了】<br>初始化：为类的静态变量赋予正确的初始值。【程序初始化顺序是<strong>从上而下</strong>，首先是counter1程序员没有对它进行赋值，还是准备赋予的值为0，接着是singleton赋值为new Singleton()，此时会调用构造器，构造器调用完毕counter1&#x3D;1，counter2&#x3D;1，然后程序继续初始化，<strong>到了 public static int counter2&#x3D;0;时，静态变量counter2重新赋值为0</strong>】</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>接口初始化规则 类加载器 准备阶段  初始化阶段</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（50）jvm锁</title>
    <url>/2020/04/08/jvm%E5%8E%9F%E7%90%86%EF%BC%8850%EF%BC%89jvm%E9%94%81/</url>
    <content><![CDATA[<h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 当我们使用synchronized关键字来修饰同步代码块时，本质上在字节码层面上是通过monitorenter</span><br><span class="line"> * 与monitorexit指令来实现同步的，当进入monitorenter指令后，线程将会持有monitor对象，</span><br><span class="line"> * 当退出monitorexit后，线程将会释放掉该monitor对象，在线程整个执行过程中，他会始终持有monitor对象的，</span><br><span class="line"> * 这样就确保了共享资源的同步访问。</span><br><span class="line"> *</span><br><span class="line"> * monitor对象到底是什么？</span><br><span class="line"> *</span><br><span class="line"> * 当我们使用new关键字创建一个java对象时，底层的jvm会自动为该创建的对象创建一个所谓的object header，并且</span><br><span class="line"> * 将该object header附加到该对象上，java中的每个对象在创建后，都会拥有一个与之相关联的monitor对象，</span><br><span class="line"> * 这也是为什么我们synchronized关键字修饰同步代码块时，我们使用什么对象（如Object，string，Date）都可以的原因所在。</span><br><span class="line"> *</span><br><span class="line"> * Object Header里面包含了很多信息，如monitor信息，锁相关的信息等。</span><br><span class="line"> *</span><br><span class="line"> *  对于同步方法的字节码来说，在反编译的字节码中并没有出现monitor与monitor相关的指令，</span><br><span class="line"> *  而是出现了一个ACC_SYNCHRONIZED标记。</span><br><span class="line"> *</span><br><span class="line"> *  本质上，jvm使用ACC_SYNCHRONIZED访问标记来判断某个方法是否是一个同步方法。</span><br><span class="line"> *</span><br><span class="line"> *  当方法调用时，调用指令会先检查该方法是否拥有ACC_SYNCHRONIZED访问标记，如果发现了该标记，那么执行的线程</span><br><span class="line"> *  将会首先持有monitor对象，接下来再去执行方法；在该方法运行期间，其他任何线程都将无法获取到monitor对象，</span><br><span class="line"> *  当方法执行完毕后，线程会释放掉所有持有的monitor对象。</span><br><span class="line"> *</span><br><span class="line"> *  那么线程所持有的的monitor对象又是什么呢？</span><br><span class="line"> *  1、如果被synchronized修饰的方法是普通实例方法，那么monitor对象就是当前被调用方法所在的那个对象。</span><br><span class="line"> *  2、如果被synchronized修饰的方法是静态方法，那么monitor对象就是当前类所对应的class对象。</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MyTest1 &#123;</span><br><span class="line">    private Object object = new Object();</span><br><span class="line"></span><br><span class="line">    public void myMethod()&#123;</span><br><span class="line">        synchronized (object)&#123;</span><br><span class="line">            System.out.println(&quot;hello world&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void method2()&#123;</span><br><span class="line">        System.out.println(&quot;hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>反编译：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Compiled from &quot;MyTest1.java&quot;</span><br><span class="line">public class com.twodragonlake.jvm.lock.MyTest1 &#123;</span><br><span class="line">  public com.twodragonlake.jvm.lock.MyTest1();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: aload_0</span><br><span class="line">       5: new           #2                  // class java/lang/Object</span><br><span class="line">       8: dup</span><br><span class="line">       9: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">      12: putfield      #3                  // Field object:Ljava/lang/Object;</span><br><span class="line">      15: return</span><br><span class="line"></span><br><span class="line">  public void myMethod();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: getfield      #3                  // Field object:Ljava/lang/Object;</span><br><span class="line">       4: dup</span><br><span class="line">       5: astore_1</span><br><span class="line">       6: monitorenter</span><br><span class="line">       7: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      10: ldc           #5                  // String hello world</span><br><span class="line">      12: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      15: aload_1</span><br><span class="line">      16: monitorexit</span><br><span class="line">      17: goto          25</span><br><span class="line">      20: astore_2</span><br><span class="line">      21: aload_1</span><br><span class="line">      22: monitorexit</span><br><span class="line">      23: aload_2</span><br><span class="line">      24: athrow</span><br><span class="line">      25: return</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           7    17    20   any</span><br><span class="line">          20    23    20   any</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="java锁的分类维度"><a href="#java锁的分类维度" class="headerlink" title="java锁的分类维度"></a>java锁的分类维度</h3><ol>
<li>共享角度：多个线程是否可以共享同一把锁，能：共享锁，不能：排它锁。</li>
<li>同一个线程在执行过程中是否可以获取到同一把锁：能：可重入锁，不能：非可重入锁。</li>
<li>资源角度：线程在执行更新操作时，是否需要利用锁来锁住同步资源：需要：悲观锁，不需要：乐观锁(CAS)。</li>
<li>多线程在竞争锁资源时是否需要排队等待：排队：公平锁，不排队：非公平锁。</li>
<li>当线程尝试锁住同步资源，但却失败了，那么线程是否需要阻塞：阻塞：，不阻塞：自旋锁。如果线程在自旋过程中一直没有获取到同步资源，那么该线程最终还是会被阻塞，进入到内核态（自适应自旋）</li>
<li>多线程在竞争同步资源的过程中的区别，无锁：多线程会同时进行资源的修改，并且不锁住资源，在这种情况下，某一个时刻只会有一个线程对资源的修改是成功的，其他线程均会失败，失败的线程则会进行不断的重试（CAS）；同一个线程在执行时，如果遇到了同步资源，那么它会自动的获取到这个锁资源，而不必进行其他任何操作（偏向锁）;多个线程同时在尝试竞争锁资源，同一时刻，只会有一个线程能够获取到锁，那么其他没有获取到锁的线程就会进行自旋等待锁的释放(轻量级锁);多个线程同时在尝试竞争锁资源，并且进行了自旋，但是经过一段时间后，线程依然无法获取到锁资源，这个时候，没有获取到锁资源的线程将会进入到阻塞状态，等待cpu的唤醒(重量级锁)。</li>
<li>关于悲观锁和乐观锁的适用场景:</li>
</ol>
<ul>
<li>乐观锁：非常适合读操作非常多的场景，因为本身不加锁，所以可以使得操作的性能有非常明显的提升。</li>
<li>悲观锁：非常适合写操作非常多的场景，因为首先需要对资源进行加锁操作，所以完全可以保证写入操作的正确性和健壮。</li>
</ul>
<h4 id="CAS-campare-and-swap-，比较与交换"><a href="#CAS-campare-and-swap-，比较与交换" class="headerlink" title="CAS (campare and swap)，比较与交换"></a>CAS (campare and swap)，比较与交换</h4><h5 id="CAS算法本质上涉及到三个数字"><a href="#CAS算法本质上涉及到三个数字" class="headerlink" title="CAS算法本质上涉及到三个数字:"></a>CAS算法本质上涉及到三个数字:</h5><ol>
<li>需要进行读写的内存值V</li>
<li>需要进行比较的值A</li>
<li>需要进行写入的新的值B<br>如果V和A相等，那么当前线程将B写入，否则当前线程会进行重试。<br>比较与更新本质上是一个原子操作，它在cpu层面上是一个指令来完成。</li>
</ol>
<h5 id="CAS的主要问题-ABA"><a href="#CAS的主要问题-ABA" class="headerlink" title="CAS的主要问题:ABA"></a>CAS的主要问题:ABA</h5><p>  AtomaticStampedReference</p>
<h4 id="自旋"><a href="#自旋" class="headerlink" title="自旋"></a>自旋</h4><p>  减少cpu状态的切换，从而减少线程在用户与内核态之间的切换，从而达到提升效率的目的。<br>  自旋会有一个上限(阈值)，默认情况下，线程会自旋10次，PreBlockSpin参数来设置线程默认的自旋次数。<br>  自旋锁是在jdk1.4中引入的，我们可以通过UseSpinning来开启自旋，从jdk1.6开始，自旋是默认开启的，同时该版本的jdk又引入了适应性自旋锁。<br>  适应性自旋锁：前边的线程或者大部分的线程自旋拿到了锁，那么当前线程在自旋的时候会大概率的自旋成功，因此可以放大自旋的次数，如果之前的线程或者大部分的线程自旋失败，那么本次线程自旋大概率也会是失败，那么本次自旋可能会让线程进入阻塞状态。</p>
<h4 id="无锁、偏向锁、轻量级锁与重量级锁"><a href="#无锁、偏向锁、轻量级锁与重量级锁" class="headerlink" title="无锁、偏向锁、轻量级锁与重量级锁"></a>无锁、偏向锁、轻量级锁与重量级锁</h4><p>  这几种本质上都是针对于synchronized关键字的。<br>  关于java对象头：<br>   Mark Word:</p>
<ol>
<li>无锁标记</li>
<li>偏向锁标记</li>
<li>轻量级锁标记</li>
<li>重量级锁标记</li>
<li>GC标记<br>   锁升级的功能主要是依赖于Mark Word中的锁标记位与是否偏向锁来达成的，synchronized关键字其实就是从偏向锁开始，然后升级为轻量级锁，最终升级为重量级锁。<br>   Monitor中拥有一个owner字段，用来标示持有该锁的线程的唯一标识，表示这个锁被该线程所持有。<br>   synchronized本质上是通过Monitor来实现的，Monitor本质上又是依赖底层操作系统的互斥锁(mutex lock)来实现的。<br>  Klaass Pointer: 指向当前对象的类的指针。</li>
</ol>
<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>  针对于同一个线程访问一个同步代码块的场景，减少了频繁获取与释放锁的代价。 UseBiaseLocking &#x3D; false</p>
<h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>  jvm会在Stack Frame中建立一个名为Lock Record的空间，用于存储锁对象目前的Mark Word的副本，同时它会将对象头中的Mark Word复制到锁记录中；如果成功，那么jvm会将对象的Mark Word更新为指向Lock record的指针，同时会将Lock Record中的owner指针指向对象的Mark word，如果该操作成功，就表示线程拥有了对象的锁，这样，对象就会处于轻量级锁的状态之中。<br>  如果当前只有一个线程等待，那么这个线程会自旋，当前自旋是由次数限制的；如果有三个线程在争夺锁资源，这个时候会升级为重量级锁；</p>
<h5 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h5><p>  是锁的最终状态。等待的线程会进入到阻塞状态(内核态)。</p>
<h4 id="JIT来实现一些优化措施："><a href="#JIT来实现一些优化措施：" class="headerlink" title="JIT来实现一些优化措施："></a>JIT来实现一些优化措施：</h4><p>  逃逸分析的技术。<br>  锁粗化：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void Method()&#123;</span><br><span class="line">  synchronized(object)&#123;&#125;</span><br><span class="line">  synchronized(object)&#123;&#125;</span><br><span class="line">  synchronized(object)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   会将三个synchronized合并为一个synchronized<br>  减小锁的粒度：<br>  ConcurrentHashMap</p>
<h4 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h4><p>  ReetrantLock提供了公平锁与非公平锁的实现，默认使用的是非公平锁。</p>
<p>  公平锁的获取：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">      //判断当前线程是否是队列的第一个</span><br><span class="line">        if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  非公平锁的获取：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">      //没有判断当前线程是否是队列的第一个</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0) // overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  判断当前线程是不是队列的第一个线程：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">    // The correctness of this depends on head being initialized</span><br><span class="line">    // before tail and on head.next being accurate if the current</span><br><span class="line">    // thread is first in queue.</span><br><span class="line">    Node t = tail; // Read fields in reverse initialization order</span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    return h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == null || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="可重入锁与非可重入锁"><a href="#可重入锁与非可重入锁" class="headerlink" title="可重入锁与非可重入锁"></a>可重入锁与非可重入锁</h3><p>java中的reentrantLock与synchronized都是可重入锁，他最大的优势在于防止死锁的出现。</p>
<h3 id="共享锁和排它锁"><a href="#共享锁和排它锁" class="headerlink" title="共享锁和排它锁"></a>共享锁和排它锁</h3><p>reentrantLock 是排它锁的典型实现，如果reentrantLock拿到锁之后，其他线程无论是读还是写都是拿不到这个对象的锁。</p>
<p>ReentrantReadWriteLock 是共享锁的实现，里边有读锁和写锁，只有所有的线程度都是读取操作的时候，是共享的，如果都是<br>写的操作，那么就是排他的。</p>
<p>AQS中：状态字段，高16位表示读状态，低16位表示写状态。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>CAS、锁升级、重入锁、公平锁、非公平锁</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（6）类加载器双亲委托机制详解</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>类加载器层级：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/20180227223057487.png" alt="这里写图片描述"></p>
<span id="more"></span>

<p><strong>类加载器的父类委托机制</strong><br>  在父类委托机制中，各个加载器按照按照父子关系形成<strong>树形结构</strong>（逻辑意义的树形结构），除了根类加载器之外，其余的类加载器都有且只有一个父加载器。</p>
<p>加载过程举例：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/20180303143640952.png" alt="这里写图片描述"><br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/20180303143718490.png" alt="这里写图片描述"><br>loader1拿到Sample的字节码的时候会把Sample交给loader1的父级加载器【系统类加载器】加载，【系统类加载器】还有一个父级加载器【扩展类加载器】然后将Sample交给了【扩展类加载器】，但是【扩展类加载器】还有一个父级加载器【根类加载器】，最终到了Sample到了【根类加载器】，由于【根类加载器】是顶层的加载器，所以【根类加载器】尝试加载Sample，但是【根类加载器】只加载规定目录下的类，显然Sample不在指定的目录下，【根类加载器】无法加载它，然后【根类加载器】把Sample交给了【扩展类加载器】，同样的道理【扩展类加载器】也是只能加载规定目录下的类，Sample不在【扩展类加载器】指定的目录下，从而无法加载，然后把Sample交给了【系统类加载器】，【系统类加载器】的加载目录包含Sample类的字节码，【系统类加载器】完成了Sample的加载，最后结果返回给了loader1<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/20180303145132407.png" alt="这里写图片描述"><br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/20180303145503257.png" alt="这里写图片描述"><br>上例中【系统类加载器】就是定义类加载器，loader1是初始类加载器。</p>
<p>实例讲解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest7 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        Class&lt;?&gt; str = Class.forName(&quot;java.lang.String&quot;);</span><br><span class="line">        System.out.println(str.getClassLoader());//打印null 因为java.lang.String是有根类加载器加载，getClassLoader()方法看下边介绍。</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; c = Class.forName(&quot;com.twodragonlake.jvm.classloader.C&quot;);//返回系统类加载器</span><br><span class="line">        System.out.println(c.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">null</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure>

<p>getClassLoader（）方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line">  * Returns the class loader for the class.  Some implementations may use</span><br><span class="line">  * null to represent the bootstrap class loader. This method will return</span><br><span class="line">  * null in such implementations if this class was loaded by the bootstrap</span><br><span class="line">  * class loader.</span><br><span class="line">  * 返回这个class的类加载器，有些实现使用null代替bootstrap 加载器，如果这个类的加载器是bootstrap 那么这个方法返回null</span><br><span class="line">  * &lt;p&gt; If a security manager is present, and the caller&#x27;s class loader is</span><br><span class="line">  * not null and the caller&#x27;s class loader is not the same as or an ancestor of</span><br><span class="line">  * the class loader for the class whose class loader is requested, then</span><br><span class="line">  * this method calls the security manager&#x27;s &#123;@code checkPermission&#125;</span><br><span class="line">  * method with a &#123;@code RuntimePermission(&quot;getClassLoader&quot;)&#125;</span><br><span class="line">  * permission to ensure it&#x27;s ok to access the class loader for the class.</span><br><span class="line">  * 如果使用了安全管理器，调用者的类加载器不是null，并且调用者的类加载器和类的加载器的层次关系不相等，那么就会用RuntimePermission(&quot;getClassLoader&quot;)调用安全管理器的getClassLoader方法来确认是否可以允许这个类的加载器去加载它。</span><br><span class="line">  * &lt;p&gt;If this object</span><br><span class="line">  * represents a primitive type or void, null is returned.</span><br><span class="line">  *</span><br><span class="line">  * @return  the class loader that loaded the class or interface</span><br><span class="line">  *          represented by this object.</span><br><span class="line">  * 返回加载了当前对象对应类的接口的加载器</span><br><span class="line">  * @throws SecurityException</span><br><span class="line">  *    if a security manager exists and its</span><br><span class="line">  *    &#123;@code checkPermission&#125; method denies</span><br><span class="line">  *    access to the class loader for the class.</span><br><span class="line">  * @see java.lang.ClassLoader</span><br><span class="line">  * @see SecurityManager#checkPermission</span><br><span class="line">  * @see java.lang.RuntimePermission</span><br><span class="line">  */</span><br><span class="line"> @CallerSensitive</span><br><span class="line"> public ClassLoader getClassLoader() &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>双亲委托机制</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（5）类加载器深入解析及重要特性剖析</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%885%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%8F%8A%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<p>类进入内存的过程：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%885%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%8F%8A%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7%E5%89%96%E6%9E%90/20180227213145481.png" alt="这里写图片描述"></p>
<span id="more"></span>

<ul>
<li>类的加载的最终产品是位于内存中的Class对象。</li>
<li>Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区的数据的接口。类是反射的入口。</li>
</ul>
<p> <strong>有两种类型的类加载器：</strong><br>     - Java虚拟机自带的加载器<br>         - 根类加载器(Bootstrap)<br>         - 扩展类加载器(Extension)<br>         - 系统(应用)类加载器(System)<br>      - 用户自己定义的类加载器<br>          - java.lang.ClassLoader的子类<br>          - 用户可以定制的加载方式</p>
<p> <strong>类的加载：</strong></p>
<ul>
<li>类的加载器并不需要等到某个类被“首次主动使用”时再加载它。</li>
</ul>
<p> 怎么理解这句话呢，我们就拿<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3pxNjU3ODcwMi9hcnRpY2xlL2RldGFpbHMvNzkzNjk0NjA=">第一篇<i class="fa fa-external-link-alt"></i></span> 文章的例子说明：<br> 我们加上-XX:+TraceClassLoading 参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(MyChild.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyParent1&#123;</span><br><span class="line">    public static String str  = &quot;hello world&quot;;</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;MyParent1 static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyChild extends  MyParent1&#123;</span><br><span class="line">    public static String str2 = &quot;welcome&quot;;</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;MyChild static bloack&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%885%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%8F%8A%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7%E5%89%96%E6%9E%90/20180227215337821.png" alt="这里写图片描述"><br>虽然子类没有被初始化，但是通过日志可以看出子类已经被加载了。</p>
<ul>
<li>JVM规范允许类加载器在预料将要被使用时就预先加载它，如果在预先加载的过程中遇到.class文件缺失或存在错误，类加载器必须在<strong>程序首次主动</strong>使用该类时才报告错误(LinkError错误)</li>
<li>如果这个类一直没有被程序主动使用，那么<strong>类加载器就不会报告错误</strong>。</li>
</ul>
<p><strong>类的验证：</strong></p>
<ul>
<li>类的验证的内容<ul>
<li>类文件的结构检查</li>
<li>语义检查</li>
<li>字节码检查</li>
<li>二进制兼容性的验证</li>
</ul>
</li>
</ul>
<p> <strong>类的准备：</strong><br> <img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%885%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%8F%8A%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7%E5%89%96%E6%9E%90/20180227220530519.png" alt="这里写图片描述"></p>
<p><strong>类的初始化：</strong><br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%885%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%8F%8A%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7%E5%89%96%E6%9E%90/20180227220751602.png" alt="这里写图片描述"><br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%885%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%8F%8A%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7%E5%89%96%E6%9E%90/20180227220841355.png" alt="这里写图片描述"></p>
<p>类的初始化步骤：<br>    - 假如这个类还没有被加载和链接，那就先进行加载和链接<br>    - 假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类<br>    - 假如类中存在初始化语句，那就依次执行这些初始化语句</p>
<p><strong>类的初始化时机：</strong><br>（1）主动使用（七种）</p>
<pre><code>创建类的实例。
访问某个类或者接口的静态变量，或者对该静态变量赋值。
调用类的静态方法。
反射 （如Class.forName(“com.test.Test”)）
初始化一个类的子类
Jav啊虚拟机启动时被标明为启动类的类(Java Test)
JDK1.7开始提供的动态 语言支持：
Java.lang.invoke.MethodHandle实例的解析结果REF_getStattic REF_putStatic REF_invokeStatic句柄对应的类如果没有初始化，则初始化(了解)
除了以上七中情况，其他使用Java类的方式都被看做是对类的被动使用，都不会导致类的初始化(指的是加载，连接，初始化这个步骤的初始化)
</code></pre>
<p>（2）<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%885%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%8F%8A%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7%E5%89%96%E6%9E%90/20180227222003415.png" alt="这里写图片描述"><br>验证第一条：在初始化一个类时，并不会先初始化它所实现的接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest5 &#123;</span><br><span class="line">/*</span><br><span class="line">详情：http://blog.csdn.net/wzq6578702/article/details/79382182</span><br><span class="line"> */</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(MyChild5.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface MyParent5&#123;</span><br><span class="line">    public static final int a =4;</span><br><span class="line">    public static Thread thread = new Thread()&#123;</span><br><span class="line">        //代码块 当Thread的匿名类初始化的时候 代码块会被执行（每new一个类代码块都会执行一次）</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;MyParent5 invoked!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyChild5 implements  MyParent5&#123;</span><br><span class="line">    public static  int b =  5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<p>如果我们把MyParent5和MyChild5都改为Class呢？<br>答案是输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyParent5 invoked!</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>因为子类的初始化会想初始化父类<br>然后我们如果把MyChild5的b改为【public static final  int b &#x3D;  5;】这样运行结果是什么呢？<br>答案是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<p>因为b是常量，常量会编译的时候就会放在MyTest5的常量池当中，甚至可以删除MyParent5和MyChild5的Class文件。<br>再进一步：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest5 &#123;</span><br><span class="line">/*</span><br><span class="line">详情：http://blog.csdn.net/wzq6578702/article/details/79382182</span><br><span class="line">当一个接口初始化时并不要求其父接口完成了初始化</span><br><span class="line">只有在真正用到父接口的时候（如引用接口中定义的常量时），才会初始化。</span><br><span class="line"> */</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(MyChild5.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Grandapa&#123;</span><br><span class="line">    public static Thread thread = new Thread()&#123;</span><br><span class="line">        //代码块 当Thread的匿名类初始化的时候 代码块会被执行（每new一个类代码块都会执行一次）</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;Grandapa invoked!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface MyParent5 extends  Grandapa&#123;</span><br><span class="line">    public static final int a =4;</span><br><span class="line">    public static Thread thread = new Thread()&#123;</span><br><span class="line">        //代码块 当Thread的匿名类初始化的时候 代码块会被执行（每new一个类代码块都会执行一次）</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;MyParent5 invoked!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyChild5 implements  MyParent5&#123;</span><br><span class="line">    public static   int b =  5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打印结果是什么呢，肯定是先5吧<br>如果把Grandapa、MyParent5全部改成Class呢：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest5 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(MyChild5.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Grandapa&#123;</span><br><span class="line">    public static Thread thread = new Thread()&#123;</span><br><span class="line">        //代码块 当Thread的匿名类初始化的时候 代码块会被执行（每new一个类代码块都会执行一次）</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;Grandapa invoked!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyParent5 extends  Grandapa&#123;</span><br><span class="line">    public static final int a =4;</span><br><span class="line">    public static Thread thread = new Thread()&#123;</span><br><span class="line">        //代码块 当Thread的匿名类初始化的时候 代码块会被执行（每new一个类代码块都会执行一次）</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;MyParent5 invoked!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyChild5 extends  MyParent5&#123;</span><br><span class="line">    public static   int b =  5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打印：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Grandapa invoked!</span><br><span class="line">MyParent5 invoked!</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>以为子类运行的时候会想去初始化它的父类。<br>验证：在初始化一个接口是，并不会先初始化它的父接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">interface  MyGrandpa5_1&#123;</span><br><span class="line">    public static Thread thread = new Thread()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;MyGrandpa5_1 invoked!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface  MyParent5_1 extends MyGrandpa5_1 &#123;</span><br><span class="line">    public static Thread thread = new Thread()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;MyParent5_1 invoked!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">public class MyTest5 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(MyParent5_1.thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyParent5_1 invoked!</span><br><span class="line">Thread[Thread-0,5,main]</span><br></pre></td></tr></table></figure>
<p>可以看到MyGrandpa5_1并没有被初始化。<br>（3）只有当程序访问的静态变量或静态方法确实在当前类或当前接口中定义时，才可以认为是对类或接口的主动使用。</p>
<p><strong>类加载器</strong><br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%885%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%8F%8A%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7%E5%89%96%E6%9E%90/20180227222516574.png" alt="这里写图片描述"><br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%885%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%8F%8A%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7%E5%89%96%E6%9E%90/20180227222758348.png" alt="这里写图片描述"><br>除了以上虚拟机自带的类加载器外，用户还可以定制自己的类加载器。Java提供了抽象类Java.lang.ClassLoader，所有用户自动以的类加载器都应该继承ClassLoader类。<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%885%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%8F%8A%E9%87%8D%E8%A6%81%E7%89%B9%E6%80%A7%E5%89%96%E6%9E%90/20180227223057487.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>ClassLoader</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（7）类加载器与类初始化深度剖析</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8E%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<p><strong>exampleA</strong>：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8E%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/20180303154639636.png" alt="这里写图片描述"></p>
<span id="more"></span>
<p>打印结果是3 ，并且静态代码块不会执行，原因是x是常量，在编译期就会放到MyTest8的常量池当中，然后FinalTest和MyTest8就没有任何关系了，可以通过反编译的结果看到。<br>把x的final去掉之后，静态代码块会打印，再去看反编译结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javap -c com.twodragonlake.jvm.classloader.MyTest8</span><br><span class="line">Compiled from &quot;MyTest8.java&quot;</span><br><span class="line">public class com.twodragonlake.jvm.classloader.MyTest8 &#123;</span><br><span class="line">  public com.twodragonlake.jvm.classloader.MyTest8();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: getstatic     #3                  // Field com/twodragonlake/jvm/classloader/FinalTest.x:I</span><br><span class="line">       6: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">       9: return</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到main方法的iconst_3变成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3: getstatic     #3                  // Field com/twodragonlake/jvm/classloader/FinalTest.x:I</span><br></pre></td></tr></table></figure>
<p>意味着MyTest8需要引用到FinalTest，两者之间存在关系的。</p>
<p><strong>exampleB</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Parent&#123;</span><br><span class="line">    static int x = 3;</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;Parent static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends  Parent&#123;</span><br><span class="line">    static int b = 4;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Child static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyTest9 &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;MyTest9 static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Child.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Parent static block</span><br><span class="line">Child static block</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>即先加载运行类，然后是Parent和Child<br>我们可以在jvm启动参数里边加入-XX:TraceClassLoading 看到加载顺序：<br><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8E%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/20180303160528398.png" alt="这里写图片描述"></p>
<p><strong>exampleC</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Parent2&#123;</span><br><span class="line">    static int a = 3;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Parent2 static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child2 extends Parent2&#123;</span><br><span class="line">    static int b = 4;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Child2 static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyTest10 &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;MyTest10 static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Parent2 parent;</span><br><span class="line">        System.out.println(&quot;-----------------&quot;);</span><br><span class="line">        parent = new Parent2();</span><br><span class="line">        System.out.println(&quot;------------------&quot;);</span><br><span class="line">        System.out.println(parent.a);</span><br><span class="line">        System.out.println(&quot;------------------&quot;);</span><br><span class="line">        System.out.println(Child2.b);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyTest10 static block</span><br><span class="line">-----------------</span><br><span class="line">Parent2 static block</span><br><span class="line">------------------</span><br><span class="line">3</span><br><span class="line">------------------</span><br><span class="line">Child2 static block</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>解析：<br>        运行main方法之前MyTest10初始化，MyTest10的静态代码块执行<br>        Parent2 parent;&#x2F;&#x2F;此行代码不会发生任何作用。<br>        System.out.println(“—————–”);<br>        parent &#x3D; new Parent2();&#x2F;&#x2F;Parent2主动使用，触发Parent2的初始化，静态代码块被执行，打印【Parent2 static block】<br>        System.out.println(“——————“);<br>        System.out.println(parent.a);&#x2F;&#x2F;打印Parent2的静态变量<br>        System.out.println(“——————“);<br>        System.out.println(Child2.b);&#x2F;&#x2F;调用Child2的静态变量 触发Child2的初始化，从而执行Child2 的静态代码块，先打印Child2 static block，在打印4</p>
<p><strong>exampleD</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Parent3&#123;</span><br><span class="line">    static int a = 3;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Parent3 static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void doSomething()&#123;</span><br><span class="line">        System.out.println(&quot;doSomething...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child3 extends  Parent3 &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Child3 static block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyTest11 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Child3.a); //a属于父类，属于对父类Parent3的主动使用，</span><br><span class="line">        //虽然名字是Child3但是却不是对Child3的主动使用，导致Parent3的初始化，然后Parent3的静态代码块被执行</span><br><span class="line">        Child3.doSomething();//调用父类Parent3的静态方法，是对服了的主动使用，触发父类Parent3的初始化。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Parent3 static block</span><br><span class="line">3</span><br><span class="line">doSomething...</span><br></pre></td></tr></table></figure>
<p>结论：<br>主动使用发生在静态变量定义在哪个类里边，而不是是谁调用了变量，定义变量的类会触发初始化。</p>
<p><strong>exampleE</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class CL&#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Class CL&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyTest12 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ClassLoader classLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        Class&lt;?&gt; cl = classLoader.loadClass(&quot;com.twodragonlake.jvm.classloader.CL&quot;);////不会触发类的初始化</span><br><span class="line">        System.out.println(cl);</span><br><span class="line">        System.out.println(&quot;-------------------------&quot;);</span><br><span class="line">        cl = Class.forName(&quot;com.twodragonlake.jvm.classloader.CL&quot;);////使用了反射，这属于类初始化时机的反射时机。会触发类的初始化。</span><br><span class="line">        System.out.println(cl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class com.twodragonlake.jvm.classloader.CL</span><br><span class="line">-------------------------</span><br><span class="line">Class CL</span><br><span class="line">class com.twodragonlake.jvm.classloader.CL</span><br></pre></td></tr></table></figure>
<p>调用classLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化<br>这个例子验证了类的初始化时机的反射时机，具体参考之前的文章：<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3pxNjU3ODcwMi9hcnRpY2xlL2RldGFpbHMvNzkzNjk0NjA=">主动使用（七种）<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>classLoader</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（8）不同的类加载器与加载与加载动作分析</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%888%EF%BC%89%E4%B8%8D%E5%90%8C%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8E%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8A%A0%E8%BD%BD%E5%8A%A8%E4%BD%9C%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>这段程序打印出系统类加载器到最上层的加载器的结构关系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest13 &#123;</span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ClassLoader classLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">        while(null != classLoader)&#123;</span><br><span class="line">            classLoader = classLoader.getParent();</span><br><span class="line">            System.out.println(classLoader);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2 【系统类加载器】</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@1540e19d  【扩展类加载器】</span><br><span class="line">null                                       【根类加载器】</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到最后输出的是null。<br>这行代码： ClassLoader classLoader &#x3D; ClassLoader.getSystemClassLoader();得到系统类加载器，看一下doc说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Returns the system class loader for delegation.  This is the default</span><br><span class="line">     * delegation parent for new &lt;tt&gt;ClassLoader&lt;/tt&gt; instances, and is</span><br><span class="line">     * typically the class loader used to start the application.</span><br><span class="line">     *返回一个针对委托的系统类加载器，并且他是默认新建类加载器实例的委托双亲（即自定义类加载器的父级，见下图），它是一个典型的启动应用的类加载器。</span><br><span class="line">     * &lt;p&gt; This method is first invoked early in the runtime&#x27;s startup</span><br><span class="line">     * sequence, at which point it creates the system class loader and sets it</span><br><span class="line">     * as the context class loader of the invoking &lt;tt&gt;Thread&lt;/tt&gt;.</span><br><span class="line">     *此方法在运行期的早期就会被调用，在这个时间点创建系统类的加载器，并且设定其为调用线程的上下文的一个类加载器。</span><br><span class="line">     * &lt;p&gt; The default system class loader is an implementation-dependent</span><br><span class="line">     * instance of this class.</span><br><span class="line">     *默认的系统类加载器与这个类实现相关的实例</span><br><span class="line">     * &lt;p&gt; If the system property &quot;&lt;tt&gt;java.system.class.loader&lt;/tt&gt;&quot; is defined</span><br><span class="line">     * when this method is first invoked then the value of that property is</span><br><span class="line">     * taken to be the name of a class that will be returned as the system</span><br><span class="line">     * class loader.  The class is loaded using the default system class loader</span><br><span class="line">     * and must define a public constructor that takes a single parameter of</span><br><span class="line">     * type &lt;tt&gt;ClassLoader&lt;/tt&gt; which is used as the delegation parent.  An</span><br><span class="line">     * instance is then created using this constructor with the default system</span><br><span class="line">     * class loader as the parameter.  The resulting class loader is defined</span><br><span class="line">     * to be the system class loader.</span><br><span class="line">     * 如果设定了java.system.class.loader那么这个方法返回的就是java.system.class.loader设定的类加载器。这个类被系统类加载器加载，并且</span><br><span class="line">     * 定义一个公共的构造方法，接受一个ClassLoader参数用作为委托的双亲，用默认系统类类加载器作为构造器的参数，就会创造一个实例 ，所得到的就是系统类加载器</span><br><span class="line">     */</span><br><span class="line">     //返回系统类加载器</span><br><span class="line">         @CallerSensitive</span><br><span class="line">    public static ClassLoader getSystemClassLoader() &#123;</span><br><span class="line">        initSystemClassLoader();</span><br><span class="line">        if (scl == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        if (sm != null) &#123;</span><br><span class="line">            checkClassLoaderPermission(scl, Reflection.getCallerClass());</span><br><span class="line">        &#125;</span><br><span class="line">        return scl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%888%EF%BC%89%E4%B8%8D%E5%90%8C%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8E%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8A%A0%E8%BD%BD%E5%8A%A8%E4%BD%9C%E5%88%86%E6%9E%90/201803122022319.png" alt="这里写图片描述"></p>
<p>getParent方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Returns the parent class loader for delegation. Some implementations may</span><br><span class="line">     * use &lt;tt&gt;null&lt;/tt&gt; to represent the bootstrap class loader. This method</span><br><span class="line">     * will return &lt;tt&gt;null&lt;/tt&gt; in such implementations if this class loader&#x27;s</span><br><span class="line">     * parent is the bootstrap class loader.</span><br><span class="line">     * 返回父加载器用于委托，有些实现返回null用来表示根类加载器，如果一个类的父加载器是根加载器，那么这个方法将会返回null</span><br><span class="line">     */</span><br><span class="line">      public final ClassLoader getParent() &#123;</span><br><span class="line">        if (parent == null)</span><br><span class="line">            return null;</span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        if (sm != null) &#123;</span><br><span class="line">            // Check access to the parent class loader</span><br><span class="line">            // If the caller&#x27;s class loader is same as this class loader,</span><br><span class="line">            // permission check is performed.</span><br><span class="line">            checkClassLoaderPermission(parent, Reflection.getCallerClass());</span><br><span class="line">        &#125;</span><br><span class="line">        return parent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>parent 变量是ClassLoader的成员变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// The parent class loader for delegation</span><br><span class="line">// Note: VM hardcoded the offset of this field, thus all new fields</span><br><span class="line">// must be added *after* it.</span><br><span class="line">用于委托的双亲加载器，JVM将这个变量的偏移量进行了硬编码，，这样新的变量就要加载这个变量的后边</span><br><span class="line">private final ClassLoader parent;</span><br></pre></td></tr></table></figure>

<p>下一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest14 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        String resourceName = &quot;com/twodragonlake/jvm/classloader/MyTest13.class&quot;;</span><br><span class="line">        /*</span><br><span class="line">        Finds all the resources with the given name. A resource is some data</span><br><span class="line">        (images, audio, text, etc) that can be accessed by class code in a way</span><br><span class="line">        that is independent of the location of the code.</span><br><span class="line">        返回给定名字所有的资源，资源可以是（图片，音频，文本，等）可以被class字节码以一种与字节码位置无关的方式去访问，</span><br><span class="line">        classLoader.getResources(resourceName)&#123;....&#125;</span><br><span class="line">		*/</span><br><span class="line">        Enumeration&lt;URL&gt; urls =  classLoader.getResources(resourceName);</span><br><span class="line">        while(urls.hasMoreElements())&#123;</span><br><span class="line">            System.out.println(urls.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;----------------&quot;);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = String.class;</span><br><span class="line">        System.out.println(clazz.getClassLoader());//自定义的类有系统类加载器加载</span><br><span class="line">        System.out.println(&quot;----------------&quot;);</span><br><span class="line">        clazz = MyTest14.class;</span><br><span class="line">        System.out.println(clazz.getClassLoader());  //由根类加载器加载 因为系统类加载器的加载目录包含rt目录</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file:/E:/Study/intelIde/jvm_lecture/out/production/classes/com/twodragonlake/jvm/classloader/MyTest13.class</span><br><span class="line">----------------</span><br><span class="line">null</span><br><span class="line">----------------</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure>

<p><strong>获取ClassLoader的方式：</strong><br>获得当前类的ClassLoader：<br>class.getClassLoader();<br>获取当前线程上下文的ClassLoader：<br>Thread.currentThread().getContextClassLoader();<br>获得系统的ClassLoader：<br>ClassLoader.getSystemClassLoader()<br>获得调用者的ClassLoader:<br>DriverManager.getCallerClassLoader();</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>ClassLoader</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm原理（9）ClassLoader源码分析与实例剖析</title>
    <url>/2018/10/04/jvm%E5%8E%9F%E7%90%86%EF%BC%889%EF%BC%89ClassLoader%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzgvZG9jcy9hcGkvamF2YS9sYW5nL0NsYXNzTG9hZGVyLmh0bWw=">https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<p><strong>public abstract class ClassLoader extends Object</strong></p>
<p>A class loader is an object that is responsible for loading classes. The class ClassLoader is an abstract class. Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a “class file” of that name from a file system.</p>
<p><strong>一个类加载器是用于加载类的这么一个对象，ClassLoader是一个抽象类，给定一个二进制的名字，类加载器应该尝试定位（找到类定义数据的位置）和生成(动态代理就是动态生成的)构成了这个类定义的数据，一个典型的策略就是将一个名字装换为一个文件名字，之后从文件系统读取这个文件包含的字节码。</strong><br>Every Class object contains a reference to the ClassLoader that defined it.<br><strong>任何一个类都有一个定义这个类的ClassLoader的引用</strong></p>
<p>Class objects for array classes are not created by class loaders, but are created automatically as required by the Java runtime. The class loader for an array class, as returned by Class.getClassLoader() is the same as the class loader for its element type; if the element type is a primitive type, then the array class has no class loader.<br><strong>对于数组类的class对象并不是由类加载器创建的，而是由java运行时在需要的时候自动创建</strong>【回顾：<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3pxNjU3ODcwMi9hcnRpY2xlL2RldGFpbHMvNzkzNzA2NjIlRTMlODAlOTE=">http://blog.csdn.net/wzq6578702/article/details/79370662】<i class="fa fa-external-link-alt"></i></span><br><strong>对于数组的类加载器来说，通过Class.getClassLoader() 返回的和数组元素的类型类加载器是一样的，如果数组的元素是原生类型的，</strong><br><strong>那么这个数组是没有类加载器的。</strong><br><strong>举例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest15 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String[] strings = new String[2];</span><br><span class="line">        System.out.println(strings.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">        MyTest15[] myTest15s = new MyTest15[2];</span><br><span class="line">        System.out.println(myTest15s.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">        int [] ints = new int[2];</span><br><span class="line">        System.out.println(ints.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">        HashMap[] maps = new HashMap[2];</span><br><span class="line">        System.out.println(maps.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">null 【这个null指的是根类加载器】</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2  【数组的加载器和数组元素扥加载器一样】</span><br><span class="line">null 【指的是没有类加载器】</span><br><span class="line">null  【这个null指的是根类加载器】</span><br></pre></td></tr></table></figure>


<p>Applications implement subclasses of ClassLoader in order to extend the manner in which the Java virtual machine dynamically loads classes.<br><strong>应用实现了ClassLoader 的子类是为了扩展Java虚拟机动态加载类的这种方式</strong><br>Class loaders may typically be used by security managers to indicate security domains.<br><strong>类加载器一般使用安全管理器确保在安全区域</strong><br>The ClassLoader class uses a delegation model to search for classes and resources. Each instance of ClassLoader has an associated parent class loader. When requested to find a class or resource, a ClassLoader instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself. The virtual machine’s built-in class loader, called the “bootstrap class loader”, does not itself have a parent but may serve as the parent of a ClassLoader instance.<br><strong>ClassLoader 使用了一种委托模型用来寻找类和资源，每个ClassLoader 的实例都有一个与之相关的父级的类加载器，当一个请求要去寻找一个类或者资源的时候，ClassLoader 实例在它自己发现类或者资源本身之前会委托他的父级类加载器去加载类或者发现资源。虚拟机内建的类加载器成为“启动类加载器”，它本身是没有双亲的，但是他本身可以作为一个类加载器的双亲。</strong><br>Class loaders that support concurrent loading of classes are known as parallel capable class loaders and are required to register themselves at their class initialization time by invoking the ClassLoader.registerAsParallelCapable method. Note that the ClassLoader class is registered as parallel capable by default. However, its subclasses still need to register themselves if they are parallel capable.<br><strong>如果类加载器支持并发，就是并发类加载器，并发类加载器要求在类的初始期间通过ClassLoader.registerAsParallelCapable方法注册上，当前的ClassLoader默认就是被注册为并行的，然而他的子类如果是可以并行加载的也需要进行注册上。</strong><br>In environments in which the delegation model is not strictly hierarchical, class loaders need to be parallel capable, otherwise class loading can lead to deadlocks because the loader lock is held for the duration of the class loading process (see loadClass methods).<br><strong>在委托模型并不是严格的层次化的环境下，类加载器是需要并行的，否则类加载过程中是会死锁的，因为类加载的过程中是持有锁的（查看getClass方法）</strong><br>Normally, the Java virtual machine loads classes from the local file system in a platform-dependent manner. For example, on UNIX systems, the virtual machine loads classes from the directory defined by the CLASSPATH environment variable.<br><strong>通常来说Java虚拟机以平台相关的形式从本地的文件系统加载类，举例，在UNIX系统，虚拟机通过CLASSPATH 环境变量的路径来加载类。</strong><br>However, some classes may not originate from a file; they may originate from other sources, such as the network, or they could be constructed by an application. The method defineClass converts an array of bytes into an instance of class Class. Instances of this newly defined class can be created using Class.newInstance.<br><strong>然后，一些类并不是来自于一个文件，他们可能来自于网络或者他们是应用本身构建出来的（动态代理），defineClass 方法会将一个字节数组转换为Class类的实例，这个新定义的类可以通过Class.newInstance去创建类的对象。</strong><br>The methods and constructors of objects created by a class loader may reference other classes. To determine the class(es) referred to, the Java virtual machine invokes the loadClass method of the class loader that originally created the class.<br><strong>由类加载器创建的对象的构造方法或者方法可能引用其他的类，	为了确定被它所引用的其他的类，Java虚拟机通过调用loadClass 去解决。</strong><br>For example, an application could create a network class loader to download class files from a server. Sample code might look like:<br><strong>举例，一个应用通过网络类加载器从网络上的一个服务来下载class文件，实例代码就像这样：</strong><br>   ClassLoader loader &#x3D; new NetworkClassLoader(host, port);<br>   Object main &#x3D; loader.loadClass(“Main”, true).newInstance();<br>        . . .</p>
<p>The network class loader subclass must define the methods findClass and loadClassData to load a class from the network. Once it has downloaded the bytes that make up the class, it should use the method defineClass to create a class instance. A sample implementation is:<br><strong>网络加载器的子类必须定义loadClassData 和findClass方法来从网络加载class，一旦下载完毕类的字节码就会构建这个class，他需要使用defineClass 方法来创建一个类的实例，一个实现的实例：</strong><br>     class NetworkClassLoader extends ClassLoader {<br>         String host;<br>         int port;</p>
<pre><code>     public Class findClass(String name) &#123;
         byte[] b = loadClassData(name);
         return defineClass(name, b, 0, b.length);
     &#125;

     private byte[] loadClassData(String name) &#123;
         // load the class data from the connection
          . . .
     &#125;
 &#125;
</code></pre>
<p>Binary names<br>Any class name provided as a String parameter to methods in ClassLoader must be a binary name as defined by The Java™ Language Specification.<br><strong>二进制名字</strong><br><strong>任何类的名字都是通过字符串的形式，作为类加载器的方法的参数，称之为二进制的名字，这是Java虚拟机规范制定的。</strong><br>Examples of valid class names include:<br><strong>二进制名字举例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;java.lang.String&quot; （String类）</span><br><span class="line">&quot;javax.swing.JSpinner$DefaultEditor&quot;（DefaultEditor是在JSpinner的内部类）</span><br><span class="line">&quot;java.security.KeyStore$Builder$FileBuilder$1&quot;（KeyStore里边的内部类Builder的内部类FileBuilder里边的第一个匿名内部类）</span><br><span class="line">&quot;java.net.URLClassLoader$3$1&quot;（URLClassLoader里边的第三个匿名内部类里边的第一个匿名内部类）</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>ClassLoader 解析</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下python3.5+pip安装</title>
    <url>/2018/10/04/linux%E4%B8%8Bpython3-5-pip%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>安装包;<br><img src="/2018/10/04/linux%E4%B8%8Bpython3-5-pip%E5%AE%89%E8%A3%85/20161201220019448.png" alt="这里写图片描述"></p>
<span id="more"></span>

<p>python依赖环境安装：<br>yum install openssl-devel -y</p>
<p>yum groupinstall ‘Development Tools’</p>
<p>yum install zlib-devel bzip2-devel  openssl-devel ncurses-devel</p>
<p>A：解压python:<br>解压：tar jxvf Python-*<br>进入文件目录，运行以下命令：<br>1）.&#x2F;configure<br>2）make<br>3）sudo make install</p>
<p>重新指向（默认是2.6）<br>ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3.3 &#x2F;usr&#x2F;bin&#x2F;python</p>
<p>B: 安装setuptools软件包</p>
<p>(1)解压setuptools包<br>tar zxvf setuptools-2.0.tar.gz<br>cd setuptools-2.0<br>(2)编译setuptools<br> python setup.py build<br>(3)开始执行setuptools安装<br>python setup.py install</p>
<p>验证;<br><img src="/2018/10/04/linux%E4%B8%8Bpython3-5-pip%E5%AE%89%E8%A3%85/20161128214730486.png" alt="这里写图片描述"></p>
<p>ok可以正常安装软件</p>
<p>C:安装pip：<br>python setup.py install</p>
<p>D:安装ipython<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lweXRob24vaXB5dGhvbi9hcmNoaXZlLzUuMS4wLnRhci5neg==">https://github.com/ipython/ipython/archive/5.1.0.tar.gz<i class="fa fa-external-link-alt"></i></span></p>
<p>pip install ipython<br>pip install “ipython[notebook]”<br>ipython notebook<br> pip install jupyter<br>浏览器会打开下面这个页面：<br><img src="/2018/10/04/linux%E4%B8%8Bpython3-5-pip%E5%AE%89%E8%A3%85/20161203200608554.png" alt="这里写图片描述"><br>点击要打开的文件比如Computer_Sketchy_score.ipynb，就可以打开了</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python pip jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下搭建RabbitMQ服务</title>
    <url>/2018/09/28/linux%E4%B8%8B%E6%90%AD%E5%BB%BARabbitMQ%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p><strong>引言</strong><br>你是否遇到过两个（多个）系统间需要通过定时任务来同步某些数据？你是否在为异构系统的不同进程间相互调用、通讯的问题而苦恼、挣扎？如果是，那么恭喜你，消息服务让你可以很轻松地解决这些问题。<br>消息服务擅长于解决多系统、异构系统间的数据交换（消息通知&#x2F;通讯）问题，你也可以把它用于系统间服务的相互调用（RPC）。本文将要介绍的RabbitMQ就是当前最主流的消息中间件之一。</p>
<span id="more"></span>

<p><strong>RabbitMQ简介</strong><br>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。<br>AMQP的主要特征是面向消息、队列、路由（包括点对点和发布&#x2F;订阅）、可靠性、安全。<br>RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。<br>Rabbitmq试用业务范围：<br><strong>场景1：单发送单接收</strong><br>使用场景：简单的发送与接收，没有特别的处理。<br><strong>场景2：单发送多接收</strong><br>使用场景：一个发送端，多个接收端，如分布式的任务派发。为了保证消息发送的可靠性，不丢失消息，使消息持久化了。同时为了防止接收端在处理消息时down掉，只有在消息处理完成后才发送ack消息<br><strong>场景3：Publish&#x2F;Subscribe</strong><br>使用场景：发布、订阅模式，发送端发送广播消息，多个接收端接收。<br><strong>场景4：Routing (按路线发送接收)</strong><br>使用场景：发送端按routing key发送消息，不同的接收端按不同的routing key接收消息。<br><strong>场景5：Topics (按topic发送接收)</strong><br>使用场景：发送端不只按固定的routing key发送消息，而是按字符串“匹配”发送，接收端同样如此。</p>
<p>1:下载所需的tar.gz包<br> 1)ncurses-5.2.tar(它是一个可以使应用程序直接控制终端屏幕显示的库,在安装rabbitmq-server中会报错缺少这个库)<br> 2)simplejson-3.8.0.tar(它是 Python解析JSON的程序库。)<br> 3)otp_src_R15B01.tar(RabbitMQ是基于Erlang的，所以首先必须配置Erlang环境,otp_src_R15B01是提供该环境的包)<br> 4)rabbitmq-server-3.5.4.tar</p>
<p>#########################搭建Erlang环境##############################<br> 2:登录到指定的一台linux服务器<br>   选择要创建一个文件夹，我选择的目录是(目录名称可随便)：<br>   &#x2F;data&#x2F;rabbitMQ<br><img src="/2018/09/28/linux%E4%B8%8B%E6%90%AD%E5%BB%BARabbitMQ%E6%9C%8D%E5%8A%A1/20160802101807942.png" alt="这里写图片描述"><br>3：进入到该目录,做以下操作<br> cd  &#x2F;data&#x2F;rabbitMQ<br> tar xvzf otp_src_R15B01.tar.gz<br> cd otp_src_R15B01<br> .&#x2F;configure</p>
<p>最后一步执行完，可能会报一个错：<br> No curses library functions found(这是缺少ncurses-5.2.tar包)<br>把ncurses-5.2.tar放到指定路径，我这里放到的是&#x2F;data&#x2F;ncurses 下，最好和之前放同一个路径<br><img src="/2018/09/28/linux%E4%B8%8B%E6%90%AD%E5%BB%BARabbitMQ%E6%9C%8D%E5%8A%A1/20160802101839630.png" alt="这里写图片描述"><br>执行以下操作：<br>tar zxvf ncurses-5.2.tar #解压缩并且释放 文件包<br>cd ncurses-5.2    #进入解压缩的目录（注意版本）<br>.&#x2F;configure #按照你的系统环境制作安装配置文件<br>make #编译源代码并且编译NCURSES库<br>su root #切换到root用户环境<br>make install #安装编译好的NCURSES库</p>
<p>等操作完以上命令，在重新执行搭建Erlang环境的 .&#x2F;configure 命令：<br>编译后的输出如下图<br><img src="/2018/09/28/linux%E4%B8%8B%E6%90%AD%E5%BB%BARabbitMQ%E6%9C%8D%E5%8A%A1/20160802101906459.png" alt="这里写图片描述"><br> 提示没有wxWidgets和fop，但是问题不大。继续：<br> make<br> sudo make install</p>
<p>如果没报错，说明已经安装完Erlang，开始安装RabbitMQ-Server。</p>
<p>#########################搭建simplejson环境##############################<br>安装RabbitMQ-Server之前，必须先安装simplejson<br>主要参考官方文档：<span class="exturl" data-url="aHR0cDovL3d3dy5yYWJiaXRtcS5jb20vYnVpbGQtc2VydmVyLmh0bWw=">http://www.rabbitmq.com/build-server.html<i class="fa fa-external-link-alt"></i></span><br>需要安装simplejson。从此处下载最新的版本： <span class="exturl" data-url="aHR0cDovL3B5cGkucHl0aG9uLm9yZy9weXBpL3NpbXBsZWpzb24jZG93bmxvYWRz">http://pypi.python.org/pypi/simplejson#downloads<i class="fa fa-external-link-alt"></i></span> 。我下载的版本是 simplejson-3.8.0.tar.gz<br>安装这个很简单，执行以下3个步骤即可：<br>进入到该目录：<br><img src="/2018/09/28/linux%E4%B8%8B%E6%90%AD%E5%BB%BARabbitMQ%E6%9C%8D%E5%8A%A1/20160802101942194.png" alt="这里写图片描述"><br>tar xvzf simplejson-3.8.0.tar.gz<br>cd simplejson-3.8.0<br>sudo python setup.py install</p>
<p>#########################安装RabbitMQ Server环境##############################</p>
<p>最后安装RabbitMQ Server。从此处下载源代码版本的RabbitMQ： <span class="exturl" data-url="aHR0cDovL3d3dy5yYWJiaXRtcS5jb20vc2VydmVyLmh0bWwlRTMlODAlODI=">http://www.rabbitmq.com/server.html。<i class="fa fa-external-link-alt"></i></span><br>我下载的版本是 rabbitmq-server-3.5.4.tar.gz</p>
<p>进入该目录：<br><img src="/2018/09/28/linux%E4%B8%8B%E6%90%AD%E5%BB%BARabbitMQ%E6%9C%8D%E5%8A%A1/20160802102010282.png" alt="这里写图片描述"><br>所需要的包<br>yum install xmlto</p>
<p>tar xvzf rabbitmq-server-3.5.4.tar.gz<br> cd rabbitmq-server-3.5.4<br> make<br> TARGET_DIR&#x3D;&#x2F;usr&#x2F;local SBIN_DIR&#x3D;&#x2F;usr&#x2F;local&#x2F;sbin MAN_DIR&#x3D;&#x2F;usr&#x2F;local&#x2F;man make install</p>
<p>安装成功。</p>
<p>运行<br>找到sbin&#x2F;目录，默认目录在：&#x2F;usr&#x2F;local&#x2F;sbin&#x2F;下<br>运行程序：<br>rabbitmq-server –detached<br>停止程序：<br>rabbitmqctl stop</p>
<p>安装管理插件<br>mkdir &#x2F;etc&#x2F;rabbitmq<br>cd &#x2F;usr&#x2F;local&#x2F;sbin&#x2F;<br>.&#x2F;rabbitmq-plugins enable rabbitmq_management</p>
<p>.&#x2F;rabbitmq-server -detached</p>
<p>重新启动RabbitMQ，输入<span class="exturl" data-url="aHR0cDovL3NlcnZlci1uYW1lOjE1NjcyLw==">http://server-name:15672<i class="fa fa-external-link-alt"></i></span> 就能够进入到监控页面。默认的用户名和密码是： guest 和 guest。<br>server-name:你指定的linux服务器ip，我的是10.1.100.67</p>
<p>浏览器输入：<span class="exturl" data-url="aHR0cDovLzEwLjEuMTAwLjY3OjE1NjcyLw==">http://10.1.100.67:15672/<i class="fa fa-external-link-alt"></i></span> 则说明环境搭建成功<br><img src="/2018/09/28/linux%E4%B8%8B%E6%90%AD%E5%BB%BARabbitMQ%E6%9C%8D%E5%8A%A1/20160802102045118.png" alt="这里写图片描述"><br>输入默认用户名和密码：guest ，提示登陆失败<br> 翻看官方的release文档后，得知由于账号guest具有所有的操作权限，并且又是默认账号，出于安全因素的考虑，guest用户只能通过localhost登陆使用，并建议修改guest用户的密码以及新建其他账号管理使用rabbitmq(该功能是在3.3.0版本引入的)。</p>
<p>解决方法：<br>进入&#x2F;data&#x2F;rabbitMQ&#x2F;rabbitmq-server&#x2F;rabbitmq-server-3.5.4&#x2F;ebin目录下rabbit.app中找到：loopback_users里的&lt;&lt;”guest”&gt;&gt;删除。<br> 并重启rabbitmq，则可以用guest账号登陆管理控制台。成功界面如下：<br><img src="/2018/09/28/linux%E4%B8%8B%E6%90%AD%E5%BB%BARabbitMQ%E6%9C%8D%E5%8A%A1/20160802102122048.png" alt="这里写图片描述"></p>
<pre><code>             Java 代码与spring集成
</code></pre>
<p>1：发送者配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">	xmlns:rabbit=&quot;http://www.springframework.org/schema/rabbit&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</span><br><span class="line">	xsi:schemaLocation=&quot;</span><br><span class="line">		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit-1.3.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- #################################################################### --&gt;</span><br><span class="line">	&lt;!-- # RabbitMQ 消息转换器 --&gt;</span><br><span class="line">	&lt;!-- #################################################################### --&gt;</span><br><span class="line">	&lt;bean id=&quot;rabbitMessageConverter&quot; class=&quot;org.springframework.amqp.support.converter.Jackson2JsonMessageConverter&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;classMapper&quot;&gt;</span><br><span class="line">			&lt;bean class=&quot;org.springframework.amqp.support.converter.DefaultJackson2JavaTypeMapper&quot; /&gt;</span><br><span class="line">		&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- #################################################################### --&gt;</span><br><span class="line">	&lt;!-- # RabbitMQ 异常处理程序 --&gt;</span><br><span class="line">	&lt;!-- #################################################################### --&gt;</span><br><span class="line">	&lt;bean id=&quot;logAndPropagateErrorHandler&quot; class=&quot;org.springframework.beans.factory.config.FieldRetrievingFactoryBean&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;staticField&quot;&gt;</span><br><span class="line">			&lt;value&gt;org.springframework.scheduling.support.TaskUtils.LOG_AND_PROPAGATE_ERROR_HANDLER&lt;/value&gt;</span><br><span class="line">		&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- #################################################################### --&gt;</span><br><span class="line">	&lt;!-- # rabbit 连接工厂 --&gt;</span><br><span class="line">	&lt;!-- #################################################################### --&gt;</span><br><span class="line">	&lt;rabbit:connection-factory id=&quot;rabbitConnectionFactory&quot; addresses=&quot;10.1.100.67&quot; username=&quot;guest&quot; password=&quot;guest&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- #################################################################### --&gt;</span><br><span class="line">	&lt;!-- # RabbitMQ 管理员 --&gt;</span><br><span class="line">	&lt;!-- #################################################################### --&gt;</span><br><span class="line">	&lt;rabbit:admin connection-factory=&quot;rabbitConnectionFactory&quot; /&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- #################################################################### --&gt;</span><br><span class="line">	&lt;!-- # RabbitMQ 队列 --&gt;</span><br><span class="line">	&lt;!-- #################################################################### --&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 入库自动上架消息消息队列 --&gt;</span><br><span class="line">	&lt;rabbit:queue id=&quot;queues.inbound.putway&quot; name=&quot;queues.inbound.putway&quot;&gt;</span><br><span class="line">		&lt;rabbit:queue-arguments&gt;</span><br><span class="line">			&lt;!-- 开启集群环境镜像队列 --&gt;</span><br><span class="line">			&lt;entry key=&quot;x-ha-policy&quot; value=&quot;all&quot; /&gt;</span><br><span class="line">		&lt;/rabbit:queue-arguments&gt;</span><br><span class="line">	&lt;/rabbit:queue&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- #################################################################### --&gt;</span><br><span class="line">	&lt;!-- # RabbitMQ Exchange --&gt;</span><br><span class="line">	&lt;!-- # PS：RabbitMQ 中所有生产者提交的消息都由 Exchange 来接受，再由 Exchange 按照特定的策略转发到 Queue 进行存储/处理 --&gt;</span><br><span class="line">	&lt;!-- # 策略规则：pattern 表达式中 # 表示0个或若干个关键字， * 表示一个关键字 --&gt;</span><br><span class="line">	&lt;!-- # 示例A：queues.# 能匹配 queues.sample 也能匹配 queues.sample.one --&gt;</span><br><span class="line">	&lt;!-- # 示例B：queues.* 能匹配 queues.sample 不能匹配 queues.sample.one --&gt;</span><br><span class="line">	&lt;!-- #################################################################### --&gt;</span><br><span class="line">	&lt;rabbit:topic-exchange name=&quot;amq.topic&quot;&gt;</span><br><span class="line">		&lt;rabbit:bindings&gt;</span><br><span class="line">			&lt;rabbit:binding queue=&quot;queues.inbound.putway&quot; pattern=&quot;queues.inbound.#&quot;/&gt;</span><br><span class="line">		&lt;/rabbit:bindings&gt;</span><br><span class="line">	&lt;/rabbit:topic-exchange&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- #################################################################### --&gt;</span><br><span class="line">	&lt;!-- # RabbitMQ 模板（生产者） --&gt;</span><br><span class="line">	&lt;!-- #################################################################### --&gt;</span><br><span class="line">	&lt;rabbit:template id=&quot;rabbitTemplate&quot; connection-factory=&quot;rabbitConnectionFactory&quot; channel-transacted=&quot;true&quot; message-converter=&quot;rabbitMessageConverter&quot; /&gt;</span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先导入jar：spring-rabbit-1.2.2.RELEASE.jar<br>引入jar：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private RabbitTemplate rabbitTemplate;</span><br><span class="line">发送者java代码：</span><br><span class="line">rabbitTemplate.convertAndSend(&quot;queues.inbound.putway&quot;,productPutaway);</span><br><span class="line"></span><br><span class="line">Queues.inbound.putway :xml 里面定义的id</span><br><span class="line">productPutaway:要发送的消息，可以为字符串对象，集合，map等形式</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2：消费者配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">	xmlns:rabbit=&quot;http://www.springframework.org/schema/rabbit&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</span><br><span class="line">	xsi:schemaLocation=&quot;</span><br><span class="line">		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit-1.3.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- #################################################################### --&gt;</span><br><span class="line">	&lt;!-- # RabbitMQ 消息转换器 --&gt;</span><br><span class="line">	&lt;!-- #################################################################### --&gt;</span><br><span class="line">	&lt;bean id=&quot;rabbitMessageConverter&quot; class=&quot;org.springframework.amqp.support.converter.Jackson2JsonMessageConverter&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;classMapper&quot;&gt;</span><br><span class="line">			&lt;bean class=&quot;org.springframework.amqp.support.converter.DefaultJackson2JavaTypeMapper&quot; /&gt;</span><br><span class="line">		&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- #################################################################### --&gt;</span><br><span class="line">	&lt;!-- # RabbitMQ 异常处理程序 --&gt;</span><br><span class="line">	&lt;!-- #################################################################### --&gt;</span><br><span class="line">	&lt;bean id=&quot;logAndPropagateErrorHandler&quot; class=&quot;org.springframework.beans.factory.config.FieldRetrievingFactoryBean&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;staticField&quot;&gt;</span><br><span class="line">			&lt;value&gt;org.springframework.scheduling.support.TaskUtils.LOG_AND_PROPAGATE_ERROR_HANDLER&lt;/value&gt;</span><br><span class="line">		&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- #################################################################### --&gt;</span><br><span class="line">	&lt;!-- # rabbit 连接工厂 --&gt;</span><br><span class="line">	&lt;!-- #################################################################### --&gt;</span><br><span class="line">	&lt;rabbit:connection-factory id=&quot;rabbitConnectionFactory&quot; addresses=&quot;10.1.100.67&quot; username=&quot;guest&quot; password=&quot;guest&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- #################################################################### --&gt;</span><br><span class="line">	&lt;!-- # RabbitMQ 管理员 --&gt;</span><br><span class="line">	&lt;!-- #################################################################### --&gt;</span><br><span class="line">	&lt;rabbit:admin connection-factory=&quot;rabbitConnectionFactory&quot; /&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- #################################################################### --&gt;</span><br><span class="line">	&lt;!-- # RabbitMQ 队列 --&gt;</span><br><span class="line">	&lt;!-- #################################################################### --&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&lt;!-- #################################################################### --&gt;</span><br><span class="line">	&lt;!-- # RabbitMQ 模板（生产者） --&gt;</span><br><span class="line">	&lt;!-- #################################################################### --&gt;</span><br><span class="line">	&lt;rabbit:template id=&quot;rabbitTemplate&quot; connection-factory=&quot;rabbitConnectionFactory&quot; channel-transacted=&quot;true&quot; message-converter=&quot;rabbitMessageConverter&quot; /&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- #################################################################### --&gt;</span><br><span class="line">	&lt;!-- # RabbitMQ 监听容器（消费者） --&gt;</span><br><span class="line">	&lt;!-- #################################################################### --&gt;</span><br><span class="line">	&lt;rabbit:listener-container connection-factory=&quot;rabbitConnectionFactory&quot; message-converter=&quot;rabbitMessageConverter&quot; channel-transacted=&quot;true&quot; error-handler=&quot;logAndPropagateErrorHandler&quot;&gt;</span><br><span class="line">		&lt;!-- 货品上架单消费者 --&gt;</span><br><span class="line">		&lt;rabbit:listener queues=&quot;queues.inbound.putway&quot; ref=&quot;productPutAwayMessageConsumer&quot; method=&quot;saveProductPutaway&quot; /&gt;</span><br><span class="line">	&lt;/rabbit:listener-container&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接收者Java代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 收货入库单插入上架单消息对象介绍处理类</span><br><span class="line"> * @author Min.Wang</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class ProductPutAwayMessageConsumer &#123;</span><br><span class="line">	 @Autowired</span><br><span class="line">	 private ProductPutawayService productPutawayService;</span><br><span class="line"></span><br><span class="line">	 /**</span><br><span class="line">     * 保存上架单/给收货完成是调用</span><br><span class="line">     * @author Min.Wang</span><br><span class="line">     */</span><br><span class="line">    public void saveProductPutaway(ProductPutaway productPutaway)&#123;</span><br><span class="line">    	//根据收到的消息数据，处理对应的业务逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">更多扩展请了解rabbitmq官网：http://www.rabbitmq.com/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ linux</tag>
      </tags>
  </entry>
  <entry>
    <title>netty源码分析(一)EventLoopGroup</title>
    <url>/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%80-EventLoopGroup/</url>
    <content><![CDATA[<p>首先我们使用netty建立一个服务端和客户端，功能是相互之间发消息，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzExNTY3MjE4NzQvbmV0dHlfbGVjdHVyZS90cmVlL21hc3Rlci9zcmMvbWFpbi9qYXZhL2NvbS9jZWFzZXIvbmV0dHkvc2Vjb25kZXhhbXBsZQ==">代码<i class="fa fa-external-link-alt"></i></span><br>我们把服务端的主要代码贴出来：</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.ceaser.netty.secondexample;</span><br><span class="line"></span><br><span class="line">import io.netty.bootstrap.ServerBootstrap;</span><br><span class="line">import io.netty.channel.ChannelFuture;</span><br><span class="line">import io.netty.channel.EventLoopGroup;</span><br><span class="line">import io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line">import io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by Administrator on 2017/5/20.</span><br><span class="line"> * 服务器和客户端互发程序</span><br><span class="line"> */</span><br><span class="line">public class MyServer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        EventLoopGroup bossGroup = new NioEventLoopGroup();//第一步建立bossGroup 接受数据然后转发给workerGroup ，是一个死循环</span><br><span class="line">        EventLoopGroup workerGroup = new NioEventLoopGroup();//第二部 workerGroup 完成实际数据的处理，也是一个死循环</span><br><span class="line">        try&#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = new ServerBootstrap();//第三步。启动bossGroup和workerGroup</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).</span><br><span class="line">            handler(new LoggingHandler(LogLevel.WARN))</span><br><span class="line">            .childHandler(new MyServerInitializer());</span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(8899).sync();//第四部，指定服务端的端口。</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们从EventLoopGroup 入手，看一下EventLoopGroup 的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Special &#123;@link EventExecutorGroup&#125; which allows registering &#123;@link Channel&#125;s that get</span><br><span class="line"> * processed for later selection during the event loop.</span><br><span class="line"> *EventLoopGroup 首先是一个接口，继承了EventExecutorGroup ，主要的功能是在时间循环对Channel的注册，</span><br><span class="line"> */</span><br><span class="line">public interface EventLoopGroup extends EventExecutorGroup &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Return the next &#123;@link EventLoop&#125; to use</span><br><span class="line">     * 一个EventLoopGroup 有多个EventLoop ，地方法得到下一个EventLoop</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    EventLoop next();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Register a &#123;@link Channel&#125; with this &#123;@link EventLoop&#125;. The returned &#123;@link ChannelFuture&#125;</span><br><span class="line">     * will get notified once the registration was complete.</span><br><span class="line">     * 将参数channel 注册到EventLoop当中，然后注册完毕之后会异步的ChannelFuture 返回到ChannelFuture 当中。</span><br><span class="line">     */</span><br><span class="line">    ChannelFuture register(Channel channel);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Register a &#123;@link Channel&#125; with this &#123;@link EventLoop&#125; using a &#123;@link ChannelFuture&#125;. The passed</span><br><span class="line">     * &#123;@link ChannelFuture&#125; will get notified once the registration was complete and also will get returned.</span><br><span class="line">     * 也是讲channel注册到EventLoop当中，当时我们发现 参数是ChannelPromise 类型的，不是Channel 类型的，那只有一种可能，</span><br><span class="line">     * ChannelPromise 里边包含Channel 的引用，后续会展开讲解。</span><br><span class="line">     */</span><br><span class="line">    ChannelFuture register(ChannelPromise promise);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Register a &#123;@link Channel&#125; with this &#123;@link EventLoop&#125;. The passed &#123;@link ChannelFuture&#125;</span><br><span class="line">     * will get notified once the registration was complete and also will get returned.</span><br><span class="line">     *</span><br><span class="line">     * @deprecated Use &#123;@link #register(ChannelPromise)&#125; instead.</span><br><span class="line">     * 废弃的注册，在 ChannelFuture register(ChannelPromise promise);方法当中ChannelPromise 已经包含了Channel 的引用，那么这个</span><br><span class="line">     * 方法把Channel 也作为参数，是一种功能上的重复，因此被Deprecated，不推荐使用。</span><br><span class="line">     */</span><br><span class="line">    @Deprecated</span><br><span class="line">    ChannelFuture register(Channel channel, ChannelPromise promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册返回结果ChannelFuture:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//ChannelFuture 的父类Future继承了java.util.concurrent.Future,是对结果的一些判断或者监听的操作。</span><br><span class="line">public interface ChannelFuture extends Future&lt;Void&gt; &#123;</span><br><span class="line">    Channel channel();</span><br><span class="line">    @Override</span><br><span class="line">    ChannelFuture addListener(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt; listener);</span><br><span class="line">    @Override</span><br><span class="line">    ChannelFuture addListeners(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt;... listeners);</span><br><span class="line">    @Override</span><br><span class="line">    ChannelFuture removeListener(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt; listener);</span><br><span class="line">    @Override</span><br><span class="line">    ChannelFuture removeListeners(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt;... listeners);</span><br><span class="line">    @Override</span><br><span class="line">    ChannelFuture sync() throws InterruptedException;</span><br><span class="line">    @Override</span><br><span class="line">    ChannelFuture syncUninterruptibly();</span><br><span class="line">    @Override</span><br><span class="line">    ChannelFuture await() throws InterruptedException;</span><br><span class="line">    @Override</span><br><span class="line">    ChannelFuture awaitUninterruptibly();</span><br><span class="line">    boolean isVoid();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ChannelPromise 是怎么注册Channel 的呢，因为它内部有Channel 的引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface ChannelPromise extends ChannelFuture, Promise&lt;Void&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Channel channel();</span><br><span class="line">    ...略</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>找一个ChannelPromise 的实现类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultChannelPromise extends DefaultPromise&lt;Void&gt; implements ChannelPromise, FlushCheckpoint &#123;</span><br><span class="line"></span><br><span class="line">    private final Channel channel;内部的Channel引用。</span><br><span class="line">    private long checkpoint;</span><br><span class="line">    ...</span><br><span class="line">    ...略</span><br><span class="line"> &#125;    </span><br></pre></td></tr></table></figure>

<p>接着EventLoopGroup 继承接口EventExecutorGroup：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The &#123;@link EventExecutorGroup&#125; is responsible for providing the &#123;@link EventExecutor&#125;&#x27;s to use</span><br><span class="line"> * via its &#123;@link #next()&#125; method. Besides this, it is also responsible for handling their</span><br><span class="line"> * life-cycle and allows shutting them down in a global fashion.</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public interface EventExecutorGroup extends ScheduledExecutorService, Iterable&lt;EventExecutor&gt; &#123;</span><br><span class="line">...</span><br><span class="line">...中间方法略</span><br><span class="line">...</span><br><span class="line">    /**</span><br><span class="line">     * Returns one of the &#123;@link EventExecutor&#125;s managed by this &#123;@link EventExecutorGroup&#125;.</span><br><span class="line">     * EventExecutorGroup内部管理了EventExecutor 。</span><br><span class="line">     */</span><br><span class="line">    EventExecutor next();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>透过EventLoopGroup 和EventExecutorGroup我们知道他们都有自己的EventLoop和EventExecutor<br>回到：EventLoopGroup bossGroup &#x3D; new NioEventLoopGroup();这行代码，NioEventLoopGroup()可以传递参数比如new NioEventLoopGroup(1)；代表有一个线程接受连接。<br>进入NioEventLoopGroup(Int nThreads）的构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public NioEventLoopGroup(int nThreads) &#123;</span><br><span class="line">    this(nThreads, (Executor) null);//第二个参数传null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续走：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public NioEventLoopGroup(int nThreads, Executor executor) &#123;</span><br><span class="line">    this(nThreads, executor, SelectorProvider.provider());//加入SelectorProvider,调SelectorProvider 的静态方法得到一个</span><br><span class="line">    //SelectorProvider</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>next:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public NioEventLoopGroup(</span><br><span class="line">        int nThreads, Executor executor, final SelectorProvider selectorProvider) &#123;</span><br><span class="line">    this(nThreads, executor, selectorProvider, DefaultSelectStrategyFactory.INSTANCE);</span><br><span class="line">    //DefaultSelectStrategyFactory.INSTANCE返回一个DefaultSelectStrategyFactory实例。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>next：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public NioEventLoopGroup(int nThreads, Executor executor, final SelectorProvider selectorProvider,</span><br><span class="line">                         final SelectStrategyFactory selectStrategyFactory) &#123;</span><br><span class="line">    super(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());</span><br><span class="line">    //RejectedExecutionHandlers提供了拒绝策略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>next调父类MultithreadEventLoopGroup的构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) &#123;</span><br><span class="line">    super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DEFAULT_EVENT_LOOP_THREADS 初始化是在系统加载的时候：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt(</span><br><span class="line">                &quot;io.netty.eventLoopThreads&quot;, NettyRuntime.availableProcessors() * 2));</span><br><span class="line">//如果配置了io.netty.eventLoopThreads会取io.netty.eventLoopThreads的值，否则就去系统cpu的核数*2，注意，现在的cpu都有超频技术</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(&quot;-Dio.netty.eventLoopThreads: &#123;&#125;&quot;, DEFAULT_EVENT_LOOP_THREADS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以测试一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int result = Math.max(1, SystemPropertyUtil.getInt(</span><br><span class="line">                &quot;io.netty.eventLoopThreads&quot;, NettyRuntime.availableProcessors() * 2));</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以为我的机器是8核的：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%80-EventLoopGroup/20170910175123805.png" alt="这里写图片描述"><br>运行结果是16。<br>接着往下走调用MultithreadEventLoopGroup的父类MultithreadEventExecutorGroup的构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected MultithreadEventExecutorGroup(int nThreads, Executor executor, Object... args) &#123;</span><br><span class="line">    this(nThreads, executor, DefaultEventExecutorChooserFactory.INSTANCE, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后来到最终初始化的地方MultithreadEventExecutorGroup的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class MultithreadEventExecutorGroup extends AbstractEventExecutorGroup &#123;</span><br><span class="line"></span><br><span class="line">    private final EventExecutor[] children;</span><br><span class="line">	....</span><br><span class="line">	....略</span><br><span class="line">	....</span><br><span class="line">    protected MultithreadEventExecutorGroup(int nThreads, Executor executor,</span><br><span class="line">                                            EventExecutorChooserFactory chooserFactory, Object... args) &#123;</span><br><span class="line">        if (nThreads &lt;= 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(String.format(&quot;nThreads: %d (expected: &gt; 0)&quot;, nThreads));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (executor == null) &#123;</span><br><span class="line">            executor = new ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        children = new EventExecutor[nThreads];</span><br><span class="line">		//循环对MultithreadEventExecutorGroup的数组EventExecutor初始化，根据指定的线程数量。</span><br><span class="line">        for (int i = 0; i &lt; nThreads; i ++) &#123;</span><br><span class="line">            boolean success = false;</span><br><span class="line">            try &#123;</span><br><span class="line">                children[i] = newChild(executor, args);</span><br><span class="line">                success = true;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                // TODO: Think about if this is a good exception type</span><br><span class="line">                throw new IllegalStateException(&quot;failed to create a child event loop&quot;, e);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (!success) &#123;</span><br><span class="line">                    for (int j = 0; j &lt; i; j ++) &#123;</span><br><span class="line">                        children[j].shutdownGracefully();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    for (int j = 0; j &lt; i; j ++) &#123;</span><br><span class="line">                        EventExecutor e = children[j];</span><br><span class="line">                        try &#123;</span><br><span class="line">                            while (!e.isTerminated()) &#123;</span><br><span class="line">                                e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; catch (InterruptedException interrupted) &#123;</span><br><span class="line">                            // Let the caller handle the interruption.</span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        chooser = chooserFactory.newChooser(children);</span><br><span class="line"></span><br><span class="line">        final FutureListener&lt;Object&gt; terminationListener = new FutureListener&lt;Object&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void operationComplete(Future&lt;Object&gt; future) throws Exception &#123;</span><br><span class="line">                if (terminatedChildren.incrementAndGet() == children.length) &#123;</span><br><span class="line">                    terminationFuture.setSuccess(null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        for (EventExecutor e: children) &#123;</span><br><span class="line">            e.terminationFuture().addListener(terminationListener);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;EventExecutor&gt; childrenSet = new LinkedHashSet&lt;EventExecutor&gt;(children.length);</span><br><span class="line">        Collections.addAll(childrenSet, children);</span><br><span class="line">        readonlyChildren = Collections.unmodifiableSet(childrenSet);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>由此完成初始化。<br>本节先到这儿~~</p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>nio socket netty源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>netty源码分析(七)Acceptor与Dispatcher角色分析</title>
    <url>/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%83-Acceptor%E4%B8%8EDispatcher%E8%A7%92%E8%89%B2%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>理解Reactor模式的另外一篇文章是一篇论文：《<span class="exturl" data-url="aHR0cDovL3d3dy5kcmUudmFuZGVyYmlsdC5lZHUvfnNjaG1pZHQvUERGL3JlYWN0b3Itc2llbWVucy5wZGY=">reactor-siemens<i class="fa fa-external-link-alt"></i></span>》，论文的环境是日志服务器的例子：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%83-Acceptor%E4%B8%8EDispatcher%E8%A7%92%E8%89%B2%E5%88%86%E6%9E%90/20170923190027064.png" alt="这里写图片描述"></p>
<span id="more"></span>
<p>客户端将日志发送到日志服务器，日志服务器将日志通过各种设备输出。<br>意图：<br>The Reactor design pattern handles service requests that are<br>delivered concurrently to an application by one or more<br>clients. Each service in an application may consist of<br>serveral methods and is represented by a separate event handler<br>that is responsible for dispatching service-specific requests.<br>Dispatching of event handlers is performed by an initiation<br>dispatcher, which manages the registered event handlers.<br>Demultiplexing of service requests is performed by a<br>synchronous event demultiplexer.<br>Reactor 设计模式是为了处理由一个或多个客户端向一个应用发送的请求，应用中的每个服务有单独的时间处理器组成，事件处理器的作用是特定服务的请求进行分发，时间处理器的分发是由initiation dispatcher来进行，initiation dispatcher会管理诸多的事件处理器，服务请求的分离是由同步的事件分离器处理。</p>
<p>我们拿出来论文的核心知识点说一下：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%83-Acceptor%E4%B8%8EDispatcher%E8%A7%92%E8%89%B2%E5%88%86%E6%9E%90/20170923184440826.png" alt="这里写图片描述"></p>
<p>图A是初始化的过程：</p>
<ol>
<li>The logging server (1) registers the Logging Acceptor with the Initiation Dispatcher to handle connection requests;<br>日志服务通过初始化分发器注册到日志Acceptor 上去，用来处理连接请求。</li>
<li>The logging server invokes the handle events method (2) of the Initiation Dispatcher;<br>日志服务器调用初始化分发器的处理事件方法。</li>
<li>The Initiation Dispatcher invokes the synchronous event demultiplexing select (3) operation to wait for connection requests or logging data to arrive;<br>初始化分发器通用同步的事件分离方法（select()）来等待连接请求或者数据的到达。</li>
<li>A client connects (4) to the logging server;<br>一个客户端连接到服务</li>
<li>The Logging Acceptor is notified by the Initiation Dispatcher (5) of the new connection request;<br>当一个连接请求过来时，日志接收器被初始化分发器唤醒。</li>
<li>The Logging Acceptor accepts (6) the new connection;<br>日志接收器接受新的连接 。</li>
<li>The Logging Acceptor creates (7) a Logging Handler to service the new client;<br>日志接收器创建一个日志处理器来服务新的客户端。</li>
<li>Logging Handler registers (8) its socket handle with the Initiation Dispatcher and instructs the dispatcher to notify it when the socket becomes “ready for reading.”<br>日志处理器通过初始化分发器注册到处理他的socket 上去，并且指示分发器当socket 变成准备好的时候提醒他。</li>
</ol>
<p>图B是后续其他客户端连接的处理过程：</p>
<ol>
<li>The client sends (1) a logging record;<br>一个客户端发送一个日志。</li>
<li>The Initiation Dispatcher notifies (2) the associated Logging Handler when a client logging record is queued on its socket handle by OS;<br>当一个客户端的日志进入到处理器的队列， 初始化分发器通知相关联的日志处理器。</li>
<li>The record is received (3) in a non-blocking manner (steps 2 and 3 repeat until the logging record has been received completely);<br>日志接受通过非阻塞的方式通过重复步骤2和步骤3直到所有日志接受完毕。</li>
<li>The Logging Handler processes the logging record and writes (4) it to the standard output.<br>日志处理器处理日志，并且写到标准输出里边。</li>
<li>The Logging Handler returns (5) control to the Initiation Dispatcher’s event loop.<br>处理完毕返回到 Initiation Dispatcher时间循环。</li>
</ol>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>Acceptor Dispatcher</tag>
      </tags>
  </entry>
  <entry>
    <title>netty源码分析(三)Netty服务端ServerBootstrap的初始化与反射在其中的应用分析</title>
    <url>/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%89-Netty%E6%9C%8D%E5%8A%A1%E7%AB%AFServerBootstrap%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%B0%84%E5%9C%A8%E5%85%B6%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>上一节说到EventLoopGroup只是对bossGroup和workerGroup的一些初始化，包括线程数量，执行器（命令模式），我们的服务端接下来使用ServerBootstrap对bossGroup和workerGroup进行了包装，整个过程是一个方法链的调用过程，每个方法返回调用者本身：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%89-Netty%E6%9C%8D%E5%8A%A1%E7%AB%AFServerBootstrap%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%B0%84%E5%9C%A8%E5%85%B6%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E5%88%86%E6%9E%90/20170916120817979.png" alt="这里写图片描述"></p>
<span id="more"></span>
<p>然后进行了启动，先看一下ServerBootstrap的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> //&#123;@link Bootstrap&#125; sub-class which allows easy bootstrap of &#123;@link ServerChannel&#125;</span><br><span class="line"> //Bootstrap的子类型，用来启动ServerChannel，父类是AbstractBootstrap，父类的泛型是它的子类类型ServerBootstrap和</span><br><span class="line"> //要启动的ServerChannel类型。</span><br><span class="line">public class ServerBootstrap extends AbstractBootstrap&lt;ServerBootstrap, ServerChannel&gt; &#123;</span><br><span class="line">	...略</span><br><span class="line">    private volatile EventLoopGroup childGroup;//即之前创建的workerGroup，实际处理数据的EventLoopGroup。</span><br><span class="line">    ...略</span><br><span class="line">    public ServerBootstrap() &#123; &#125; //构造器非常简化。</span><br><span class="line">	...略</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Set the &#123;@link EventLoopGroup&#125; for the parent (acceptor) and the child (client). These</span><br><span class="line">     * &#123;@link EventLoopGroup&#125;&#x27;s are used to handle all the events and IO for &#123;@link ServerChannel&#125; and</span><br><span class="line">     * &#123;@link Channel&#125;&#x27;s.</span><br><span class="line">     * parentGroup放在父类AbstractBootstrap里边，即acceptor，childGroup放在当前类里边，即client</span><br><span class="line">     * EventLoopGroup的作用就是处理所有的ServerChannel和Channel的io事件。</span><br><span class="line">     */</span><br><span class="line">    public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup) &#123;</span><br><span class="line">        super.group(parentGroup);//调父类的构造器，将parentGroup放在父类</span><br><span class="line">        if (childGroup == null) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;childGroup&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.childGroup != null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;childGroup set already&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.childGroup = childGroup;//childGroup放在子类里边</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们切换到父类AbstractBootstrap：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//泛型B是AbstractBootstrap的子类类型，当前是ServerBootstrap，C是通道类型，当前是NioServerSocketChannel（后续会提到）</span><br><span class="line">public abstract class AbstractBootstrap&lt;B extends AbstractBootstrap&lt;B, C&gt;, C extends Channel&gt; implements Cloneable &#123;</span><br><span class="line">    ...略</span><br><span class="line">        private volatile ChannelFactory&lt;? extends C&gt; channelFactory;//Channel类型的C会被反射成实体，放在ChannelFactory</span><br><span class="line">        //里边，后边会说。</span><br><span class="line"> /**</span><br><span class="line">     * The &#123;@link EventLoopGroup&#125; which is used to handle all the events for the to-be-created</span><br><span class="line">     * &#123;@link Channel&#125;</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public B group(EventLoopGroup group) &#123;</span><br><span class="line">        if (group == null) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;group&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.group != null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;group set already&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.group = group;</span><br><span class="line">        return (B) this;//返回子类型ServerBootstrap。</span><br><span class="line">    &#125;</span><br><span class="line">        ...略</span><br></pre></td></tr></table></figure>
<p>接下来会调用serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class)，channel方法，channel位于父类AbstractBootstrap里边：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The &#123;@link Class&#125; which is used to create &#123;@link Channel&#125; instances from.</span><br><span class="line"> * You either use this or &#123;@link #channelFactory(io.netty.channel.ChannelFactory)&#125; if your</span><br><span class="line"> * &#123;@link Channel&#125; implementation has no no-args constructor.</span><br><span class="line"> * channelClass即我们的参数NioServerSocketChannel.class，new ReflectiveChannelFactory&lt;C&gt;(channelClass)使用反射生成了</span><br><span class="line"> * NioServerSocketChannel的实例（无参构造器），</span><br><span class="line"> */</span><br><span class="line">public B channel(Class&lt;? extends C&gt; channelClass) &#123;</span><br><span class="line">    if (channelClass == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;channelClass&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return channelFactory(new ReflectiveChannelFactory&lt;C&gt;(channelClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里用到了ReflectiveChannelFactory，这里牵扯了三个factory和他们之间的关系，如图：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%89-Netty%E6%9C%8D%E5%8A%A1%E7%AB%AFServerBootstrap%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%B0%84%E5%9C%A8%E5%85%B6%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E5%88%86%E6%9E%90/20170916110106930.png" alt="这里写图片描述"></p>
<p>这个图我们只要了解一下即可，接下来 return channelFactory(new ReflectiveChannelFactory<C>(channelClass));，进入channelFactory方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//入参：channelFactory类型io.netty.channel.ChannelFactory</span><br><span class="line">    public B channelFactory(io.netty.channel.ChannelFactory&lt;? extends C&gt; channelFactory) &#123;</span><br><span class="line">        return channelFactory((ChannelFactory&lt;C&gt;) channelFactory);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>继续走：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//入参：channelFactory类型io.netty.bootstrap.ChannelFactory</span><br><span class="line">    public B channelFactory(ChannelFactory&lt;? extends C&gt; channelFactory) &#123;</span><br><span class="line">        if (channelFactory == null) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;channelFactory&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.channelFactory != null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;channelFactory set already&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.channelFactory = channelFactory;</span><br><span class="line">         //即AbstractBootstrap的成员变量channelFactory被赋值，实际上是一个ReflectiveChannelFactory。</span><br><span class="line">         //private volatile ChannelFactory&lt;? extends C&gt; channelFactory;</span><br><span class="line"></span><br><span class="line">        return (B) this;//返回子类型ServerBootstrap 为了链式方法调用</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接下是serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).childHandler(new MyServerInitializer());，childHandler方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Set the &#123;@link ChannelHandler&#125; which is used to serve the request for the &#123;@link Channel&#125;&#x27;s.</span><br><span class="line"> * childHandler是为了服务客户端的request请求。</span><br><span class="line"> */</span><br><span class="line">public ServerBootstrap childHandler(ChannelHandler childHandler) &#123;</span><br><span class="line">    if (childHandler == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;childHandler&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.childHandler = childHandler;//只是简单的赋值</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到目前为止：<br>bossGroup 位于父类AbstractBootstrap，workerGroup位于ServerBootstrap ，NioServerSocketChannel位于AbstractBootstrap<br>ChannelHandler位于ServerBootstrap ，这写操作都是数据的准备，为了后边的启动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ChannelFuture channelFuture = serverBootstrap.bind(8899).sync();</span><br></pre></td></tr></table></figure>

<p>bind方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Create a new &#123;@link Channel&#125; and bind it.</span><br><span class="line"> * 创建一个新的channel绑定到ServerBootstrap 上</span><br><span class="line"> */</span><br><span class="line">public ChannelFuture bind(int inetPort) &#123;</span><br><span class="line">    return bind(new InetSocketAddress(inetPort));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法最终调用dobind：<br>这个方法是启动服务的比较重要的一个实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private ChannelFuture doBind(final SocketAddress localAddress) &#123;</span><br><span class="line">       final ChannelFuture regFuture = initAndRegister();</span><br><span class="line">       final Channel channel = regFuture.channel();</span><br><span class="line">       if (regFuture.cause() != null) &#123;</span><br><span class="line">           return regFuture;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (regFuture.isDone()) &#123;</span><br><span class="line">           // At this point we know that the registration was complete and successful.</span><br><span class="line">           ChannelPromise promise = channel.newPromise();</span><br><span class="line">           doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">           return promise;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           // Registration future is almost always fulfilled already, but just in case it&#x27;s not.</span><br><span class="line">           final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);</span><br><span class="line">           regFuture.addListener(new ChannelFutureListener() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">                   Throwable cause = future.cause();</span><br><span class="line">                   if (cause != null) &#123;</span><br><span class="line">                       // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span><br><span class="line">                       // IllegalStateException once we try to access the EventLoop of the Channel.</span><br><span class="line">                       promise.setFailure(cause);</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       // Registration was successful, so set the correct executor to use.</span><br><span class="line">                       // See https://github.com/netty/netty/issues/2586</span><br><span class="line">                       promise.registered();</span><br><span class="line"></span><br><span class="line">                       doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">           return promise;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>下一节我们从initAndRegister方法开始讲解。</p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>ServerBootstrap reflect机制</tag>
      </tags>
  </entry>
  <entry>
    <title>netty源码分析(九)Reactor模式与Netty组件对比及Acceptor组件的作用分析</title>
    <url>/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B9%9D-Reactor%E6%A8%A1%E5%BC%8F%E4%B8%8ENetty%E7%BB%84%E4%BB%B6%E5%AF%B9%E6%AF%94%E5%8F%8AAcceptor%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B9%9D-Reactor%E6%A8%A1%E5%BC%8F%E4%B8%8ENetty%E7%BB%84%E4%BB%B6%E5%AF%B9%E6%AF%94%E5%8F%8AAcceptor%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8%E5%88%86%E6%9E%90/20171021143958299.png" alt="这里写图片描述"><br>Reactor模式的角色构成（Reactor模式一共有5种角色构成 ）：</p>
<span id="more"></span>
<p>1、Handle（句柄或是描述符）：本质上表示一种资源，是由操作系统提供的；该资源表示一个个的事件，比如说文件描述符，活是 针对网络编程中的Socket描述符，事件既可以来自外部，也可以来自内部，外部事件比如说客户端的连接请求，客户端发送过来数据等；内部事件比如说操作系统产生的定时器任务事件等。它本质就是一个文件描述符。Handle是事件产生的发源地。<br>2、Synchronous Event Demultiplexer(同步事件分离器)：它本身是一个系统调用，用于等待事件的发生（事件可能是一个，也可能是多个）。调用方在调用它的时候会被阻塞，一直阻塞到同步事件分离器上有事件产生为止。对于Linux来说，同步事件分离器指的就是常用的I&#x2F;O多路复用机制，比如说select、poll、epoll等。在Java Nio领域中，同步事件分离器对应的组件就是selector；对应的阻塞方法就是select方法。<br>3、Event Handler（事件处理器）：本身由多个回调方法构成，这些回调方法构成了与 应用相关的对于某个事件的反馈机制。Netty 相比于NIO来说，在事件处理器这个角色上进行了一个升级，它为我们开发者提供了大量的回调方法，供我们在特定事件产生时实现相应的回调方法进行业务逻辑的处理。<br>4、Concrete Event Handler（具体事件处理器）：是事件处理器的实现。它本身实现了事件处理器所提供的各个回调方法，从而实现了特定业务的逻辑，它本质就是我们所编写的一个个的处理器实现。<br>5、Initiation Dispatcher（初始化分发器）：实际上就是Reactor角色，它本身定义了一些规范，这些规范用于控制事件的调度方式，同时又提供了应用进行事件处理器的注册，删除等设施。它本身是整个事件处理器的核心所在，Initiation  Dispatcher会通过 同步事件分离器来等待事件的发生，一旦事件发生，Initiation  Dispatcher首先会分离出每一个事件，然后调用事件处理器，最后调用相关的回调方法来处理这些事件。</p>
<p>这些组件是怎么串联在一起的呢？<br>首先Initiation Dispatcher（初始化分发器）启动的时候，会把所有相关的Event Handler（事件处理器，具体的是它的实现类Concrete Event Handler）注册到Initiation Dispatcher，当有相关事件发生的时候，就会根据事件的类型调用Event Handler的回调，Event Handler拥有Handle的引用，即事件处理器感兴趣的事件，注册完毕之后，Initiation Dispatcher会执行自己的内部循环，在循环内部会调用Synchronous Event Demultiplexer的select方法，当有外部请求过来的时候，select方法返回事件集合，之后Initiation Dispatcher遍历集合，拿到每一个事件，根据事件类型调用Event Handler 的.handle_event(type)方法，至此整个循环过程结束。</p>
<p>为了表述清楚。分为以下6个步骤：<br>当应用向Initiation Dispatcher注册具体的事件处理器时，应用会标示出该事件处理器希望Initiation Dispatcher在某个事件发生时向其通知的改事件，该事件与Handle关联。<br>2、Initiation Dispatcher会要求每个事件处理器向其传递内部的Handle。该Handle向操作系统标识了事件处理器。<br>3、当所有的事件处理器注册完毕后，应用会调用handle_events方法来启动Initiation Dispatcher的事件循环。这时，Initiation Dispatcher会将每个注册的事件管理器的Handle合并起来，并使用同步事件分离器等待事件的发生。比如说。TCP协议层会使用selecct同步事件分离器操作来等待客户端发送的数据到达连接的socket handle上。<br>4、当与某个事件源对应的Handle变为ready状态时（比如说，TCP socket变为等待状态时），同步事件分离器就会通知Initiation Dispatcher。<br>5、Initiation Dispatcher会触发事件处理器的回调方法，从而响应这个处于ready状态的Handle，当事件发生时，Initiation Dispatcher会将被事件源激活的Handle作为key来寻找并分发恰当的事件处理器回调。<br>6、Initiation Dispatcher回调事件处理器的handle_event回调方法来执行特定于应用的功能（开发者自己所编写的功能），从而响应这个事件。所发生的事件类型可以作为该方法参数并被该方法内部使用来执行额外的特定于服务的分离与分发。</p>
<p>下面我们结合netty的源码看一下这2张图：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B9%9D-Reactor%E6%A8%A1%E5%BC%8F%E4%B8%8ENetty%E7%BB%84%E4%BB%B6%E5%AF%B9%E6%AF%94%E5%8F%8AAcceptor%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8%E5%88%86%E6%9E%90/20171021154108934.png" alt="这里写图片描述"><br> Initiation Dispatcher对应右边图的mainReactor和subReactor，只是右边图把所谓的初始化分离器拆开，变成2个Reactor，中间用acceptor连接起来，右图，当我们服务端一个channel绑定一个端口的时候，就会生成一个Reactor，Reactor是连接netty的bossgroup和workgroup的桥梁，我们跟踪一下代码，我们从</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ChannelFuture channelFuture = serverBootstrap.bind(8899).sync();</span><br></pre></td></tr></table></figure>
<p>这行代码往下走，最后我们到达ServerBootstrap的init方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void init(Channel channel) throws Exception &#123;</span><br><span class="line">        final Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class="line">        synchronized (options) &#123;</span><br><span class="line">            setChannelOptions(channel, options, logger);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class="line">        synchronized (attrs) &#123;</span><br><span class="line">            for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</span><br><span class="line">                channel.attr(key).set(e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ChannelPipeline p = channel.pipeline();</span><br><span class="line"></span><br><span class="line">        final EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">        final ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">        final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">        final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</span><br><span class="line">        synchronized (childOptions) &#123;</span><br><span class="line">            currentChildOptions = childOptions.entrySet().toArray(newOptionArray(childOptions.size()));</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (childAttrs) &#123;</span><br><span class="line">            currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(childAttrs.size()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void initChannel(final Channel ch) throws Exception &#123;</span><br><span class="line">                final ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                ChannelHandler handler = config.handler();</span><br><span class="line">                if (handler != null) &#123;</span><br><span class="line">                    pipeline.addLast(handler);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ch.eventLoop().execute(new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                    //重点：此处在服务启动的时候netty给我们new了一个ServerBootstrapAcceptor</span><br><span class="line">                        pipeline.addLast(new ServerBootstrapAcceptor(</span><br><span class="line">                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们进入ServerBootstrapAcceptor看看是怎么将bossgroup和workgroup连接在一起的：<br>主要的方法是channelRead</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</span><br><span class="line">    final Channel child = (Channel) msg;</span><br><span class="line"></span><br><span class="line">    child.pipeline().addLast(childHandler);</span><br><span class="line"></span><br><span class="line">    setChannelOptions(child, childOptions, logger);</span><br><span class="line"></span><br><span class="line">    for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</span><br><span class="line">        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">    //childGroup的定义:  private final EventLoopGroup childGroup;</span><br><span class="line">    //把bossgroup接受接收的信息的通道通过Accptor注册到workgroup，即childGroup。</span><br><span class="line">        childGroup.register(child).addListener(new ChannelFutureListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">                if (!future.isSuccess()) &#123;</span><br><span class="line">                    forceClose(child, future.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        forceClose(child, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>Reactor模式 Acceptor组件</tag>
      </tags>
  </entry>
  <entry>
    <title>netty源码分析(二)Netty对Executor的实现机制源码分析</title>
    <url>/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C-Netty%E5%AF%B9Executor%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>上一节说到NioEventLoopGroup 的初始化，到了他的父类MultithreadEventExecutorGroup的构造器：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    protected MultithreadEventExecutorGroup(int nThreads, Executor executor,</span><br><span class="line">                                            EventExecutorChooserFactory chooserFactory, Object... args) &#123;</span><br><span class="line">...略</span><br><span class="line">        if (executor == null) &#123;</span><br><span class="line">            executor = new ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">        &#125;</span><br><span class="line">...略</span><br></pre></td></tr></table></figure>
<p>MultithreadEventExecutorGroup.newDefaultThreadFactory():</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected ThreadFactory newDefaultThreadFactory() &#123;</span><br><span class="line">    return new DefaultThreadFactory(getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DefaultThreadFactory默认线程工厂类，继承了ThreadFactory<br>next(DefaultThreadFactory类):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public DefaultThreadFactory(Class&lt;?&gt; poolType) &#123;</span><br><span class="line">    this(poolType, false, Thread.NORM_PRIORITY);//参数poolType为newDefaultThreadFactory的class，false表示线程不是后台线</span><br><span class="line">    //程，Thread.NORM_PRIORITY，是正常的线程的优先级(三个优先级：MIN_PRIORITY = 1;NORM_PRIORITY = 5;MAX_PRIORITY = 10;)。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>next:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public DefaultThreadFactory(Class&lt;?&gt; poolType, boolean daemon, int priority) &#123;</span><br><span class="line">    this(toPoolName(poolType), daemon, priority);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>toPoolName(poolType)的功能：比如我们给定当前newDefaultThreadFactory的poolType为io.netty.util.concurrent.newDefaultThreadFactory,那么经过toPoolName（）方法返回为newDefaultThreadFactory。<br>next：<br>加入了线程组参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public DefaultThreadFactory(String poolName, boolean daemon, int priority) &#123;</span><br><span class="line">    this(poolName, daemon, priority, System.getSecurityManager() == null ?</span><br><span class="line">            Thread.currentThread().getThreadGroup() : System.getSecurityManager().getThreadGroup());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着走：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public DefaultThreadFactory(String poolName, boolean daemon, int priority, ThreadGroup threadGroup) &#123;</span><br><span class="line">    if (poolName == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;poolName&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (priority &lt; Thread.MIN_PRIORITY || priority &gt; Thread.MAX_PRIORITY) &#123;</span><br><span class="line">        throw new IllegalArgumentException(</span><br><span class="line">                &quot;priority: &quot; + priority + &quot; (expected: Thread.MIN_PRIORITY &lt;= priority &lt;= Thread.MAX_PRIORITY)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prefix = poolName + &#x27;-&#x27; + poolId.incrementAndGet() + &#x27;-&#x27;;</span><br><span class="line">    //poolId:private static final AtomicInteger poolId = new AtomicInteger();保证线程安全。</span><br><span class="line">    this.daemon = daemon;//是否后台线程</span><br><span class="line">    this.priority = priority;//优先级</span><br><span class="line">    this.threadGroup = threadGroup;//线程组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到现在只是指定了线程的一些属性的设置，返回到MultithreadEventExecutorGroup：<br> executor &#x3D; new ThreadPerTaskExecutor(newDefaultThreadFactory());</p>
<p>newDefaultThreadFactory继承了ThreadFactory:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将一个Runnable 做成一个Thread ，并且可以指定线程的name、daemon status ThreadGroup</span><br><span class="line">public interface ThreadFactory &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Constructs a new &#123;@code Thread&#125;.  Implementations may also initialize</span><br><span class="line">     * priority, name, daemon status, &#123;@code ThreadGroup&#125;, etc.</span><br><span class="line">     *</span><br><span class="line">     * @param r a runnable to be executed by new thread instance</span><br><span class="line">     * @return constructed thread, or &#123;@code null&#125; if the request to</span><br><span class="line">     *         create a thread is rejected</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    Thread newThread(Runnable r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们创建完DefaultThreadFactory之后给了ThreadPerTaskExecutor:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ThreadPerTaskExecutor 使用了命令模式，execute执行的是命令。ThreadPerTaskExecutor的构造方法只是把DefaultThreadFactory传递进来。public final class ThreadPerTaskExecutor implements Executor &#123;</span><br><span class="line">    private final ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line">    public ThreadPerTaskExecutor(ThreadFactory threadFactory) &#123;</span><br><span class="line">        if (threadFactory == null) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;threadFactory&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.threadFactory = threadFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute(Runnable command) &#123;</span><br><span class="line">        threadFactory.newThread(command).start();//ThreadFactory 执行命令，稍后我们到DefaultThreadFactory里边看看newThread</span><br><span class="line">        //方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DefaultThreadFactory的newThread：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Thread newThread(Runnable r) &#123;</span><br><span class="line">    Thread t = newThread(new DefaultRunnableDecorator(r), prefix + nextId.incrementAndGet());</span><br><span class="line">    //将参数r包装为一个DefaultRunnableDecorator(实现了Runnable)</span><br><span class="line">    try &#123;</span><br><span class="line">        if (t.isDaemon() != daemon) &#123;</span><br><span class="line">            t.setDaemon(daemon);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (t.getPriority() != priority) &#123;</span><br><span class="line">            t.setPriority(priority);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception ignored) &#123;</span><br><span class="line">        // Doesn&#x27;t matter even if failed to set.</span><br><span class="line">    &#125;</span><br><span class="line">    return t;//返回Thread</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切到DefaultRunnableDecorator:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static final class DefaultRunnableDecorator implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private final Runnable r;</span><br><span class="line"></span><br><span class="line">    DefaultRunnableDecorator(Runnable r) &#123;</span><br><span class="line">        this.r = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            r.run();//注意！！！！直接调用的命令的run方法，并没有创建线程，也就是说</span><br><span class="line">            //threadFactory.newThread(command).start()只有一个线程。</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            FastThreadLocal.removeAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种调用方式和jdk内置的Executor（ThreadPerTaskExecutor implements Executor）如出一撤,DefaultRunnableDecorator 的run（通过Thread的start调用）直接调用了Runnable 的run方法，我们去看一些Executor的文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * An object that executes submitted &#123;@link Runnable&#125; tasks. This</span><br><span class="line"> * interface provides a way of decoupling task submission from the</span><br><span class="line"> * mechanics of how each task will be run, including details of thread</span><br><span class="line"> * use, scheduling, etc.  An &#123;@code Executor&#125; is normally used</span><br><span class="line"> * instead of explicitly creating threads. For example, rather than</span><br><span class="line"> * invoking &#123;@code new Thread(new(RunnableTask())).start()&#125; for each</span><br><span class="line"> * of a set of tasks, you might use:</span><br><span class="line"> *大体意思是将任务（线程）的提交和线程的细节解耦，例如new Thread(new(RunnableTask())).start()这种方式被得到替换。</span><br><span class="line"> * &lt;pre&gt;使用方式</span><br><span class="line"> * Executor executor = &lt;em&gt;anExecutor&lt;/em&gt;;</span><br><span class="line"> * executor.execute(new RunnableTask1());</span><br><span class="line"> * executor.execute(new RunnableTask2());</span><br><span class="line"> * ...</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line"> *</span><br><span class="line"> * However, the &#123;@code Executor&#125; interface does not strictly</span><br><span class="line"> * require that execution be asynchronous. In the simplest case, an</span><br><span class="line"> * executor can run the submitted task immediately in the caller&#x27;s</span><br><span class="line"> * thread:</span><br><span class="line"> *当然Executor不会严格的要求执行是异步的，因为在有些情况会被调用线程直接执行任务的run方法。</span><br><span class="line"> *  &lt;pre&gt; &#123;@code</span><br><span class="line"> * class DirectExecutor implements Executor &#123;</span><br><span class="line"> *   public void execute(Runnable r) &#123;</span><br><span class="line"> *     r.run();</span><br><span class="line"> *   &#125;</span><br><span class="line"> * &#125;&#125;&lt;/pre&gt;</span><br><span class="line"> *</span><br><span class="line"> * More typically, tasks are executed in some thread other</span><br><span class="line"> * than the caller&#x27;s thread.  The executor below spawns a new thread</span><br><span class="line"> * for each task.</span><br><span class="line"> *典型的方式是将任务依附在Thread上执行，是一个线程。</span><br><span class="line"> *  &lt;pre&gt; &#123;@code</span><br><span class="line"> * class ThreadPerTaskExecutor implements Executor &#123;</span><br><span class="line"> *   public void execute(Runnable r) &#123;</span><br><span class="line"> *     new Thread(r).start();</span><br><span class="line"> *   &#125;</span><br><span class="line"> * &#125;&#125;&lt;/pre&gt;</span><br><span class="line"> *</span><br><span class="line"> * Many &#123;@code Executor&#125; implementations impose some sort of</span><br><span class="line"> * limitation on how and when tasks are scheduled.  The executor below</span><br><span class="line"> * serializes the submission of tasks to a second executor,</span><br><span class="line"> * illustrating a composite executor.</span><br><span class="line"> *有的时候任务会被串行的被多个tasks  执行，A-&gt;B-&gt;C-&gt;D，是一个流水的过程。</span><br><span class="line"> *  &lt;pre&gt; &#123;@code</span><br><span class="line"> * class SerialExecutor implements Executor &#123;</span><br><span class="line"> *   final Queue&lt;Runnable&gt; tasks = new ArrayDeque&lt;Runnable&gt;();</span><br><span class="line"> *   final Executor executor;</span><br><span class="line"> *   Runnable active;</span><br><span class="line"> *</span><br><span class="line"> *   SerialExecutor(Executor executor) &#123;</span><br><span class="line"> *     this.executor = executor;</span><br><span class="line"> *   &#125;</span><br><span class="line"> *</span><br><span class="line"> *   public synchronized void execute(final Runnable r) &#123;</span><br><span class="line"> *     tasks.offer(new Runnable() &#123;</span><br><span class="line"> *       public void run() &#123;</span><br><span class="line"> *         try &#123;</span><br><span class="line"> *           r.run();</span><br><span class="line"> *         &#125; finally &#123;</span><br><span class="line"> *           scheduleNext();//转到下一个task执行。</span><br><span class="line"> *         &#125;</span><br><span class="line"> *       &#125;</span><br><span class="line"> *     &#125;);</span><br><span class="line"> *     if (active == null) &#123;</span><br><span class="line"> *       scheduleNext();</span><br><span class="line"> *     &#125;</span><br><span class="line"> *   &#125;</span><br><span class="line"> *</span><br><span class="line"> *   protected synchronized void scheduleNext() &#123;</span><br><span class="line"> *     if ((active = tasks.poll()) != null) &#123;</span><br><span class="line"> *       executor.execute(active);</span><br><span class="line"> *     &#125;</span><br><span class="line"> *   &#125;</span><br><span class="line"> * &#125;&#125;&lt;/pre&gt;</span><br><span class="line"> *</span><br><span class="line"> * The &#123;@code Executor&#125; implementations provided in this package</span><br><span class="line"> * implement &#123;@link ExecutorService&#125;, which is a more extensive</span><br><span class="line"> * interface.  The &#123;@link ThreadPoolExecutor&#125; class provides an</span><br><span class="line"> * extensible thread pool implementation. The &#123;@link Executors&#125; class</span><br><span class="line"> * provides convenient factory methods for these Executors.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Memory consistency effects: Actions in a thread prior to</span><br><span class="line"> * submitting a &#123;@code Runnable&#125; object to an &#123;@code Executor&#125;</span><br><span class="line"> * &lt;a href=&quot;package-summary.html#MemoryVisibility&quot;&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;</span><br><span class="line"> * its execution begins, perhaps in another thread.</span><br><span class="line"> *</span><br><span class="line"> * @since 1.5</span><br><span class="line"> * @author Doug Lea</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>Executor 实现机制</tag>
      </tags>
  </entry>
  <entry>
    <title>netty源码分析(二十)NIO堆外内存与零拷贝深入讲解</title>
    <url>/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C%E5%8D%81-NIO%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<p><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C%E5%8D%81-NIO%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3/20171118184319019.png" alt="这里写图片描述"></p>
<span id="more"></span>

<p>ByteBuffer byteBuffer &#x3D; ByteBuffer.allocateDirect(512);<br>直接内存：返回DirectByteBuffer对象，DirectByteBuffer的父类是MappedByteBuffer ，MappedByteBuffer 的父类是ByteBuffer ， 在ByteBuffer的上边是Buffer，在<br>          Buffer里边有一个address 他的声明和注释如下：<br>                &#x2F;&#x2F; Used only by direct buffers<br>                &#x2F;&#x2F; NOTE: hoisted here for speed in JNI GetDirectBufferAddress<br>                long address;<br>                address是专门为DirectByteBuffer使用的，存储是堆外内存的地址。在 DirectByteBuffer 的构造器里边，会对 address 进行赋值。<br> DirectByteBuffer使用的是直接的对外内存，去除了使用HeapByteBuffer方式的内存拷贝，因此有另外一个说法叫“零拷贝”，address对应的内存区域在os的内存空间，这块内存直接与io设备进行交互，当jvm对DirectByteBuffer内存垃圾回收的时候，会通过address调os，os将address对应的区域回收。</p>
<p>ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(512);<br>堆内存：返回 HeapByteBuffer<br>           HeapByteBuffer是在jvm的内存范围之内，然后在调io的操作时会将数据区域拷贝一份到os的内存区域，这样造成了不必要的性能上的降低，这样做是有原因的，试想假设如果os和jvm都是用jvm里边的数据区域， 但是jvm会对这块内存区域进行GC回收，可能会对这块内存的数据进行更改，根据我们的假设，由于这块区域os也在使用，jvm对这块共享数据发生了变更，os那边就会出现数据错乱的情况。那么如果不让jvm对这块共享区域进行GC是不是可以避免这个问题呢？答案是不行的，也会存在问题，如果jvm不对其进行GC回收，jvm这边可能会出现OOM的内存溢出。因此，最后这个地方非常尴尬，只能拷贝jvm的那一份到os的内存空间，即使jvm那边的数据区域被改变，但是os里边的不会受到影响，等os使用io结束后会对这块区域进行回收，因为这是os的管理范围之内。</p>
<p> 如果你想了解更详细的说明请看知乎的一个回答：<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzU3Mzc0MDY4">https://www.zhihu.com/question/57374068<i class="fa fa-external-link-alt"></i></span><br> RednaxelaFX是一个大牛，在社区中参与到jvm的很多工作。</p>
<p>再说一下NIO的零拷贝，如图：<br><strong>case1非零拷贝(传统的方式)：</strong><br>传统方式的NIO存在数据拷贝问题，实例代码：<br>客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OldClient &#123;</span><br><span class="line">    public static void main(String[] args) throws  Exception &#123;</span><br><span class="line">        Socket socket = new Socket(&quot;localhost&quot;,8899);</span><br><span class="line">        InputStream inputStream = new FileInputStream(&quot;niofiles/spark-2.2.0-bin-hadoop2.7.tgz&quot;);</span><br><span class="line">        DataOutputStream dataOutputStream = new DataOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        int totalSend = 0;</span><br><span class="line">        int readCount = 0;</span><br><span class="line">        byte[] buff =new byte[4096];</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        while((readCount=inputStream.read(buff))&gt;=0)&#123;</span><br><span class="line">            totalSend+=readCount;</span><br><span class="line">            dataOutputStream.write(buff);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;send bytes :&quot;+totalSend+&quot;,timecost:&quot;+(System.currentTimeMillis()-startTime));</span><br><span class="line">        dataOutputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OldServer  &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)  throws  Exception&#123;</span><br><span class="line">        ServerSocket serverSocket = new ServerSocket(8899);</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            Socket socket  = serverSocket.accept();</span><br><span class="line">            DataInputStream dataInputStream = new DataInputStream(socket.getInputStream());</span><br><span class="line">            byte[] buff = new byte[4096];</span><br><span class="line"></span><br><span class="line">            while(true)&#123;</span><br><span class="line">                int readcount = dataInputStream.read(buff,0,buff.length);</span><br><span class="line"></span><br><span class="line">                if(-1==readcount)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图示：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C%E5%8D%81-NIO%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3/20171118214504920.png" alt="这里写图片描述"><br>注意第一次数据拷贝是必须的。<br><strong>case2零拷贝：</strong><br>新的IO即NIO是零拷贝的方式：<br>实例代码：<br>客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class NewClient &#123;</span><br><span class="line">    public static void main(String[] args)  throws  Exception&#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;,8899));</span><br><span class="line">        socketChannel.configureBlocking(true);</span><br><span class="line">        String name = &quot;niofiles/spark-2.2.0-bin-hadoop2.7.tgz&quot;;</span><br><span class="line">        FileChannel fileChannel = new FileInputStream(name).getChannel();</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        //零拷贝关键代码</span><br><span class="line">        /**</span><br><span class="line">         * This method is potentially much more efficient than a simple loop</span><br><span class="line">         * that reads from this channel and writes to the target channel.  Many</span><br><span class="line">         * operating systems can transfer bytes directly from the filesystem cache</span><br><span class="line">         * to the target channel without actually copying them.</span><br><span class="line">         */</span><br><span class="line">       long  transCount =  fileChannel.transferTo(0,fileChannel.size(),socketChannel);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;发送字节数:&quot;+transCount+&quot;,耗时：&quot;+(System.currentTimeMillis()-start));</span><br><span class="line">        fileChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class NewServer &#123;</span><br><span class="line">    public static void main(String[] args) throws  Exception &#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        ServerSocket serverSocket =  serverSocketChannel.socket();</span><br><span class="line">        serverSocket.bind(new InetSocketAddress(8899));</span><br><span class="line">        serverSocket.setReuseAddress(true);</span><br><span class="line"></span><br><span class="line">        ByteBuffer byteBuffer =  ByteBuffer.allocate(4096);</span><br><span class="line"></span><br><span class="line">        while(true)&#123;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                SocketChannel socketChannel =  serverSocketChannel.accept();</span><br><span class="line">                socketChannel.configureBlocking(true);</span><br><span class="line"></span><br><span class="line">                int readcount = 0;</span><br><span class="line">                while(-1!=readcount)&#123;</span><br><span class="line">                    readcount = socketChannel.read(byteBuffer);</span><br><span class="line">                    byteBuffer.rewind();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图示：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C%E5%8D%81-NIO%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3/20171118215619952.png" alt="这里写图片描述"><br>数据首先通过DMA从硬件设备（硬盘）读取到内核空间，然后将内核空间数据copy对接到socket buffer，socket buffer是一个缓冲区，之后socket buffer数据拷贝到协议引擎写到服务器端。这里减去了传统io在内核和用户之间的拷贝，但是内核里边的拷贝还是存在。<br>到时到了Linux2.4又有了改善：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C%E5%8D%81-NIO%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3/20171118225322248.png" alt="这里写图片描述"></p>
<p>再看最后一个图，Linux2.4以后的版本：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C%E5%8D%81-NIO%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3/20171118230603907.png" alt="这里写图片描述"><br>socket buffer 在这里不是一个缓冲区了，而是一个文件描述符，描述的是数据在kernel buffer的数据从哪里开始，长度是多少，里边基本上不存储数据大部分是指针，然后协议引擎protocol engine也是通过DMA 拷贝的方式从文件描述符socket buffer读取。<br>首先首先从硬件设备读取数据到kernel buffer，kernel buffer可能是多个字节数组，然后socket buffer 通过gatter的方式直接从kernel buffer映射（从哪个位置，读取多少长度，即gatter操作）数据，最后协议引擎protocol engine通过socket buffer的映射读到kernel buffer数据，再也没有数据拷贝的问题。</p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>nio 堆外内存 零拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>netty源码分析(二十一)Netty数据容器ByteBuf底层数据结构深度剖析与ReferenceCounted初探</title>
    <url>/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C%E5%8D%81%E4%B8%80-Netty%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8ByteBuf%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%8EReferenceCounted%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<p><strong>ByteBuf</strong><br>ByteBuf是Netty提供的代替jdk的ByteBuffer的一个容器，首先看一下他的具体用法：</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ByteBufTest0 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ByteBuf byteBuf = Unpooled.buffer(10);//堆缓冲区</span><br><span class="line">        for(int i=0;i&lt;byteBuf.capacity();i++)&#123;</span><br><span class="line">            byteBuf.writeByte(i);</span><br><span class="line">        &#125;</span><br><span class="line">//绝对方式  不会改变readerIndex</span><br><span class="line">        for(int i=0;i&lt;byteBuf.capacity();i++)&#123;</span><br><span class="line">            System.out.println(byteBuf.getByte(i));</span><br><span class="line">        &#125;</span><br><span class="line">//相对方式 会改变writerIndex</span><br><span class="line">        for(int i=0;i&lt;byteBuf.capacity();i++)&#123;</span><br><span class="line">            System.out.println(byteBuf.readByte());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Netty ByteBuf内部有几个游标：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /*      +-------------------+------------------+------------------+</span><br><span class="line">         *      | discardable bytes |  readable bytes  |  writable bytes  |</span><br><span class="line">         *      |                   |     (CONTENT)    |                  |</span><br><span class="line">         *      +-------------------+------------------+------------------+</span><br><span class="line">         *      |                   |                  |                  |</span><br><span class="line">         *      0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=    capacity</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>readerIndex   控制读的游标，writerIndex    控制写的游标，capacity是容量。</p>
<p>再看一下例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ByteBufTest1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * ByteBuf有2种维度，一种是堆内还是堆外</span><br><span class="line">         * 另一种是池化还是非池化</span><br><span class="line">         */</span><br><span class="line">        //utf-8字符编码，一个汉字占3个字节</span><br><span class="line">        ByteBuf byteBuf = Unpooled.copiedBuffer(&quot;张hello world&quot;, Charset.forName(&quot;utf-8&quot;));</span><br><span class="line"></span><br><span class="line">        //如果是在堆上的返回true</span><br><span class="line">        if(byteBuf.hasArray())&#123;</span><br><span class="line">            //ByteBuf内部的堆数组</span><br><span class="line">            byte[] cotent =  byteBuf.array();</span><br><span class="line">            System.out.println(new String(cotent,Charset.forName(&quot;utf-8&quot;)));</span><br><span class="line"></span><br><span class="line">            //ByteBuf实际实现类的类型</span><br><span class="line">            System.out.println(byteBuf);</span><br><span class="line">            System.out.println(byteBuf.arrayOffset());</span><br><span class="line">            System.out.println(byteBuf.readerIndex());</span><br><span class="line">            System.out.println(byteBuf.writerIndex());</span><br><span class="line">            System.out.println(byteBuf.capacity());</span><br><span class="line"></span><br><span class="line">            int length  = byteBuf.readableBytes();</span><br><span class="line">            for (int i=0;i&lt;length;i++)&#123;</span><br><span class="line">                System.out.println((char)byteBuf.getByte(i));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(byteBuf.getCharSequence(0,4,Charset.forName(&quot;utf-8&quot;)));</span><br><span class="line">            //输出&quot;张h&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Netty ByteBuf所提供的三种缓冲区类型：<br>1、heap buffer。<br>2、direct buffer。<br>3、composite buffer。</p>
<p>Heap Buffer（堆缓冲区）<br>这是最常用的类型，ByteBuf将数据存储到JVM的堆空间中，并且将实际的数据存放到byte array中来实现。<br>优点：由于数据是存储在JVM的堆中，因此可以快速的创建于快速的释放，并且它提供了直接访问内部字节数组的方法。</p>
<p>缺点：每次读写数据时，都需要先将数据复制到直接缓冲区中再进行网络传输。</p>
<p>Direct Buffer（直接缓冲区）</p>
<p>在堆之外直接分配内存空间，直接缓冲区并不会占用堆的容量空间，因为它是由操作系统在本地内存进行的数据分配。</p>
<p>优点：在使用Socket进行数据传递时，性能非常好，因为数据直接位于操作系统的本地内存中，所以不需要从JVM将数据复制到直接缓冲区，性能很好。<br>缺点：因为Direct Buffer是直接在操作系统内存中的，所以内存的分配与释放要比堆空间更加复杂，而且速度要慢一些。</p>
<p>Netty通过提供内存池来解决这个问题，直接缓冲区并不支持通过字节数组的方式来访问数据。<br>重点：对于后端的业务消息的编解码来说，推荐使用HeapByteBuf；对于I&#x2F;O通信线程在读写缓冲区时，推荐使用DirectByteBuf。</p>
<p>CompositeByteBuf：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ByteBufTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CompositeByteBuf compositeByteBuf = Unpooled.compositeBuffer();</span><br><span class="line">        ByteBuf heapBuf = Unpooled.buffer(10);</span><br><span class="line">        ByteBuf directBuf = Unpooled.directBuffer(8);</span><br><span class="line">        compositeByteBuf.addComponents(heapBuf,directBuf);</span><br><span class="line">       // compositeByteBuf.removeComponent(0);</span><br><span class="line">        Iterator iterator = compositeByteBuf.iterator();</span><br><span class="line">        while(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        compositeByteBuf.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Composite Buffer(符合缓冲区)</p>
<p>JDK的ByteBuffer和Netty的ByteBuf之间的差异对比：<br>1、Netty的ByteBuf采用读写索引分离的策略（readerIndex与writerIndex），一个初始化（里面尚未有任何数据）的ByteBuf的readerIndex与writerIndex值都为0.<br>2、当读索引与写索引处于同一个位置时，如果我们继续读取，那么就会抛出IndexOutOfBoundException。<br>3、对于ByteBuf的任何读写操作都会分别单独维护读索引与写索引，maxCapacity最大 容量默认的限制就是Integer.MAX_VALUE</p>
<p>JDK的ByteBuffer的缺点：<br>1、final byte[] bb 这是JDK的ByteBuffer对象中用于存储数据的对象声明，可以看到，其字节数组是被声明为final的，也就是长度是固定不变的，一旦分配好后不能动态扩容与收缩，<br>而且当待存储的数据字节很大时就很有可能出现那么就会抛出IndexOutOfBoundException，如果要预防这个异常，那就需要在存储事前完全确定好待存储的字节大小。如果ByteBuffer的空间不足，我们只有一种解决方案：<br>创建一个全新的ByteBuffer对象，然后再将之前的ByteBuffer中的数据复制过去，这一切都需要开发者自己来手动完成。<br>2、ByteBuffer只是用一个position指针来标示位置信息，在进行读写切换时就需要调用flip方法或是rewind方法，使用起来很不方便。</p>
<p>Netty的ByteBuf的优点：<br>1、存储字节的数组是动态的，其最大值默认是Integer.MAX_VALUE，这里的动态性是体现在write方法中的，write方法在执行时会判断buffer容量，如果不足则自动扩容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final void ensureWritable0(int minWritableBytes) &#123;</span><br><span class="line">    ensureAccessible();</span><br><span class="line">    if (minWritableBytes &lt;= writableBytes()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (minWritableBytes &gt; maxCapacity - writerIndex) &#123;</span><br><span class="line">        throw new IndexOutOfBoundsException(String.format(</span><br><span class="line">                &quot;writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s&quot;,</span><br><span class="line">                writerIndex, minWritableBytes, maxCapacity, this));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Normalize the current capacity to the power of 2.</span><br><span class="line">    int newCapacity = alloc().calculateNewCapacity(writerIndex + minWritableBytes, maxCapacity);//计算新的容量</span><br><span class="line"></span><br><span class="line">    // Adjust to the new capacity.</span><br><span class="line">    capacity(newCapacity);//自动调节容量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、ByteBuf的读写索引是完全分开的，使用起来很方便。</p>
<p><strong>ReferenceCounted</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A reference-counted object that requires explicit deallocation.</span><br><span class="line"> * 引用计数回收对象</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * When a new &#123;@link ReferenceCounted&#125; is instantiated, it starts with the reference count of &#123;@code 1&#125;.</span><br><span class="line"> * &#123;@link #retain()&#125; increases the reference count, and &#123;@link #release()&#125; decreases the reference count.</span><br><span class="line"> * If the reference count is decreased to &#123;@code 0&#125;, the object will be deallocated explicitly, and accessing</span><br><span class="line"> * the deallocated object will usually result in an access violation.</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> * 当一个ReferenceCounted创建的时候他的初始引用数量是1，retain方法增加一个引用数量，release方法减少一个引用数量，如果引用数量是</span><br><span class="line"> * 变成0，那么对象就会被死亡回收，加入引用一个已经被定义为死亡的对象的结果通常是会出现问题的。</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * If an object that implements &#123;@link ReferenceCounted&#125; is a container of other objects that implement</span><br><span class="line"> * &#123;@link ReferenceCounted&#125;, the contained objects will also be released via &#123;@link #release()&#125; when the container&#x27;s</span><br><span class="line"> * reference count becomes 0.</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> * 如果一个实现了ReferenceCounted接口的这个对象作为一个容器，他的内部的对象也是实现了ReferenceCounted接口，那么当外边的容器的</span><br><span class="line"> * count引用数量变为0的时候，容器内部的对象也会别回收。</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>引用加1的逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ByteBuf retain(int increment) &#123;</span><br><span class="line">    return retain0(checkPositive(increment, &quot;increment&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private ByteBuf retain0(int increment) &#123;</span><br><span class="line">    for (;;) &#123;//回旋锁</span><br><span class="line">        int refCnt = this.refCnt;</span><br><span class="line">        final int nextCnt = refCnt + increment;</span><br><span class="line"></span><br><span class="line">        // Ensure we not resurrect (which means the refCnt was 0) and also that we encountered an overflow.</span><br><span class="line">        //如果refCnt 是0那么就会出现nextCnt = increment的情况，但是这样违背了netty的回收计数器的原则，程序就可以往下走，这是</span><br><span class="line">        //不合法的，当为0的时候正常的情况是要被回收的。</span><br><span class="line">        if (nextCnt &lt;= increment) &#123;</span><br><span class="line">            throw new IllegalReferenceCountException(refCnt, increment);</span><br><span class="line">        &#125;</span><br><span class="line">        //    private static final AtomicIntegerFieldUpdater&lt;AbstractReferenceCountedByteBuf&gt; refCntUpdater =</span><br><span class="line">       //     AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCountedByteBuf.class, &quot;refCnt&quot;);</span><br><span class="line">       //首先使用的是AtomicIntegerFieldUpdater进行的cas操作（基于硬件的更新实现），其次refCnt是</span><br><span class="line">       //    private volatile int refCnt = 1;即是volatile 类型的，在多线程的情况下保证相互之间的可见性。</span><br><span class="line">        if (refCntUpdater.compareAndSet(this, refCnt, nextCnt)) &#123;//cas操作增加引用计数</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处用了回旋锁+cas保证操作的原子性。<br>AtomicIntegerFieldUpdater使用反射 更新某个类的内部的一个int类型的并且是volatitle的变量。<br>这里提一下AtomicIntegerFieldUpdater：<br>1、更新器更新的必须int类型的变量	，不能是其包装类型。<br>2、更新器更新的必须是volatitle类型变量，确保线程之间共享变量时的立即可见性。<br>AtomicIntegerFieldUpdater.newUpdater()方法的实现是AtomicIntegerFieldUpdaterImpl:<br>AtomicIntegerFieldUpdaterImpl的构造器会对类型进行验证：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">if (field.getType() != int.class)</span><br><span class="line">    throw new IllegalArgumentException(&quot;Must be integer type&quot;);</span><br><span class="line"></span><br><span class="line">if (!Modifier.isVolatile(modifiers))</span><br><span class="line">    throw new IllegalArgumentException(&quot;Must be volatile type&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由此验证我们说的第一和第二条原则。<br>3、变量不能是static的，必须是实例变量，因为Unsafe.objectFieldOffset()方法不支持静态变量(cas操作本质上是通过对象实例的偏移量来直接进行赋值)<br>4、更新器只能修改可见范围内的变量，因为更新器是通过反射来得到这个变量，如果变量不可见就会报错。<br>实际验证：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	public class AtomicUpdatorTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person person = new Person();</span><br><span class="line"> /*       for(int i=0;i&lt;10;++i)&#123;</span><br><span class="line">            Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(20);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println( person.age++);</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">            //会有严重的问题，会出现多次打印1之类的问题。。这个时候是AtommicIntegerUpdator登场的时候了</span><br><span class="line">        &#125;*/</span><br><span class="line"></span><br><span class="line">//原子方式更新</span><br><span class="line">        AtomicIntegerFieldUpdater&lt;Person&gt; atomicIntegerFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Person.class,&quot;age&quot;);</span><br><span class="line">        for(int i=0;i&lt;10;++i)&#123;</span><br><span class="line">            Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(20);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println( atomicIntegerFieldUpdater.getAndIncrement(person));</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">   volatile int age = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>volatile变量自身具有下列特性。<br>·可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写<br>入。<br>·原子性：对任意单个volatile变量的读&#x2F;写具有原子性，但类似于volatile++这种复合操作不<br>具有原子性。</p>
<p>对volatile写和volatile读的内存语义：<br>·线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程<br>发出了（其对共享变量所做修改的）消息。<br>·线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile<br>变量之前对共享变量所做修改的）消息。<br>·线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过<br>主内存向线程B发送消息。</p>
<p>关于<span class="exturl" data-url="aHR0cDovL25ldHR5LmlvL3dpa2kvcmVmZXJlbmNlLWNvdW50ZWQtb2JqZWN0cy5odG1s">引用计数器可以参考netty的官方文档<i class="fa fa-external-link-alt"></i></span>的介绍。</p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>ByteBuf ReferenceCounted</tag>
      </tags>
  </entry>
  <entry>
    <title>netty源码分析(二十三)ReplayingDecoder源码分析与特性解读以及其他编解码器介绍</title>
    <url>/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C%E5%8D%81%E4%B8%89-ReplayingDecoder%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>在介绍ReplayingDecoder之前 想看一下它的用法，构建一个服务端和客户端的模型：<br>服务端：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyServer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        EventLoopGroup bossGroup = new NioEventLoopGroup(1);</span><br><span class="line">        EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line">        try&#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = new ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(new MyServerInitializer());</span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(8899).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端initializer：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">        ChannelPipeline pipline = ch.pipeline();</span><br><span class="line">        pipline.addLast(new MyReplayingDecoder());//使用ReplayingDecoder</span><br><span class="line">        pipline.addLast(new MyLongToByteEncoder());</span><br><span class="line">        pipline.addLast(new MyServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ServerHandler:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyServerHandler extends SimpleChannelInboundHandler&lt;Long&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, Long msg) throws Exception &#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress()+&quot; --&gt; &quot;+msg);</span><br><span class="line">        ctx.writeAndFlush(654321L);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MyReplayingDecoder:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyReplayingDecoder extends ReplayingDecoder&lt;Void&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;MyReplayingDecoder decode invoked!&quot;);</span><br><span class="line">        out.add(in.readLong());//注意没有判断字节数！！！！</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MyLongToByteEncoder:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyLongToByteEncoder extends MessageToByteEncoder&lt;Long&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void encode(ChannelHandlerContext ctx, Long msg, ByteBuf out) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;encode invoked&quot;);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        out.writeLong(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Myclient &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        EventLoopGroup eventLoopGroup = new NioEventLoopGroup();</span><br><span class="line">        try &#123;</span><br><span class="line">            Bootstrap bootstrap = new Bootstrap();</span><br><span class="line">            bootstrap.group(eventLoopGroup).channel(NioSocketChannel.class).handler(new MyClientIniatializer());</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(&quot;localhost&quot;, 8899).sync();</span><br><span class="line">            channelFuture.channel().writeAndFlush(&quot;hello&quot;);</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            eventLoopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>客户端Iniatializer：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyClientIniatializer extends ChannelInitializer&lt;SocketChannel&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">        ChannelPipeline pipline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        pipline.addLast(new MyReplayingDecoder());</span><br><span class="line">        pipline.addLast(new MyLongToByteEncoder());</span><br><span class="line">        pipline.addLast(new MyClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端Handler：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyClientHandler extends SimpleChannelInboundHandler&lt;Long&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, Long msg) throws Exception &#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress());</span><br><span class="line">        System.out.println(&quot;client output &quot;+msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        ctx.writeAndFlush(123456L);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        super.exceptionCaught(ctx, cause);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行服务端，之后运行客户端：<br>服务端输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyReplayingDecoder decode invoked!</span><br><span class="line">/127.0.0.1:4448 --&gt; 123456</span><br><span class="line">encode invoked</span><br><span class="line">654321</span><br></pre></td></tr></table></figure>
<p>客户端输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">encode invoked</span><br><span class="line">123456</span><br><span class="line">MyReplayingDecoder decode invoked!</span><br><span class="line">localhost/127.0.0.1:8899</span><br><span class="line">client output 654321</span><br></pre></td></tr></table></figure>
<p>至于为什么是这样的输出结果，这里就不去做详细走读了，现在看一下ReplayingDecoder的javadoc：</p>
<font color="#FF0000">
A specialized variation of ByteToMessageDecoder which enables implementation of a non-blocking decoder in the blocking I/O paradigm.
The biggest difference between ReplayingDecoder and ByteToMessageDecoder is that ReplayingDecoder allows you to implement the decode() and decodeLast() methods just like all required bytes were received already, rather than checking the availability of the required bytes. For example, the following ByteToMessageDecoder implementation:
</font>
一个特殊的ByteToMessageDecoder ，可以在阻塞的i/o模式下实现非阻塞的解码。
ReplayingDecoder 和ByteToMessageDecoder 最大的不同就是ReplayingDecoder 允许你实现decode()和decodeLast()就像所有的字节已经接收到一样，不需要判断可用的字节，举例，下面的ByteToMessageDecoder 实现：

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class IntegerHeaderFrameDecoder extends ByteToMessageDecoder &#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">  protected void decode(ChannelHandlerContext ctx,</span><br><span class="line">                          ByteBuf buf, List&lt;Object&gt; out) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    if (buf.readableBytes() &lt; 4) &#123;</span><br><span class="line">       return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf.markReaderIndex();</span><br><span class="line">    int length = buf.readInt();</span><br><span class="line"></span><br><span class="line">    if (buf.readableBytes() &lt; length) &#123;</span><br><span class="line">       buf.resetReaderIndex();</span><br><span class="line">       return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    out.add(buf.readBytes(length));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码表达的意思是先读取前边4隔壁字节（即，一个int类型），然后再去读取后边个字节，如果前边四个字节无法读取，直接返回，如果可以读取前四个字节，那么紧接着读取同样长度个字节，这种方式是一种消息头，消息体的协议模型，先读取消息头，之后再去读取消息体：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C%E5%8D%81%E4%B8%89-ReplayingDecoder%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E4%BB%8B%E7%BB%8D/20171217140403291.png" alt="这里写图片描述"><br>好了先说到这里，协议以后再讨论，那现在我们使用ReplayingDecoder可以简化为：</p>
<p>is simplified like the following with ReplayingDecoder:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class IntegerHeaderFrameDecoder</span><br><span class="line">     extends ReplayingDecoder&lt;Void&gt; &#123;</span><br><span class="line"></span><br><span class="line">  protected void decode(ChannelHandlerContext ctx,</span><br><span class="line">                          ByteBuf buf) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    out.add(buf.readBytes(buf.readInt()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<font color="#FF0000">
How does this work?
ReplayingDecoder passes a specialized ByteBuf implementation which throws an Error of certain type when there's not enough data in the buffer. In the IntegerHeaderFrameDecoder above, you just assumed that there will be 4 or more bytes in the buffer when you call buf.readInt(). If there's really 4 bytes in the buffer, it will return the integer header as you expected. Otherwise, the Error will be raised and the control will be returned to ReplayingDecoder. If ReplayingDecoder catches the Error, then it will rewind the readerIndex of the buffer back to the 'initial' position (i.e. the beginning of the buffer) and call the decode(..) method again when more data is received into the buffer.
Please note that ReplayingDecoder always throws the same cached Error instance to avoid the overhead of creating a new Error and filling its stack trace for every throw.
</font>

<p>这是怎样完成的？<br>当ReplayingDecoder 接收的buffer的数据不足时，会抛出一个异常，ReplayingDecoder 通过一个ByteBuf 的具体实现来完成。在上边的IntegerHeaderFrameDecoder ，当你调用buf.readInt().你就假设在buffer里边有4个字节，如果里边确实有4个字节，它将会返回一个整型的头，就像你期望的一样，否则，将会抛出一个Error并且控制会返回到ReplayingDecoder，如果ReplayingDecoder扑捉到这个错误，然后他就会将读的索引重置到刚开始的位置（buffer的开始位置），之后再次调用decode方法当数据继续进入buffer的时候。</p>
<p>请注意ReplayingDecoder 总是返回一个缓冲的Error 的实例，，来避免创建新的Error对象和每次填充堆栈的负担。</p>
<font color="#FF0000">
Limitations
At the cost of the simplicity, ReplayingDecoder enforces you a few limitations:
Some buffer operations are prohibited.
Performance can be worse if the network is slow and the message format is complicated unlike the example above. In this case, your decoder might have to decode the same part of the message over and over again.
You must keep in mind that decode(..) method can be called many times to decode a single message. For example, the following code will not work:
</font>
限制
简化使用带来的成本，ReplayingDecoder 强制带来了2个限制：

<ul>
<li>一些buffer 的操作是被禁止的</li>
<li>如果网络过慢并且消息的格式复杂不像上边提到的那种简单的例子，会导致性能下降。在这种情况下，你的解码器就会一遍又一遍解码一个消息的同一个部分。</li>
<li>你必须要记住decode方法为了解码一个消息可能别调用多次，下面的情况是不能工作的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyDecoder extends ReplayingDecoder&lt;Void&gt; &#123;</span><br><span class="line"></span><br><span class="line">  private final Queue&lt;Integer&gt; values = new LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">  public void decode(.., ByteBuf buf, List&lt;Object&gt; out) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    // A message contains 2 integers.</span><br><span class="line">    values.offer(buf.readInt());</span><br><span class="line">    values.offer(buf.readInt());</span><br><span class="line"></span><br><span class="line">    // This assertion will fail intermittently since values.offer()</span><br><span class="line">    // can be called more than two times!</span><br><span class="line">    assert values.size() == 2;</span><br><span class="line">    out.add(values.poll() + values.poll());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上边的方式当中，假如走到第二个values.offer(buf.readInt());时候抛出了异常，下边的逻辑就不会走，但是values 里边已经有一个消息了，当下次再调用decode方法的时候（加入过来了2条数据），那么assert values.size() &#x3D;&#x3D; 2;永远都不会通过，因为加上之前的一条现在values里边是三条数据。</p>
<p>The correct implementation looks like the following, and you can also utilize the ‘checkpoint’ feature which is explained in detail in the next section.<br>正确的实现应该是下边这样的方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyDecoder extends ReplayingDecoder&lt;Void&gt; &#123;</span><br><span class="line"></span><br><span class="line">  private final Queue&lt;Integer&gt; values = new LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">  public void decode(.., ByteBuf buf, List&lt;Object&gt; out) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    // Revert the state of the variable that might have been changed</span><br><span class="line">    // since the last partial decode.</span><br><span class="line">    values.clear();//首先要清理掉里边的消息</span><br><span class="line"></span><br><span class="line">    // A message contains 2 integers.</span><br><span class="line">    values.offer(buf.readInt());</span><br><span class="line">    values.offer(buf.readInt());</span><br><span class="line"></span><br><span class="line">    // Now we know this assertion will never fail.</span><br><span class="line">    assert values.size() == 2;</span><br><span class="line">    out.add(values.poll() + values.poll());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="#FF0000">
Improving the performance
</font>
性能提升
<font color="#FF0000">
Fortunately, the performance of a complex decoder implementation can be improved significantly with the checkpoint() method. The checkpoint() method updates the 'initial' position of the buffer so that ReplayingDecoder rewinds the readerIndex of the buffer to the last position where you called the checkpoint() method.
</font>
幸好，复杂解码器性能的提升可以通过checkpoint()方法实现，checkpoint()方法可以更新buffer的初始化的位置，这样ReplayingDecoder 就可以在调用checkpoint()方法的时候重新回到上一次读索引的位置。
<font color="#FF0000">
Calling checkpoint(T) with an Enum
Although you can just use checkpoint() method and manage the state of the decoder by yourself, the easiest way to manage the state of the decoder is to create an Enum type which represents the current state of the decoder and to call checkpoint(T) method whenever the state changes. You can have as many states as you want depending on the complexity of the message you want to decode:
</font>
通过枚举调用索引，尽管你可以自己使用checkpoint()方法来管理decoder的状态，最易用的方式就是使用枚举来管理decoder的状态，这个枚举代表了当前decoder的状态，当状态改变时可以调用checkpoint()方法，你可以有很多状态取决于你想解码的消息的复杂度。

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum MyDecoderState &#123;</span><br><span class="line">//假设消息有2种状态，读取长度状态和读取内容的状态。</span><br><span class="line">  READ_LENGTH,</span><br><span class="line">  READ_CONTENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class IntegerHeaderFrameDecoder</span><br><span class="line">     extends ReplayingDecoder&lt;MyDecoderState&gt; &#123;</span><br><span class="line"></span><br><span class="line">  private int length;</span><br><span class="line"></span><br><span class="line">  public IntegerHeaderFrameDecoder() &#123;</span><br><span class="line">    // Set the initial state.</span><br><span class="line">    super(MyDecoderState.READ_LENGTH);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">  protected void decode(ChannelHandlerContext ctx,</span><br><span class="line">                          ByteBuf buf, List&lt;Object&gt; out) throws Exception &#123;</span><br><span class="line">    switch (state()) &#123;</span><br><span class="line">    case READ_LENGTH:</span><br><span class="line">      length = buf.readInt();</span><br><span class="line">      checkpoint(MyDecoderState.READ_CONTENT);</span><br><span class="line">      //注意这里没有break，也就是说接下来就是进入READ_CONTENT的代码块，执行读取内容的逻辑</span><br><span class="line">    case READ_CONTENT:</span><br><span class="line">      ByteBuf frame = buf.readBytes(length);</span><br><span class="line">      checkpoint(MyDecoderState.READ_LENGTH);</span><br><span class="line">      out.add(frame);</span><br><span class="line">      break;</span><br><span class="line">    default:</span><br><span class="line">      throw new Error(&quot;Shouldn&#x27;t reach here.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Calling checkpoint() with no parameter<br>An alternative way to manage the decoder state is to manage it by yourself.<br>没有参数调用checkpoint()方法：</p>
<p>另外一种管理decoder的方式是自己管理decoder状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class IntegerHeaderFrameDecoder</span><br><span class="line">     extends ReplayingDecoder&lt;Void&gt; &#123;</span><br><span class="line"></span><br><span class="line">  private boolean readLength;</span><br><span class="line">  private int length;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">  protected void decode(ChannelHandlerContext ctx,</span><br><span class="line">                          ByteBuf buf, List&lt;Object&gt; out) throws Exception &#123;</span><br><span class="line">    if (!readLength) &#123;</span><br><span class="line">      length = buf.readInt();</span><br><span class="line">      readLength = true;</span><br><span class="line">      checkpoint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (readLength) &#123;</span><br><span class="line">      ByteBuf frame = buf.readBytes(length);</span><br><span class="line">      readLength = false;</span><br><span class="line">      checkpoint();</span><br><span class="line">      out.add(frame);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Replacing a decoder with another decoder in a pipeline<br>在管道中用另外一个decoder替换一个decoder<br><font color="#FF0000"><br>If you are going to write a protocol multiplexer, you will probably want to replace a ReplayingDecoder (protocol detector) with another ReplayingDecoder, ByteToMessageDecoder or MessageToMessageDecoder (actual protocol decoder). It is not possible to achieve this simply by calling ChannelPipeline.replace(ChannelHandler, String, ChannelHandler), but some additional steps are required:<br></font><br>如果你想写一个协议组件，你可能替换一个ReplayingDecoder （协议探测者）用另外的ReplayingDecoder、ByteToMessageDecoder 或者MessageToMessageDecoder （实际的解码器），<br>你不可能简单的通过调用ChannelPipeline.replace(ChannelHandler, String, ChannelHandler)来实现，但是一些额外的步骤是需要的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FirstDecoder extends ReplayingDecoder&lt;Void&gt; &#123;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">    protected void decode(ChannelHandlerContext ctx,</span><br><span class="line">                            ByteBuf buf, List&lt;Object&gt; out) &#123;</span><br><span class="line">        ...</span><br><span class="line">        // Decode the first message</span><br><span class="line">        Object firstMessage = ...;</span><br><span class="line"></span><br><span class="line">        // Add the second decoder</span><br><span class="line">        ctx.pipeline().addLast(&quot;second&quot;, new SecondDecoder());</span><br><span class="line"></span><br><span class="line">        if (buf.isReadable()) &#123;</span><br><span class="line">            // Hand off the remaining data to the second decoder</span><br><span class="line">            out.add(firstMessage);</span><br><span class="line">            out.add(buf.readBytes(super.actualReadableBytes()));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Nothing to hand off</span><br><span class="line">            out.add(firstMessage);</span><br><span class="line">        &#125;</span><br><span class="line">        // Remove the first decoder (me)</span><br><span class="line">        ctx.pipeline().remove(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>不需要状态管理的时候不需要Void泛型。</p>
<p>另外上文提到的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzExNTY3MjE4NzQvbmV0dHlfbGVjdHVyZS9ibG9iL21hc3Rlci9zcmMvbWFpbi9qYXZhL2NvbS9jZWFzZXIvbmV0dHkvbWVzc2FnZVRvTWVzc2FnZURlY29kZXI=">MessageToMessageDecoder<i class="fa fa-external-link-alt"></i></span>解码器在这里不做详细介绍，主要是实现消息到消息的解码，可以去git看具体使用方式。</p>
<p>除了编码器很解码器之外还有既是解码器又是编码器的：MessageToMessageCodec（继承的方式）、CombinedChannelDuplexHandler（组合方式）,那么我们在实际开发的时候怎么选择呢，根据单一职责设计原则，尽量是要分开。<br>几种常见的编解码器:</p>
<p><strong>LineBasedFrameDecoder</strong><br><font color="#FF0000"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A decoder that splits the received &#123;@link ByteBuf&#125;s on line endings.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * Both &#123;@code &quot;\n&quot;&#125; and &#123;@code &quot;\r\n&quot;&#125; are handled.</span><br><span class="line"> * For a more general delimiter-based decoder, see &#123;@link DelimiterBasedFrameDecoder&#125;.</span><br><span class="line"> * 基于行的解码器，遇到 &quot;\n&quot;、&quot;\r\n&quot;会被作为行分隔符</span><br><span class="line"> */</span><br><span class="line">public class LineBasedFrameDecoder extends ByteToMessageDecoder</span><br></pre></td></tr></table></figure>
</font>

<p><strong>FixedLengthFrameDecoder</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">A decoder that splits the received ByteBufs by the fixed number of bytes. For example, if you received the following four fragmented packets:</span><br><span class="line"> +---+----+------+----+</span><br><span class="line"> | A | BC | DEFG | HI |</span><br><span class="line"> +---+----+------+----+</span><br><span class="line"></span><br><span class="line">A FixedLengthFrameDecoder(3) will decode them into the following three packets with the fixed length:</span><br><span class="line"> +-----+-----+-----+</span><br><span class="line"> | ABC | DEF | GHI |</span><br><span class="line"> +-----+-----+-----+</span><br><span class="line"> 按照固定长度包的解码器</span><br><span class="line">*/</span><br><span class="line">public class FixedLengthFrameDecoder extends ByteToMessageDecoder</span><br></pre></td></tr></table></figure>

<p><strong>DelimiterBasedFrameDecoder</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A decoder that splits the received ByteBufs by one or more delimiters. It is particularly useful for decoding the frames which ends with a delimiter such as NUL or newline characters.</span><br><span class="line">Predefined delimiters</span><br><span class="line">Delimiters defines frequently used delimiters for convenience&#x27; sake.</span><br><span class="line"></span><br><span class="line">Specifying more than one delimiter</span><br><span class="line">DelimiterBasedFrameDecoder allows you to specify more than one delimiter. If more than one delimiter is found in the buffer, it chooses the delimiter which produces the shortest frame. For example, if you have the following data in the buffer:</span><br><span class="line"></span><br><span class="line"> +--------------+</span><br><span class="line"> | ABC\nDEF\r\n |</span><br><span class="line"> +--------------+</span><br><span class="line"></span><br><span class="line">a DelimiterBasedFrameDecoder(Delimiters.lineDelimiter()) will choose &#x27;\n&#x27; as the first delimiter and produce two frames:</span><br><span class="line"> +-----+-----+</span><br><span class="line"> | ABC | DEF |</span><br><span class="line"> +-----+-----+</span><br><span class="line"></span><br><span class="line">rather than incorrectly choosing &#x27;\r\n&#x27; as the first delimiter:</span><br><span class="line"> +----------+</span><br><span class="line"> | ABC\nDEF |</span><br><span class="line"> +----------+</span><br><span class="line"> 基于分隔符的振解码器,注意使用&#x27;\n&#x27;分割会产生2个振，使用&#x27;\r\n&#x27;会产生1个振，</span><br><span class="line"> DelimiterBasedFrameDecoder原则使用产生最小振的分隔符，即&#x27;\n&#x27;</span><br><span class="line"> public class DelimiterBasedFrameDecoder extends ByteToMessageDecoder</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>LengthFieldBasedFrameDecoder</strong></p>
<p>public class LengthFieldBasedFrameDecoder extends ByteToMessageDecoder</p>
<font color="#FF0000">
A decoder that splits the received ByteBufs dynamically by the value of the length field in the message. It is particularly useful when you decode a binary message which has an integer header field that represents the length of the message body or the whole message.
LengthFieldBasedFrameDecoder has many configuration parameters so that it can decode any message with a length field, which is often seen in proprietary client-server protocols. Here are some example that will give you the basic idea on which option does what.
</font>

<p>可以通过接收的消息中的length的值得来动态分割接收的ByteBufs ，当我们解码一个二进制消息，其中有一个整型的字段在header里边，这个字段代表消息体的长度或者整个消息的长度，这种情况LengthFieldBasedFrameDecoder是非常有用的。<br>LengthFieldBasedFrameDecoder 拥有许多配置参数，因此他可以通过长度length filed解码任意的消息，通常在一些私有的协议是经常出现的，下面的实例让你对每一个的含义都有一个了解。</p>
<p>2 bytes length field at offset 0, do not strip header<br>偏移量是0不会去除header<br><font color="#FF0000"><br>The value of the length field in this example is 12 (0x0C) which represents the length of “HELLO, WORLD”. By default, the decoder assumes that the length field represents the number of the bytes that follows the length field. Therefore, it can be decoded with the simplistic parameter combination.<br></font><br>长度字段的值是1代表“HELLO, WORLD”的字符串的长度，默认情况下，解码器假设长度字段的值代表的是length field后边跟随字节的长度，<br>因此它可以通过简单的参数组合的方式来解码。<br> lengthFieldOffset   &#x3D; 0<br> lengthFieldLength   &#x3D; 2<br> lengthAdjustment    &#x3D; 0<br> initialBytesToStrip &#x3D; 0 (&#x3D; do not strip header)</p>
<p> BEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)<br> +——–+—————-+      +——–+—————-+<br> | Length | Actual Content |—–&gt;| Length | Actual Content |<br> | 0x000C | “HELLO, WORLD” |      | 0x000C | “HELLO, WORLD” |<br> +——–+—————-+      +——–+—————-+<br> 【Length 的值是12，后边跟随的content的长度是12个字节。】<br> <font color="#FF0000"><br>2 bytes length field at offset 0, strip header<br></font><br>偏移量是0跳过头<br><font color="#FF0000"><br>Because we can get the length of the content by calling ByteBuf.readableBytes(), you might want to strip the length field by specifying initialBytesToStrip. In this example, we specified 2, that is same with the length of the length field, to strip the first two bytes.<br></font><br>因为我们可以通过调用 ByteBuf.readableBytes()老得到内容的长度，你可以通过指定initialBytesToStrip的值跳过length field，在这例子中，我们指定的是2，他和length field的值是一致的，为了跳过开始的2个字节。<br> lengthFieldOffset   &#x3D; 0<br> lengthFieldLength   &#x3D; 2<br> lengthAdjustment    &#x3D; 0<br> initialBytesToStrip &#x3D; 2 (&#x3D; the length of the Length field)</p>
<p> BEFORE DECODE (14 bytes)         AFTER DECODE (12 bytes)<br> +——–+—————-+      +—————-+<br> | Length | Actual Content |—–&gt;| Actual Content |<br> | 0x000C | “HELLO, WORLD” |      | “HELLO, WORLD” |<br> +——–+—————-+      +—————-+</p>
<font color="#FF0000">
2 bytes length field at offset 0, do not strip header, the length field represents the length of the whole message
</font>
偏移量是0，不跳过头，length field代表是整个消息的长度
<font color="#FF0000">
In most cases, the length field represents the length of the message body only, as shown in the previous examples. However, in some protocols, the length field represents the length of the whole message, including the message header. In such a case, we specify a non-zero lengthAdjustment. Because the length value in this example message is always greater than the body length by 2, we specify -2 as lengthAdjustment for compensation.
</font>
在大多数情况下，length field 代表的是消息体的长度，就像在之前的例子，当然，在某些协议，length field 代表这个消息的长度，在这种情况，我们指定一个非0的lengthAdjustment，因为在这个例子中length value总是大于消息体2，我们指定-2位lengthAdjustment 的值为了补偿。
 lengthFieldOffset   =  0
 lengthFieldLength   =  2
 lengthAdjustment    = -2 (= the length of the Length field)
 initialBytesToStrip =  0

<p> BEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)<br> +——–+—————-+      +——–+—————-+<br> | Length | Actual Content |—–&gt;| Length | Actual Content |<br> | 0x000E | “HELLO, WORLD” |      | 0x000E | “HELLO, WORLD” |<br> +——–+—————-+      +——–+—————-+</p>
<font color="#FF0000">
3 bytes length field at the end of 5 bytes header, do not strip header
The following message is a simple variation of the first example. An extra header value is prepended to the message. lengthAdjustment is zero again because the decoder always takes the length of the prepended data into account during frame length calculation.
</font>
 lengthFieldOffset   = 2 (= the length of Header 1)
 lengthFieldLength   = 3
 lengthAdjustment    = 0
 initialBytesToStrip = 0

<p> BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)<br> +———-+———-+—————-+      +———-+———-+—————-+<br> | Header 1 |  Length  | Actual Content |—–&gt;| Header 1 |  Length  | Actual Content |<br> |  0xCAFE  | 0x00000C | “HELLO, WORLD” |      |  0xCAFE  | 0x00000C | “HELLO, WORLD” |<br> +———-+———-+—————-+      +———-+———-+—————-+</p>
<font color="#FF0000">
3 bytes length field at the beginning of 5 bytes header, do not strip header
This is an advanced example that shows the case where there is an extra header between the length field and the message body. You have to specify a positive lengthAdjustment so that the decoder counts the extra header into the frame length calculation.
</font>
 lengthFieldOffset   = 0
 lengthFieldLength   = 3
 lengthAdjustment    = 2 (= the length of Header 1)
 initialBytesToStrip = 0

<p> BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)<br> +———-+———-+—————-+      +———-+———-+—————-+<br> |  Length  | Header 1 | Actual Content |—–&gt;|  Length  | Header 1 | Actual Content |<br> | 0x00000C |  0xCAFE  | “HELLO, WORLD” |      | 0x00000C |  0xCAFE  | “HELLO, WORLD” |<br> +———-+———-+—————-+      +———-+———-+—————-+</p>
<font color="#FF0000">
2 bytes length field at offset 1 in the middle of 4 bytes header, strip the first header field and the length field
This is a combination of all the examples above. There are the prepended header before the length field and the extra header after the length field. The prepended header affects the lengthFieldOffset and the extra header affects the lengthAdjustment. We also specified a non-zero initialBytesToStrip to strip the length field and the prepended header from the frame. If you don't want to strip the prepended header, you could specify 0 for initialBytesToSkip.
</font>
 lengthFieldOffset   = 1 (= the length of HDR1)
 lengthFieldLength   = 2
 lengthAdjustment    = 1 (= the length of HDR2)
 initialBytesToStrip = 3 (= the length of HDR1 + LEN)

<p> BEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)<br> +——+——–+——+—————-+      +——+—————-+<br> | HDR1 | Length | HDR2 | Actual Content |—–&gt;| HDR2 | Actual Content |<br> | 0xCA | 0x000C | 0xFE | “HELLO, WORLD” |      | 0xFE | “HELLO, WORLD” |<br> +——+——–+——+—————-+      +——+—————-+</p>
<font color="#FF0000">
2 bytes length field at offset 1 in the middle of 4 bytes header, strip the first header field and the length field, the length field represents the length of the whole message
Let's give another twist to the previous example. The only difference from the previous example is that the length field represents the length of the whole message instead of the message body, just like the third example. We have to count the length of HDR1 and Length into lengthAdjustment. Please note that we don't need to take the length of HDR2 into account because the length field already includes the whole header length.
</font>
 lengthFieldOffset   =  1
 lengthFieldLength   =  2
 lengthAdjustment    = -3 (= the length of HDR1 + LEN, negative)
 initialBytesToStrip =  3

<p> BEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)<br> +——+——–+——+—————-+      +——+—————-+<br> | HDR1 | Length | HDR2 | Actual Content |—–&gt;| HDR2 | Actual Content |<br> | 0xCA | 0x0010 | 0xFE | “HELLO, WORLD” |      | 0xFE | “HELLO, WORLD” |<br> +——+——–+——+—————-+      +——+—————-+</p>
<p>相应中文介绍和举例：<span class="exturl" data-url="aHR0cDovL3d3dy5qaWFuc2h1LmNvbS9wL2EwYTUxZmQ3OWY2Mg==">http://www.jianshu.com/p/a0a51fd79f62<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>ReplayingDecoder</tag>
      </tags>
  </entry>
  <entry>
    <title>netty源码分析(二十二)Netty编解码器剖析与入站出站处理器详解</title>
    <url>/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C%E5%8D%81%E4%BA%8C-Netty%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E5%89%96%E6%9E%90%E4%B8%8E%E5%85%A5%E7%AB%99%E5%87%BA%E7%AB%99%E5%A4%84%E7%90%86%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>Netty处理器重要概念：<br>1、Netty的处理器可以分为两类：入栈处理器和出栈处理器。</p>
<span id="more"></span>
<p>2、入栈处理器的顶层是ChannelInboundHandler，出栈处理器的顶层是ChannelOutboundHandler。<br>3、数据处理时常用的各种编解码器本质上都是处理器。<br>4、编解码器：无论我们是向网络中写入数据是什么类型（int、char、String、二进制等），数据在网络中传递时，其都是以字节流的形式出现的；将数据由原本的形式转换为字节流的操作称为编码（encode），将数据由字节转换为它原本的格式或是其他格式的操作称为解码（decode），编码统一称为codec。<br>5、编码：本质上是一种出栈处理器；因此，编码一定是一种ChannelOutboundHandler。<br>6、解码：本质上是一种入栈处理器，因此。解码一定是一种ChannelInboundHandler。<br>7、在Netty中，编码器通常以XXXEncoder命名；解码器通常以XXXDecoder命名。</p>
<p>netty下边有很多编解码器的实现：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C%E5%8D%81%E4%BA%8C-Netty%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E5%89%96%E6%9E%90%E4%B8%8E%E5%85%A5%E7%AB%99%E5%87%BA%E7%AB%99%E5%A4%84%E7%90%86%E5%99%A8%E8%AF%A6%E8%A7%A3/20171210132017305.png" alt="这里写图片描述"></p>
<p>实际开发的过程中我们可以去使用它们，我们要讲的不是去使用它们，现在以一个例子来说明编解码的一些内幕：<br>netty提供了一个字节到消息的转换器(ByteToMessageDecoder)：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C%E5%8D%81%E4%BA%8C-Netty%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E5%89%96%E6%9E%90%E4%B8%8E%E5%85%A5%E7%AB%99%E5%87%BA%E7%AB%99%E5%A4%84%E7%90%86%E5%99%A8%E8%AF%A6%E8%A7%A3/20171210135608726.png" alt="这里写图片描述"><br>接下来我们使用ByteToMessageDecoder自己实现一个解码器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class MyByteToLongDecoder extends ByteToMessageDecoder &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;decode invoked&quot;);</span><br><span class="line">        System.out.println(in.readableBytes());</span><br><span class="line">        if(in.readableBytes()&gt;=8)&#123;</span><br><span class="line">                out.add(in.readLong());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后需要一个将Long类型的数据转换为byte的书装换器：<br>使用MessageToByteEncoder：<br>服务端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by Administrator on 2017/5/20.</span><br><span class="line"> * 服务器和客户端互发程序</span><br><span class="line"> */</span><br><span class="line">public class MyServer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        EventLoopGroup bossGroup = new NioEventLoopGroup(1);</span><br><span class="line">        EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line">        try&#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = new ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(new MyServerInitializer());</span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(8899).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">        ChannelPipeline pipline = ch.pipeline();</span><br><span class="line">        pipline.addLast(new MyByteToLongDecoder());</span><br><span class="line">        pipline.addLast(new MyLongToByteEncoder());</span><br><span class="line">        pipline.addLast(new MyServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端handler：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyServerHandler extends SimpleChannelInboundHandler&lt;Long&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, Long msg) throws Exception &#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress()+&quot; --&gt; &quot;+msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Myclient &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        EventLoopGroup eventLoopGroup = new NioEventLoopGroup();</span><br><span class="line">        try &#123;</span><br><span class="line">            Bootstrap bootstrap = new Bootstrap();</span><br><span class="line">            bootstrap.group(eventLoopGroup).channel(NioSocketChannel.class).handler(new MyClientIniatializer());</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(&quot;localhost&quot;, 8899).sync();</span><br><span class="line">            channelFuture.channel().writeAndFlush(&quot;hello&quot;);</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            eventLoopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>客户端的initializer：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyClientIniatializer extends ChannelInitializer&lt;SocketChannel&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">        ChannelPipeline pipline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        pipline.addLast(new MyByteToLongDecoder());</span><br><span class="line">        pipline.addLast(new MyLongToByteEncoder());</span><br><span class="line">        pipline.addLast(new MyClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>客户端handler：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyClientHandler extends SimpleChannelInboundHandler&lt;Long&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, Long msg) throws Exception &#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress());</span><br><span class="line">        System.out.println(&quot;client output &quot;+msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        ctx.writeAndFlush(123456L);//一定要加L，否则会作为int类型处理，最终导致消息发送不出去。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        super.exceptionCaught(ctx, cause);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节到Long类型的解码器（解析网络传过来的数据）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyByteToLongDecoder extends ByteToMessageDecoder &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;decode invoked&quot;);</span><br><span class="line">        System.out.println(in.readableBytes());</span><br><span class="line">        if(in.readableBytes()&gt;=8)&#123;</span><br><span class="line">                out.add(in.readLong());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Long类型转换为字节（发送到网络之前的转换）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyLongToByteEncoder extends MessageToByteEncoder&lt;Long&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void encode(ChannelHandlerContext ctx, Long msg, ByteBuf out) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;encode invoked&quot;);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        out.writeLong(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行服务端，之后运行客户端，打印输出：<br>server端输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">decode invoked</span><br><span class="line">8</span><br><span class="line">/127.0.0.1:4679 --&gt; 123456</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>client输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">encode invoked</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>
<p>至于为什么是这样一个过程：<br>首先客户端启动之后，调用MyLongToByteEncoder的encode方法打印“encode invoked”和发送的数据“123456”。<br>服务段接受到之后调用MyByteToLongDecoder的decode打印“decode invoked”和数据长度“8”，之后是调用MyClientHandler的channelRead0打印“&#x2F;127.0.0.1:4679 –&gt; 123456”</p>
<p>接下来我们修改MyClientHandler如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyClientHandler extends SimpleChannelInboundHandler&lt;Long&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, Long msg) throws Exception &#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress());</span><br><span class="line">        System.out.println(&quot;client output &quot;+msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        // ctx.writeAndFlush(123456L);</span><br><span class="line">    /*</span><br><span class="line">        都可以发送</span><br><span class="line">        ctx.writeAndFlush(1L);</span><br><span class="line">        ctx.writeAndFlush(2L);</span><br><span class="line">        ctx.writeAndFlush(3L);</span><br><span class="line">        ctx.writeAndFlush(4L);*/</span><br><span class="line"></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;helloworld&quot;, Charset.forName(&quot;utf-8&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        super.exceptionCaught(ctx, cause);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ctx.writeAndFlush(Unpooled.copiedBuffer(“helloworld”, Charset.forName(“utf-8”)));<br>这行代码，即发送一个Buffer，我们查看控制台打印的数据：<br>server端的打印：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">decode invoked</span><br><span class="line">10</span><br><span class="line">/127.0.0.1:6394 --&gt; 7522537965574647666</span><br><span class="line">decode invoked</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>客户端没有任何输出，因为我们的客户端使用的是ByteBuff，而客户端的编码器是Long类型的，所以编码器没有执行，直接把数据丢给了Socket传输到了网络，所以服务端会收到数据，我们发送的数据是“helloworld”由于是utf-8，所以一个英文字符是一个字节，一共是10个字节，我们解码器只有在大于8个字节的时候才会对其进行解码然后给到下一个处理器，所以10个字节前8个通过了解码器，去了下一个handler，而剩下的2个没有通过解码器，服务端打印的“&#x2F;127.0.0.1:6394 –&gt; 7522537965574647666”后边的那串数字是8个字节的数据。</p>
<p>  关于netty编解码器的重要结论：<br>  1、无论是编码器还是解码器，其接受的消息类型必须要与待处理的参数类型一致，否则该编码器或解码器并不会执行。<br>  2、在解码器进行数据解码时，一定要记得判断缓冲（ByteBuf）中的数据是否 足够，否则将会产生一些问题。<br>  例如上边的例子判断是否是8个长度（因为long是占用8个字节的数据类型）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;decode invoked&quot;);</span><br><span class="line">    System.out.println(in.readableBytes());</span><br><span class="line">    if(in.readableBytes()&gt;=8)&#123;</span><br><span class="line">            out.add(in.readLong());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>编解码器 出栈处理器 入栈处理器</tag>
      </tags>
  </entry>
  <entry>
    <title>netty源码分析(二十四)TCP粘包与拆包实例演示及分析</title>
    <url>/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C%E5%8D%81%E5%9B%9B-TCP%E7%B2%98%E5%8C%85%E4%B8%8E%E6%8B%86%E5%8C%85%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA%E5%8F%8A%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>关于粘包与拆包的概念这里不再熬术，下面举一个粘包的例子：<br>客户端启动的时候向服务端写入了10条消息，然后服务端接收到消息之后，回写客户端一条UUID，客户端打印服务端发过来的UUID</p>
<span id="more"></span>
<p>MyServer：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyServer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        EventLoopGroup bossGroup = new NioEventLoopGroup(1);</span><br><span class="line">        EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line">        try&#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = new ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(new MyServerInitializer());</span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(8899).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>MyClientIniatializer：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyClientIniatializer extends ChannelInitializer&lt;SocketChannel&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">        ChannelPipeline pipline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        pipline.addLast(new MyClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MyServerHandler：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyServerHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt; &#123;</span><br><span class="line">    private int  count ;</span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception &#123;</span><br><span class="line">        byte[] buffer = new byte[msg.readableBytes()] ;</span><br><span class="line">        msg.readBytes(buffer);//注意buffer的长度必须和msg.readableBytes()一样，否则报错，这是netty规定的</span><br><span class="line">        String message = new String(buffer, Charset.forName(&quot;utf-8&quot;));</span><br><span class="line">        System.out.println(&quot;服务端接收到的消息：&quot;+message);</span><br><span class="line">        System.out.println(&quot;服务端接收到的消息数量：&quot;+(++this.count));</span><br><span class="line"></span><br><span class="line">        ByteBuf responseMessage = Unpooled.copiedBuffer(UUID.randomUUID().toString(),Charset.forName(&quot;utf-8&quot;));</span><br><span class="line">        ctx.writeAndFlush(responseMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Myclient：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Myclient &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        EventLoopGroup eventLoopGroup = new NioEventLoopGroup();</span><br><span class="line">        try &#123;</span><br><span class="line">            Bootstrap bootstrap = new Bootstrap();</span><br><span class="line">            bootstrap.group(eventLoopGroup).channel(NioSocketChannel.class).handler(new MyClientIniatializer());</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(&quot;localhost&quot;, 8899).sync();</span><br><span class="line">            channelFuture.channel().writeAndFlush(&quot;hello&quot;);</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            eventLoopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>MyClientIniatializer：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyClientIniatializer extends ChannelInitializer&lt;SocketChannel&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">        ChannelPipeline pipline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        pipline.addLast(new MyClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyClientHandler：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyClientHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt; &#123;</span><br><span class="line">    private int count;</span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception &#123;</span><br><span class="line">        byte[] buffer = new byte[msg.readableBytes()];</span><br><span class="line">        msg.readBytes(buffer);</span><br><span class="line"></span><br><span class="line">        String message = new String(buffer,Charset.forName(&quot;utf-8&quot;));</span><br><span class="line">        System.out.println(&quot;客户端接收到的消息内容：&quot;+message);</span><br><span class="line">        System.out.println(&quot;客户端接收到的消息数量：&quot;+(++this.count));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        for(int i = 0;i &lt;10;i++)&#123;</span><br><span class="line">            ByteBuf buffer  = Unpooled.copiedBuffer(&quot;sent from client&quot;,Charset.forName(&quot;utf-8&quot;));</span><br><span class="line">            ctx.writeAndFlush(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        super.exceptionCaught(ctx, cause);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">服务端接收到的消息：sent from clientsent from clientsent from clientsent from clientsent from clientsent from clientsent from clientsent from clientsent from clientsent from client</span><br><span class="line">服务端接收到的消息数量：1</span><br></pre></td></tr></table></figure>

<p>客户端打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端接收到的消息内容：8c260c09-8a9d-4491-9bf7-ff5c5c8f790c</span><br><span class="line">客户端接收到的消息数量：1</span><br></pre></td></tr></table></figure>
<p>很多人认为客户端应该收到10条UUID才对，但是这里协议进行了粘包，将客户端的10条消息作为一条消息发给我服务端，才导致服务端只打印了一天消息（10条客户端消息的集合）而且只接受了一次，因此服务端打印的接收数量是1。</p>
<p>此时我们把客户端关闭，然后重新连接服务端，我们重复2次这个过程。<br>服务端打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">服务端接收到的消息：sent from clientsent from clientsent from clientsent from clientsent from clientsent from clientsent from clientsent from clientsent from clientsent from client</span><br><span class="line">服务端接收到的消息数量：1</span><br><span class="line">服务端接收到的消息：sent from client</span><br><span class="line">服务端接收到的消息数量：1</span><br><span class="line">服务端接收到的消息：sent from client</span><br><span class="line">服务端接收到的消息数量：2</span><br><span class="line">服务端接收到的消息：sent from clientsent from clientsent from client</span><br><span class="line">服务端接收到的消息数量：3</span><br><span class="line">服务端接收到的消息：sent from clientsent from client</span><br><span class="line">服务端接收到的消息数量：4</span><br><span class="line">服务端接收到的消息：sent from clientsent from clientsent from client</span><br><span class="line">服务端接收到的消息数量：5</span><br><span class="line">服务端接收到的消息：sent from client</span><br><span class="line">服务端接收到的消息数量：1</span><br><span class="line">服务端接收到的消息：sent from client</span><br><span class="line">服务端接收到的消息数量：2</span><br><span class="line">服务端接收到的消息：sent from clientsent from clientsent from clientsent from client</span><br><span class="line">服务端接收到的消息数量：3</span><br><span class="line">服务端接收到的消息：sent from clientsent from client</span><br><span class="line">服务端接收到的消息数量：4</span><br><span class="line">服务端接收到的消息：sent from clientsent from client</span><br><span class="line">服务端接收到的消息数量：5</span><br></pre></td></tr></table></figure>
<p>疑问是为什么MyServerHandler里边的count会重新从1开始？<br>其实这里的MyServerInitializer每当有一个客户端连接上来的时候都会新建一个MyServerHandler，也就会初始化MyServerHandler的count，因此出现这样的结果。<br>这样的现象是tcp协议的一部分，我们在使用netty的时候可以通过编解码器来解决tcp粘包和拆包的问题。</p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>tcp  粘包 拆包</tag>
      </tags>
  </entry>
  <entry>
    <title>netty源码分析(二十五)Netty自定义协议与TCP粘包拆包问题解决之道</title>
    <url>/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C%E5%8D%81%E4%BA%94-Netty%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE%E4%B8%8ETCP%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E4%B9%8B%E9%81%93/</url>
    <content><![CDATA[<p>上一节说了TCP的粘包和拆包，用一个实例的方式做了说明，那么在netty里面是怎么解决粘包和拆包问题呢，这就需要编解码器，我们写一个简单的自动以协议的demo，说明一下编解码器在解决tcp粘包和拆包的解决方式。<br>先罗列一下服务端的代码：</p>
<span id="more"></span>
<p>MyServer负责服务端的启动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyServer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        EventLoopGroup bossGroup = new NioEventLoopGroup(1);</span><br><span class="line">        EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line">        try&#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = new ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(new MyServerInitializer());</span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(8899).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MyServerInitializer 负责加入编解码器和handler，包括我们自己定义的编解码器（MyPersonDecoder、MyPersonEncoder）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">       ChannelPipeline channelPipeline =  ch.pipeline();</span><br><span class="line">        channelPipeline.addLast(new MyPersonDecoder());</span><br><span class="line">        channelPipeline.addLast(new MyPersonEncoder());</span><br><span class="line">        channelPipeline.addLast(new MyServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyServerHandler，接受客户端发来的信息并打印调用次数，之后向客户端写入一个uuid：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyServerHandler extends SimpleChannelInboundHandler&lt;PersonProtocal&gt; &#123;</span><br><span class="line">    private int count;</span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, PersonProtocal msg) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;服务端接受到的数据：&quot;);</span><br><span class="line">        System.out.println(&quot;数据长度:&quot;+msg.getLength());</span><br><span class="line">        System.out.println(&quot;数据内容：&quot;+ new String(msg.getContent(), Charset.forName(&quot;utf-8&quot;)) );</span><br><span class="line">        System.out.println(&quot;服务端接收到的消息数量:&quot;+(++count));</span><br><span class="line"></span><br><span class="line">        String responseMessage = UUID.randomUUID().toString();</span><br><span class="line">        int responseLength = responseMessage.getBytes(Charset.forName(&quot;utf-8&quot;)).length;</span><br><span class="line">        byte[] responseContent = responseMessage.getBytes(Charset.forName(&quot;utf-8&quot;));</span><br><span class="line">        PersonProtocal personProtocal = new PersonProtocal();</span><br><span class="line">        personProtocal.setLength(responseLength);</span><br><span class="line">        personProtocal.setContent(responseContent);</span><br><span class="line">        ctx.writeAndFlush(personProtocal);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解码器，将字节数组解码成我们自定义的协议PersonProtocal类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyPersonDecoder extends ReplayingDecoder&lt;Void&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;MyPersonDecoder decode invoked &quot;);</span><br><span class="line">        int length = in.readInt();</span><br><span class="line">        byte[] content = new byte[length];</span><br><span class="line">        in.readBytes(content);</span><br><span class="line"></span><br><span class="line">        PersonProtocal personProtocal = new PersonProtocal();</span><br><span class="line">        personProtocal.setLength(length);</span><br><span class="line">        personProtocal.setContent(content);</span><br><span class="line"></span><br><span class="line">        out.add(personProtocal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>PersonProtocal 自定义的协议的封装，其实很简单，只有消息的长度和消息内容，先读取消息长度，再读取消息内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PersonProtocal &#123;</span><br><span class="line">    private int length;</span><br><span class="line"></span><br><span class="line">    private byte[] content;</span><br><span class="line"></span><br><span class="line">    public int getLength() &#123;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLength(int length) &#123;</span><br><span class="line">        this.length = length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public byte[] getContent() &#123;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setContent(byte[] content) &#123;</span><br><span class="line">        this.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解码器MyPersonDecoder ，我们继承了ReplayingDecoder无需关注粘包问题，将字节转换为协议实体（PersonProtocal）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyPersonDecoder extends ReplayingDecoder&lt;Void&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;MyPersonDecoder decode invoked &quot;);</span><br><span class="line">        int length = in.readInt();</span><br><span class="line">        byte[] content = new byte[length];</span><br><span class="line">        in.readBytes(content);</span><br><span class="line"></span><br><span class="line">        PersonProtocal personProtocal = new PersonProtocal();</span><br><span class="line">        personProtocal.setLength(length);</span><br><span class="line">        personProtocal.setContent(content);</span><br><span class="line"></span><br><span class="line">        out.add(personProtocal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编码器MyPersonEncoder实现很简单，这是将数据（PersonProtocal）写入到网络：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class MyPersonEncoder extends MessageToByteEncoder&lt;PersonProtocal&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void encode(ChannelHandlerContext ctx, PersonProtocal msg, ByteBuf out) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;MyPersonEncoder encode invoked&quot;);</span><br><span class="line">        out.writeInt(msg.getLength());</span><br><span class="line">        out.writeBytes(msg.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是客户端的程序MyClientHandler，启动的时候向服务端发送十条消息，再者接受服务端回执的uuid：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyClientHandler extends SimpleChannelInboundHandler&lt;PersonProtocal&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private int count;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            String messaage = &quot;sent from client&quot;;</span><br><span class="line">            int length = messaage.getBytes(Charset.forName(&quot;utf-8&quot;)).length;</span><br><span class="line">            byte[] content = messaage.getBytes(Charset.forName(&quot;utf-8&quot;));</span><br><span class="line">            PersonProtocal personProtocal = new PersonProtocal();</span><br><span class="line">            personProtocal.setLength(length);</span><br><span class="line">            personProtocal.setContent(content);</span><br><span class="line">            ctx.writeAndFlush(personProtocal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, PersonProtocal msg) throws Exception &#123;</span><br><span class="line">        int length = msg.getLength();</span><br><span class="line">        byte[] content = msg.getContent();</span><br><span class="line">        System.out.println(&quot;客户端接收到的消息&quot;);</span><br><span class="line">        System.out.println(&quot;长度:&quot;+length);</span><br><span class="line">        System.out.println(&quot;消息内容:&quot;+new String(content,Charset.forName(&quot;utf-8&quot;)));</span><br><span class="line">        System.out.println(&quot;客户端接收到的消息数量:&quot;+(++this.count));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端启动程序Myclient：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Myclient &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        EventLoopGroup eventLoopGroup = new NioEventLoopGroup();</span><br><span class="line">        try &#123;</span><br><span class="line">            Bootstrap bootstrap = new Bootstrap();</span><br><span class="line">            bootstrap.group(eventLoopGroup).channel(NioSocketChannel.class).handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                protected void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">                    ChannelPipeline channelPipeline =  ch.pipeline();</span><br><span class="line">                    channelPipeline.addLast(new MyPersonDecoder());</span><br><span class="line">                    channelPipeline.addLast(new MyPersonEncoder());</span><br><span class="line">                    channelPipeline.addLast(new MyClientHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(&quot;localhost&quot;, 8899).sync();</span><br><span class="line">            channelFuture.channel().writeAndFlush(&quot;hello&quot;);</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            eventLoopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>整个流程：<br>客户端启动之后，向服务端发送了十条“sent from client”客户端经过编码器MyPersonEncoder发送出去， 然后服务端接收到之后先经过解码器MyPersonDecoder，解码成PersonProtocal实体，然后打印消息内容，服务端每接收到一条“sent from client”，紧接着向客户端发送一个uuid（讲过编码器MyPersonEncoder），之后客户端收到uuid，经过解码器MyPersonDecoder转换成PersonProtocal实体。<br>服务端打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyPersonDecoder decode invoked</span><br><span class="line">服务端接受到的数据：</span><br><span class="line">数据长度:16</span><br><span class="line">数据内容：sent from client</span><br><span class="line">服务端接收到的消息数量:1</span><br><span class="line">MyPersonEncoder encode invoked</span><br><span class="line">MyPersonDecoder decode invoked</span><br><span class="line">服务端接受到的数据：</span><br><span class="line">数据长度:16</span><br><span class="line">数据内容：sent from client</span><br><span class="line">服务端接收到的消息数量:2</span><br><span class="line">MyPersonEncoder encode invoked</span><br><span class="line">MyPersonDecoder decode invoked</span><br><span class="line">服务端接受到的数据：</span><br><span class="line">数据长度:16</span><br><span class="line">数据内容：sent from client</span><br><span class="line">服务端接收到的消息数量:3</span><br><span class="line">MyPersonEncoder encode invoked</span><br><span class="line">MyPersonDecoder decode invoked</span><br><span class="line">服务端接受到的数据：</span><br><span class="line">数据长度:16</span><br><span class="line">数据内容：sent from client</span><br><span class="line">服务端接收到的消息数量:4</span><br><span class="line">MyPersonEncoder encode invoked</span><br><span class="line">MyPersonDecoder decode invoked</span><br><span class="line">服务端接受到的数据：</span><br><span class="line">数据长度:16</span><br><span class="line">数据内容：sent from client</span><br><span class="line">服务端接收到的消息数量:5</span><br><span class="line">MyPersonEncoder encode invoked</span><br><span class="line">MyPersonDecoder decode invoked</span><br><span class="line">服务端接受到的数据：</span><br><span class="line">数据长度:16</span><br><span class="line">数据内容：sent from client</span><br><span class="line">服务端接收到的消息数量:6</span><br><span class="line">MyPersonEncoder encode invoked</span><br><span class="line">MyPersonDecoder decode invoked</span><br><span class="line">服务端接受到的数据：</span><br><span class="line">数据长度:16</span><br><span class="line">数据内容：sent from client</span><br><span class="line">服务端接收到的消息数量:7</span><br><span class="line">MyPersonEncoder encode invoked</span><br><span class="line">MyPersonDecoder decode invoked</span><br><span class="line">服务端接受到的数据：</span><br><span class="line">数据长度:16</span><br><span class="line">数据内容：sent from client</span><br><span class="line">服务端接收到的消息数量:8</span><br><span class="line">MyPersonEncoder encode invoked</span><br><span class="line">MyPersonDecoder decode invoked</span><br><span class="line">服务端接受到的数据：</span><br><span class="line">数据长度:16</span><br><span class="line">数据内容：sent from client</span><br><span class="line">服务端接收到的消息数量:9</span><br><span class="line">MyPersonEncoder encode invoked</span><br><span class="line">MyPersonDecoder decode invoked</span><br><span class="line">服务端接受到的数据：</span><br><span class="line">数据长度:16</span><br><span class="line">数据内容：sent from client</span><br><span class="line">服务端接收到的消息数量:10</span><br><span class="line">MyPersonEncoder encode invoked</span><br></pre></td></tr></table></figure>
<p>客户端打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyPersonEncoder encode invoked</span><br><span class="line">MyPersonEncoder encode invoked</span><br><span class="line">MyPersonEncoder encode invoked</span><br><span class="line">MyPersonEncoder encode invoked</span><br><span class="line">MyPersonEncoder encode invoked</span><br><span class="line">MyPersonEncoder encode invoked</span><br><span class="line">MyPersonEncoder encode invoked</span><br><span class="line">MyPersonEncoder encode invoked</span><br><span class="line">MyPersonEncoder encode invoked</span><br><span class="line">MyPersonEncoder encode invoked</span><br><span class="line">MyPersonDecoder decode invoked</span><br><span class="line">客户端接收到的消息</span><br><span class="line">长度:36</span><br><span class="line">消息内容:aeb03767-5b48-4c1b-ae08-2c643fa511f1</span><br><span class="line">客户端接收到的消息数量:1</span><br><span class="line">MyPersonDecoder decode invoked</span><br><span class="line">客户端接收到的消息</span><br><span class="line">长度:36</span><br><span class="line">消息内容:22a19d24-3a53-4954-af51-6d8a47a31412</span><br><span class="line">客户端接收到的消息数量:2</span><br><span class="line">MyPersonDecoder decode invoked</span><br><span class="line">客户端接收到的消息</span><br><span class="line">长度:36</span><br><span class="line">消息内容:0bb4cbff-8725-4aa1-b431-81d185639dd0</span><br><span class="line">客户端接收到的消息数量:3</span><br><span class="line">MyPersonDecoder decode invoked</span><br><span class="line">客户端接收到的消息</span><br><span class="line">长度:36</span><br><span class="line">消息内容:4770c9ec-8868-4253-a6be-632105bc677c</span><br><span class="line">客户端接收到的消息数量:4</span><br><span class="line">MyPersonDecoder decode invoked</span><br><span class="line">客户端接收到的消息</span><br><span class="line">长度:36</span><br><span class="line">消息内容:07562dc9-bde7-42bf-91b5-a964d320a4ab</span><br><span class="line">客户端接收到的消息数量:5</span><br><span class="line">MyPersonDecoder decode invoked</span><br><span class="line">客户端接收到的消息</span><br><span class="line">长度:36</span><br><span class="line">消息内容:08955003-5487-47a4-92c0-3fd6d636abbd</span><br><span class="line">客户端接收到的消息数量:6</span><br><span class="line">MyPersonDecoder decode invoked</span><br><span class="line">客户端接收到的消息</span><br><span class="line">长度:36</span><br><span class="line">消息内容:4e35d4d9-5780-46df-a78a-8bc0bf293e03</span><br><span class="line">客户端接收到的消息数量:7</span><br><span class="line">MyPersonDecoder decode invoked</span><br><span class="line">客户端接收到的消息</span><br><span class="line">长度:36</span><br><span class="line">消息内容:051d7e80-8e1c-4b0a-979e-9ab390c9d139</span><br><span class="line">客户端接收到的消息数量:8</span><br><span class="line">MyPersonDecoder decode invoked</span><br><span class="line">客户端接收到的消息</span><br><span class="line">长度:36</span><br><span class="line">消息内容:a220680e-852f-4525-9ec4-06f7912dcabe</span><br><span class="line">客户端接收到的消息数量:9</span><br><span class="line">MyPersonDecoder decode invoked</span><br><span class="line">客户端接收到的消息</span><br><span class="line">长度:36</span><br><span class="line">消息内容:64bf6571-e246-4f4e-89f5-afe609ccc4ed</span><br><span class="line">客户端接收到的消息数量:10</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>自定义协议 tcp粘包拆包问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>netty源码分析(五)Netty服务器地址绑定底层源码分析</title>
    <url>/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%94-Netty%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%B0%E5%9D%80%E7%BB%91%E5%AE%9A%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>AbstractBootstrapd的initAndRegister方法，完成 初始化和注册：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final ChannelFuture initAndRegister() &#123;</span><br><span class="line">       Channel channel = null;</span><br><span class="line">       try &#123;</span><br><span class="line">           channel = channelFactory.newChannel();//channelFactory是ReflectiveChannelFactory，ReflectiveChannelFactory</span><br><span class="line">           //内部的成员变量是NioServerSocketChannel.class，调用newChannel()即通过反射得到一个NioServerSocketChannel实体对象</span><br><span class="line">           //调用无参构造器。在接下来的NioServerSocketChannel介绍你会知道这句代码做了哪些事情，透剧一下：</span><br><span class="line">           //设置ServerSocketChannel的兴趣事件（初始状态都是SelectionKey.OP_ACCEPT）、ChannelId（唯一的一个编码）、</span><br><span class="line">           //设置ServerSocketChannel为非阻塞、初始化了ServerSocketChannel的pipline。</span><br><span class="line"></span><br><span class="line">           init(channel);//进入init方法。</span><br><span class="line">       &#125; catch (Throwable t) &#123;</span><br><span class="line">           if (channel != null) &#123;</span><br><span class="line">               // channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))</span><br><span class="line">               channel.unsafe().closeForcibly();</span><br><span class="line">           &#125;</span><br><span class="line">           // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span><br><span class="line">           return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">       if (regFuture.cause() != null) &#123;</span><br><span class="line">           if (channel.isRegistered()) &#123;</span><br><span class="line">               channel.close();</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               channel.unsafe().closeForcibly();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // If we are here and the promise is not failed, it&#x27;s one of the following cases:</span><br><span class="line">       // 1) If we attempted registration from the event loop, the registration has been completed at this point.</span><br><span class="line">       //    i.e. It&#x27;s safe to attempt bind() or connect() now because the channel has been registered.</span><br><span class="line">       // 2) If we attempted registration from the other thread, the registration request has been successfully</span><br><span class="line">       //    added to the event loop&#x27;s task queue for later execution.</span><br><span class="line">       //    i.e. It&#x27;s safe to attempt bind() or connect() now:</span><br><span class="line">       //         because bind() or connect() will be executed *after* the scheduled registration task is executed</span><br><span class="line">       //         because register(), bind(), and connect() are all bound to the same thread.</span><br><span class="line"></span><br><span class="line">       return regFuture;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>紧接着我们进入init方法，init方法是父类AbstractBootstrap的方法，我们到子类ServerBootstrap里边查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void init(Channel channel) throws Exception &#123;</span><br><span class="line">       final Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();//ServerBootstrap设置的option集合，是一个LinkedHashMap</span><br><span class="line">       synchronized (options) &#123;</span><br><span class="line">           setChannelOptions(channel, options, logger);//将options 集合放到channel（NioServerSocketChannel）里边</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       final Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();//ServerBootstrap设置的属性，也是一个LinkedHashMap</span><br><span class="line">       synchronized (attrs) &#123;</span><br><span class="line">           for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</span><br><span class="line">               @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">               AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</span><br><span class="line">               channel.attr(key).set(e.getValue());//设置到channel里边。</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ChannelPipeline p = channel.pipeline();//获取channel的对应的管道。</span><br><span class="line"></span><br><span class="line">       final EventLoopGroup currentChildGroup = childGroup;//MyServer实例程序中的workerGroup</span><br><span class="line">       final ChannelHandler currentChildHandler = childHandler;//MyServer实例程序中的MyServerInitializer</span><br><span class="line">       final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">       final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</span><br><span class="line">       synchronized (childOptions) &#123;</span><br><span class="line">           currentChildOptions = childOptions.entrySet().toArray(newOptionArray(childOptions.size()));</span><br><span class="line">       &#125;</span><br><span class="line">       synchronized (childAttrs) &#123;</span><br><span class="line">           currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(childAttrs.size()));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">       //ChannelInitializer</span><br><span class="line">           /**</span><br><span class="line">           This method will be called once the &#123;@link Channel&#125; was registered. After the method returns this instance</span><br><span class="line">           will be removed from the &#123;@link ChannelPipeline&#125; of the &#123;@link Channel&#125;.</span><br><span class="line">           当Channel被注册的时候当前方法会被调用，当方法返回的时候当前Channel的实例会被删除从ChannelPipeline当中。</span><br><span class="line">           */</span><br><span class="line">           public void initChannel(final Channel ch) throws Exception &#123;</span><br><span class="line">               final ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">               ChannelHandler handler = config.handler();//MyServer实例程序中的LoggingHandler</span><br><span class="line">               //LoggingHandler详见MyServer实例程序 http://blog.csdn.net/wzq6578702/article/details/77923602</span><br><span class="line">               if (handler != null) &#123;</span><br><span class="line">                   pipeline.addLast(handler);//如果ServerBootstrap的handler被设置过，把设置的Handler放到管道当中。</span><br><span class="line">                   //详见MyServer实例程序 http://blog.csdn.net/wzq6578702/article/details/77923602</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               ch.eventLoop().execute(new Runnable() &#123;//ch.eventLoop()得到是一个类似于线程池的东西</span><br><span class="line">                   @Override</span><br><span class="line">                   public void run() &#123;</span><br><span class="line">                       pipeline.addLast(new ServerBootstrapAcceptor(</span><br><span class="line">                               ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>另外还有一个重要的点，initAndRegister的channel 实例化：channel &#x3D; channelFactory.newChannel();是对NioServerSocketChannel<br>调用无参数的构造器通过反射实例化出来的，我们进入到NioServerSocketChannel无参构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class NioServerSocketChannel extends AbstractNioMessageChannel</span><br><span class="line">                             implements io.netty.channel.socket.ServerSocketChannel &#123;</span><br><span class="line">      private static final SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider();</span><br><span class="line">          private static ServerSocketChannel newSocket(SelectorProvider provider) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            /**</span><br><span class="line">             *  Use the &#123;@link SelectorProvider&#125; to open &#123;@link SocketChannel&#125; and so remove condition in</span><br><span class="line">             *  &#123;@link SelectorProvider#provider()&#125; which is called by each ServerSocketChannel.open() otherwise.</span><br><span class="line">             *</span><br><span class="line">             *  See &lt;a href=&quot;https://github.com/netty/netty/issues/2308&quot;&gt;#2308&lt;/a&gt;.</span><br><span class="line">             */</span><br><span class="line">            return provider.openServerSocketChannel();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new ChannelException(</span><br><span class="line">                    &quot;Failed to open a server socket.&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;             </span><br><span class="line">//SelectorProvider是jdk提供的一个提供Channel的提供者,java.nio.channels.DatagramChannel、java.nio.channels.Pipe</span><br><span class="line">// java.nio.channels.Selector、java.nio.channels.ServerSocketChannel等Channel都是通过SelectorProvider.provider()</span><br><span class="line">//打开一个通道，但是SelectorProvider.provider()是同步的（有synchronized）,netty为了适应在高并发的其工况下，这样的同步会造成性能</span><br><span class="line">//的损失，因此将SelectorProvider.provider()获得的SelectorProvider做成一个名字是DEFAULT_SELECTOR_PROVIDER 的常量，获得通道的时候</span><br><span class="line">//直接使用[ return provider.openServerSocketChannel();]类似这样的用法返回Channel，不会有同步加锁操作，提高了并发，有兴趣的可以看下</span><br><span class="line">//https://github.com/netty/netty/issues/2308 说明，为什么netty这样写。</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Create a new instance</span><br><span class="line">     * 无参构造器，主要获取ServerSocketChannel</span><br><span class="line">     */</span><br><span class="line">    public NioServerSocketChannel() &#123;</span><br><span class="line">        this(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">    &#125;              </span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Create a new instance using the given &#123;@link ServerSocketChannel&#125;.</span><br><span class="line">     * 设置ServerSocketChannel的兴趣事件（初始状态都是SelectionKey.OP_ACCEPT）、ChannelId（唯一的一个编码）、</span><br><span class="line">     * 设置ServerSocketChannel为非阻塞、初始化了ServerSocketChannel的pipline。</span><br><span class="line">     *</span><br><span class="line">     * config 对ServerSocketChannelConfig进行了赋值。</span><br><span class="line">     */</span><br><span class="line">    public NioServerSocketChannel(ServerSocketChannel channel) &#123;</span><br><span class="line">        super(null, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">        config = new NioServerSocketChannelConfig(this, javaChannel().socket());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;                     </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty服务器地址绑定</tag>
      </tags>
  </entry>
  <entry>
    <title>netty源码分析(六)Reactor模式透彻理解及其在Netty中的应用</title>
    <url>/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%85%AD-Reactor%E6%A8%A1%E5%BC%8F%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%9C%A8Netty%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>前边讲了EventLoopGroup的一些知识，在netty的架构这块我们使用一种bossGroup加workerGroup的方式，bossGroup只负责请求的转发，workerGroup是具体的数据处理，其实netty整个框架使用的是Reactor(响应器)的设计模式。这方面知名的大佬就是Doug Lea，Java.util.current包的很多线程的API和工具都出自大佬之手。<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%85%AD-Reactor%E6%A8%A1%E5%BC%8F%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%9C%A8Netty%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/20170923142146979.jpg" alt="这里写图片描述"></p>
<span id="more"></span>
<p>大佬的一片文章对这种模式做了非常细致的介绍,《<span class="exturl" data-url="aHR0cDovL2dlZS5jcy5vc3dlZ28uZWR1L2RsL2NwanNsaWRlcy9uaW8ucGRm">Scalable IO in Java<i class="fa fa-external-link-alt"></i></span>》<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%85%AD-Reactor%E6%A8%A1%E5%BC%8F%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%9C%A8Netty%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/20170923142426064.png" alt="这里写图片描述">  </p>
<p>大多数的网络服务都是下面的流程：<br>读取请求<br>对请求进行解码<br>处理服务（业务逻辑）<br>编码相应<br>发送响应<br>经典的io模式是这样的：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%85%AD-Reactor%E6%A8%A1%E5%BC%8F%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%9C%A8Netty%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/20170923142529241.png" alt="这里写图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Server implements Runnable &#123;</span><br><span class="line">	public void run() &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		ServerSocket ss = new ServerSocket(PORT);</span><br><span class="line">		while (!Thread.interrupted())</span><br><span class="line">			new Thread(new Handler(ss.accept())).start();</span><br><span class="line">		// or, single-threaded, or a thread pool</span><br><span class="line">	&#125; catch (IOException ex) &#123; /* ... */ &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	static class Handler implements Runnable &#123;</span><br><span class="line">		final Socket socket;</span><br><span class="line">		Handler(Socket s) &#123; socket = s; &#125;</span><br><span class="line">		public void run() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			byte[] input = new byte[MAX_INPUT];</span><br><span class="line">			socket.getInputStream().read(input);</span><br><span class="line">			byte[] output = process(input);</span><br><span class="line">			socket.getOutputStream().write(output);</span><br><span class="line">		&#125; catch (IOException ex) &#123; /* ... */ &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	private byte[] process(byte[] cmd) &#123; /* ... */ &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个请求开一个线程去处理。</p>
<p>这种方式不是一直能够好的做法，会有阻塞和瓶颈。接下来是Reactor Design的方式：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%85%AD-Reactor%E6%A8%A1%E5%BC%8F%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%9C%A8Netty%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/20170923143326543.png" alt="这里写图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Reactor implements Runnable &#123;</span><br><span class="line">	final Selector selector;</span><br><span class="line">	final ServerSocketChannel serverSocket;</span><br><span class="line">Reactor(int port) throws IOException &#123;</span><br><span class="line">	selector = Selector.open();</span><br><span class="line">	serverSocket = ServerSocketChannel.open();</span><br><span class="line">	serverSocket.socket().bind(new InetSocketAddress(port));</span><br><span class="line">	serverSocket.configureBlocking(false);</span><br><span class="line">	SelectionKey sk =serverSocket.register(selector,SelectionKey.OP_ACCEPT);</span><br><span class="line">	sk.attach(new Acceptor());</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">Alternatively, use explicit SPI provider:</span><br><span class="line">SelectorProvider p = SelectorProvider.provider();</span><br><span class="line">selector = p.openSelector();</span><br><span class="line">serverSocket = p.openServerSocketChannel();</span><br><span class="line">*/</span><br><span class="line">// class Reactor continued</span><br><span class="line">public void run() &#123; // normally in a newThread</span><br><span class="line">	try &#123;</span><br><span class="line">		while (!Thread.interrupted()) &#123;</span><br><span class="line">			selector.select();</span><br><span class="line">			Set selected = selector.selectedKeys();</span><br><span class="line">			Iterator it = selected.iterator();</span><br><span class="line">			while (it.hasNext())</span><br><span class="line">			dispatch((SelectionKey)(it.next());</span><br><span class="line">			selected.clear();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; catch (IOException ex) &#123; /* ... */ &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void dispatch(SelectionKey k) &#123;</span><br><span class="line">	Runnable r = (Runnable)(k.attachment());</span><br><span class="line">		if (r != null)</span><br><span class="line">		r.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Reactor 只负责请求的接受，和nio变成一样初始化注册的是OP_ACCEPT，然后绑定一个Acceptor（实现Runnable接口），主循环中，收到准备好的selectedKeys，并且遍历selectedKeys，将每一个keydispatch下去，在dispatch里边通过selectedKey得到绑定的Acceptor,看一下Acceptor的逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// class Reactor continued</span><br><span class="line">class Acceptor implements Runnable &#123; // inner</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">		SocketChannel c = serverSocket.accept();</span><br><span class="line">		if (c != null)</span><br><span class="line">		new Handler(selector, c);</span><br><span class="line">		&#125;catch(IOException ex) &#123; /* ... */ &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final class Handler implements Runnable &#123;</span><br><span class="line">	final SocketChannel socket;</span><br><span class="line">	final SelectionKey sk;</span><br><span class="line">	ByteBuffer input = ByteBuffer.allocate(MAXIN);</span><br><span class="line">	ByteBuffer output = ByteBuffer.allocate(MAXOUT);</span><br><span class="line">	static final int READING = 0, SENDING = 1;</span><br><span class="line">	int state = READING;</span><br><span class="line">	Handler(Selector sel, SocketChannel c)</span><br><span class="line">		throws IOException &#123;</span><br><span class="line">		socket = c; c.configureBlocking(false);</span><br><span class="line">		// Optionally try first read now</span><br><span class="line">		sk = socket.register(sel, 0);</span><br><span class="line">		sk.attach(this);</span><br><span class="line">		sk.interestOps(SelectionKey.OP_READ);</span><br><span class="line">		sel.wakeup();//注册OP_READ兴趣之后，让select()方法返回，接受要读取的数据</span><br><span class="line">	&#125;</span><br><span class="line">	boolean inputIsComplete() &#123; /* ... */ &#125;</span><br><span class="line">	boolean outputIsComplete() &#123; /* ... */ &#125;</span><br><span class="line">	void process() &#123; /* ... */ &#125;</span><br><span class="line"></span><br><span class="line">// class Handler continued</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			if (state == READING) read();</span><br><span class="line">			else if (state == SENDING) send();</span><br><span class="line">		&#125; catch (IOException ex) &#123; /* ... */ &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	void read() throws IOException &#123;</span><br><span class="line">	socket.read(input);</span><br><span class="line">		if (inputIsComplete()) &#123;</span><br><span class="line">			process();</span><br><span class="line">			state = SENDING;</span><br><span class="line">			// Normally also do first write now</span><br><span class="line">			sk.interestOps(SelectionKey.OP_WRITE);//将状态变为SENDING之后，接下来就是往外写数据，对写感兴趣。</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	void send() throws IOException &#123;</span><br><span class="line">		socket.write(output);</span><br><span class="line">		if (outputIsComplete()) sk.cancel();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>Acceptor 获得SocketChannel接着进入到实际的处理类Handler里边，Handler有SocketChannel	和SelectionKey的引用，Handler的构造器将当前类（Handler）加入到绑定里边，并且对READ感兴趣，之后调sel.wakeup()意思是让select( )方法立刻返回，如果当前没有select()方法阻塞的话，那么下一次调用select()会立即返回，然后执行run()方法，是通过判断状态的方式来决定是写还是读 ，这个在Netty3中就是需要这样实现handler代码的，需要自己判断状态来决定业务逻辑。Netty4已经改成各种回调了，比如channelRead，channelActive等。<br>：’<br>文档接着介绍了 基于模式的设计，提前绑定合适的handler作为attachment：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//A simple use of GoF State-Object pattern</span><br><span class="line">//Rebind appropriate handler as attachment</span><br><span class="line">class Handler &#123; // ...</span><br><span class="line">	public void run() &#123; // initial state is reader</span><br><span class="line">		socket.read(input);</span><br><span class="line">		if (inputIsComplete()) &#123;</span><br><span class="line">		process();</span><br><span class="line">		sk.attach(new Sender());//绑定UI个发送者。</span><br><span class="line">		sk.interest(SelectionKey.OP_WRITE);//由于发送者是写操作，因此兴趣是OP_WRITE</span><br><span class="line">		sk.selector().wakeup();//让select方法立刻返回，执行写的逻辑。</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Sender implements Runnable &#123;</span><br><span class="line">	public void run()&#123; // ...</span><br><span class="line">		socket.write(output);</span><br><span class="line">		if (outputIsComplete()) sk.cancel();</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着是handler基于线程池的实现：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%85%AD-Reactor%E6%A8%A1%E5%BC%8F%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%9C%A8Netty%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/20170923160427112.png" alt="这里写图片描述"></p>
<p>这个版本是对于handler的减压，接着多个selector的Reactor：</p>
<p><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%85%AD-Reactor%E6%A8%A1%E5%BC%8F%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%9C%A8Netty%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/20170923161803582.png" alt="这里写图片描述"><br>mainReactor相当于bossGroup,subReactorx 相当于netty里边的workerGroup.整个过程下来其实就是netty的 框架内在的模式。</p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>Reactor模式 netty的异步</tag>
      </tags>
  </entry>
  <entry>
    <title>netty源码分析(八)Netty的自适应缓冲区分配策略与堆外内存创建方式</title>
    <url>/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%85%AB-Netty%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E7%BC%93%E5%86%B2%E5%8C%BA%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%E4%B8%8E%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>我们总结一下netty的模式：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%85%AB-Netty%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E7%BC%93%E5%86%B2%E5%8C%BA%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%E4%B8%8E%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/20170923212403693.png" alt="这里写图片描述"></p>
<span id="more"></span>

<p>bossGroup将得到的selectedKyes中的socketchannel接收到，然后封装成NioServerSocketChannel,NioServerSocketChannel注册到workerGroup里边，最后客户端直接和workerGroup 里边的NioServerSocketChannel通信交换信息，即bossGroup负责派发，workerGroup 负责真正数据的处理。</p>
<p>我们在处理实际的业务数据的时候，一般是在handler里边的方法去实现业务逻辑:<br>channelRead0这个方法肯定是被netty框架回调&#x3D;被执行，但是我们的业务逻辑如果复杂，整个channelRead0需要执行很长时间，虽然netty性能很高，但是过长时间的业务处理使得整体速度变慢，对于这种情况，我们需要建立一个业务的线程组放在channelRead0里边，做成异步的处理，处理完毕用 channel写回到客户端处理结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyServerHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception &#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress()+&quot; --&gt; &quot;+msg);</span><br><span class="line">        ctx.channel().writeAndFlush(&quot;from server : &quot;+ UUID.randomUUID());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后下一个知识点是关于缓冲区的申请是怎么回事、<br>回到NioServerSocketChannel:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Create a new instance</span><br><span class="line">    * 默认构造器</span><br><span class="line">    */</span><br><span class="line">   public NioServerSocketChannel() &#123;</span><br><span class="line">       this(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * Create a new instance using the given &#123;@link ServerSocketChannel&#125;.</span><br><span class="line">    * 默认构造器调用带ServerSocketChannel参数的构造器</span><br><span class="line">    */</span><br><span class="line">   public NioServerSocketChannel(ServerSocketChannel channel) &#123;</span><br><span class="line">       super(null, channel, SelectionKey.OP_ACCEPT);//这一部分之前我们讲解过，不做介绍。</span><br><span class="line">       config = new NioServerSocketChannelConfig(this, javaChannel().socket());</span><br><span class="line">       //javaChannel()  是ServerSocketChannel，javaChannel().socket()就是一个ServerSocketChannel得到的ServerSocket。</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   //获取无参构造器设置的ServerSocketChannel</span><br><span class="line">   protected ServerSocketChannel javaChannel() &#123;</span><br><span class="line">       return (ServerSocketChannel) super.javaChannel();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">//紧接着进入NioServerSocketChannelConfig的构造器，NioServerSocketChannelConfig是NioServerSocketChannel的内部类。</span><br><span class="line">   private final class NioServerSocketChannelConfig extends DefaultServerSocketChannelConfig &#123;</span><br><span class="line">       private NioServerSocketChannelConfig(NioServerSocketChannel channel, ServerSocket javaSocket) &#123;</span><br><span class="line">           super(channel, javaSocket);//调用DefaultServerSocketChannelConfig的构造器</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       protected void autoReadCleared() &#123;</span><br><span class="line">           clearReadPending();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>进入DefaultServerSocketChannelConfig的构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultServerSocketChannelConfig extends DefaultChannelConfig</span><br><span class="line">                                              implements ServerSocketChannelConfig&#123;</span><br><span class="line">    ....略</span><br><span class="line">    public DefaultServerSocketChannelConfig(ServerSocketChannel channel, ServerSocket javaSocket) &#123;</span><br><span class="line">        super(channel);//进入DefaultChannelConfig的构造器</span><br><span class="line">        if (javaSocket == null) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;javaSocket&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.javaSocket = javaSocket;</span><br><span class="line">    &#125;</span><br><span class="line">     ....略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DefaultChannelConfig构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public DefaultChannelConfig(Channel channel) &#123;</span><br><span class="line">    this(channel, new AdaptiveRecvByteBufAllocator());//Channel是NioServerSocketChannel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里见到一个新的类AdaptiveRecvByteBufAllocator，适配的字节缓冲器，进去看看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The &#123;@link RecvByteBufAllocator&#125; that automatically increases and</span><br><span class="line"> * decreases the predicted buffer size on feed back.</span><br><span class="line"> * &lt;p&gt;RecvByteBufAllocator是一个对buffer的大小根据反馈自动自动增长或者减少的这么一个类。</span><br><span class="line"> * It gradually increases the expected number of readable bytes if the previous</span><br><span class="line"> * read fully filled the allocated buffer.  It gradually decreases the expected</span><br><span class="line"> * number of readable bytes if the read operation was not able to fill a certain</span><br><span class="line"> * amount of the allocated buffer two times consecutively.  Otherwise, it keeps</span><br><span class="line"> * returning the same prediction.</span><br><span class="line"> * 如果前一次的缓冲区的申请大小满了，那么本次会自动增加容量，同样的道理如果上2次没有填满，那么本次的容量会减少。</span><br><span class="line"> * */</span><br><span class="line">public class AdaptiveRecvByteBufAllocator extends DefaultMaxMessagesRecvByteBufAllocator &#123;</span><br><span class="line"></span><br><span class="line">    static final int DEFAULT_MINIMUM = 64;</span><br><span class="line">    static final int DEFAULT_INITIAL = 1024;</span><br><span class="line">    static final int DEFAULT_MAXIMUM = 65536;</span><br><span class="line"></span><br><span class="line">    private static final int INDEX_INCREMENT = 4;</span><br><span class="line">    private static final int INDEX_DECREMENT = 1;</span><br><span class="line"></span><br><span class="line">    private static final int[] SIZE_TABLE;</span><br><span class="line"></span><br><span class="line">    //静态代码块的作用是对SIZE_TABLE数组填写1~38的坐标的值是16，32，48....一直到65536</span><br><span class="line">    //自动减少或者增加的幅度就是来自于这个数组。具体逻辑在HandleImpl对的record方法。</span><br><span class="line">    static &#123;</span><br><span class="line">        List&lt;Integer&gt; sizeTable = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        for (int i = 16; i &lt; 512; i += 16) &#123;</span><br><span class="line">            sizeTable.add(i);//1~16的设置是16到（512-16）</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 512; i &gt; 0; i &lt;&lt;= 1) &#123;</span><br><span class="line">            sizeTable.add(i);//从512到65536</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SIZE_TABLE = new int[sizeTable.size()];</span><br><span class="line">        for (int i = 0; i &lt; SIZE_TABLE.length; i ++) &#123;</span><br><span class="line">            SIZE_TABLE[i] = sizeTable.get(i);//填写到SIZE_TABLE数组</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates a new predictor with the default parameters.  With the default</span><br><span class="line">     * parameters, the expected buffer size starts from &#123;@code 1024&#125;, does not</span><br><span class="line">     * go down below &#123;@code 64&#125;, and does not go up above &#123;@code 65536&#125;.</span><br><span class="line">     */</span><br><span class="line">    public AdaptiveRecvByteBufAllocator() &#123;</span><br><span class="line">        this(DEFAULT_MINIMUM, DEFAULT_INITIAL, DEFAULT_MAXIMUM);//默认是是DEFAULT_MINIMUM（也是最小值，即64）</span><br><span class="line">        //初始大小DEFAULT_INITIAL（即1024），最大值是DEFAULT_MAXIMUM（即65536）</span><br><span class="line">    &#125;</span><br><span class="line">.....略。。。</span><br><span class="line">    private final class HandleImpl extends MaxMessageHandle &#123;</span><br><span class="line">        private final int minIndex;</span><br><span class="line">        private final int maxIndex;</span><br><span class="line">        private int index;</span><br><span class="line">        private int nextReceiveBufferSize;</span><br><span class="line">        private boolean decreaseNow;</span><br><span class="line"></span><br><span class="line">        public HandleImpl(int minIndex, int maxIndex, int initial) &#123;</span><br><span class="line">            this.minIndex = minIndex;</span><br><span class="line">            this.maxIndex = maxIndex;</span><br><span class="line"></span><br><span class="line">            index = getSizeTableIndex(initial);</span><br><span class="line">            nextReceiveBufferSize = SIZE_TABLE[index];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        //得到预测值</span><br><span class="line">        public int guess() &#123;</span><br><span class="line">            return nextReceiveBufferSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       //计算预测值</span><br><span class="line">        private void record(int actualReadBytes) &#123;</span><br><span class="line">            if (actualReadBytes &lt;= SIZE_TABLE[Math.max(0, index - INDEX_DECREMENT - 1)]) &#123;</span><br><span class="line">                if (decreaseNow) &#123;</span><br><span class="line">                    index = Math.max(index - INDEX_DECREMENT, minIndex);</span><br><span class="line">                    nextReceiveBufferSize = SIZE_TABLE[index];</span><br><span class="line">                    decreaseNow = false;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    decreaseNow = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (actualReadBytes &gt;= nextReceiveBufferSize) &#123;</span><br><span class="line">                index = Math.min(index + INDEX_INCREMENT, maxIndex);</span><br><span class="line">                nextReceiveBufferSize = SIZE_TABLE[index];</span><br><span class="line">                decreaseNow = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void readComplete() &#123;</span><br><span class="line">            record(totalBytesRead());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ....略...</span><br></pre></td></tr></table></figure>

<p>我们进入HandleImpl 的父类MaxMessageHandle 之中，里边有一个申请缓冲区的重要方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ByteBuf allocate(ByteBufAllocator alloc) &#123;</span><br><span class="line">    return alloc.ioBuffer(guess());//guess()方法得到预测值，用来设置当前缓冲区的大小</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>alloc.ioBuffer(）有很多实现方法，我们拿AbstractByteBufAllocator举例。<br>进入AbstractByteBufAllocator：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line"> PlatformDependent.hasUnsafe()会根据是否存在io.netty.noUnsafe配置返回boolean,如果是android系统返回false。</span><br><span class="line"> */</span><br><span class="line">public ByteBuf ioBuffer(int initialCapacity) &#123;</span><br><span class="line">    if (PlatformDependent.hasUnsafe()) &#123;</span><br><span class="line">        return directBuffer(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    return heapBuffer(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下directBuffer（）方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ByteBuf directBuffer(int initialCapacity) &#123;</span><br><span class="line">    return directBuffer(initialCapacity, DEFAULT_MAX_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续钻：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ByteBuf directBuffer(int initialCapacity, int maxCapacity) &#123;</span><br><span class="line">    if (initialCapacity == 0 &amp;&amp; maxCapacity == 0) &#123;</span><br><span class="line">        return emptyBuf;</span><br><span class="line">    &#125;</span><br><span class="line">    validate(initialCapacity, maxCapacity);</span><br><span class="line">    return newDirectBuffer(initialCapacity, maxCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于中间调用链比较长，不在列举，最后我们会找到我们熟悉的nio的API：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected ByteBuffer allocateDirect(int initialCapacity) &#123;</span><br><span class="line">    return ByteBuffer.allocateDirect(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即netty最终是用nio的ByteBuffer申请的直接内存。<br>同样的道理，堆内内存的申请也是如此：<br>heapBuffer(initialCapacity)方法最终的调用是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte[] allocateArray(int initialCapacity) &#123;</span><br><span class="line">    return new byte[initialCapacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于是堆内内存直接是返回一个数组。</p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>自适应缓冲区分配策略 堆外内存创建</tag>
      </tags>
  </entry>
  <entry>
    <title>netty源码分析(十)ChannelPipeline创建时机与高级拦截过滤器模式的运用</title>
    <url>/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81-ChannelPipeline%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA%E4%B8%8E%E9%AB%98%E7%BA%A7%E6%8B%A6%E6%88%AA%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%BF%90%E7%94%A8/</url>
    <content><![CDATA[<p>ChannelPipeline的创建时机：<br>我们从服务端的入口main程序开始：</p>
<span id="more"></span>
<p>1、</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ChannelFuture channelFuture = serverBootstrap.bind(8899).sync();</span><br></pre></td></tr></table></figure>
<p>2、<br>AbstractBootstrap:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ChannelFuture bind(SocketAddress localAddress) &#123;</span><br><span class="line">    validate();</span><br><span class="line">    if (localAddress == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;localAddress&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return doBind(localAddress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、AbstractBootstrap</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">....略</span><br><span class="line">    private ChannelFuture doBind(final SocketAddress localAddress) &#123;</span><br><span class="line">        final ChannelFuture regFuture = initAndRegister();</span><br><span class="line">        final Channel channel = regFuture.channel();</span><br><span class="line">....略</span><br></pre></td></tr></table></figure>

<p>4、AbstractBootstrap</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">....略</span><br><span class="line">    final ChannelFuture initAndRegister() &#123;</span><br><span class="line">        Channel channel = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            channel = channelFactory.newChannel();//前边章节说过这个channel 是NioServerSocketChannel通过反射new出来的</span><br><span class="line">            init(channel);//init方法内部会直接调用ChannelPipeline p = channel.pipeline();，即NioServerSocketChannel</span><br><span class="line">            //实例化的时候构建了ChannelPipeline</span><br><span class="line">                        ....略</span><br></pre></td></tr></table></figure>
<p>5、进入NioServerSocketChannel的构造器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public NioServerSocketChannel() &#123;</span><br><span class="line">      this(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>6、NioServerSocketChannel重载构造器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Create a new instance using the given &#123;@link ServerSocketChannel&#125;.</span><br><span class="line"> */</span><br><span class="line">public NioServerSocketChannel(ServerSocketChannel channel) &#123;</span><br><span class="line">    super(null, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">    config = new NioServerSocketChannelConfig(this, javaChannel().socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7、进入super 类 AbstractNioMessageChannel的构造器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected AbstractNioMessageChannel(Channel parent, SelectableChannel ch, int readInterestOp) &#123;</span><br><span class="line">     super(parent, ch, readInterestOp);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>8、进入super类AbstractNioChannel的构造器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected AbstractNioChannel(Channel parent, SelectableChannel ch, int readInterestOp) &#123;</span><br><span class="line">    super(parent);</span><br><span class="line">    this.ch = ch;</span><br><span class="line">    this.readInterestOp = readInterestOp;</span><br><span class="line">    try &#123;</span><br><span class="line">        ch.configureBlocking(false);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ch.close();</span><br><span class="line">        &#125; catch (IOException e2) &#123;</span><br><span class="line">            if (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(</span><br><span class="line">                        &quot;Failed to close a partially initialized socket.&quot;, e2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        throw new ChannelException(&quot;Failed to enter non-blocking mode.&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>9、进入super类AbstractChannel的构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected AbstractChannel(Channel parent) &#123;</span><br><span class="line">    this.parent = parent;</span><br><span class="line">    id = newId();</span><br><span class="line">    unsafe = newUnsafe();</span><br><span class="line">    pipeline = newChannelPipeline();//ChannelPipeline被实例化</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10、进入newChannelPipeline的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected DefaultChannelPipeline newChannelPipeline() &#123;</span><br><span class="line">    return new DefaultChannelPipeline(this);//返回的是一个DefaultChannelPipeline，并且DefaultChannelPipeline持有</span><br><span class="line">    //AbstractChannel的引用，即Channel的引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>11、进入DefaultChannelPipeline的构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultChannelPipeline implements ChannelPipeline &#123;</span><br><span class="line">...略</span><br><span class="line">    final AbstractChannelHandlerContext head;</span><br><span class="line">    final AbstractChannelHandlerContext tail;</span><br><span class="line">    private final Channel channel;//ChannelPipeline 持有Channel的引用</span><br><span class="line">...略</span><br><span class="line">    protected DefaultChannelPipeline(Channel channel) &#123;</span><br><span class="line">        this.channel = ObjectUtil.checkNotNull(channel, &quot;channel&quot;);//给DefaultChannelPipeline的Channel引用赋值。</span><br><span class="line">        succeededFuture = new SucceededChannelFuture(channel, null);</span><br><span class="line">        voidPromise =  new VoidChannelPromise(channel, true);</span><br><span class="line"></span><br><span class="line">        tail = new TailContext(this);//构造尾结点</span><br><span class="line">        head = new HeadContext(this);//构造头结点</span><br><span class="line">        //组成链表</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">...略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到Channel所有的ChannelPipeline组成了一个链表的形式，回想我们之前分析的ServerBootstrap类的启动初始化过程的init方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void init(Channel channel) throws Exception &#123;</span><br><span class="line"> ChannelPipeline p = channel.pipeline();</span><br><span class="line"> p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void initChannel(final Channel ch) throws Exception &#123;</span><br><span class="line">               final ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">               ChannelHandler handler = config.handler();</span><br><span class="line">               if (handler != null) &#123;</span><br><span class="line">                   pipeline.addLast(handler);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               ch.eventLoop().execute(new Runnable() &#123;</span><br><span class="line">                   @Override</span><br><span class="line">                   public void run() &#123;</span><br><span class="line">                       pipeline.addLast(new ServerBootstrapAcceptor(</span><br><span class="line">                               ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>
<p>当拿到ChannelPipeline 之后，紧接着会在链表上添加一个ChannelInitializer，以及我们开发者自己写的Initializer，都是在链表上执行add方法，加入到链表里边：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">        ChannelPipeline pipline = ch.pipeline();</span><br><span class="line">        pipline.addLast(new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,0,4,0,4));</span><br><span class="line">        pipline.addLast(new LengthFieldPrepender(4));</span><br><span class="line">        pipline.addLast(new StringDecoder(CharsetUtil.UTF_8));</span><br><span class="line">        pipline.addLast(new StringEncoder(CharsetUtil.UTF_8));</span><br><span class="line">        pipline.addLast(new MyServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们有必要看一下ChannelPipeline的doc：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A list of &#123;@link ChannelHandler&#125;s which handles or intercepts inbound events and outbound operations of a</span><br><span class="line"> * &#123;@link Channel&#125;.  &#123;@link ChannelPipeline&#125; implements an advanced form of the</span><br><span class="line"> * &lt;a href=&quot;http://www.oracle.com/technetwork/java/interceptingfilter-142169.html&quot;&gt;Intercepting Filter&lt;/a&gt; pattern</span><br><span class="line"> * to give a user full control over how an event is handled and how the &#123;@link ChannelHandler&#125;s in a pipeline</span><br><span class="line"> * interact with each other.</span><br><span class="line">ChannelPipeline是一个处理或者拦截Channel的出栈事件或者入栈操作的ChannelHandler列表，</span><br><span class="line">ChannelPipeline实现了一种高效的拦截过滤器模式的形式来让用户完全控制一个事件怎样处理</span><br><span class="line">和pipeline的ChannelHandler怎样和其他ChannelHandler交互。</span><br><span class="line"> * &lt;h3&gt;Creation of a pipeline&lt;/h3&gt;</span><br><span class="line"> * Each channel has its own pipeline and it is created automatically when a new channel is created.</span><br><span class="line"> * 每一个channel 都有自己的pipeline，就是在channel 创建的时候自动创建一个pipeline</span><br><span class="line"> * &lt;h3&gt;How an event flows in a pipeline&lt;/h3&gt;</span><br><span class="line"> * 一个事件是怎样在pipeline流动的。</span><br><span class="line"> * The following diagram describes how I/O events are processed by &#123;@link ChannelHandler&#125;s in a &#123;@link ChannelPipeline&#125;</span><br><span class="line"> * typically. An I/O event is handled by either a &#123;@link ChannelInboundHandler&#125; or a &#123;@link ChannelOutboundHandler&#125;</span><br><span class="line"> * and be forwarded to its closest handler by calling the event propagation methods defined in</span><br><span class="line"> * &#123;@link ChannelHandlerContext&#125;, such as &#123;@link ChannelHandlerContext#fireChannelRead(Object)&#125; and</span><br><span class="line"> * &#123;@link ChannelHandlerContext#write(Object)&#125;.</span><br><span class="line"> * 下面的图描述了一个I/O事件一般是怎样在ChannelPipeline里的ChannelHandler处理的，</span><br><span class="line"> * 一个I/O事件要么被ChannelInboundHandler处理，要么</span><br><span class="line"> * 里边的事件传播方法转发给最近的一个处理器，比如ChannelHandlerContext#fireChannelRead(Object)</span><br><span class="line"> * 和ChannelHandlerContext#write(Object)。</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> *                                                 I/O Request</span><br><span class="line"> *                                            via &#123;@link Channel&#125; or</span><br><span class="line"> *                                        &#123;@link ChannelHandlerContext&#125;</span><br><span class="line"> *                                                      |</span><br><span class="line"> *  +---------------------------------------------------+---------------+</span><br><span class="line"> *  |                           ChannelPipeline         |               |</span><br><span class="line"> *  |                                                  \|/              |</span><br><span class="line"> *  |    +---------------------+            +-----------+----------+    |</span><br><span class="line"> *  |    | Inbound Handler  N  |            | Outbound Handler  1  |    |</span><br><span class="line"> *  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line"> *  |              /|\                                  |               |</span><br><span class="line"> *  |               |                                  \|/              |</span><br><span class="line"> *  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line"> *  |    | Inbound Handler N-1 |            | Outbound Handler  2  |    |</span><br><span class="line"> *  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line"> *  |              /|\                                  .               |</span><br><span class="line"> *  |               .                                   .               |</span><br><span class="line"> *  | ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|</span><br><span class="line"> *  |        [ method call]                       [method call]         |</span><br><span class="line"> *  |               .                                   .               |</span><br><span class="line"> *  |               .                                  \|/              |</span><br><span class="line"> *  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line"> *  |    | Inbound Handler  2  |            | Outbound Handler M-1 |    |</span><br><span class="line"> *  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line"> *  |              /|\                                  |               |</span><br><span class="line"> *  |               |                                  \|/              |</span><br><span class="line"> *  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line"> *  |    | Inbound Handler  1  |            | Outbound Handler  M  |    |</span><br><span class="line"> *  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line"> *  |              /|\                                  |               |</span><br><span class="line"> *  +---------------+-----------------------------------+---------------+</span><br><span class="line"> *                  |                                  \|/</span><br><span class="line"> *  +---------------+-----------------------------------+---------------+</span><br><span class="line"> *  |               |                                   |               |</span><br><span class="line"> *  |       [ Socket.read() ]                    [ Socket.write() ]     |</span><br><span class="line"> *  |                                                                   |</span><br><span class="line"> *  |  Netty Internal I/O Threads (Transport Implementation)            |</span><br><span class="line"> *  +-------------------------------------------------------------------+</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line">通过上图可以看到入栈的和出栈的处理器互不干扰。</span><br><span class="line"> * An inbound event is handled by the inbound handlers in the bottom-up direction as shown on the left side of the</span><br><span class="line"> * diagram.  An inbound handler usually handles the inbound data generated by the I/O thread on the bottom of the</span><br><span class="line"> * diagram.  The inbound data is often read from a remote peer via the actual input operation such as</span><br><span class="line"> * &#123;@link SocketChannel#read(ByteBuffer)&#125;.  If an inbound event goes beyond the top inbound handler, it is discarded</span><br><span class="line"> * silently, or logged if it needs your attention.</span><br><span class="line"> * 在左图，一个入栈事件是从下到上的顺序被绑定的处理器处理的，一个入栈处理器通常处理从I/O线程生成的数据，</span><br><span class="line"> * 这些入栈数据一般是从远程实际的操作</span><br><span class="line"> *  它将会被悄无声息的丢弃，或者需要的话使用日志</span><br><span class="line"> * 记录下来。</span><br><span class="line"> * * &lt;p&gt;</span><br><span class="line"> * An outbound event is handled by the outbound handler in the top-down direction as shown on the right side of the</span><br><span class="line"> * diagram.  An outbound handler usually generates or transforms the outbound traffic such as write requests.</span><br><span class="line"> * If an outbound event goes beyond the bottom outbound handler, it is handled by an I/O thread associated with the</span><br><span class="line"> * &#123;@link Channel&#125;. The I/O thread often performs the actual output operation such as</span><br><span class="line"> * &#123;@link SocketChannel#write(ByteBuffer)&#125;.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 右图，一个出栈事件会被出栈处理器处理，一个出栈处理器生成或者传输出栈数据，比如写请求，</span><br><span class="line"> * 如果一个出栈事件超出最底层的处理器，那么他将会被I/O</span><br><span class="line"> * 线程处理，与其关联的SocketChannel#write(ByteBuffer)操作。</span><br><span class="line">  * For example, let us assume that we created the following pipeline:</span><br><span class="line">  * 加入我们假设创建了如下的pipeline</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> * &#123;@link ChannelPipeline&#125; p = ...;</span><br><span class="line"> * p.addLast(&quot;1&quot;, new InboundHandlerA());//入栈处理器</span><br><span class="line"> * p.addLast(&quot;2&quot;, new InboundHandlerB());//入栈处理器</span><br><span class="line"> * p.addLast(&quot;3&quot;, new OutboundHandlerA());//出栈处理器</span><br><span class="line"> * p.addLast(&quot;4&quot;, new OutboundHandlerB());//出栈处理器</span><br><span class="line"> * p.addLast(&quot;5&quot;, new InboundOutboundHandlerX());//既是入栈又是出栈处理器</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">  * In the example above, the class whose name starts with &#123;@code Inbound&#125; means it is an inbound handler.</span><br><span class="line"> * The class whose name starts with &#123;@code Outbound&#125; means it is a outbound handler.</span><br><span class="line"> * 在前边提到的例子中，以Inbound开头的都是入栈处理器，以Outbound开头的都是出栈处理器。</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * In the given example configuration, the handler evaluation order is 1, 2, 3, 4, 5 when an event goes inbound.</span><br><span class="line"> * When an event goes outbound, the order is 5, 4, 3, 2, 1.  On top of this principle, &#123;@link ChannelPipeline&#125; skips</span><br><span class="line"> * the evaluation of certain handlers to shorten the stack depth:</span><br><span class="line">根据上边的原理，ChannelPipeline会忽略掉某些处理器来减</span><br><span class="line"> * 栈的深度。</span><br><span class="line"> * &lt;ul&gt;</span><br><span class="line"> * &lt;li&gt;3 and 4 don&#x27;t implement &#123;@link ChannelInboundHandler&#125;, and therefore the actual evaluation order of an inbound</span><br><span class="line"> *     event will be: 1, 2, and 5.&lt;/li&gt;</span><br><span class="line"> * 3和4没有实现ChannelInboundHandler，因此实际的入栈顺序是1, 2, 5</span><br><span class="line"> * &lt;li&gt;1 and 2 don&#x27;t implement &#123;@link ChannelOutboundHandler&#125;, and therefore the actual evaluation order of a</span><br><span class="line"> *     outbound event will be: 5, 4, and 3.&lt;/li&gt;</span><br><span class="line"> * 1和2没有实现ChannelOutboundHandler，因此出栈顺序是 5, 4, 3</span><br><span class="line"> * &lt;li&gt;If 5 implements both &#123;@link ChannelInboundHandler&#125; and &#123;@link ChannelOutboundHandler&#125;, the evaluation order of</span><br><span class="line"> *     an inbound and a outbound event could be 125 and 543 respectively.&lt;/li&gt;</span><br><span class="line"> * 5实现了ChannelInboundHandler和ChannelOutboundHandler，出栈和入栈都包含5。只是一个在结尾，一个在开头。</span><br><span class="line"> * &lt;/ul&gt;</span><br><span class="line"> * &lt;h3&gt;Forwarding an event to the next handler&lt;/h3&gt;</span><br><span class="line"> * 将事件转发给下一个处理器。</span><br><span class="line"> * As you might noticed in the diagram shows, a handler has to invoke the event propagation methods in</span><br><span class="line"> * &#123;@link ChannelHandlerContext&#125; to forward an event to its next handler.  Those methods include:</span><br><span class="line"> * 你可能在图中可以看到，一个处理器调用ChannelHandlerContext的事件传播方法转发给下一个处理器，这些方法包括：</span><br><span class="line"> * &lt;ul&gt;</span><br><span class="line"> * &lt;li&gt;Inbound event propagation methods:</span><br><span class="line"> *    入栈事件传播方法</span><br><span class="line"> *     &lt;ul&gt;</span><br><span class="line"> *     &lt;li&gt;&#123;@link ChannelHandlerContext#fireChannelRegistered()&#125;&lt;/li&gt;</span><br><span class="line"> *     &lt;li&gt;&#123;@link ChannelHandlerContext#fireChannelActive()&#125;&lt;/li&gt;</span><br><span class="line"> *     &lt;li&gt;&#123;@link ChannelHandlerContext#fireChannelRead(Object)&#125;&lt;/li&gt;</span><br><span class="line"> *     &lt;li&gt;&#123;@link ChannelHandlerContext#fireChannelReadComplete()&#125;&lt;/li&gt;</span><br><span class="line"> *     &lt;li&gt;&#123;@link ChannelHandlerContext#fireExceptionCaught(Throwable)&#125;&lt;/li&gt;</span><br><span class="line"> *     &lt;li&gt;&#123;@link ChannelHandlerContext#fireUserEventTriggered(Object)&#125;&lt;/li&gt;</span><br><span class="line"> *     &lt;li&gt;&#123;@link ChannelHandlerContext#fireChannelWritabilityChanged()&#125;&lt;/li&gt;</span><br><span class="line"> *     &lt;li&gt;&#123;@link ChannelHandlerContext#fireChannelInactive()&#125;&lt;/li&gt;</span><br><span class="line"> *     &lt;li&gt;&#123;@link ChannelHandlerContext#fireChannelUnregistered()&#125;&lt;/li&gt;</span><br><span class="line"> *     &lt;/ul&gt;</span><br><span class="line"> * &lt;/li&gt;</span><br><span class="line"> * &lt;li&gt;Outbound event propagation methods:</span><br><span class="line"> * 出栈事件传播方法</span><br><span class="line"> *     &lt;ul&gt;</span><br><span class="line"> *     &lt;li&gt;&#123;@link ChannelHandlerContext#bind(SocketAddress, ChannelPromise)&#125;&lt;/li&gt;</span><br><span class="line"> *     &lt;li&gt;&#123;@link ChannelHandlerContext#connect(SocketAddress, SocketAddress, ChannelPromise)&#125;&lt;/li&gt;</span><br><span class="line"> *     &lt;li&gt;&#123;@link ChannelHandlerContext#write(Object, ChannelPromise)&#125;&lt;/li&gt;</span><br><span class="line"> *     &lt;li&gt;&#123;@link ChannelHandlerContext#flush()&#125;&lt;/li&gt;</span><br><span class="line"> *     &lt;li&gt;&#123;@link ChannelHandlerContext#read()&#125;&lt;/li&gt;</span><br><span class="line"> *     &lt;li&gt;&#123;@link ChannelHandlerContext#disconnect(ChannelPromise)&#125;&lt;/li&gt;</span><br><span class="line"> *     &lt;li&gt;&#123;@link ChannelHandlerContext#close(ChannelPromise)&#125;&lt;/li&gt;</span><br><span class="line"> *     &lt;li&gt;&#123;@link ChannelHandlerContext#deregister(ChannelPromise)&#125;&lt;/li&gt;</span><br><span class="line"> *     &lt;/ul&gt;</span><br><span class="line"> * &lt;/li&gt;</span><br><span class="line"> * &lt;/ul&gt;</span><br><span class="line"> *</span><br><span class="line"> * and the following example shows how the event propagation is usually done:</span><br><span class="line"> *下面的实例展示了事件传播是怎么做的</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> * public class MyInboundHandler extends &#123;@link ChannelInboundHandlerAdapter&#125; &#123;</span><br><span class="line"> *     &#123;@code @Override&#125;</span><br><span class="line"> *     public void channelActive(&#123;@link ChannelHandlerContext&#125; ctx) &#123;</span><br><span class="line"> *         System.out.println(&quot;Connected!&quot;);</span><br><span class="line"> *         ctx.fireChannelActive();//传播下一个</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *</span><br><span class="line"> * public class MyOutboundHandler extends &#123;@link ChannelOutboundHandlerAdapter&#125; &#123;</span><br><span class="line"> *     &#123;@code @Override&#125;</span><br><span class="line"> *     public void close(&#123;@link ChannelHandlerContext&#125; ctx, &#123;@link ChannelPromise&#125; promise) &#123;</span><br><span class="line"> *         System.out.println(&quot;Closing ..&quot;);</span><br><span class="line"> *         ctx.close(promise);//关闭</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;h3&gt;Building a pipeline&lt;/h3&gt;</span><br><span class="line"> * 创建pipeline</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * A user is supposed to have one or more &#123;@link ChannelHandler&#125;s in a pipeline to receive I/O events (e.g. read) and</span><br><span class="line"> * to request I/O operations (e.g. write and close).  For example, a typical server will have the following handlers</span><br><span class="line"> * in each channel&#x27;s pipeline, but your mileage may vary depending on the complexity and characteristics of the</span><br><span class="line"> * protocol and business logic:</span><br><span class="line"> *一个用户可以支持在pipeline 中有一个或者多个ChannelHandler来接受I/O 事件，</span><br><span class="line"> 比如读操作，或者请求I/O操作，比如写后者关闭，比如，一个典型</span><br><span class="line"> 的服务的每个channel下的pipeline有下面的处理器，但是会因为复杂度和协议的特性或者业务逻辑而有一些不同：</span><br><span class="line"> * &lt;ol&gt;</span><br><span class="line"> * &lt;li&gt;Protocol Decoder - translates binary data (e.g. &#123;@link ByteBuf&#125;) into a Java object.&lt;/li&gt;</span><br><span class="line"> * 协议解码器 - 将二级制转换为一个Java对象，比如ByteBuf，</span><br><span class="line"> * &lt;li&gt;Protocol Encoder - translates a Java object into binary data.&lt;/li&gt;</span><br><span class="line"> * 协议解码器，将一个Java对象转换为一个二进制数据</span><br><span class="line"> * &lt;li&gt;Business Logic Handler - performs the actual business logic (e.g. database access).&lt;/li&gt;</span><br><span class="line"> * 业务逻辑处理器 - 实现实际的业务逻辑.</span><br><span class="line"> * &lt;/ol&gt;</span><br><span class="line"> *</span><br><span class="line"> * and it could be represented as shown in the following example:</span><br><span class="line"> *这些会通过如下的业务逻辑来体现。</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> * static final &#123;@link EventExecutorGroup&#125; group = new &#123;@link DefaultEventExecutorGroup&#125;(16);</span><br><span class="line"> * ...</span><br><span class="line"> *</span><br><span class="line"> * &#123;@link ChannelPipeline&#125; pipeline = ch.pipeline();</span><br><span class="line"> *</span><br><span class="line"> * pipeline.addLast(&quot;decoder&quot;, new MyProtocolDecoder());</span><br><span class="line"> * pipeline.addLast(&quot;encoder&quot;, new MyProtocolEncoder());</span><br><span class="line"> *</span><br><span class="line"> * // Tell the pipeline to run MyBusinessLogicHandler&#x27;s event handler methods</span><br><span class="line"> * // in a different thread than an I/O thread so that the I/O thread is not blocked by</span><br><span class="line"> * // a time-consuming task.</span><br><span class="line"> * // If your business logic is fully asynchronous or finished very quickly, you don&#x27;t</span><br><span class="line"> * // need to specify a group.</span><br><span class="line"> * 告诉pipeline 在另外一个I/O 线程里边执行MyBusinessLogicHandler的事件处理器的方法，</span><br><span class="line"> * 这样就不会阻塞实时消费任务。</span><br><span class="line"> * 如果你得业务逻辑是同步的或者完成速度非常快，就不需要指定这个group。</span><br><span class="line"> * pipeline.addLast(group, &quot;handler&quot;, new MyBusinessLogicHandler());</span><br><span class="line"> * 这种方式是netty指定的标准方式，另外一种方式是在MyBusinessLogicHandler里边创建线程池也是可以的。</span><br><span class="line"> *  * &lt;/pre&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;h3&gt;Thread safety&lt;/h3&gt;</span><br><span class="line"> * 线程安全性</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * A &#123;@link ChannelHandler&#125; can be added or removed at any time because a &#123;@link ChannelPipeline&#125; is thread safe.</span><br><span class="line"> * For example, you can insert an encryption handler when sensitive information is about to be exchanged,</span><br><span class="line"> * after the exchange.</span><br><span class="line"> * ChannelHandler可以随时添加和删除，因为ChannelPipeline是线程安全的，比如，</span><br><span class="line"> * 当敏感的数据被交换的时候你可以插入一个加密的处理器，</span><br><span class="line"> * 当交换完毕再删除掉。</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>ChannelPipeline 拦截过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title>netty源码分析(十一)Netty常量池实现及ChannelOption与Attribute作用分析</title>
    <url>/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E4%B8%80-Netty%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8F%8AChannelOption%E4%B8%8EAttribute%E4%BD%9C%E7%94%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>ServerBootstrap的init方法是服务初始的关键逻辑：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void init(Channel channel) throws Exception &#123;</span><br><span class="line">    final Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();//是一个linkedHashMap</span><br><span class="line">    synchronized (options) &#123;</span><br><span class="line">        setChannelOptions(channel, options, logger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class="line">    synchronized (attrs) &#123;</span><br><span class="line">        for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</span><br><span class="line">            channel.attr(key).set(e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line"></span><br><span class="line">    final EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">    final ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">    final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">    final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</span><br><span class="line">    synchronized (childOptions) &#123;</span><br><span class="line">        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(childOptions.size()));</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (childAttrs) &#123;</span><br><span class="line">        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(childAttrs.size()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void initChannel(final Channel ch) throws Exception &#123;</span><br><span class="line">            final ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line">            if (handler != null) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ch.eventLoop().execute(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    pipeline.addLast(new ServerBootstrapAcceptor(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里边有2个重要的类：ChannelOption和AttributeKey。<br>ChannelOption：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E4%B8%80-Netty%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8F%8AChannelOption%E4%B8%8EAttribute%E4%BD%9C%E7%94%A8%E5%88%86%E6%9E%90/20171028105501784.png" alt="这里写图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ChannelOption的doc说明</span><br><span class="line">/**</span><br><span class="line"> * A &#123;@link ChannelOption&#125; allows to configure a &#123;@link ChannelConfig&#125; in a type-safe</span><br><span class="line"> * way. Which &#123;@link ChannelOption&#125; is supported depends on the actual implementation</span><br><span class="line"> * of &#123;@link ChannelConfig&#125; and may depend on the nature of the transport it belongs</span><br><span class="line"> * to.</span><br><span class="line"> *</span><br><span class="line"> * @param &lt;T&gt;   the type of the value which is valid for the &#123;@link ChannelOption&#125;</span><br><span class="line"> */</span><br><span class="line"> ChannelOption是一种以一种安全的方式配置ChannelConfig，ChannelOption支持的类型个依赖于ChannelConfig的实际类型</span><br><span class="line"> 和他所属的传输层的本质。</span><br><span class="line"> T 类型是ChannelOption的值得类型</span><br><span class="line">public class ChannelOption&lt;T&gt; extends AbstractConstant&lt;ChannelOption&lt;T&gt;&gt; &#123;</span><br><span class="line">    private static final ConstantPool&lt;ChannelOption&lt;Object&gt;&gt; pool = new ConstantPool&lt;ChannelOption&lt;Object&gt;&gt;() &#123;</span><br><span class="line">        protected ChannelOption&lt;Object&gt; newConstant(int id, String name) &#123;</span><br><span class="line">            return new ChannelOption&lt;Object&gt;(id, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ...略</span><br></pre></td></tr></table></figure>
<p>ChannelOption的主要作用是用来存在TCP之类的传输层的一些协议的参数，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static final ChannelOption&lt;Boolean&gt; SO_BROADCAST = valueOf(&quot;SO_BROADCAST&quot;);</span><br><span class="line"> public static final ChannelOption&lt;Boolean&gt; SO_KEEPALIVE = valueOf(&quot;SO_KEEPALIVE&quot;);</span><br><span class="line"> public static final ChannelOption&lt;Integer&gt; SO_SNDBUF = valueOf(&quot;SO_SNDBUF&quot;);</span><br><span class="line"> public static final ChannelOption&lt;Integer&gt; SO_RCVBUF = valueOf(&quot;SO_RCVBUF&quot;);</span><br><span class="line"> public static final ChannelOption&lt;Boolean&gt; SO_REUSEADDR = valueOf(&quot;SO_REUSEADDR&quot;);</span><br><span class="line"> public static final ChannelOption&lt;Integer&gt; SO_LINGER = valueOf(&quot;SO_LINGER&quot;);</span><br><span class="line"> public static final ChannelOption&lt;Integer&gt; SO_BACKLOG = valueOf(&quot;SO_BACKLOG&quot;);</span><br><span class="line"> public static final ChannelOption&lt;Integer&gt; SO_TIMEOUT = valueOf(&quot;SO_TIMEOUT&quot;);</span><br></pre></td></tr></table></figure>
<p>紧接着我们进入AbstractConstant：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractConstant&lt;T extends AbstractConstant&lt;T&gt;&gt; implements Constant&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>AbstractConstant实现了Constant接口:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A singleton which is safe to compare via the &#123;@code ==&#125; operator. Created and managed by &#123;@link ConstantPool&#125;.</span><br><span class="line"> * 是单例的并且是可以用过“==”安全比较的。使用ConstantPool创建和管理</span><br><span class="line"> */</span><br><span class="line">public interface Constant&lt;T extends Constant&lt;T&gt;&gt; extends Comparable&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the unique number assigned to this &#123;@link Constant&#125;.</span><br><span class="line">     * 返回唯一的编码</span><br><span class="line">     */</span><br><span class="line">    int id();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the name of this &#123;@link Constant&#125;.</span><br><span class="line">     * 返回一个名称</span><br><span class="line">     */</span><br><span class="line">    String name();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConstantPool是什么:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A pool of &#123;@link Constant&#125;s.</span><br><span class="line"> *一个Constant的常量池</span><br><span class="line"> * @param &lt;T&gt; the type of the constant</span><br><span class="line"> * T是constant类型</span><br><span class="line"> */</span><br><span class="line">public abstract class ConstantPool&lt;T extends Constant&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final ConcurrentMap&lt;String, T&gt; constants = PlatformDependent.newConcurrentHashMap();</span><br><span class="line">    //返回Java.util里边的ConcurrentHashMap</span><br><span class="line">    private final AtomicInteger nextId = new AtomicInteger(1);</span><br><span class="line">    ....略</span><br><span class="line">    /**</span><br><span class="line">     * Get existing constant by name or creates new one if not exists. Threadsafe</span><br><span class="line">     * 通过name得到一个已近存在的constant ，没有的话直接创建，线程安全的</span><br><span class="line">     * @param name the name of the &#123;@link Constant&#125;</span><br><span class="line">     * 常量的名字</span><br><span class="line">     */</span><br><span class="line">    private T getOrCreate(String name) &#123;</span><br><span class="line">        T constant = constants.get(name);//根据名字从ConcurrentHashMap里边获取</span><br><span class="line">        if (constant == null) &#123;//不存在</span><br><span class="line">            final T tempConstant = newConstant(nextId(), name);//构建一个，id是随机出来的</span><br><span class="line">            constant = constants.putIfAbsent(name, tempConstant);//放入ConcurrentHashMap里边</span><br><span class="line">            if (constant == null) &#123;//考虑多线程的时候，二次判空处理</span><br><span class="line">                return tempConstant;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return constant;</span><br><span class="line">    &#125;</span><br><span class="line">    public final int nextId() &#123;</span><br><span class="line">        return nextId.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">        ....略</span><br></pre></td></tr></table></figure>

<p>回到ChannelOption,ChannelOption不存储值，只存储值得类型.<br>回到init方法，我们进入setChannelOptions里边：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void setChannelOptions(Channel channel, Map&lt;ChannelOption&lt;?&gt;, Object&gt; options, InternalLogger logger) &#123;</span><br><span class="line">    for (Map.Entry&lt;ChannelOption&lt;?&gt;, Object&gt; e: options.entrySet()) &#123;</span><br><span class="line">        setChannelOption(channel, e.getKey(), e.getValue(), logger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>setChannelOption：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static void setChannelOption(</span><br><span class="line">        Channel channel, ChannelOption&lt;?&gt; option, Object value, InternalLogger logger) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (!channel.config().setOption((ChannelOption&lt;Object&gt;) option, value)) &#123;//将ChannelOption作为key，value</span><br><span class="line">        //作为value塞到config里边</span><br><span class="line">            logger.warn(&quot;Unknown channel option &#x27;&#123;&#125;&#x27; for channel &#x27;&#123;&#125;&#x27;&quot;, option, channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        logger.warn(</span><br><span class="line">                &quot;Failed to set channel option &#x27;&#123;&#125;&#x27; with value &#x27;&#123;&#125;&#x27; for channel &#x27;&#123;&#125;&#x27;&quot;, option, value, channel, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是在ChannelOption上层我们看到的设置过程，那么在ChannelOption里边是怎么一些细节呢?<br>以ChannelOption里边的任意一个参数为入口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static final ChannelOption&lt;Boolean&gt; AUTO_CLOSE = valueOf(&quot;AUTO_CLOSE&quot;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static &lt;T&gt; ChannelOption&lt;T&gt; valueOf(String name) &#123;</span><br><span class="line">    return (ChannelOption&lt;T&gt;) pool.valueOf(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入ConstantPool</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Returns the &#123;@link Constant&#125; which is assigned to the specified &#123;@code name&#125;.</span><br><span class="line"> * If there&#x27;s no such &#123;@link Constant&#125;, a new one will be created and returned.</span><br><span class="line"> * Once created, the subsequent calls with the same &#123;@code name&#125; will always return the previously created one</span><br><span class="line"> * (i.e. singleton.)</span><br><span class="line"> *</span><br><span class="line"> * @param name the name of the &#123;@link Constant&#125;</span><br><span class="line"> */</span><br><span class="line">public T valueOf(String name) &#123;</span><br><span class="line">    checkNotNullAndNotEmpty(name);</span><br><span class="line">    return getOrCreate(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入ConstantPool的getOrCreate</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Get existing constant by name or creates new one if not exists. Threadsafe</span><br><span class="line"> *</span><br><span class="line"> * @param name the name of the &#123;@link Constant&#125;</span><br><span class="line"> */</span><br><span class="line">private T getOrCreate(String name) &#123;</span><br><span class="line">    T constant = constants.get(name);</span><br><span class="line">    if (constant == null) &#123;</span><br><span class="line">        final T tempConstant = newConstant(nextId(), name);</span><br><span class="line">        constant = constants.putIfAbsent(name, tempConstant);</span><br><span class="line">        if (constant == null) &#123;</span><br><span class="line">            return tempConstant;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return constant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就是我们刚才看到的那个方法，为什么ChannelOption是线程安全的，原因就在于此,并且ChannelOption不存储值，只是存储值得类型。<br>在服务端我们用的时候可以这样设置ChannelOption：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">serverBootstrap.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).handler(new LoggingHandler(LogLevel.WARN)).option(option,value)</span><br></pre></td></tr></table></figure>
<p>ChannelOption是用来配置ChannelConfig的，那么看一下ChannelConfig：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A set of configuration properties of a &#123;@link Channel&#125;.</span><br><span class="line"> * 一个Channel配置属性的集合</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * Please down-cast to more specific configuration type such as</span><br><span class="line"> * &#123;@link SocketChannelConfig&#125; or use &#123;@link #setOptions(Map)&#125; to set the</span><br><span class="line"> * transport-specific properties:</span><br><span class="line"> * 通过向下类型转换比如SocketChannelConfig或者使用setOptions(Map)设置特殊传输属性</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> * &#123;@link Channel&#125; ch = ...;</span><br><span class="line"> * &#123;@link SocketChannelConfig&#125; cfg = &lt;strong&gt;(&#123;@link SocketChannelConfig&#125;) ch.getConfig();&lt;/strong&gt;</span><br><span class="line"> * cfg.setTcpNoDelay(false);</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;h3&gt;Option map&lt;/h3&gt;</span><br><span class="line"> *</span><br><span class="line"> * An option map property is a dynamic write-only property which allows</span><br><span class="line"> * the configuration of a &#123;@link Channel&#125; without down-casting its associated</span><br><span class="line"> * &#123;@link ChannelConfig&#125;.  To update an option map, please call &#123;@link #setOptions(Map)&#125;.</span><br><span class="line"> * 使用map将所有的属性进行设置，它们的key可以是如下的一些参数，value是向下类型装换的类。</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * All &#123;@link ChannelConfig&#125; has the following options:</span><br><span class="line"> *</span><br><span class="line"> * &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;6&quot;&gt;</span><br><span class="line"> * &lt;tr&gt;</span><br><span class="line"> * &lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Associated setter method&lt;/th&gt;</span><br><span class="line"> * &lt;/tr&gt;&lt;tr&gt;</span><br><span class="line"> * &lt;td&gt;&#123;@link ChannelOption#CONNECT_TIMEOUT_MILLIS&#125;&lt;/td&gt;&lt;td&gt;&#123;@link #setConnectTimeoutMillis(int)&#125;&lt;/td&gt;</span><br><span class="line"> * &lt;/tr&gt;&lt;tr&gt;</span><br><span class="line"> * &lt;td&gt;&#123;@link ChannelOption#WRITE_SPIN_COUNT&#125;&lt;/td&gt;&lt;td&gt;&#123;@link #setWriteSpinCount(int)&#125;&lt;/td&gt;</span><br><span class="line"> * &lt;/tr&gt;&lt;tr&gt;</span><br><span class="line"> * &lt;td&gt;&#123;@link ChannelOption#WRITE_BUFFER_WATER_MARK&#125;&lt;/td&gt;&lt;td&gt;&#123;@link #setWriteBufferWaterMark(WriteBufferWaterMark)&#125;&lt;/td&gt;</span><br><span class="line"> * &lt;/tr&gt;&lt;tr&gt;</span><br><span class="line"> * &lt;td&gt;&#123;@link ChannelOption#ALLOCATOR&#125;&lt;/td&gt;&lt;td&gt;&#123;@link #setAllocator(ByteBufAllocator)&#125;&lt;/td&gt;</span><br><span class="line"> * &lt;/tr&gt;&lt;tr&gt;</span><br><span class="line"> * &lt;td&gt;&#123;@link ChannelOption#AUTO_READ&#125;&lt;/td&gt;&lt;td&gt;&#123;@link #setAutoRead(boolean)&#125;&lt;/td&gt;</span><br><span class="line"> * &lt;/tr&gt;</span><br><span class="line"> * &lt;/table&gt;</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * More options are available in the sub-types of &#123;@link ChannelConfig&#125;.  For</span><br><span class="line"> * example, you can configure the parameters which are specific to a TCP/IP</span><br><span class="line"> * socket as explained in &#123;@link SocketChannelConfig&#125;.</span><br><span class="line"> * 更多的参数设置可以在ChannelConfig子类类型里边设置，比如你可以在SocketChannelConfig里边指定TCP/IP的一些设置</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>对于ChannelConfig来说他是对Channel一个整个配置的信息。</p>
<p>再来看一下AttributeKey：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E4%B8%80-Netty%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8F%8AChannelOption%E4%B8%8EAttribute%E4%BD%9C%E7%94%A8%E5%88%86%E6%9E%90/20171028115151418.png" alt="这里写图片描述"><br>可以看到它和ChannelOption的上层结构是一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Key which can be used to access &#123;@link Attribute&#125; out of the &#123;@link AttributeMap&#125;. Be aware that it is not be</span><br><span class="line"> * possible to have multiple keys with the same name.</span><br><span class="line"> * 一个在AttributeMap外部访问Attribute的key，不会出现2个相同的key</span><br><span class="line"> * @param &lt;T&gt;   the type of the &#123;@link Attribute&#125; which can be accessed via this &#123;@link AttributeKey&#125;.</span><br><span class="line"> * T类型是一个Attribute类型，可以通过AttributeKey访问</span><br><span class="line"> */</span><br><span class="line">@SuppressWarnings(&quot;UnusedDeclaration&quot;) // &#x27;T&#x27; is used only at compile time</span><br><span class="line">public final class AttributeKey&lt;T&gt; extends AbstractConstant&lt;AttributeKey&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static final ConstantPool&lt;AttributeKey&lt;Object&gt;&gt; pool = new ConstantPool&lt;AttributeKey&lt;Object&gt;&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected AttributeKey&lt;Object&gt; newConstant(int id, String name) &#123;</span><br><span class="line">            return new AttributeKey&lt;Object&gt;(id, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到AttributeKey类的结构和ChannelOption是一样的，都有一个ConstantPool。<br> 和AttributeKey相关的一个组件Attribute，Attribute是什么呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * An attribute which allows to store a value reference. It may be updated atomically and so is thread-safe.</span><br><span class="line"> *用来存放值得引用，可以进行原子操作，并且是线程安全的。</span><br><span class="line"> * @param &lt;T&gt;   the type of the value it holds.</span><br><span class="line"> * T是Attribute持有的值得类型</span><br><span class="line"> */</span><br><span class="line">public interface Attribute&lt;T&gt; &#123;</span><br></pre></td></tr></table></figure>
<p>AttributeKey作为AttributeMap的key，Attribute作为AttributeMap的value：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Holds &#123;@link Attribute&#125;s which can be accessed via &#123;@link AttributeKey&#125;.</span><br><span class="line"> *通过AttributeKey访问Attribute</span><br><span class="line"> * Implementations must be Thread-safe.</span><br><span class="line"> * 实现类必须是线程安全的</span><br><span class="line"> */</span><br><span class="line">public interface AttributeMap &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Get the &#123;@link Attribute&#125; for the given &#123;@link AttributeKey&#125;. This method will never return null, but may return</span><br><span class="line">     * an &#123;@link Attribute&#125; which does not have a value set yet.</span><br><span class="line">     */</span><br><span class="line">    &lt;T&gt; Attribute&lt;T&gt; attr(AttributeKey&lt;T&gt; key);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns &#123;@code&#125; true if and only if the given &#123;@link Attribute&#125; exists in this &#123;@link AttributeMap&#125;.</span><br><span class="line">     */</span><br><span class="line">    &lt;T&gt; boolean hasAttr(AttributeKey&lt;T&gt; key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AttributeMap 、 Attribute 、 AttributeKey 分别对应Map、value、Key，netty对他们进行了一次封装。</p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty常量池 ChannelOption Attribute</tag>
      </tags>
  </entry>
  <entry>
    <title>netty源码分析(十七)Netty线程模型深度解读与架构设计原则</title>
    <url>/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E4%B8%83-Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%BA%A6%E8%A7%A3%E8%AF%BB%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>上次分析到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br><span class="line">public abstract class SingleThreadEventLoop extends SingleThreadEventExecutor implements EventLoop</span><br><span class="line">  public ChannelFuture register(final ChannelPromise promise) &#123;</span><br><span class="line">      ObjectUtil.checkNotNull(promise, &quot;promise&quot;);</span><br><span class="line">      promise.channel().unsafe().register(this, promise);</span><br><span class="line">      return promise;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前提到的ChannelPromise 结构，其实是一个异步返回结果的封装，它持有channel和当前的SingleThreadEventLoop :<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E4%B8%83-Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%BA%A6%E8%A7%A3%E8%AF%BB%E4%B8%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/20171105134757100.png" alt="这里写图片描述"></p>
<p>进入unsafe实现类AbstractUnsafe的register方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected abstract class AbstractUnsafe implements Unsafe &#123;</span><br><span class="line"></span><br><span class="line">      private volatile ChannelOutboundBuffer outboundBuffer = new ChannelOutboundBuffer(AbstractChannel.this);</span><br><span class="line">      private RecvByteBufAllocator.Handle recvHandle;</span><br><span class="line">      private boolean inFlush0;</span><br><span class="line">      /** true if the channel has never been registered, false otherwise */</span><br><span class="line">      private boolean neverRegistered = true;</span><br><span class="line">public final void register(EventLoop eventLoop, final ChannelPromise promise) &#123;</span><br><span class="line">          if (eventLoop == null) &#123;</span><br><span class="line">              throw new NullPointerException(&quot;eventLoop&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          if (isRegistered()) &#123;</span><br><span class="line">              promise.setFailure(new IllegalStateException(&quot;registered to an event loop already&quot;));</span><br><span class="line">              return;</span><br><span class="line">          &#125;</span><br><span class="line">          if (!isCompatible(eventLoop)) &#123;</span><br><span class="line">              promise.setFailure(</span><br><span class="line">                      new IllegalStateException(&quot;incompatible event loop type: &quot; + eventLoop.getClass().getName()));</span><br><span class="line">              return;</span><br><span class="line">          &#125;</span><br><span class="line">           //上边的逻辑主要是一些非空判断之类的东西</span><br><span class="line">          AbstractChannel.this.eventLoop = eventLoop;</span><br><span class="line">    //主要的注册逻辑分支，if和else分支可以看到最后调用的都是register0，但是else里边加了一个外壳---线程</span><br><span class="line">          if (eventLoop.inEventLoop()) &#123;</span><br><span class="line">              register0(promise);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                  eventLoop.execute(new Runnable() &#123;</span><br><span class="line">                      @Override</span><br><span class="line">                      public void run() &#123;</span><br><span class="line">                          register0(promise);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;);</span><br><span class="line">              &#125; catch (Throwable t) &#123;</span><br><span class="line">                  logger.warn(</span><br><span class="line">                          &quot;Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;&quot;,</span><br><span class="line">                          AbstractChannel.this, t);</span><br><span class="line">                  closeForcibly();</span><br><span class="line">                  closeFuture.setClosed();</span><br><span class="line">                  safeSetFailure(promise, t);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>eventLoop.inEventLoop()是分支逻辑的主要判断依据(eventLoop实体是SingleThreadEventExecutor):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface EventExecutor extends EventExecutorGroup &#123;</span><br><span class="line">...略</span><br><span class="line">  /**</span><br><span class="line">   * Calls &#123;@link #inEventLoop(Thread)&#125; with &#123;@link Thread#currentThread()&#125; as argument</span><br><span class="line">   * 将当前线程作为参数。</span><br><span class="line">   */</span><br><span class="line">  boolean inEventLoop();</span><br><span class="line">  ...略</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>找到他的实现类:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractEventExecutor extends AbstractExecutorService implements EventExecutor &#123;</span><br><span class="line">  ...略</span><br><span class="line">  public boolean inEventLoop() &#123;</span><br><span class="line">      return inEventLoop(Thread.currentThread());//参数为当前线程。</span><br><span class="line">  &#125;</span><br><span class="line">  ...略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在SingleThreadEventExecutor:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean inEventLoop(Thread thread) &#123;</span><br><span class="line">    return thread == this.thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，即，判断当前线程是不是SingleThreadEventExecutor里边维护的线程。所以else里边的逻辑是SingleThreadEventExecutor里边的线程不是当前线程的时候，新建一个Thread去执行register0，下边看一下register0的逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void register0(ChannelPromise promise) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // check if the channel is still open as it could be closed in the mean time when the register</span><br><span class="line">        // call was outside of the eventLoop</span><br><span class="line">        if (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean firstRegistration = neverRegistered;</span><br><span class="line">        doRegister();//核心注册方法</span><br><span class="line">        neverRegistered = false;</span><br><span class="line">        registered = true;</span><br><span class="line"></span><br><span class="line">        // Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</span><br><span class="line">        // user may already fire events through the pipeline in the ChannelFutureListener.</span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        // Only fire a channelActive if the channel has never been registered. This prevents firing</span><br><span class="line">        // multiple channel actives if the channel is deregistered and re-registered.</span><br><span class="line">        if (isActive()) &#123;</span><br><span class="line">            if (firstRegistration) &#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; else if (config().isAutoRead()) &#123;</span><br><span class="line">                // This channel was registered before and autoRead() is set. This means we need to begin read</span><br><span class="line">                // again so that we process inbound data.</span><br><span class="line">                //</span><br><span class="line">                // See https://github.com/netty/netty/issues/4805</span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        // Close the channel directly to avoid FD leak.</span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下doRegister()：<br>看一下AbstractNioChannel 实现类的doRegister逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractNioChannel extends AbstractChannel &#123;</span><br><span class="line">...略</span><br><span class="line">  protected void doRegister() throws Exception &#123;</span><br><span class="line">      boolean selected = false;</span><br><span class="line">      for (;;) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">              selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);</span><br><span class="line">              //javaChannel()返回的是SelectableChannel(jdk的java.nio.channels.SelectableChannel)</span><br><span class="line">              //javaChannel().register是将channel注册到Selector上去，所以eventLoop().unwrappedSelector()返回的是Selector</span><br><span class="line">              //（jdk的java.nio.channels.Selector）</span><br><span class="line">              return;</span><br><span class="line">          &#125; catch (CancelledKeyException e) &#123;</span><br><span class="line">              if (!selected) &#123;</span><br><span class="line">                  // Force the Selector to select now as the &quot;canceled&quot; SelectionKey may still be</span><br><span class="line">                  // cached and not removed because no Select.select(..) operation was called yet.</span><br><span class="line">                  eventLoop().selectNow();</span><br><span class="line">                  selected = true;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  // We forced a select operation on the selector before but the SelectionKey is still cached</span><br><span class="line">                  // for whatever reason. JDK bug ?</span><br><span class="line">                  throw e;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里我们看到了最终netty的JavaNio的注册实现。最后说一下比较重要的一点，上边提到的主要的注册逻辑分支，if和else分支可以看到最后调用的都是register0，但是else里边加了一个外壳—线程，这个地方有这么五点需要注意：</p>
<ol>
<li>一个EventLoopGroup当中会包含一个或多个EventLoop。</li>
<li>一个EventLoop在它的整个生命周期当中都只会与唯一一个Thread进行绑定。</li>
<li>所有由EventLoop所处理的各种I&#x2F;O事件都将在它所关联的那个Thread上进行处理。</li>
<li>一个Channel在它的整个生命周期中只会注册在一个EventLoop上。</li>
<li>一个EventLoop在运行过程中，会被分配给一个或多个Channel。</li>
</ol>
<p>这是netty的核心的架构理念，非常重要！！！</p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>线程模型 架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>netty源码分析(十三)Netty核心四大组件关系与构建方式深度解读</title>
    <url>/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E4%B8%89-Netty%E6%A0%B8%E5%BF%83%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E5%85%B3%E7%B3%BB%E4%B8%8E%E6%9E%84%E5%BB%BA%E6%96%B9%E5%BC%8F%E6%B7%B1%E5%BA%A6%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<p>上一节主要看了一下ChannelHandlerContext，中间我们走到DefaultChannelPipeline的addLast方法，这一节我们从addLast方法切入：<br>其中group为null，name为null</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultChannelPipeline implements ChannelPipeline &#123;</span><br><span class="line">...略</span><br><span class="line">    /**</span><br><span class="line">	* Set to &#123;@code true&#125; once the &#123;@link AbstractChannel&#125; is registered.Once set to &#123;@code true&#125; the value will</span><br><span class="line">	*  never  change.</span><br><span class="line">	* 当AbstractChannel注册的时候被设置为true，设置之后以后就不会被改变。</span><br><span class="line">    */</span><br><span class="line">    private boolean registered;</span><br><span class="line">   ...略</span><br><span class="line">   public final ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) &#123;</span><br><span class="line">        final AbstractChannelHandlerContext newCtx;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            checkMultiplicity(handler);//判断是否已经添加过。</span><br><span class="line">            newCtx = newContext(group, filterName(name, handler), handler);//重要方法，创建有一个context</span><br><span class="line">            addLast0(newCtx);//最后添加到Pipeline的handlers集合里边的对象，准确的说不是handler，而是context。</span><br><span class="line">            // If the registered is false it means that the channel was not registered on an eventloop yet.</span><br><span class="line">            // In this case we add the context to the pipeline and add a task that will call</span><br><span class="line">            // ChannelHandler.handlerAdded(...) once the channel is registered.</span><br><span class="line">            //如果registered是false，意味着channel没有在事件循环组中注册过，</span><br><span class="line">            //这种情况下我们将context添加到pipeline 当中，并且添加一个回调任务，当channel 被注册的时候，回调任务会执行</span><br><span class="line">            //ChannelHandler.handlerAdded(...)方法。</span><br><span class="line">            if (!registered) &#123;</span><br><span class="line">                newCtx.setAddPending();//将当前context挂起。</span><br><span class="line">                callHandlerCallbackLater(newCtx, true);//建议一个线程任务稍后执行。</span><br><span class="line">                return this;</span><br><span class="line">            &#125;</span><br><span class="line">            EventExecutor executor = newCtx.executor();</span><br><span class="line">            if (!executor.inEventLoop()) &#123;</span><br><span class="line">                newCtx.setAddPending();</span><br><span class="line">                executor.execute(new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        callHandlerAdded0(newCtx);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                return this;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //我们自己重写的handler的handlerAdded方法会被执行。</span><br><span class="line">        callHandlerAdded0(newCtx);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void checkMultiplicity(ChannelHandler handler) &#123;</span><br><span class="line">        if (handler instanceof ChannelHandlerAdapter) &#123;</span><br><span class="line">            ChannelHandlerAdapter h = (ChannelHandlerAdapter) handler;</span><br><span class="line">            if (!h.isSharable() &amp;&amp; h.added) &#123;//不是共享的，并且被添加过直接抛出异常</span><br><span class="line">                throw new ChannelPipelineException(</span><br><span class="line">                        h.getClass().getName() +</span><br><span class="line">                        &quot; is not a @Sharable handler, so can&#x27;t be added or removed multiple times.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            h.added = true;//设置added 标志位为true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //创建一个context，this是DefaultChannelPipeline，group为null，</span><br><span class="line">    private AbstractChannelHandlerContext newContext(EventExecutorGroup group, String name, ChannelHandler handler) &#123;</span><br><span class="line">        return new DefaultChannelHandlerContext(this, childExecutor(group), name, handler);</span><br><span class="line">    &#125;</span><br><span class="line">    //如果name为空，生成一个名字</span><br><span class="line">    private String filterName(String name, ChannelHandler handler) &#123;</span><br><span class="line">        if (name == null) &#123;</span><br><span class="line">            return generateName(handler);</span><br><span class="line">        &#125;</span><br><span class="line">        //判断名字是否重复</span><br><span class="line">        checkDuplicateName(name);</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//生成名字的私有方法，nameCaches是一个FastThreadLocal（ThreadLocal原生ThreadLocal的封装，区别在于ThreadLocal是使用hash散列的</span><br><span class="line">方式，而FastThreadLocal使用的是数组，用的索引定位，比ThreadLocal性能上稍微快了一些，可以看到netty对性能要求非常高。）</span><br><span class="line">    private String generateName(ChannelHandler handler) &#123;</span><br><span class="line">        Map&lt;Class&lt;?&gt;, String&gt; cache = nameCaches.get();</span><br><span class="line">        Class&lt;?&gt; handlerType = handler.getClass();</span><br><span class="line">        String name = cache.get(handlerType);</span><br><span class="line">        if (name == null) &#123;</span><br><span class="line">            name = generateName0(handlerType);</span><br><span class="line">            cache.put(handlerType, name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // It&#x27;s not very likely for a user to put more than one handler of the same type, but make sure to avoid</span><br><span class="line">        // any name conflicts.  Note that we don&#x27;t cache the names generated here.</span><br><span class="line">        if (context0(name) != null) &#123;</span><br><span class="line">            String baseName = name.substring(0, name.length() - 1); // Strip the trailing &#x27;0&#x27;.</span><br><span class="line">            for (int i = 1;; i ++) &#123;</span><br><span class="line">                String newName = baseName + i;</span><br><span class="line">                if (context0(newName) == null) &#123;</span><br><span class="line">                    name = newName;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">//添加一个context到pipline操作（pipline默认只有tail和head2个节点），其实就是双向 链表的添加节点的操作。</span><br><span class="line">    private void addLast0(AbstractChannelHandlerContext newCtx) &#123;</span><br><span class="line">        AbstractChannelHandlerContext prev = tail.prev;</span><br><span class="line">        newCtx.prev = prev;</span><br><span class="line">        newCtx.next = tail;</span><br><span class="line">        prev.next = newCtx;</span><br><span class="line">        tail.prev = newCtx;</span><br><span class="line">    &#125;</span><br><span class="line">	//建立一个稍后执行的任务。</span><br><span class="line">    private void callHandlerCallbackLater(AbstractChannelHandlerContext ctx, boolean added) &#123;</span><br><span class="line">        assert !registered;</span><br><span class="line">        PendingHandlerCallback task = added ? new PendingHandlerAddedTask(ctx) : new PendingHandlerRemovedTask(ctx);</span><br><span class="line">        PendingHandlerCallback pending = pendingHandlerCallbackHead;</span><br><span class="line">        if (pending == null) &#123;</span><br><span class="line">            pendingHandlerCallbackHead = task;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Find the tail of the linked-list.</span><br><span class="line">            //将新建的任务添加到链表里边</span><br><span class="line">            while (pending.next != null) &#123;</span><br><span class="line">                pending = pending.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pending.next = task;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //context被添加到pipline之后调用callHandlerAdded0，我们自己写的handler的handlerAdded方法会被执行，这也是handlerAdded</span><br><span class="line">    //为什么会被首先执行的原因。</span><br><span class="line">    private void callHandlerAdded0(final AbstractChannelHandlerContext ctx) &#123;</span><br><span class="line">       ...略</span><br><span class="line">            ctx.handler().handlerAdded(ctx);</span><br><span class="line">            ctx.setAddComplete();</span><br><span class="line">           ...略      </span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25ldHR5L25ldHR5L2Jsb2IvZWI3Zjc1MWJhNTE5Y2JjYWI0N2Q2NDBjZDE4NzU3ZjA5ZDA3N2I1NS9jb21tb24vc3JjL21haW4vamF2YS9pby9uZXR0eS91dGlsL2NvbmN1cnJlbnQvRmFzdFRocmVhZExvY2FsLmphdmE=">FastThreadLocal<i class="fa fa-external-link-alt"></i></span> 详细请参考git源码。<br>DefaultChannelHandlerContext：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final class DefaultChannelHandlerContext extends AbstractChannelHandlerContext &#123;</span><br><span class="line">    private final ChannelHandler handler;//持有Handler的引用，从这里可以看出一个context对应一个Handler。</span><br><span class="line">    DefaultChannelHandlerContext(</span><br><span class="line">            DefaultChannelPipeline pipeline, EventExecutor executor, String name, ChannelHandler handler) &#123;</span><br><span class="line">        super(pipeline, executor, name, isInbound(handler), isOutbound(handler));</span><br><span class="line">        if (handler == null) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;handler&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取持有的Handler</span><br><span class="line">    public ChannelHandler handler() &#123;</span><br><span class="line">        return handler;</span><br><span class="line">    &#125;</span><br><span class="line">//入栈处理器是ChannelInboundHandler的实现</span><br><span class="line">    private static boolean isInbound(ChannelHandler handler) &#123;</span><br><span class="line">        return handler instanceof ChannelInboundHandler;</span><br><span class="line">    &#125;</span><br><span class="line">//出栈处理器是ChannelOutboundHandler的实现</span><br><span class="line">    private static boolean isOutbound(ChannelHandler handler) &#123;</span><br><span class="line">        return handler instanceof ChannelOutboundHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DefaultChannelHandlerContext的super构造器结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor, String name,</span><br><span class="line">                              boolean inbound, boolean outbound) &#123;</span><br><span class="line">    this.name = ObjectUtil.checkNotNull(name, &quot;name&quot;);</span><br><span class="line">    this.pipeline = pipeline;//赋值pipeline（ private final DefaultChannelPipeline pipeline;）</span><br><span class="line">    //DefaultChannelPipeline 持有Channel的引用</span><br><span class="line">    this.executor = executor;</span><br><span class="line">    this.inbound = inbound;//入栈处理器</span><br><span class="line">    this.outbound = outbound;//出栈处理器</span><br><span class="line">    // Its ordered if its driven by the EventLoop or the given Executor is an instanceof OrderedEventExecutor.</span><br><span class="line">    ordered = executor == null || executor instanceof OrderedEventExecutor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到DefaultChannelHandlerContext持有pipeline 、handler  、channel（DefaultChannelPipeline的接口ChannelPipeline有    Channel channel();方法），Context是这三者的一个桥梁，并且pipline里边添加的对象准确的说不是handler而是Context，而Context持有handler  对象，到此为止我们已经非常清楚的知道addlast方法的逻辑是什么样子了。<br>我们回到ServerBootstrap的init方法看一下ChannelInitializer：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void initChannel(final Channel ch) throws Exception &#123;</span><br><span class="line">        final ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        ChannelHandler handler = config.handler();</span><br><span class="line">        if (handler != null) &#123;</span><br><span class="line">            pipeline.addLast(handler);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ch.eventLoop().execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                pipeline.addLast(new ServerBootstrapAcceptor(</span><br><span class="line">                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>ChannelInitializer部分逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class ChannelInitializer&lt;C extends Channel&gt; extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">....略</span><br><span class="line">    /**</span><br><span class="line">     * This method will be called once the &#123;@link Channel&#125; was registered. After the method returns this instance</span><br><span class="line">     * will be removed from the &#123;@link ChannelPipeline&#125; of the &#123;@link Channel&#125;.</span><br><span class="line">     *当initChannel方法被调用完毕返回的时候，当前ChannelInitializer对象会被从pipline里边删除掉。</span><br><span class="line">     * @param ch            the &#123;@link Channel&#125; which was registered.</span><br><span class="line">     * @throws Exception    is thrown if an error occurs. In that case it will be handled by</span><br><span class="line">     *                      &#123;@link #exceptionCaught(ChannelHandlerContext, Throwable)&#125; which will by default close</span><br><span class="line">     *                      the &#123;@link Channel&#125;.</span><br><span class="line">     */</span><br><span class="line">    protected abstract void initChannel(C ch) throws Exception;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * &#123;@inheritDoc&#125; If override this method ensure you call super!</span><br><span class="line">     * 如果重写，确保调用父类的方法。</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        if (ctx.channel().isRegistered()) &#123;</span><br><span class="line">            // This should always be true with our current DefaultChannelPipeline implementation.</span><br><span class="line">            // The good thing about calling initChannel(...) in handlerAdded(...) is that there will be no ordering</span><br><span class="line">            // surprises if a ChannelInitializer will add another ChannelInitializer. This is as all handlers</span><br><span class="line">            // will be added in the expected order.</span><br><span class="line">            initChannel(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    private boolean initChannel(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        if (initMap.putIfAbsent(ctx, Boolean.TRUE) == null) &#123; // Guard against re-entrance.</span><br><span class="line">            try &#123;</span><br><span class="line">            //初始化。</span><br><span class="line">                initChannel((C) ctx.channel());</span><br><span class="line">            &#125; catch (Throwable cause) &#123;</span><br><span class="line">                // Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...).</span><br><span class="line">                // We do so to prevent multiple calls to initChannel(...).</span><br><span class="line">                exceptionCaught(ctx, cause);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">            掉完initChannel之后从pipline删除当前对象</span><br><span class="line">                remove(ctx);</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">//删除逻辑，首先拿到ChannelPipeline ，然后remove掉</span><br><span class="line">    private void remove(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ChannelPipeline pipeline = ctx.pipeline();</span><br><span class="line">            if (pipeline.context(this) != null) &#123;</span><br><span class="line">                pipeline.remove(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">        //同时删除对应的context</span><br><span class="line">            initMap.remove(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ChannelInitializer的使命就是对handlers的一个暂时的封装处理，把所有的handler添加到pipline之后，他的使命就完成了，所以调用完initChannel之后会被清除掉。<br>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyChatClientInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">        ChannelPipeline channelPipeline =  ch.pipeline();</span><br><span class="line">        channelPipeline.addLast(new DelimiterBasedFrameDecoder(4096, Delimiters.lineDelimiter()));</span><br><span class="line">        channelPipeline.addLast(new StringEncoder(CharsetUtil.UTF_8));</span><br><span class="line">        channelPipeline.addLast(new StringDecoder(CharsetUtil.UTF_8));</span><br><span class="line">        channelPipeline.addLast(new MyChatClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这些handler加添到pipline之后，即调用完initChannel方法之后，MyChatClientInitializer对象会被删除</p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty四大核心组件</tag>
      </tags>
  </entry>
  <entry>
    <title>netty源码分析(十九)Netty项目开发过程中常见且重要事项分析</title>
    <url>/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E4%B9%9D-Netty%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%B8%B8%E8%A7%81%E4%B8%94%E9%87%8D%E8%A6%81%E4%BA%8B%E9%A1%B9%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>一、服务端在回写数据到客户端的时候可以有一下2中方式：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E4%B9%9D-Netty%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%B8%B8%E8%A7%81%E4%B8%94%E9%87%8D%E8%A6%81%E4%BA%8B%E9%A1%B9%E5%88%86%E6%9E%90/20171118104445662.png" alt="这里写图片描述"></p>
<span id="more"></span>
<p>在Netty中有22种发送消息的方式，可以直接写到Channel中，也可以写到与ChannelHandler所关联的那个ChannelHandlerContext中，对于前一种方式来说，消息会从ChannelPipeline的末尾开始流动，对于后一种方式来说，消息将从ChannelPipleline中的下一个ChannelG、Handler开始流动。<br>图示：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E4%B9%9D-Netty%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%B8%B8%E8%A7%81%E4%B8%94%E9%87%8D%E8%A6%81%E4%BA%8B%E9%A1%B9%E5%88%86%E6%9E%90/20171118105821855.png" alt="这里写图片描述"><br>二、nio和oio通用的线程模型。<br>1、ChannelHandlerContext与ChannelHandler之间的关联绑定关系是永远都不会发生改变的，因此对其进行缓存是没有任何问题的。<br>2、对于与Channel的同名方法来说，channelHandlerContext的方法将会产生更短的事件流，所以我们应该在可能的情况下利用这个特性来提升应用性能。<br>Netty中不光支持了Java中NIO模型，同时也提供了对OIO模型的支持。（New IO vs Old IO）。<br>首先，在Netty中，切换OIO和NIO两种模式是非常方便的，只需要初始化不同的Channel工程即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Netty中不光支持了Java中NIO模型，同时也提供了对OIO模型的支持。（New IO vs Old IO）。</span><br><span class="line">首先，在Netty中，切换OIO和NIO两种模式是非常方便的，只需要初始化不同的Channel工程即可。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Netty中不光支持了Java中NIO模型，同时也提供了对OIO模型的支持。（New IO vs Old IO）。</span><br><span class="line">首先，在Netty中，切换OIO和NIO两种模式是非常方便的，只需要初始化不同的Channel工程即可。</span><br></pre></td></tr></table></figure>
<p>NIO时候异步的，调用完毕之后会立刻返回，那么OIO是怎么做到适应这个Netty建立的模型的呢？<br>答案是通过设置OIO的超时时间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">	oio synchronous operation (setTimeOut(xxxx))</span><br><span class="line">&#125;catch(SocketTimeOutException ex)&#123;</span><br><span class="line">	捕捉异常</span><br><span class="line">	捕捉到异常之后会进行记录下次时间还会去执行这个oio操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是Netty框架为我们做的贡献。<br>图示：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E4%B9%9D-Netty%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%B8%B8%E8%A7%81%E4%B8%94%E9%87%8D%E8%A6%81%E4%BA%8B%E9%A1%B9%E5%88%86%E6%9E%90/20171118114535305.png" alt="这里写图片描述"><br>左图是nio的情况，一个线程（EventLoop）可以处理多个Channel连接，右图是OIO，每个EventLoop只能处理一个Channel连接。</p>
<p>三、客户端A连接服务端B然后服务端B把消息转发给C，那么B的模型是什么样子的呢？<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E4%B9%9D-Netty%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%B8%B8%E8%A7%81%E4%B8%94%E9%87%8D%E8%A6%81%E4%BA%8B%E9%A1%B9%E5%88%86%E6%9E%90/20171118120501393.png" alt="这里写图片描述"><br>这个时候要在B上写一个Netty的客户端用来连接C，但是我们可以共用B的EventLoopGroup：<br>伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void channelActive(ChannelHandlerContext ctx)&#123;</span><br><span class="line">	BootStrap bootstrap = .....</span><br><span class="line">	bootstrap.channel(NioSocketChannel.class).handler(</span><br><span class="line">			bootstrap.group(ctx.channeleventLoop());</span><br><span class="line">			bootstrap.connect();</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>netty实践问题</tag>
      </tags>
  </entry>
  <entry>
    <title>netty源码分析(十五)Channel注册流程深度解读</title>
    <url>/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E4%BA%94-Channel%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B%E6%B7%B1%E5%BA%A6%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<p>前边的介绍是netty对一些组件初始化的过程，接下来是第二部分，注册，还是之前的initAndRegister方法：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    final ChannelFuture initAndRegister() &#123;</span><br><span class="line">        Channel channel = null;</span><br><span class="line">...略</span><br><span class="line">            channel = channelFactory.newChannel();</span><br><span class="line">            init(channel);</span><br><span class="line"> ...略</span><br><span class="line">        ChannelFuture regFuture = config().group().register(channel);//注册逻辑</span><br><span class="line">        ...略</span><br><span class="line">        return regFuture;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>config方法从字面意思来看就是得到一个配置，具体的是什么配置呢：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ServerBootstrap extends AbstractBootstrap&lt;ServerBootstrap, ServerChannel&gt; &#123;</span><br><span class="line">...略</span><br><span class="line">    private final ServerBootstrapConfig config = new ServerBootstrapConfig(this);</span><br><span class="line">    ...略</span><br><span class="line">    public final ServerBootstrapConfig config() &#123;</span><br><span class="line">        return config;</span><br><span class="line">    &#125;</span><br><span class="line">    ...略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>config方法返回的是一个ServerBootstrapConfig ,他有ServerBootstrap的引用,因此ServerBootstrapConfig 可以得到ServerBootstrap的一些属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public EventLoopGroup childGroup() &#123;</span><br><span class="line">    return bootstrap.childGroup();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Returns the configured &#123;@link ChannelHandler&#125; be used for the child channels or &#123;@code null&#125;</span><br><span class="line"> * if non is configured yet.</span><br><span class="line"> */</span><br><span class="line">public ChannelHandler childHandler() &#123;</span><br><span class="line">    return bootstrap.childHandler();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Returns a copy of the configured options which will be used for the child channels.</span><br><span class="line"> */</span><br><span class="line">public Map&lt;ChannelOption&lt;?&gt;, Object&gt; childOptions() &#123;</span><br><span class="line">    return bootstrap.childOptions();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Returns a copy of the configured attributes which will be used for the child channels.</span><br><span class="line"> */</span><br><span class="line">public Map&lt;AttributeKey&lt;?&gt;, Object&gt; childAttrs() &#123;</span><br><span class="line">    return bootstrap.childAttrs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的ServerBootstrap的就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private final Map&lt;ChannelOption&lt;?&gt;, Object&gt; childOptions = new LinkedHashMap&lt;ChannelOption&lt;?&gt;, Object&gt;();</span><br><span class="line">private final Map&lt;AttributeKey&lt;?&gt;, Object&gt; childAttrs = new LinkedHashMap&lt;AttributeKey&lt;?&gt;, Object&gt;();</span><br><span class="line">private volatile EventLoopGroup childGroup;</span><br><span class="line">private volatile ChannelHandler childHandler;</span><br></pre></td></tr></table></figure>
<p>回到initAndRegister方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ChannelFuture regFuture = config().group().register(channel);</span><br></pre></td></tr></table></figure>
<p>config()方法返回的是ServerBootstrapConfig ，接着调用他的group(),实际上调用的是他的父类AbstractBootstrapConfig的group()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractBootstrapConfig&lt;B extends AbstractBootstrap&lt;B, C&gt;, C extends Channel&gt; &#123;</span><br><span class="line">...略</span><br><span class="line">    protected final B bootstrap;//B的实际类型是ServerBootstrap</span><br><span class="line">    public final EventLoopGroup group() &#123;</span><br><span class="line">        return bootstrap.group();</span><br><span class="line">    &#125;</span><br><span class="line">    ...略</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>bootstrap.group():</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractBootstrap&lt;B extends AbstractBootstrap&lt;B, C&gt;, C extends Channel&gt; implements Cloneable &#123;</span><br><span class="line">...略</span><br><span class="line">    volatile EventLoopGroup group;//事件循环组，实际上是NioEventLoopGroup</span><br><span class="line">    ...略</span><br><span class="line">    public final EventLoopGroup group() &#123;</span><br><span class="line">        return group;</span><br><span class="line">    &#125;</span><br><span class="line">    ...略</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>接下来是register方法，我们在此处打一个断点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ChannelFuture regFuture = config().group().register(channel);</span><br></pre></td></tr></table></figure>
<p>但是我们看到的register是在MultithreadEventLoopGroup里边：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E4%BA%94-Channel%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B%E6%B7%B1%E5%BA%A6%E8%A7%A3%E8%AF%BB/20171104122652131.png" alt="这里写图片描述"></p>
<p>这个比较让人困惑，其实很简单：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E4%BA%94-Channel%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B%E6%B7%B1%E5%BA%A6%E8%A7%A3%E8%AF%BB/20171104122817431.png" alt="这里写图片描述"><br>即 NioEventLoopGroup的父类是MultithreadEventLoopGroup，register是父类的方法，所以我们才进入MultithreadEventLoopGroup里边。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ChannelFuture register(Channel channel) &#123;</span><br><span class="line">    return next().register(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来进入真正的注册过程。</p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>channel注册</tag>
      </tags>
  </entry>
  <entry>
    <title>netty源码分析(十二)Channel与ChannelHandler及ChannelHandlerContext之间的关系分析</title>
    <url>/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E4%BA%8C-Channel%E4%B8%8EChannelHandler%E5%8F%8AChannelHandlerContext%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>还是之前的init代码入口，上一节我们介绍了ChannelOption和AttributeKey，本次我们说下Channel与ChannelHandler及ChannelHandlerContext之间的关系分析。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br><span class="line">void init(Channel channel) throws Exception &#123;</span><br><span class="line">        final Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class="line">        synchronized (options) &#123;</span><br><span class="line">            setChannelOptions(channel, options, logger);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class="line">        synchronized (attrs) &#123;</span><br><span class="line">            for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</span><br><span class="line">                channel.attr(key).set(e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ChannelPipeline p = channel.pipeline();</span><br><span class="line"></span><br><span class="line">        final EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">        final ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">        final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">        final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</span><br><span class="line">        synchronized (childOptions) &#123;</span><br><span class="line">            currentChildOptions = childOptions.entrySet().toArray(newOptionArray(childOptions.size()));</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (childAttrs) &#123;</span><br><span class="line">            currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(childAttrs.size()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void initChannel(final Channel ch) throws Exception &#123;</span><br><span class="line">                final ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                ChannelHandler handler = config.handler();</span><br><span class="line">                if (handler != null) &#123;</span><br><span class="line">                    pipeline.addLast(handler);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ch.eventLoop().execute(new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        pipeline.addLast(new ServerBootstrapAcceptor(</span><br><span class="line">                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>先从ChannelInitializer，我们看下它的doc：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * A special &#123;@link ChannelInboundHandler&#125; which offers an easy way to initialize a &#123;@link Channel&#125; once it was</span><br><span class="line"> * registered to its &#123;@link EventLoop&#125;.</span><br><span class="line"> * 一个特殊的ChannelInboundHandler，提供了简单的方式来初始化Channel，通过注册到EventLoop里边来实现的。</span><br><span class="line"> * Implementations are most often used in the context of &#123;@link Bootstrap#handler(ChannelHandler)&#125; ,</span><br><span class="line"> * &#123;@link ServerBootstrap#handler(ChannelHandler)&#125; and &#123;@link ServerBootstrap#childHandler(ChannelHandler)&#125; to</span><br><span class="line"> * setup the &#123;@link ChannelPipeline&#125; of a &#123;@link Channel&#125;.</span><br><span class="line"> * 具体实现经常使用在Bootstrap#handler(ChannelHandler)、ServerBootstrap#handler(ChannelHandler)、</span><br><span class="line"> * ServerBootstrap#childHandler(ChannelHandler)等来初始化Channel的ChannelPipeline</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> *  使用举例：</span><br><span class="line"> * public class MyChannelInitializer extends &#123;@link ChannelInitializer&#125; &#123;</span><br><span class="line"> *     public void initChannel(&#123;@link Channel&#125; channel) &#123;</span><br><span class="line"> *         channel.pipeline().addLast(&quot;myHandler&quot;, new MyHandler());</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *</span><br><span class="line"> * &#123;@link ServerBootstrap&#125; bootstrap = ...;</span><br><span class="line"> * ...</span><br><span class="line"> * bootstrap.childHandler(new MyChannelInitializer());</span><br><span class="line"> * ...</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line"> * Be aware that this class is marked as &#123;@link Sharable&#125; and so the implementation must be safe to be re-used.</span><br><span class="line"> *注意这个类是标记为Sharable的，所以在实现的时候必须是线程安全的。</span><br><span class="line"> * @param &lt;C&gt;   A sub-type of &#123;@link Channel&#125;</span><br><span class="line"> */</span><br><span class="line">@Sharable</span><br><span class="line">public abstract class ChannelInitializer&lt;C extends Channel&gt; extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序调用p.addLast(new ChannelInitializer<Channel>() ……这样的方式把ChannelInitializer放到ChannelPipeline当中，那么ChannelPipeline.addLast()的逻辑是怎样的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Inserts &#123;@link ChannelHandler&#125;s at the last position of this pipeline.</span><br><span class="line"> * 在pipeline的最后一个位置插入一个ChannelHandler</span><br><span class="line"> * @param handlers  the handlers to insert last</span><br><span class="line"> */</span><br><span class="line">ChannelPipeline addLast(ChannelHandler... handlers);</span><br></pre></td></tr></table></figure>
<p>查看ChannelPipeline 的实现类DefaultChannelPipeline：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultChannelPipeline implements ChannelPipeline &#123;</span><br><span class="line">...略</span><br><span class="line">    @Override</span><br><span class="line">    public final ChannelPipeline addLast(ChannelHandler... handlers) &#123;</span><br><span class="line">        return addLast(null, handlers);</span><br><span class="line">    &#125;</span><br><span class="line">    ...略</span><br></pre></td></tr></table></figure>
<p>调用了addLast(null, handlers),第一个参数为null：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">即executor为null</span><br><span class="line">    public final ChannelPipeline addLast(EventExecutorGroup executor, ChannelHandler... handlers) &#123;</span><br><span class="line">        if (handlers == null) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;handlers&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">//循环遍历，调用addLast(executor, null, h)方法，第二个参数也为null</span><br><span class="line">        for (ChannelHandler h: handlers) &#123;</span><br><span class="line">            if (h == null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            addLast(executor, null, h);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>进入最终的方法，其中group为null，name为null：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) &#123;</span><br><span class="line">    final AbstractChannelHandlerContext newCtx;//首先声明一个AbstractChannelHandlerContext</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line">        newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line">        addLast0(newCtx);</span><br><span class="line"></span><br><span class="line">        // If the registered is false it means that the channel was not registered on an eventloop yet.</span><br><span class="line">        // In this case we add the context to the pipeline and add a task that will call</span><br><span class="line">        // ChannelHandler.handlerAdded(...) once the channel is registered.</span><br><span class="line">        if (!registered) &#123;</span><br><span class="line">            newCtx.setAddPending();</span><br><span class="line">            callHandlerCallbackLater(newCtx, true);</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        EventExecutor executor = newCtx.executor();</span><br><span class="line">        if (!executor.inEventLoop()) &#123;</span><br><span class="line">            newCtx.setAddPending();</span><br><span class="line">            executor.execute(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    callHandlerAdded0(newCtx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上文提到AbstractChannelHandlerContext ，那么看下AbstractChannelHandlerContext 的doc是怎么一个东西：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abstract class AbstractChannelHandlerContext extends DefaultAttributeMap</span><br><span class="line">        implements ChannelHandlerContext, ResourceLeakHint &#123;</span><br></pre></td></tr></table></figure>
<p>进入他的接口ChannelHandlerContext：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Enables a &#123;@link ChannelHandler&#125; to interact with its &#123;@link ChannelPipeline&#125;</span><br><span class="line"> * and other handlers. Among other things a handler can notify the next &#123;@link ChannelHandler&#125; in the</span><br><span class="line"> * &#123;@link ChannelPipeline&#125; as well as modify the &#123;@link ChannelPipeline&#125; it belongs to dynamically.</span><br><span class="line"> * 使ChannelHandler和它的ChannelPipeline以及其他的处理器之间进行交互，可以通知ChannelPipeline里的下一个ChannelHandler，</span><br><span class="line"> * 以及动态的修改它属的ChannelPipeline</span><br><span class="line"> * &lt;h3&gt;Notify&lt;/h3&gt;</span><br><span class="line"> *  通知</span><br><span class="line"> * You can notify the closest handler in the same &#123;@link ChannelPipeline&#125; by calling one of the various methods</span><br><span class="line"> * provided here.</span><br><span class="line"> *你可以通过调用各种方法来通知ChannelPipeline里边最近的一个handler</span><br><span class="line"> * Please refer to &#123;@link ChannelPipeline&#125; to understand how an event flows.</span><br><span class="line"> * 请参考ChannelPipeline来理解事件的过程。</span><br><span class="line"> * &lt;h3&gt;Modifying a pipeline&lt;/h3&gt;</span><br><span class="line"> * 修改一个pipeline</span><br><span class="line"> * You can get the &#123;@link ChannelPipeline&#125; your handler belongs to by calling</span><br><span class="line"> * &#123;@link #pipeline()&#125;.  A non-trivial application could insert, remove, or</span><br><span class="line"> * replace handlers in the pipeline dynamically at runtime.</span><br><span class="line"> *你可以调用所属处理器的pipeline()方法得到ChannelPipeline，一个应用可以在pipeline 里边动态的插入，删除或者替换处理器。</span><br><span class="line"> * &lt;h3&gt;Retrieving for later use&lt;/h3&gt;</span><br><span class="line"> *  获取为了以后使用</span><br><span class="line"> * You can keep the &#123;@link ChannelHandlerContext&#125; for later use, such as</span><br><span class="line"> * triggering an event outside the handler methods, even from a different thread.</span><br><span class="line"> * 你可以持有ChannelHandlerContext为了后续使用，比如在handler 方法之外触发一个事件，甚至是不同的线程。</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> * public class MyHandler extends &#123;@link ChannelDuplexHandler&#125; &#123;</span><br><span class="line"> *</span><br><span class="line"> *     &lt;b&gt;private &#123;@link ChannelHandlerContext&#125; ctx;&lt;/b&gt;</span><br><span class="line"> *</span><br><span class="line"> *     public void beforeAdd(&#123;@link ChannelHandlerContext&#125; ctx) &#123;</span><br><span class="line"> *         &lt;b&gt;this.ctx = ctx;&lt;/b&gt;//提前获得ChannelHandlerContext</span><br><span class="line"> *     &#125;</span><br><span class="line"> *</span><br><span class="line"> *     public void login(String username, password) &#123;</span><br><span class="line"> *         ctx.write(new LoginMessage(username, password));//之后的业务逻辑再去使用</span><br><span class="line"> *     &#125;</span><br><span class="line"> *     ...</span><br><span class="line"> * &#125;</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;h3&gt;Storing stateful information&lt;/h3&gt;</span><br><span class="line"> *  存储状态信息</span><br><span class="line"> * &#123;@link #attr(AttributeKey)&#125; allow you to</span><br><span class="line"> * store and access stateful information that is related with a handler and its</span><br><span class="line"> * context.  Please refer to &#123;@link ChannelHandler&#125; to learn various recommended</span><br><span class="line"> * ways to manage stateful information.</span><br><span class="line"> * AttributeKey允许你存储和它有关联的handler 以及它的上下文的状态信息，可以参考ChannelHandler学习不同的方式来管理状态信息</span><br><span class="line"> * &lt;h3&gt;A handler can have more than one context&lt;/h3&gt;</span><br><span class="line"> *  一个handler 可以有多个上下文</span><br><span class="line"> * Please note that a &#123;@link ChannelHandler&#125; instance can be added to more than</span><br><span class="line"> * one &#123;@link ChannelPipeline&#125;.  It means a single &#123;@link ChannelHandler&#125;</span><br><span class="line"> * instance can have more than one &#123;@link ChannelHandlerContext&#125; and therefore</span><br><span class="line"> * the single instance can be invoked with different</span><br><span class="line"> * &#123;@link ChannelHandlerContext&#125;s if it is added to one or more</span><br><span class="line"> * &#123;@link ChannelPipeline&#125;s more than once.</span><br><span class="line"> * 注意，一个ChannelHandler可以被添加多次在一个ChannelPipeline里边，意味着一个单独的ChannelHandler实例可以有多个</span><br><span class="line"> * ChannelHandlerContext以及因此一个单独的实例可以被多个ChannelHandlerContext多次调用，如果ChannelHandler实例被添加了多次。</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * For example, the following handler will have as many independent &#123;@link AttributeKey&#125;s</span><br><span class="line"> * as how many times it is added to pipelines, regardless if it is added to the</span><br><span class="line"> * same pipeline multiple times or added to different pipelines multiple times:</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> * public class FactorialHandler extends &#123;@link ChannelInboundHandlerAdapter&#125; &#123;</span><br><span class="line"> *</span><br><span class="line"> *   private final &#123;@link AttributeKey&#125;&amp;lt;&#123;@link Integer&#125;&amp;gt; counter = &#123;@link AttributeKey&#125;.valueOf(&quot;counter&quot;);</span><br><span class="line"> *</span><br><span class="line"> *   // This handler will receive a sequence of increasing integers starting</span><br><span class="line"> *   // from 1.</span><br><span class="line"> *   &#123;@code @Override&#125;</span><br><span class="line"> *   public void channelRead(&#123;@link ChannelHandlerContext&#125; ctx, Object msg) &#123;</span><br><span class="line"> *     Integer a = ctx.attr(counter).get();</span><br><span class="line"> *</span><br><span class="line"> *     if (a == null) &#123;</span><br><span class="line"> *       a = 1;</span><br><span class="line"> *     &#125;</span><br><span class="line"> *</span><br><span class="line"> *     attr.set(a * (Integer) msg);</span><br><span class="line"> *   &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *</span><br><span class="line"> * // Different context objects are given to &quot;f1&quot;, &quot;f2&quot;, &quot;f3&quot;, and &quot;f4&quot; even if</span><br><span class="line"> * // they refer to the same handler instance.  Because the FactorialHandler</span><br><span class="line"> * // stores its state in a context object (using an &#123;@link AttributeKey&#125;), the factorial is</span><br><span class="line"> * // calculated correctly 4 times once the two pipelines (p1 and p2) are active.</span><br><span class="line"> * 给出&quot;f1&quot;, &quot;f2&quot;, &quot;f3&quot;, and &quot;f4&quot;不同的上下文对象，但是他们来自同一个实例，因为FactorialHandler存储了他们的状态在上下文对象里边</span><br><span class="line"> * （使用AttributeKey），当处于活动状态的factorial ，factorial 被计算了四次在2个pipelines （p1 和 p2）中。</span><br><span class="line"> * FactorialHandler fh = new FactorialHandler();</span><br><span class="line"> *</span><br><span class="line"> * &#123;@link ChannelPipeline&#125; p1 = &#123;@link Channels&#125;.pipeline();</span><br><span class="line"> * p1.addLast(&quot;f1&quot;, fh);</span><br><span class="line"> * p1.addLast(&quot;f2&quot;, fh);</span><br><span class="line"> *</span><br><span class="line"> * &#123;@link ChannelPipeline&#125; p2 = &#123;@link Channels&#125;.pipeline();</span><br><span class="line"> * p2.addLast(&quot;f3&quot;, fh);</span><br><span class="line"> * p2.addLast(&quot;f4&quot;, fh);</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;h3&gt;Additional resources worth reading&lt;/h3&gt;</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * Please refer to the &#123;@link ChannelHandler&#125;, and</span><br><span class="line"> * &#123;@link ChannelPipeline&#125; to find out more about inbound and outbound operations,</span><br><span class="line"> * what fundamental differences they have, how they flow in a  pipeline,  and how to handle</span><br><span class="line"> * the operation in your application.</span><br><span class="line"> * 请参考ChannelHandler和ChannelPipeline来找出更多的关于出栈和入栈的操作、他们之间最基本的不同、怎样在pipeline流动，怎么使用在应用当中</span><br><span class="line"> */</span><br><span class="line">public interface ChannelHandlerContext extends AttributeMap, ChannelInboundInvoker, ChannelOutboundInvoker &#123;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>channel ChannelHandler ChannelHandlerContext</tag>
      </tags>
  </entry>
  <entry>
    <title>netty源码分析(十八)Netty底层架构系统总结与应用实践</title>
    <url>/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E5%85%AB-Netty%E5%BA%95%E5%B1%82%E6%9E%B6%E6%9E%84%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<ol>
<li>一个EventLoopGroup当中会包含一个或多个EventLoop。</li>
<li>一个EventLoop在它的整个生命周期当中都只会与唯一一个Thread进行绑定。<span id="more"></span></li>
<li>所有由EventLoop所处理的各种I&#x2F;O事件都将在它所关联的那个Thread上进行处理。</li>
<li>一个Channel在它的整个生命周期中只会注册在一个EventLoop上。</li>
<li>一个EventLoop在运行过程中，会被分配给一个或多个Channel。</li>
<li>同一个Channel提交的任务执行顺序和提交顺序是一样的（先进去的先出来，任务队列）。</li>
</ol>
<p>重要结论：在netty的实现当中一定是线程安全的，基于此我们可以存储存储一个channel的引用，并且在需要向远程端点发送数据时，通过这个引用来调用Channel相应的方法；即便当时有很多线程在使用它也不会出现多线程问题，而且消息一定会按照顺序发送出去。</p>
<p>重要结论：我们在业务开发中，不要将长时间执行的耗时任务放入到EventLoop的执行队列中，因为它将会一直阻塞该线程所对应的所有Channel上的其他执行任务，如果我们需要进行阻塞调用或是耗时的操作（实际开发中很常见），那么我们就需要使用一个专门的EventExecutor（业务线程池）。</p>
<p>通常会有2种实现方式：<br>1、在ChannelHandler的回调方法中，使用自己定义的业务线程池，这样就可以实现异步调用。<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E5%85%AB-Netty%E5%BA%95%E5%B1%82%E6%9E%B6%E6%9E%84%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/20171111111532427.png" alt="这里写图片描述"><br>2、借助于netty提供的向ChannelPipeLine添加ChannelHandler时调用的addLast方法来传递EventExecutor。<br>说明：默认情况下（调用addLast(handler)），ChannelHandler中的回调方法都是由I&#x2F;O线程所执行，如果调用了ChannelPipeline addLast(EventExecutorGroup group, ChannelHandler… handlers);方法，那么ChannelHandler中的回调方法就是由参数中的group线程组来执行。<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E5%85%AB-Netty%E5%BA%95%E5%B1%82%E6%9E%B6%E6%9E%84%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/20171111111707281.png" alt="这里写图片描述">  </p>
<p>netty的异步：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E5%85%AB-Netty%E5%BA%95%E5%B1%82%E6%9E%B6%E6%9E%84%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/20171111123724142.png" alt="这里写图片描述">  </p>
<p>从上图可以看到，ChannelPromise继承了Promise 接口，而Promise是可以写的(writable)，什么是可以写的，之前的Future都是get，isSuccess之类的方法，在ChannelPromise里边可以看到setSuccess(Void result)【setSuccess只能写一次，下一次写报错】之类的写方法。ChannelPromise字面意思是承诺的意思，不管是成功还是失败会承诺给你一个结果。</p>
<p>JDK所提供的Future只能通过手工方式检查执行结果，而这个操作是会阻塞的；Netty则对ChannelFuture进行了增强，这里涉及到的是观察者模式，通过ChannelFutureListener以回调的方式来获取执行结果，去除了手工检查阻塞的操作，值得注意的是：ChannelFutureListener的operationcomplete方法是由I&#x2F;O线程执行的，因此要注意的是不要再这里执行耗时操作，否则需要需要通过另外的线程或线程池来执行。<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E5%85%AB-Netty%E5%BA%95%E5%B1%82%E6%9E%B6%E6%9E%84%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/20171111143540741.png" alt="这里写图片描述"><br>举例：jdk的Future得到返回结果是使用get或者isDone获取，而这两个方式是阻塞的，即使是用超时时间的方法如果时间到了获取不到也是返回null，这些事情都是开发人员自己做的，而Netty解决了这个弊端，netty通过在Future上加入了监听器的模式，注册到Future上若干Listner，Future持有Channel，当某一个事件发生的时候，Future调用对应的Listner的方法，方法入参会有当前Future的引用，所以在Listener里边就会得到Future的Channel，之后在Listener里边得到Channel的数据进行处理，这也是上边说的不要再Listener的方法里边处理耗时的业务的原因。</p>
<p>再说一下ChannelHandler，ChannelHandler有入栈和出栈的Handler，就拿ChannelInboundHandlerAdapter 来说，我们要写一个入栈处理器，需要必须重写接口里边的所有方法，但是我们只用一部分方法，而Adapter是一种适配器模式，会把所有方法实现，我们在用的时候直接用适配的类（要么重写要么直接使用）去实现业务逻辑就可以了，大大方便了开发者以及减轻来了开发者的工作量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ChannelInboundHandlerAdapter extends ChannelHandlerAdapter implements ChannelInboundHandler &#123;</span><br><span class="line">...略</span><br><span class="line">   public ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">   &#125;</span><br><span class="line">   public void channelRegistered(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">       ctx.fireChannelRegistered();</span><br><span class="line">   &#125;</span><br><span class="line">   public void channelUnregistered(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">       ctx.fireChannelUnregistered();</span><br><span class="line">   &#125;</span><br><span class="line">   ...略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ChannelInboundHandlerAdapter 的具体实现类有SimpleChannelInboundHandler,他和ChannelInboundHandlerAdapter 有什么区别呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class SimpleChannelInboundHandler&lt;I&gt; extends ChannelInboundHandlerAdapter</span><br><span class="line">&#123;</span><br><span class="line">...略</span><br><span class="line"> protected abstract void channelRead0(ChannelHandlerContext ctx, I msg) throws Exception;</span><br><span class="line"> //开发者必须实现该方法，因为是静态的（模板设计模式）</span><br><span class="line"> ...略</span><br><span class="line"></span><br><span class="line">     public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">       boolean release = true;</span><br><span class="line">       try &#123;</span><br><span class="line">           if (acceptInboundMessage(msg)) &#123;</span><br><span class="line">               @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">               I imsg = (I) msg;//强制转换</span><br><span class="line">               channelRead0(ctx, imsg);//暴露给开发者的接口，带有泛型</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               release = false;</span><br><span class="line">               ctx.fireChannelRead(msg);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (autoRelease &amp;&amp; release) &#123;</span><br><span class="line">               ReferenceCountUtil.release(msg);//引用数减一，将资源释放掉，因此消息的引用我们不要再外围引用，</span><br><span class="line">               //因为消息在这里被释放掉了</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很直观就是加了一个泛型I，I就是接受的消息的类型，比如String，Object等，而在ChannelInboundHandlerAdapter 里边四需要把消息 强制类型转换的，这是他们最大的区别。除此之外SimpleChannelInboundHandler会对消息执行ReferenceCountUtil.release(Object)和ReferenceCountUtil.retain(Object)  分别是释放一个消息引用和保持一个消息引用（流到下一个handler）.<br>我们一般会使用ChannelInboundHandlerAdapter 和SimpleChannelInboundHandler处理入栈数据。<br>实际应用：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E5%85%AB-Netty%E5%BA%95%E5%B1%82%E6%9E%B6%E6%9E%84%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/20171111154834954.png" alt="这里写图片描述"></p>
<p>ReferenceCountUtil的release方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static boolean release(Object msg) &#123;</span><br><span class="line">    if (msg instanceof ReferenceCounted) &#123;</span><br><span class="line">        return ((ReferenceCounted) msg).release();</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终使用的是ReferenceCounted类操作的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* A reference-counted object that requires explicit deallocation.</span><br><span class="line">* &lt;p&gt;</span><br><span class="line">* When a new &#123;@link ReferenceCounted&#125; is instantiated, it starts with the reference count of &#123;@code 1&#125;.</span><br><span class="line">* &#123;@link #retain()&#125; increases the reference count, and &#123;@link #release()&#125; decreases the reference count.</span><br><span class="line">* If the reference count is decreased to &#123;@code 0&#125;, the object will be deallocated explicitly, and accessing</span><br><span class="line">* the deallocated object will usually result in an access violation.</span><br><span class="line">* &lt;/p&gt;</span><br><span class="line">* 当一个ReferenceCounted被实例化的时候，它的引用数是1，retain()增加一个引用次数，release()减少一个引用次数，如果引用数量是0</span><br><span class="line">* 的时候，这个对象将会被显示的回收，去访问的一个被回收的对象通常的结果是访问违法常规的。</span><br><span class="line">* &lt;p&gt;</span><br><span class="line">* If an object that implements &#123;@link ReferenceCounted&#125; is a container of other objects that implement</span><br><span class="line">* &#123;@link ReferenceCounted&#125;, the contained objects will also be released via &#123;@link #release()&#125; when the container&#x27;s</span><br><span class="line">* reference count becomes 0.</span><br><span class="line">* &lt;/p&gt;</span><br><span class="line">* 如果一个一个实现了ReferenceCounted的类的对象最为一个容器，并且容器里边有若干对象，那么在容器外部被引用的次数为0的时候，随着容器的回收，</span><br><span class="line">* 容器内部的对象也会被回收。</span><br><span class="line">*/</span><br><span class="line">public interface ReferenceCounted &#123;</span><br><span class="line">....略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>netty源码分析(十六)Channel选择器工厂与轮询算法及注册底层实现</title>
    <url>/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E5%85%AD-Channel%E9%80%89%E6%8B%A9%E5%99%A8%E5%B7%A5%E5%8E%82%E4%B8%8E%E8%BD%AE%E8%AF%A2%E7%AE%97%E6%B3%95%E5%8F%8A%E6%B3%A8%E5%86%8C%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>上一节说到注册的入口，即<br>MultithreadEventLoopGroup:</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ChannelFuture register(Channel channel) &#123;</span><br><span class="line">    return next().register(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册channel第一步调用了next()方法，next()是MultithreadEventLoopGroup里边的:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public EventLoop next() &#123;</span><br><span class="line">    return (EventLoop) super.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到了父类MultithreadEventExecutorGroup：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public EventExecutor next() &#123;</span><br><span class="line">    return chooser.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里出现了一个chooser：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private final EventExecutorChooserFactory.EventExecutorChooser chooser;</span><br></pre></td></tr></table></figure>
<p>看一下他的结构,EventExecutorChooserFactory是一个工厂，生产各种Executor,，用EventExecutorChooserFactory的实现类DefaultEventExecutorChooserFactory看一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Default implementation which uses simple round-robin to choose next &#123;@link EventExecutor&#125;.</span><br><span class="line"> * 默认使用round-robin算法选择下一个实例的EventExecutor实现</span><br><span class="line"> * round-robin：主要用在负载均衡方向，比如有5台机器，第一次分请求到了第一台机器，第二次到了第二台机器，第三次请求到了第三台请求，以此类推一直到第五台机器，然后第六次又到了第一台机器，这样一个轮流的调用，处理负载，这里的Executor数组也是使用这种方式，保证数组里边的EventExecutor被均衡调用。</span><br><span class="line"> */</span><br><span class="line">public final class DefaultEventExecutorChooserFactory implements EventExecutorChooserFactory &#123;</span><br><span class="line">    public EventExecutorChooser newChooser(EventExecutor[] executors) &#123;</span><br><span class="line">        if (isPowerOfTwo(executors.length)) &#123;</span><br><span class="line">            return new PowerOfTwoEventExecutorChooser(executors);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return new GenericEventExecutorChooser(executors);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从这里可以看到netty对性能的压榨，当有2的指数个executor的时候使用PowerOfTwoEventExecutorChooser性能会比非指数个的GenericEventExecutorChooser性能高一点,PowerOfTwoEventExecutorChooser和GenericEventExecutorChooser都是DefaultEventExecutorChooserFactory 的静态内部类，都有next()方法返回一个EventExecutor。以上是对chooser的创建的一个分析,<br>回到MultithreadEventExecutorGroup看一下对chooser的赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//伪代码</span><br><span class="line">public abstract class MultithreadEventExecutorGroup extends AbstractEventExecutorGroup &#123;</span><br><span class="line">    private final EventExecutor[] children;</span><br><span class="line">    protected MultithreadEventExecutorGroup(int nThreads, Executor executor,</span><br><span class="line">                                            EventExecutorChooserFactory chooserFactory, Object... args) &#123;</span><br><span class="line">       children = new EventExecutor[nThreads];</span><br><span class="line">         for (int i = 0; i &lt; nThreads; i ++) &#123;</span><br><span class="line">            children[i] = newChild(executor, args);</span><br><span class="line">         &#125;   </span><br><span class="line">        chooser = chooserFactory.newChooser(children);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>children的来源是newChild()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Create a new EventExecutor which will later then accessible via the &#123;@link #next()&#125;  method. This method will be</span><br><span class="line"> * called for each thread that will serve this &#123;@link MultithreadEventExecutorGroup&#125;.</span><br><span class="line"> *</span><br><span class="line"> 创建一个EventExecutor ，稍后可以调用next()方法，这个next()方法被每个线程调用，这些线程 是服务MultithreadEventExecutorGroup的</span><br><span class="line"> */</span><br><span class="line">protected abstract EventExecutor newChild(Executor executor, Object... args) throws Exception;</span><br></pre></td></tr></table></figure>
<p>这个是EventExecutor 的创建，接下来我们看一下register方法，我们打了一个断点：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E5%85%AD-Channel%E9%80%89%E6%8B%A9%E5%99%A8%E5%B7%A5%E5%8E%82%E4%B8%8E%E8%BD%AE%E8%AF%A2%E7%AE%97%E6%B3%95%E5%8F%8A%E6%B3%A8%E5%86%8C%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/20171105130718472.png" alt="这里写图片描述"><br>之后debug进入register方法，我们进入的是SingleThreadEventLoop:<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E5%85%AD-Channel%E9%80%89%E6%8B%A9%E5%99%A8%E5%B7%A5%E5%8E%82%E4%B8%8E%E8%BD%AE%E8%AF%A2%E7%AE%97%E6%B3%95%E5%8F%8A%E6%B3%A8%E5%86%8C%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/20171105130647892.png" alt="这里写图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Abstract base class for &#123;@link EventLoop&#125;s that execute all its submitted tasks in a single thread.</span><br><span class="line"> * EventLoop的基础抽象类，所有提交的任务都会在一个线程里边执行。</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public abstract class SingleThreadEventLoop extends SingleThreadEventExecutor implements EventLoop &#123;</span><br><span class="line">...略</span><br><span class="line">    public ChannelFuture register(Channel channel) &#123;</span><br><span class="line">        return register(new DefaultChannelPromise(channel, this));</span><br><span class="line">    &#125;</span><br><span class="line">    ...略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DefaultChannelPromise是ChannelFuture的具体实现，	其持有Channel 和当前的EventLoop。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public DefaultChannelPromise(Channel channel, EventExecutor executor) &#123;</span><br><span class="line">    super(executor);</span><br><span class="line">    this.channel = channel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父类-&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultPromise&lt;V&gt; extends AbstractFuture&lt;V&gt; implements Promise&lt;V&gt; &#123;</span><br><span class="line">    public DefaultPromise(EventExecutor executor) &#123;</span><br><span class="line">        this.executor = checkNotNull(executor, &quot;executor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  最后我们来到register方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class SingleThreadEventLoop extends SingleThreadEventExecutor implements EventLoop</span><br><span class="line">    public ChannelFuture register(final ChannelPromise promise) &#123;</span><br><span class="line">        ObjectUtil.checkNotNull(promise, &quot;promise&quot;);</span><br><span class="line">        promise.channel().unsafe().register(this, promise);</span><br><span class="line">        return promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是注册逻辑的真正的入口了，出现了unsafe对象，下一节介绍。</p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>Channel注册 轮询算法</tag>
      </tags>
  </entry>
  <entry>
    <title>netty源码分析(十四)Netty初始化流程总结及Channel与ChannelHandlerContext作用域分析</title>
    <url>/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E5%9B%9B-Netty%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93%E5%8F%8AChannel%E4%B8%8EChannelHandlerContext%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>我们回到ServerBootstrap的init方法，之前介绍过Attribute的设置，那么Attribute的具体设置是怎样的呢：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    void init(Channel channel) throws Exception &#123;</span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line">        final Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class="line">        synchronized (options) &#123;</span><br><span class="line">            setChannelOptions(channel, options, logger);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class="line">        synchronized (attrs) &#123;</span><br><span class="line">            for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</span><br><span class="line">                channel.attr(key).set(e.getValue());//channel的实例是NioServerSocketChannel</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>我们在NioServerSocketChannel里边并没有找到attr方法，那么看一下NioServerSocketChannel层次关系：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E5%9B%9B-Netty%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93%E5%8F%8AChannel%E4%B8%8EChannelHandlerContext%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%88%86%E6%9E%90/20171029153531008.png" alt="这里写图片描述"><br>在DefaultAttributeMap找到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultAttributeMap implements AttributeMap &#123;</span><br><span class="line">    private volatile AtomicReferenceArray&lt;DefaultAttribute&lt;?&gt;&gt; attributes;</span><br><span class="line">    public &lt;T&gt; Attribute&lt;T&gt; attr(AttributeKey&lt;T&gt; key) &#123;</span><br><span class="line">....略</span><br><span class="line">    &#125;</span><br><span class="line">    ....略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>attr(AttributeKey<T> key)方法在DefaultAttributeMap 里边。<br>在NioServerSocketChannel还有一个    private final ServerSocketChannelConfig config;这样的一个生命，ServerSocketChannelConfig 用来设置ServerSocketChannel的一些配置信息的，可以看到ServerSocketChannelConfig 和Attribute共同完成了channel的配置。<br>类似：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Channel&#123;</span><br><span class="line"> private final ServerSocketChannelConfig config;</span><br><span class="line">  private volatile AtomicReferenceArray&lt;DefaultAttribute&lt;?&gt;&gt; attributes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Channel与ChannelHandlerContext作用域分析</strong><br>首先我们要知道netty4.0和netty4.1是不同的，4.1对ChannelHandlerContext.attr(..) 和 Channel.attr(..)的改进：<br><span class="exturl" data-url="aHR0cDovL25ldHR5LmlvL3dpa2kvbmV3LWFuZC1ub3Rld29ydGh5LWluLTQuMS5odG1s">http://netty.io/wiki/new-and-noteworthy-in-4.1.html<i class="fa fa-external-link-alt"></i></span></p>
<p>ChannelHandlerContext.attr(..) &#x3D;&#x3D; Channel.attr(..)<br>Both Channel and ChannelHandlerContext implement the interface AttributeMap to enable a user to attach one or more user-defined attributes to them. What sometimes made a user confused was that a Channel and a ChannelHandlerContext had its own storage for the user-defined attributes. For example, even if you put an attribute ‘KEY_X’ via Channel.attr(KEY_X).set(valueX), you will never find it via ChannelHandlerContext.attr(KEY_X).get() and vice versa. This behavior is not only confusing but also is waste of memory.<br>Channel 和ChannelHandlerContext都 实现了AttributeMap 用来设置用户自定义的属性。有时候Channel 和ChannelHandlerContext 都有自己的一套用户定义的属性（相互之间没有任何关系，即Channel 有自己的map，ChannelHandlerContext 也有自己的map）让用户感到非常困惑，比如我们使用 Channel.attr(KEY_X).set(valueX)设置一个key和value，但是没法通过ChannelHandlerContext.attr(KEY_X).get()方式获得，而且这样还浪费内存。<br>To address this issue, we decided to keep only one map per Channel internally. AttributeMap always uses AttributeKey as its key. AttributeKey ensures uniqueness between each key, and thus there’s no point of having more than one attribute map per Channel. As long as a user defines its own AttributeKey as a private static final field of his or her ChannelHandler, there will be no risk of duplicate keys.<br>为了解决这个问题，我们决定在每个Channel 内部只维护一个map，AttributeMap 永远使用AttributeKey 作为他的key，AttributeKey 保证在所有key之中是唯一的，这样就没有必要每个Channel定义多个属性，这样每个用户在ChannelHandler里边定义私有的静态属性的key（AttributeKey ）就没有重复键的问题。</p>
<p> 我们看一下实际的代码是怎么写的：<br> Channel的实现类NioServerSocketChannel的父类DefaultAttributeMap的attr方法：<br> <img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8D%81%E5%9B%9B-Netty%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93%E5%8F%8AChannel%E4%B8%8EChannelHandlerContext%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%88%86%E6%9E%90/20171029161754857.png" alt="这里写图片描述"></p>
<p> ChannelHandlerContext 实现类AbstractChannelHandlerContext的attr方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abstract class AbstractChannelHandlerContext extends DefaultAttributeMap</span><br><span class="line">        implements ChannelHandlerContext, ResourceLeakHint &#123;</span><br><span class="line">        ...略</span><br><span class="line">     public &lt;T&gt; Attribute&lt;T&gt; attr(AttributeKey&lt;T&gt; key) &#123;</span><br><span class="line">        return channel().attr(key);//直接使用的是channel的attr属性</span><br><span class="line">    &#125;</span><br><span class="line">    ...略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到ChannelHandlerContext 和Channel用的都是Channel的attr，即：ChannelHandlerContext.attr(..) &#x3D;&#x3D; Channel.attr(..)<br>到此为止netty的2大模块（初始化和注册）的初始流程解析完毕。接下来说一下注册流程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final ChannelFuture initAndRegister() &#123;</span><br><span class="line">       Channel channel = null;</span><br><span class="line">       try &#123;</span><br><span class="line">           channel = channelFactory.newChannel();</span><br><span class="line">           init(channel);//初始化</span><br><span class="line">       &#125; catch (Throwable t) &#123;</span><br><span class="line">           if (channel != null) &#123;</span><br><span class="line">               // channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))</span><br><span class="line">               channel.unsafe().closeForcibly();</span><br><span class="line">           &#125;</span><br><span class="line">           // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span><br><span class="line">           return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">       &#125;</span><br><span class="line">       ChannelFuture regFuture = config().group().register(channel);//注册</span><br><span class="line">       if (regFuture.cause() != null) &#123;</span><br><span class="line">           if (channel.isRegistered()) &#123;</span><br><span class="line">               channel.close();</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               channel.unsafe().closeForcibly();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return regFuture;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>初始化 channel ChannelHandlerContext</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制在权限系统中的应用</title>
    <url>/2018/09/28/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9C%A8%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p><strong>基于二进制的权限管理与验证</strong><br> <strong>1. 权限值的设定</strong><br>       用二进制来表示权限值应该是按位来设置，每个位占一个，表示一种权限，如：</p>
<span id="more"></span>

<pre><code>    00000001表示十进制1，
    00000010表示十进制2，
    00000100表示十进制4，
    00001000表示十进制8；
    依次类推，才能清晰正确的标识，多种权限的赋予则使用“或运算”，此时各位比较混乱，如00000011表示十进制3，此时它意味着拥有两种权
    限。

**Long userrolevalue ;//用户的权限值，根据他属于的权限组，这个值会不同
Long oprolevalue   ;//一个操作的权限值，根据他属于的权限组，这个值会不同**
</code></pre>
<p> <strong>2. 权限的赋予(或运算)</strong><br>         	 userrolevalue &#x3D; userrolevalue | oprolevalue<br>        假设一个用户u1，他的初始权限值为0(00000000)。如果要指定他有经理的权限，经理的权限值为4(00000100),在第三个二进制位为1。<br>        很显然，userrolevalue &#x3D;  0 | 4 ,值为4，如果u1要同时具有文员、主管、经理的权限呢，<br>        userrolevalue &#x3D; 0 | 1   00000000 | 00000001  &#x3D; 00000001<br>        userrolevalue &#x3D; 1 | 2   00000001 | 00000010  &#x3D; 00000011<br>        userrolevalue &#x3D; 3 | 4   00000011 | 00000100  &#x3D; 00000111<br>        这样，第1、2、3位都是1了，<strong>用 “或”的好处就是只改变指定位的值，如果用户已经有了该权限，直接简单的用加法来做会出错,而用”或”再<br>         赋予一次，也不会出错</strong>，如下：<br>        userrolevalue &#x3D; 7 | 4   00000111 | 00000100  &#x3D; 00000111<br> <strong>3. 权限的除去(求补、与运算)</strong><br>         userrolevalue &#x3D; userrolevalue &amp; (~oprolevalue)<br>假设一个用户u1,他的初始权限值为7(00000111),说明他能做文员、主管、经理权限组所能作的所有操作。如果不想让他有主管权限组能作的操作呢，那么，就要把他的权限值变为00000101，而主管权限组的权限值是00000010，显然简单的用减法，肯定也是不行的，但是先对00000010作补运算，可以得到11111101，再同00000111作与运算，就得到了00000101，这样就只对第二位作了改变，不会影响到其它位，我们的目的也就达到了。</p>
<p><strong>对于一个操作，哪些权限组能操作它，也可以用与运算来做，不让某些权限组有些操作的权限，也可以先求补，再作与运算来解决。</strong><br> <strong>4. 权限的验证(与运算)</strong><br>     (userrolevalue &amp; oprolevalue) !&#x3D; 0表示拥有oprolevalue所表示权限</p>
<p>　例如：现有一个用户User的权限为6(00000110)，通过&amp;(与)运算，使用公式 “(User的权限 &amp; 权限值) !&#x3D; 0” 即可判断拥有某个权限值表示的权限—-6 &amp; 2 &#x3D;&#x3D; 2 (00000110 &amp; 00000010 &#x3D;&#x3D; 00000010)，表示User拥有主管权限；6 ＆ 4 !&#x3D;0 (00000110 &amp; 00000100 &#x3D;&#x3D; 00000100) ，表示User拥有经理权限；6 &amp; 1 &#x3D;&#x3D; 0(00000110 &amp; 00000001 &#x3D;&#x3D; 00000000)，表示User无文员权限；</p>
]]></content>
      <categories>
        <category>binaryCode</category>
      </categories>
      <tags>
        <tag>binaryCode privilege</tag>
      </tags>
  </entry>
  <entry>
    <title>netty源码分析(四)Netty提供的Future与ChannelFuture优势分析与源码讲解</title>
    <url>/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%9B%9B-Netty%E6%8F%90%E4%BE%9B%E7%9A%84Future%E4%B8%8EChannelFuture%E4%BC%98%E5%8A%BF%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<p>上一节我们讲到netty启动服务类AbstractBootstrap的doBind的方法：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private ChannelFuture doBind(final SocketAddress localAddress) &#123;</span><br><span class="line">    final ChannelFuture regFuture = initAndRegister();</span><br><span class="line">    ...略</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>这里边有一个重要的类ChannelFuture ：<br><img src="/2018/10/04/netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%9B%9B-Netty%E6%8F%90%E4%BE%9B%E7%9A%84Future%E4%B8%8EChannelFuture%E4%BC%98%E5%8A%BF%E5%88%86%E6%9E%90%E4%B8%8E%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3/20170916155223422.png" alt="这里写图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最红他们的接口会来到jdk的Future接口，Future代表了一个异步处理的结果。</span><br><span class="line">/**</span><br><span class="line"> * A &#123;@code Future&#125; represents the result of an asynchronous</span><br><span class="line"> * computation.  Methods are provided to check if the computation is</span><br><span class="line"> * complete, to wait for its completion, and to retrieve the result of</span><br><span class="line"> * the computation.  The result can only be retrieved using method</span><br><span class="line"> * &#123;@code get&#125; when the computation has completed, blocking if</span><br><span class="line"> * necessary until it is ready.  Cancellation is performed by the</span><br><span class="line"> * &#123;@code cancel&#125; method.  Additional methods are provided to</span><br><span class="line"> * determine if the task completed normally or was cancelled. Once a</span><br><span class="line"> * computation has completed, the computation cannot be cancelled.</span><br><span class="line"> * If you would like to use a &#123;@code Future&#125; for the sake</span><br><span class="line"> * of cancellability but not provide a usable result, you can</span><br><span class="line"> * declare types of the form &#123;@code Future&lt;?&gt;&#125; and</span><br><span class="line"> * return &#123;@code null&#125; as a result of the underlying task.</span><br><span class="line"> 译：</span><br><span class="line">一个Future代表一个一步计算的结果，它提供了一些方法检查是否计算完毕，比如等待计算完毕，获取计算结果的方法。</span><br><span class="line">当计算完毕之后只能通过get方法获取结果，或者一直阻塞等待计算的完成。取消操作通过cancle方法来取消，</span><br><span class="line">另外还提供了检测是正常的完成还是被取消的方法，当一个计算完成后，不能进行取消操作。如果你想用Future实现取消，</span><br><span class="line">但是却没有一个可用的结果，你可以声明很多Future的类型，然后返回一个null的结果给当前任务。</span><br><span class="line"></span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * &lt;b&gt;Sample Usage&lt;/b&gt; (Note that the following classes are all</span><br><span class="line"> * made-up.)</span><br><span class="line"> * &lt;pre&gt; &#123;@code</span><br><span class="line"> * interface ArchiveSearcher &#123; String search(String target); &#125;</span><br><span class="line"> * class App &#123;</span><br><span class="line"> *   ExecutorService executor = ...//线程池</span><br><span class="line"> *   ArchiveSearcher searcher = ...//搜索接口</span><br><span class="line"> *   void showSearch(final String target)</span><br><span class="line"> *       throws InterruptedException &#123;</span><br><span class="line"> *     Future&lt;String&gt; future</span><br><span class="line"> *       = executor.submit(new Callable&lt;String&gt;() &#123;//创建一个Callable给线程池，Callable是有返回结果的。</span><br><span class="line"> *         public String call() &#123;</span><br><span class="line"> *             return searcher.search(target);</span><br><span class="line"> *         &#125;&#125;);</span><br><span class="line"> *     displayOtherThings(); // do other things while searching  中间可以做其他的事情，submit不会阻塞。</span><br><span class="line"> *     try &#123;</span><br><span class="line"> *       displayText(future.get()); // use future  使用future的get拿到线程的处理结果，此处是阻塞的方式。</span><br><span class="line"> *     &#125; catch (ExecutionException ex) &#123; cleanup(); return; &#125;</span><br><span class="line"> *   &#125;</span><br><span class="line"> * &#125;&#125;&lt;/pre&gt;</span><br><span class="line"> *</span><br><span class="line"> * The &#123;@link FutureTask&#125; class is an implementation of &#123;@code Future&#125; that</span><br><span class="line"> * implements &#123;@code Runnable&#125;, and so may be executed by an &#123;@code Executor&#125;.</span><br><span class="line"> * FutureTask是Future的实现类，并且实现了Runnable接口，因此可以被Executor执行。</span><br><span class="line"> * For example, the above construction with &#123;@code submit&#125; could be replaced by:</span><br><span class="line"> * 之前的方式可以被下边的FutureTask的方式替换。</span><br><span class="line"> *  &lt;pre&gt; &#123;@code</span><br><span class="line"> * FutureTask&lt;String&gt; future =</span><br><span class="line"> *   new FutureTask&lt;String&gt;(new Callable&lt;String&gt;() &#123;</span><br><span class="line"> *     public String call() &#123;</span><br><span class="line"> *       return searcher.search(target);</span><br><span class="line"> *   &#125;&#125;);</span><br><span class="line"> * executor.execute(future);&#125;&lt;/pre&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Memory consistency effects: Actions taken by the asynchronous computation</span><br><span class="line"> * &lt;a href=&quot;package-summary.html#MemoryVisibility&quot;&gt; &lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;</span><br><span class="line"> * actions following the corresponding &#123;@code Future.get()&#125; in another thread.</span><br><span class="line"> * 内存一致性影响：异步计算的动作的完成，发生在Future.get()之前。</span><br><span class="line"> * @see FutureTask</span><br><span class="line"> * @see Executor</span><br><span class="line"> * @since 1.5</span><br><span class="line"> * @author Doug Lea</span><br><span class="line"> * @param &lt;V&gt; The result type returned by this Future&#x27;s &#123;@code get&#125; method</span><br><span class="line"> */</span><br><span class="line"> public interface Future&lt;V&gt; &#123;</span><br><span class="line">	 boolean cancel(boolean mayInterruptIfRunning);</span><br><span class="line">	 boolean isCancelled();</span><br><span class="line">	 boolean isDone();</span><br><span class="line">	 V get() throws InterruptedException, ExecutionException;</span><br><span class="line">	 V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">     V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125;</span><br></pre></td></tr></table></figure>
<p>io.netty.util.concurrent.Future对java.util.concurrent.Future进行了扩展：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Future&lt;V&gt; extends java.util.concurrent.Future&lt;V&gt; &#123;</span><br><span class="line">    boolean isSuccess();//是否计算成功</span><br><span class="line">    boolean isCancellable();//可以被取消</span><br><span class="line">    Throwable cause();//原因</span><br><span class="line">    Future&lt;V&gt; addListener(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt; listener);//添加一个监听器</span><br><span class="line">    Future&lt;V&gt; addListeners(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt;... listeners);//添加多个监听器</span><br><span class="line">    Future&lt;V&gt; removeListener(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt; listener);//移除一个监听器</span><br><span class="line">    Future&lt;V&gt; removeListeners(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt;... listeners);//移除多个监听器</span><br><span class="line">    Future&lt;V&gt; sync() throws InterruptedException;//等待结果返回</span><br><span class="line">    Future&lt;V&gt; syncUninterruptibly();//等待结果返回，不能被中断</span><br><span class="line">    Future&lt;V&gt; await() throws InterruptedException;//等待结果返回</span><br><span class="line">    Future&lt;V&gt; awaitUninterruptibly();//等待结果返回，不能被中断</span><br><span class="line">    boolean await(long timeout, TimeUnit unit) throws InterruptedException;</span><br><span class="line">    boolean await(long timeoutMillis) throws InterruptedException;</span><br><span class="line">    boolean awaitUninterruptibly(long timeout, TimeUnit unit);</span><br><span class="line">    boolean awaitUninterruptibly(long timeoutMillis);</span><br><span class="line">    V getNow();//立刻返回，没有计算完毕，返回null，需要配合isDone()方法判定是不是已经完成，因为runnable没有返回结果，</span><br><span class="line">    //而callable有返回结果</span><br><span class="line">    boolean cancel(boolean mayInterruptIfRunning);  //取消                                                          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提到一个监听器GenericFutureListener的封装，一碰到XXXlistener，都会用到监听器模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Listens to the result of a &#123;@link Future&#125;.  The result of the asynchronous operation is notified once this listener</span><br><span class="line"> * is added by calling &#123;@link Future#addListener(GenericFutureListener)&#125;.</span><br><span class="line"> * 监听Future的结果，当一个监听器被注册后，结果的异步操作会被注册的监听器监听。</span><br><span class="line"> */</span><br><span class="line">public interface GenericFutureListener&lt;F extends Future&lt;?&gt;&gt; extends EventListener &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Invoked when the operation associated with the &#123;@link Future&#125; has been completed.</span><br><span class="line">     *</span><br><span class="line">     * 和Future的完成计算相关的事件，次方法会被调用。</span><br><span class="line">     */</span><br><span class="line">    void operationComplete(F future) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>监听器对Future的扩展起到了很灵活的作用，当某个计算完毕，会触发相应的时间，得到Future的结果，因为jdk的get方法我们知道什么时候去掉，调早了需要等待，调晚了浪费了一段时间，还有isDone里边有2种情况，无法区分到底是正常的io完毕返回的true还是被取消之后返回的true，所有到了netty的Future里边加了一个isSuccess()方法，只有正常的io处理结束isSuccess()才返回true。</p>
<p>接下来我们会走一下ChannelFuture的源码的doc：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The result of an asynchronous &#123;@link Channel&#125; I/O operation.</span><br><span class="line"> * Channel的异步io操作的结果。</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * All I/O operations in Netty are asynchronous.  It means any I/O calls will</span><br><span class="line"> * return immediately with no guarantee that the requested I/O operation has</span><br><span class="line"> * been completed at the end of the call.  Instead, you will be returned with</span><br><span class="line"> * a &#123;@link ChannelFuture&#125; instance which gives you the information about the</span><br><span class="line"> * result or status of the I/O operation.</span><br><span class="line"> * netty中所有的i/o都是异步的，意味着很多i/o操作被调用过后会立刻返回，并且不能保证i/o请求操作被调用后计算已经完毕，</span><br><span class="line"> * 替代它的是返回一个当前i/o操作状态和结果信息的ChannelFuture实例。</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * A &#123;@link ChannelFuture&#125; is either &lt;em&gt;uncompleted&lt;/em&gt; or &lt;em&gt;completed&lt;/em&gt;.</span><br><span class="line"> * When an I/O operation begins, a new future object is created.  The new future</span><br><span class="line"> * is uncompleted initially - it is neither succeeded, failed, nor cancelled</span><br><span class="line"> * because the I/O operation is not finished yet.  If the I/O operation is</span><br><span class="line"> * finished either successfully, with failure, or by cancellation, the future is</span><br><span class="line"> * marked as completed with more specific information, such as the cause of the</span><br><span class="line"> * failure.  Please note that even failure and cancellation belong to the</span><br><span class="line"> * completed state.</span><br><span class="line"> * 一个ChannelFuture要么是完成的，要么是未完成的。当一个i/o操作开始的时候，会创建一个future 对象，future 初始化的时候是为完成的状态，</span><br><span class="line"> * 既不是是成功的，或者失败的，也不是取消的，因为i/o操作还没有完成，如果一个i/o不管是成功，还是失败，或者被取消，future 会被标记一些特殊</span><br><span class="line"> * 的信息，比如失败的原因，请注意即使是失败和取消也属于完成状态。</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> *                                      +---------------------------+</span><br><span class="line"> *                                      | Completed successfully    |</span><br><span class="line"> *                                      +---------------------------+</span><br><span class="line"> *                                 +----&gt;      isDone() = true      |</span><br><span class="line"> * +--------------------------+    |    |   isSuccess() = true      |</span><br><span class="line"> * |        Uncompleted       |    |    +===========================+</span><br><span class="line"> * +--------------------------+    |    | Completed with failure    |</span><br><span class="line"> * |      isDone() = false    |    |    +---------------------------+</span><br><span class="line"> * |   isSuccess() = false    |----+----&gt;      isDone() = true      |</span><br><span class="line"> * | isCancelled() = false    |    |    |       cause() = non-null  |</span><br><span class="line"> * |       cause() = null     |    |    +===========================+</span><br><span class="line"> * +--------------------------+    |    | Completed by cancellation |</span><br><span class="line"> *                                 |    +---------------------------+</span><br><span class="line"> *                                 +----&gt;      isDone() = true      |</span><br><span class="line"> *                                      | isCancelled() = true      |</span><br><span class="line"> *                                      +---------------------------+</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line"> *</span><br><span class="line"> * Various methods are provided to let you check if the I/O operation has been</span><br><span class="line"> * completed, wait for the completion, and retrieve the result of the I/O</span><br><span class="line"> * operation. It also allows you to add &#123;@link ChannelFutureListener&#125;s so you</span><br><span class="line"> * can get notified when the I/O operation is completed.</span><br><span class="line"> * ChannelFuture提供了很多方法让你检查i/o操作是否完成、等待完成、获取i/o操作的结果，他也允许你添加ChannelFutureListener</span><br><span class="line"> * 因此可以在i/o操作完成的时候被通知。</span><br><span class="line"> * &lt;h3&gt;Prefer &#123;@link #addListener(GenericFutureListener)&#125; to &#123;@link #await()&#125;&lt;/h3&gt;</span><br><span class="line"> * 建议使用addListener(GenericFutureListener)，而不使用await()</span><br><span class="line"> * It is recommended to prefer &#123;@link #addListener(GenericFutureListener)&#125; to</span><br><span class="line"> * &#123;@link #await()&#125; wherever possible to get notified when an I/O operation is</span><br><span class="line"> * done and to do any follow-up tasks.</span><br><span class="line"> * 推荐优先使用addListener(GenericFutureListener)，不是await()在可能的情况下，这样就能在i/o操作完成的时候收到通知，并且可以去做</span><br><span class="line"> * 后续的任务处理。</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * &#123;@link #addListener(GenericFutureListener)&#125; is non-blocking.  It simply adds</span><br><span class="line"> * the specified &#123;@link ChannelFutureListener&#125; to the &#123;@link ChannelFuture&#125;, and</span><br><span class="line"> * I/O thread will notify the listeners when the I/O operation associated with</span><br><span class="line"> * the future is done.  &#123;@link ChannelFutureListener&#125; yields the best</span><br><span class="line"> * performance and resource utilization because it does not block at all, but</span><br><span class="line"> * it could be tricky to implement a sequential logic if you are not used to</span><br><span class="line"> * event-driven programming.</span><br><span class="line"> * addListener(GenericFutureListener)本身是非阻塞的，他会添加一个指定的ChannelFutureListener到ChannelFuture</span><br><span class="line"> * 并且i/o线程在完成对应的操作将会通知监听器，ChannelFutureListener也会提供最好的性能和资源利用率，因为他永远不会阻塞，但是如果</span><br><span class="line"> * 不是基于事件编程，他可能在顺序逻辑存在棘手的问题。</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * By contrast, &#123;@link #await()&#125; is a blocking operation.  Once called, the</span><br><span class="line"> * caller thread blocks until the operation is done.  It is easier to implement</span><br><span class="line"> * a sequential logic with &#123;@link #await()&#125;, but the caller thread blocks</span><br><span class="line"> * unnecessarily until the I/O operation is done and there&#x27;s relatively</span><br><span class="line"> * expensive cost of inter-thread notification.  Moreover, there&#x27;s a chance of</span><br><span class="line"> * dead lock in a particular circumstance, which is described below.</span><br><span class="line"> *相反的，await()是一个阻塞的操作，一旦被调用，调用者线程在操作完成之前是阻塞的，实现顺序的逻辑比较容易，但是他让调用者线程等待是没有必要</span><br><span class="line"> * 的，会造成资源的消耗，更多可能性会造成死锁，接下来会介绍。</span><br><span class="line"> * &lt;h3&gt;Do not call &#123;@link #await()&#125; inside &#123;@link ChannelHandler&#125;&lt;/h3&gt;</span><br><span class="line"> * 不要再ChannelHandler里边调用await()方法</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * The event handler methods in &#123;@link ChannelHandler&#125; are usually called by</span><br><span class="line"> * an I/O thread.  If &#123;@link #await()&#125; is called by an event handler</span><br><span class="line"> * method, which is called by the I/O thread, the I/O operation it is waiting</span><br><span class="line"> * for might never complete because &#123;@link #await()&#125; can block the I/O</span><br><span class="line"> * operation it is waiting for, which is a dead lock.</span><br><span class="line"> * ChannelHandler里边的时间处理器通常会被i/o线程调用，如果await()被一个时间处理方法调用，并且是一个i/o线程，那么这个i/o操作将永远不会</span><br><span class="line"> * 完成，因为await()是会阻塞i/o操作，这是一个死锁。</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> * // BAD - NEVER DO THIS 不推荐的使用方式</span><br><span class="line"> * &#123;@code @Override&#125;</span><br><span class="line"> * public void channelRead(&#123;@link ChannelHandlerContext&#125; ctx, Object msg) &#123;</span><br><span class="line"> *     &#123;@link ChannelFuture&#125; future = ctx.channel().close();</span><br><span class="line"> *     future.awaitUninterruptibly();//不要使用await的 方式</span><br><span class="line"> *     // Perform post-closure operation</span><br><span class="line"> *     // ...</span><br><span class="line"> * &#125;</span><br><span class="line"> *</span><br><span class="line"> * // GOOD</span><br><span class="line"> * &#123;@code @Override&#125; //推荐使用的方式</span><br><span class="line"> * public void channelRead(&#123;@link ChannelHandlerContext&#125; ctx, Object msg) &#123;</span><br><span class="line"> *     &#123;@link ChannelFuture&#125; future = ctx.channel().close();</span><br><span class="line"> *     future.addListener(new &#123;@link ChannelFutureListener&#125;() &#123;//使用时间的方式</span><br><span class="line"> *         public void operationComplete(&#123;@link ChannelFuture&#125; future) &#123;</span><br><span class="line"> *             // Perform post-closure operation</span><br><span class="line"> *             // ...</span><br><span class="line"> *         &#125;</span><br><span class="line"> *     &#125;);</span><br><span class="line"> * &#125;</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * In spite of the disadvantages mentioned above, there are certainly the cases</span><br><span class="line"> * where it is more convenient to call &#123;@link #await()&#125;. In such a case, please</span><br><span class="line"> * make sure you do not call &#123;@link #await()&#125; in an I/O thread.  Otherwise,</span><br><span class="line"> * &#123;@link BlockingOperationException&#125; will be raised to prevent a dead lock.</span><br><span class="line"> * 尽管出现了上面提到的这些缺陷，但是在某些情况下更方便，在这种情况下，请确保不要再i/o线程里边调用await()方法，</span><br><span class="line"> * 否则会出现BlockingOperationException异常，导致死锁。</span><br><span class="line"> * &lt;h3&gt;Do not confuse I/O timeout and await timeout&lt;/h3&gt;</span><br><span class="line"> *不要将i/o超时和等待超时混淆。</span><br><span class="line"> * The timeout value you specify with &#123;@link #await(long)&#125;,</span><br><span class="line"> * &#123;@link #await(long, TimeUnit)&#125;, &#123;@link #awaitUninterruptibly(long)&#125;, or</span><br><span class="line"> * &#123;@link #awaitUninterruptibly(long, TimeUnit)&#125; are not related with I/O</span><br><span class="line"> * timeout at all.  If an I/O operation times out, the future will be marked as</span><br><span class="line"> * &#x27;completed with failure,&#x27; as depicted in the diagram above.  For example,</span><br><span class="line"> * connect timeout should be configured via a transport-specific option:</span><br><span class="line"> * 使用await(long)、await(long, TimeUnit)、awaitUninterruptibly(long)、awaitUninterruptibly(long, TimeUnit)设置的超时时间</span><br><span class="line"> * 和i/o超时没有任何关系，如果一个i/o操作超时，future 将被标记为失败的完成状态，比如连接超时通过一些选项来配置：</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> * // BAD - NEVER DO THIS //不推荐的方式</span><br><span class="line"> * &#123;@link Bootstrap&#125; b = ...;</span><br><span class="line"> * &#123;@link ChannelFuture&#125; f = b.connect(...);</span><br><span class="line"> * f.awaitUninterruptibly(10, TimeUnit.SECONDS);//不真正确的等待超时</span><br><span class="line"> * if (f.isCancelled()) &#123;</span><br><span class="line"> *     // Connection attempt cancelled by user</span><br><span class="line"> * &#125; else if (!f.isSuccess()) &#123;</span><br><span class="line"> *     // You might get a NullPointerException here because the future//不能确保future 的完成。</span><br><span class="line"> *     // might not be completed yet.</span><br><span class="line"> *     f.cause().printStackTrace();</span><br><span class="line"> * &#125; else &#123;</span><br><span class="line"> *     // Connection established successfully</span><br><span class="line"> * &#125;</span><br><span class="line"> *</span><br><span class="line"> * // GOOD//推荐的方式</span><br><span class="line"> * &#123;@link Bootstrap&#125; b = ...;</span><br><span class="line"> * // Configure the connect timeout option.</span><br><span class="line"> * &lt;b&gt;b.option(&#123;@link ChannelOption&#125;.CONNECT_TIMEOUT_MILLIS, 10000);&lt;/b&gt;//配置连接超时</span><br><span class="line"> * &#123;@link ChannelFuture&#125; f = b.connect(...);</span><br><span class="line"> * f.awaitUninterruptibly();</span><br><span class="line"> *</span><br><span class="line"> * // Now we are sure the future is completed.//确保future 一定是完成了。</span><br><span class="line"> * assert f.isDone();</span><br><span class="line"> *</span><br><span class="line"> * if (f.isCancelled()) &#123;</span><br><span class="line"> *     // Connection attempt cancelled by user</span><br><span class="line"> * &#125; else if (!f.isSuccess()) &#123;</span><br><span class="line"> *     f.cause().printStackTrace();</span><br><span class="line"> * &#125; else &#123;</span><br><span class="line"> *     // Connection established successfully</span><br><span class="line"> * &#125;</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line"> */</span><br><span class="line">public interface ChannelFuture extends Future&lt;Void&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns a channel where the I/O operation associated with this</span><br><span class="line">     * future takes place.</span><br><span class="line">	 * 返回和当前future 相关联的i/o操作的channel</span><br><span class="line">     */</span><br><span class="line">    Channel channel();</span><br><span class="line">    ChannelFuture addListener(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt; listener);</span><br><span class="line">    ChannelFuture addListeners(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt;... listeners);</span><br><span class="line">    ChannelFuture removeListener(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt; listener);</span><br><span class="line">    ChannelFuture removeListeners(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt;... listeners);</span><br><span class="line">    ChannelFuture sync() throws InterruptedException;</span><br><span class="line">    ChannelFuture syncUninterruptibly();</span><br><span class="line">    ChannelFuture await() throws InterruptedException;</span><br><span class="line">    ChannelFuture awaitUninterruptibly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一接介绍initAndRegister( )方法。</p>
]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>Future ChannelFuture</tag>
      </tags>
  </entry>
  <entry>
    <title>几种常见的【排序】与【数据结构】</title>
    <url>/2018/09/28/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E3%80%90%E6%8E%92%E5%BA%8F%E3%80%91%E4%B8%8E%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91/</url>
    <content><![CDATA[<p><strong>（一）常见排序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Sort &#123;</span><br><span class="line">//快速排序</span><br><span class="line">	private static int partition(int[] arr, int low, int hight) &#123;</span><br><span class="line">		int pivotkey = arr[low];</span><br><span class="line">		while (low &lt; hight) &#123;</span><br><span class="line">			while (low &lt; hight &amp;&amp; pivotkey &lt;= arr[hight])</span><br><span class="line">				--hight;</span><br><span class="line">			int temp1 = arr[low];</span><br><span class="line">			arr[low]=arr[hight];</span><br><span class="line">			arr[hight]=temp1;</span><br><span class="line">			//arr[low] = arr[hight];</span><br><span class="line">			while (low &lt; hight &amp;&amp; pivotkey &gt;= arr[low])</span><br><span class="line">				++low;</span><br><span class="line">			int temp2 = arr[low];</span><br><span class="line">			arr[low]=arr[hight];</span><br><span class="line">			arr[hight]=temp2;</span><br><span class="line">			//arr[hight] = arr[low];</span><br><span class="line">		&#125;</span><br><span class="line">		return low;</span><br><span class="line">	&#125;</span><br><span class="line">//快速排序</span><br><span class="line">	public static void qSort(int[] arr, int low, int hight) &#123;</span><br><span class="line">		if (low &lt; hight) &#123;</span><br><span class="line">			int pivotkey = partition(arr, low, hight);</span><br><span class="line">			qSort(arr, low, pivotkey - 1);</span><br><span class="line">			qSort(arr, pivotkey + 1, hight);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">//插入排序</span><br><span class="line">	public static int[] insertOrder(int a[])&#123;</span><br><span class="line">		for (int i = 1; i &lt; a.length; i++) &#123;</span><br><span class="line">			int k = a[i];</span><br><span class="line">			int j;</span><br><span class="line">			for (j = i - 1; j &gt;= 0 &amp;&amp; k &lt; a[j]; j--) &#123;</span><br><span class="line">				a[j + 1] = a[j];</span><br><span class="line">			&#125;</span><br><span class="line">			a[j + 1] = k;</span><br><span class="line">			//System.out.println(Arrays.toString(a));</span><br><span class="line">		&#125;</span><br><span class="line">		return a;</span><br><span class="line">	&#125;</span><br><span class="line">	//冒泡排序</span><br><span class="line">	public static int[] maopao(int[] a)&#123;</span><br><span class="line"></span><br><span class="line">		for(int i=0;i&lt;a.length-1;i++)&#123;//i 代表伦次</span><br><span class="line">			for(int j=0;j&lt;a.length-i-1;j++)&#123;//j和j+1代表相邻元素</span><br><span class="line">				if(a[j]&gt;a[j+1])&#123;</span><br><span class="line">					int temp = a[j];</span><br><span class="line">					a[j]= a[j+1];</span><br><span class="line">					a[j+1]=temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			//System.out.println(Arrays.toString(a));</span><br><span class="line">			//Arrays.sort(a);</span><br><span class="line">		&#125;</span><br><span class="line">		return a;</span><br><span class="line">	&#125;</span><br><span class="line">	//选择排序</span><br><span class="line">	public int[] selectOrder(int arr[] ) &#123;</span><br><span class="line">		for (int i = 0; i &lt;arr.length; i++) &#123;</span><br><span class="line">			int max = arr[i];</span><br><span class="line">			for (int j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">				if (arr[j] &lt; max) &#123;</span><br><span class="line">					int temp = arr[j];</span><br><span class="line">					arr[j] = max;</span><br><span class="line">					max = temp;</span><br><span class="line">					arr[i] = max;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return arr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 二分查找</span><br><span class="line">		public void binarySearch() &#123;</span><br><span class="line">			int b[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 &#125;;</span><br><span class="line">			int start = 0;</span><br><span class="line">			int end = b.length - 1;</span><br><span class="line">			int mid;</span><br><span class="line">			int target = 1;</span><br><span class="line">			while (true) &#123;</span><br><span class="line">				mid = ((end + start) / 2);</span><br><span class="line">				if (b[mid] == target) &#123;</span><br><span class="line">					System.out.println(mid);</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				if (target &lt; b[mid]) &#123;</span><br><span class="line">					end = mid;</span><br><span class="line">				&#125;</span><br><span class="line">				if (target &gt; b[mid]) &#123;</span><br><span class="line">					start = mid + 1;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String args[]) &#123;</span><br><span class="line">		int Arr[] = &#123; 10, 30, 20, 50, 90, 80, 60, 40, 70 &#125;;</span><br><span class="line">		System.out.println(Arrays.toString(Arr));</span><br><span class="line">		qSort(Arr, 0, Arr.length -1);</span><br><span class="line">		System.out.println(Arrays.toString(Arr));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">希尔排序:</span><br><span class="line">算法思想</span><br><span class="line"></span><br><span class="line">它是对插入插入排序的改进</span><br><span class="line"></span><br><span class="line">搜索维基百科可知</span><br><span class="line">希尔排序，也称递减增量排序算法</span><br><span class="line">假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]</span><br><span class="line">，我们分别以步长为5，3，1进行排序（希尔排序最后的步长一定是1）</span><br><span class="line"></span><br><span class="line">步长为5，我们可以得到如下数据，</span><br><span class="line">13 14 94 33 82</span><br><span class="line">25 59 94 65 23</span><br><span class="line">45 27 73 25 39</span><br><span class="line">10</span><br><span class="line">然后 按照列排序</span><br><span class="line">10 14 73 25 23</span><br><span class="line">13 27 94 33 39</span><br><span class="line">25 59 94 65 82</span><br><span class="line">45</span><br><span class="line"></span><br><span class="line">将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序：</span><br><span class="line">10 14 13</span><br><span class="line">25 23 33</span><br><span class="line">27 25 59</span><br><span class="line">39 65 73</span><br><span class="line">45 94 82</span><br><span class="line">94</span><br><span class="line">-最后以1步长进行排序（此时就是简单的插入排序了）。</span><br><span class="line"></span><br><span class="line">public static void shellPass(Integer[] array, int d) &#123;</span><br><span class="line">    for (int i = d; i &lt; array.length; i++) &#123;</span><br><span class="line">        int temp = array[i];</span><br><span class="line">        int j = i - d;</span><br><span class="line">        while (j &gt;= 0 &amp;&amp; array[j] &gt; temp) &#123;</span><br><span class="line">            array[j + d] = array[j];</span><br><span class="line">            j -= d;</span><br><span class="line">        &#125;</span><br><span class="line">        array[j + d] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void shellSort(Integer[] data) &#123;</span><br><span class="line">    int increment = 12;</span><br><span class="line">    do &#123;</span><br><span class="line">        increment = increment / 3 + 1;</span><br><span class="line">        shellPass(data, increment);</span><br><span class="line">    &#125; while (increment &gt; 1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>（二）常见数据结构</strong><br>2.1 graph<br>2.1.1图节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class GraphNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">    GraphNode next;</span><br><span class="line">    GraphNode[] neighbors;</span><br><span class="line">    boolean visited;</span><br><span class="line"></span><br><span class="line">    GraphNode(int x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GraphNode(int x, GraphNode[] n)&#123;</span><br><span class="line">        val = x;</span><br><span class="line">        neighbors = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return &quot;value: &quot;+ this.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.1.2队列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Queue &#123;</span><br><span class="line">	 GraphNode first, last;</span><br><span class="line"></span><br><span class="line">	    public void enqueue(GraphNode n)&#123;</span><br><span class="line">	        if(first == null)&#123;</span><br><span class="line">	            first = n;</span><br><span class="line">	            last = first;</span><br><span class="line">	        &#125;else&#123;</span><br><span class="line">	            last.next = n;</span><br><span class="line">	            last = n;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    public GraphNode dequeue()&#123;</span><br><span class="line">	        if(first == null)&#123;</span><br><span class="line">	            return null;</span><br><span class="line">	        &#125;else&#123;</span><br><span class="line">	            GraphNode temp = new GraphNode(first.val, first.neighbors);</span><br><span class="line">	            first = first.next;</span><br><span class="line">	            return temp;</span><br><span class="line">	        &#125;   </span><br><span class="line">	    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.1.3测试类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class GraphTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        GraphNode n1 = new GraphNode(1);</span><br><span class="line">        GraphNode n2 = new GraphNode(2);</span><br><span class="line">        GraphNode n3 = new GraphNode(3);</span><br><span class="line">        GraphNode n4 = new GraphNode(4);</span><br><span class="line">        GraphNode n5 = new GraphNode(5);</span><br><span class="line"></span><br><span class="line">        n1.neighbors = new GraphNode[]&#123;n2,n3,n5&#125;;</span><br><span class="line">        n2.neighbors = new GraphNode[]&#123;n1,n4&#125;;</span><br><span class="line">        n3.neighbors = new GraphNode[]&#123;n1,n4,n5&#125;;</span><br><span class="line">        n4.neighbors = new GraphNode[]&#123;n2,n3,n5&#125;;</span><br><span class="line">        n5.neighbors = new GraphNode[]&#123;n1,n3,n4&#125;;</span><br><span class="line"></span><br><span class="line">        breathFirstSearch(n1, 5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void breathFirstSearch(GraphNode root, int x)&#123;</span><br><span class="line">        if(root.val == x)</span><br><span class="line">            System.out.println(&quot;find in root&quot;);</span><br><span class="line"></span><br><span class="line">        Queue queue = new Queue();</span><br><span class="line">        root.visited = true;</span><br><span class="line">        queue.enqueue(root);</span><br><span class="line"></span><br><span class="line">        while(queue.first != null)&#123;</span><br><span class="line">            GraphNode c = (GraphNode) queue.dequeue();</span><br><span class="line">            for(GraphNode n: c.neighbors)&#123;</span><br><span class="line"></span><br><span class="line">                if(!n.visited)&#123;</span><br><span class="line">                    System.out.print(n + &quot; &quot;);</span><br><span class="line">                    n.visited = true;</span><br><span class="line">                    if(n.val == x)</span><br><span class="line">                        System.out.println(&quot;Find &quot;+n);</span><br><span class="line">                    queue.enqueue(n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.2link<br>2.2.1链表实例节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Node &#123;</span><br><span class="line">    int val;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    Node(int x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.3Queue<br>2.3.1队列节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Node &#123;</span><br><span class="line">    int val;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    Node(int x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.3.2队列操作类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Queue &#123;</span><br><span class="line">	Node first, last;</span><br><span class="line"></span><br><span class="line">    public void enqueue(Node n)&#123;</span><br><span class="line">        if(first == null)&#123;</span><br><span class="line">            first = n;</span><br><span class="line">            last = first;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            last.next = n;</span><br><span class="line">            last = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node dequeue()&#123;</span><br><span class="line">        if(first == null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            Node temp = new Node(first.val);</span><br><span class="line">            first = first.next;</span><br><span class="line">            return temp;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.4stack<br>2.4.1栈的节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Node &#123;</span><br><span class="line">    int val;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    Node(int x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.4.2栈的操作类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Stack &#123;</span><br><span class="line">	Node top;</span><br><span class="line"></span><br><span class="line">    public Node peek()&#123;</span><br><span class="line">        if(top != null)&#123;</span><br><span class="line">            return top;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node pop()&#123;</span><br><span class="line">        if(top == null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            Node temp = new Node(top.val);</span><br><span class="line">            top = top.next;</span><br><span class="line">            return temp;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(Node n)&#123;</span><br><span class="line">        if(n != null)&#123;</span><br><span class="line">            n.next = top;</span><br><span class="line">            top = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.5Tree<br>2.5.1数的节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line">    int value;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法 数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程（jdk8-常用函数式编程基础类）</title>
    <url>/2018/10/04/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%88jdk8-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%B1%BB%EF%BC%89/</url>
    <content><![CDATA[<p>在jdk8中什么是函数式接口：<br>1、被@FunctionalInterface注解修饰的。</p>
<span id="more"></span>
<p>2、接口里边只有一个非default的方法。<br>满足以上2个条件的即为函数式接口，ps：即使一个接口没有被@FunctionalInterface修饰，但是满足2，那么这样的接口也会是函数式接口。<br><strong>Supplier</strong><br>概要：不接受参数，返回一个值。<br>jdk源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> */</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface Supplier&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Gets a result.</span><br><span class="line">     *</span><br><span class="line">     * @return a result</span><br><span class="line">     */</span><br><span class="line">    T get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即：Supplier不接受参数，返回一个值。<br>example：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SupplierTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Supplier&lt;Student&gt; supplier = Student::new;//这里使用了方法引用（后续解释）生成了一个对象。</span><br><span class="line">        System.out.println(supplier.get().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Function</strong><br>概要：接受一个参数返回一个值<br>jdk源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//类型T入参，类型R是返回值的类型</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface Function&lt;T, R&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">		接受一个参数，返回一个结果</span><br><span class="line">     */</span><br><span class="line">    R apply(T t);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 默认方法是讲的课8新加入的一种类型，入参before是一个Function（接受参数V类型，输出T类型），从实现来看其首先调用before的行为得到输出T，</span><br><span class="line">     * 随后T作为当前Function的入参，最后当前Function输入R类型。即：compose函数传入的函数首先被调用，得到的结果作为当前Function的入参使用</span><br><span class="line">     */</span><br><span class="line">    default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) &#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        return (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * andThen是和compose相反的操作，当前Function首先被调用，得到的结果作为参数after的入参，调用after。</span><br><span class="line">     */</span><br><span class="line">    default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        return (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 对接受的元素，不做处理</span><br><span class="line">     */</span><br><span class="line">    static &lt;T&gt; Function&lt;T, T&gt; identity() &#123;</span><br><span class="line">        return t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>BiFunction</strong><br>概要：接受2个参数，返回一个值。<br>jdk源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//T和U类型是参数，R类型是返回值。</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface BiFunction&lt;T, U, R&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * BiFunction的主方法，接受2个参数，返回一个结果</span><br><span class="line">     */</span><br><span class="line">    R apply(T t, U u);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 先执行当前BiFunction的行为，得到结果R类型，R类型最后作为Function的实例after的入参（泛型“? super R”即“？”是R类型或者是R类型的</span><br><span class="line">     * 父级）返回V类型的结果。PS：考虑为什么andThen的入参是一个Function，而不是一个BiFunction？</span><br><span class="line">     */</span><br><span class="line">    default &lt;V&gt; BiFunction&lt;T, U, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        return (T t, U u) -&gt; after.apply(apply(t, u));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by CeaserWang on 2017/1/8.</span><br><span class="line"> */</span><br><span class="line">public class FunctionATest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FunctionATest functionTestA = new FunctionATest();</span><br><span class="line">       // functionTestA.testfunction1();</span><br><span class="line">        System.out.println(functionTestA.computeA(3,value -&gt; value = value * 3,value -&gt; value+1));</span><br><span class="line"></span><br><span class="line">        System.out.println(functionTestA.computeB(3,value -&gt; value = value * 3,value -&gt; value+1));</span><br><span class="line"></span><br><span class="line">        System.out.println(functionTestA.computeC(3,4,(value1,value2) -&gt; &#123;return value1+value2;&#125;,value -&gt; value*value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void testfunction1()&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wangwu&quot;);</span><br><span class="line">         Collections.sort(list,(o1,o2) -&gt; &#123;return o1.compareTo(o2); &#125;);</span><br><span class="line">        Collections.sort(list,(o1,o2) -&gt;  o1.compareTo(o2));</span><br><span class="line"></span><br><span class="line">        list.forEach((item) -&gt; System.out.println(item));</span><br><span class="line">         list.forEach(String::toUpperCase);</span><br><span class="line">         list.stream().map(String::toUpperCase).forEach(item -&gt; System.out.println(item));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int  computeA(int a, Function&lt;Integer,Integer&gt; function,Function&lt;Integer,Integer&gt; befor )&#123;</span><br><span class="line">        return  function.compose(befor).apply(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int  computeB(int a, Function&lt;Integer,Integer&gt; function,Function&lt;Integer,Integer&gt; after )&#123;</span><br><span class="line">        return  function.andThen(after).apply(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int  computeC(int a,int b, BiFunction&lt;Integer, Integer,Integer&gt; bifunction, Function&lt;Integer,Integer&gt; function )&#123;</span><br><span class="line">        return  bifunction.andThen(function).apply(a,b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>BinaryOperator</strong><br>概要：继承了BiFunction新加了2个求最大值和最小值的方法。<br>jdk源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//继承了BiFunction，入参和返回值都是同一种类型T，因为2中相同类型的元素做大小比较，返回的是其中一个，即还是原来入参的类型。</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 根据比较器comparator求最小值</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; BinaryOperator&lt;T&gt; minBy(Comparator&lt;? super T&gt; comparator) &#123;</span><br><span class="line">        Objects.requireNonNull(comparator);</span><br><span class="line">        return (a, b) -&gt; comparator.compare(a, b) &lt;= 0 ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据比较器comparator求最大值</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; BinaryOperator&lt;T&gt; maxBy(Comparator&lt;? super T&gt; comparator) &#123;</span><br><span class="line">        Objects.requireNonNull(comparator);</span><br><span class="line">        return (a, b) -&gt; comparator.compare(a, b) &gt;= 0 ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by Administrator on 2017/1/8.</span><br><span class="line"> */</span><br><span class="line">public class BinaryOperatorTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BinaryOperatorTest  BinaryOperatorTest = new BinaryOperatorTest();</span><br><span class="line">        Integer rnum =   BinaryOperatorTest.compute(2,3,(num1,num2) -&gt; &#123;return num1 * num2;&#125;,value -&gt; 2*value);</span><br><span class="line">        System.out.println(rnum);</span><br><span class="line">        System.out.println(&quot;-------------------------------------&quot;);</span><br><span class="line">        Integer rnum2 =   BinaryOperatorTest.compute(2,3,(num1,num2) -&gt; &#123;return num1 * num2;&#125;);</span><br><span class="line">        System.out.println(rnum2);</span><br><span class="line">        System.out.println(&quot;-------------------------------------&quot;);</span><br><span class="line">        Integer rnum3 =   BinaryOperatorTest.computeA(2,3,(num1,num2) -&gt;   num1.compareTo(num2));</span><br><span class="line">        System.out.println(rnum3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer compute(Integer a, Integer b, BinaryOperator&lt;Integer&gt; binaryoperator, Function&lt;Integer,Integer&gt; function) &#123;</span><br><span class="line">        return binaryoperator.andThen(function).apply(a,b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Integer compute(Integer a, Integer b, BinaryOperator&lt;Integer&gt; binaryoperator) &#123;</span><br><span class="line">        return binaryoperator.apply(a,b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Integer computeA(Integer a, Integer b, Comparator&lt;Integer&gt; comparator)&#123;</span><br><span class="line">        return BinaryOperator.minBy(comparator).apply(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Predicate</strong><br>概要：接受一个参数返回boolean类型，常用语filter过滤条件使用。<br>jdk源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Predicate&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 接受一个参数返回一个boolean值</span><br><span class="line">     */</span><br><span class="line">    boolean test(T t);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *与操作，支持短路与</span><br><span class="line">     */</span><br><span class="line">    default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) &#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        return (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 取反操作</span><br><span class="line">     */</span><br><span class="line">    default Predicate&lt;T&gt; negate() &#123;</span><br><span class="line">        return (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 或操作，支持短路或</span><br><span class="line">     */</span><br><span class="line">    default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) &#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        return (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 比较2个对象是否相同</span><br><span class="line">     */</span><br><span class="line">    static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) &#123;</span><br><span class="line">        return (null == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by CeaserWang on 2017/1/8.</span><br><span class="line"> */</span><br><span class="line">public class PredicateTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Predicate&lt;String&gt; mypredicate = value -&gt; value.length()&gt;5;</span><br><span class="line">        System.out.println(mypredicate.test(&quot;hello55s&quot;));</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; nums = Arrays.asList(1,2,3,4,5,6,7,8,9);</span><br><span class="line">        PredicateTest predicatetest = new PredicateTest();</span><br><span class="line">        predicatetest.condationA(nums,value -&gt; value&gt;5);</span><br><span class="line">        System.out.println(&quot;\n---------------------------&quot;);</span><br><span class="line">        predicatetest.condationA(nums,value -&gt; value % 2 ==0);</span><br><span class="line">        System.out.println(&quot;\n---------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(predicatetest.condationEqual(&quot;test&quot;).test(&quot;test&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void condationA(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predate)&#123;</span><br><span class="line">        for(Integer item : list)&#123;</span><br><span class="line">            if(predate.test(item))&#123;</span><br><span class="line">                System.out.print(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Predicate&lt;String&gt; condationEqual(Object obj)&#123;</span><br><span class="line">        return Predicate.isEqual(obj) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Optional</strong><br>概要：jdk8为了解决NPE问题提供的解决方案。<br>在jdk7中业务中很多代码都是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(null!=XXX)&#123;</span><br><span class="line">	doSomeThing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开发人员需要警惕NPE问题，给开发带来了一些不便，现在我们不想用这三行固定的语句，为此jdk8有了Optional。<br>Optional内部维护了一个value的成员变量，为此Optional提供了诸多针对于此成员变量的方法。<br>Optional中的其中一个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//空对象</span><br><span class="line">   private static final Optional&lt;?&gt; EMPTY = new Optional&lt;&gt;();</span><br><span class="line"></span><br><span class="line">//Optional维护的值</span><br><span class="line"> private final T value;</span><br><span class="line">//是否是空值</span><br><span class="line">   public boolean isPresent() &#123;</span><br><span class="line">       return value != null;</span><br><span class="line">   &#125;</span><br><span class="line">   //如果不是空值，那么执行针对于value的行为。</span><br><span class="line">       public void ifPresent(Consumer&lt;? super T&gt; consumer) &#123;</span><br><span class="line">       if (value != null)</span><br><span class="line">           consumer.accept(value);</span><br><span class="line">   &#125;</span><br><span class="line">   //构造一个值为value的Optional对象，value不能为空，否则报错。</span><br><span class="line">   public static &lt;T&gt; Optional&lt;T&gt; of(T value) &#123;</span><br><span class="line">       return new Optional&lt;&gt;(value);</span><br><span class="line">   &#125;</span><br><span class="line">   //返回一个空值</span><br><span class="line">   public static&lt;T&gt; Optional&lt;T&gt; empty() &#123;</span><br><span class="line">       @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">       Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class="line">       return t;</span><br><span class="line">   &#125;</span><br><span class="line">   //创建一个允许空值的Optional对象</span><br><span class="line">      public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) &#123;</span><br><span class="line">       return value == null ? empty() : of(value);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>example：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by CeaserWang on 2017/1/8.</span><br><span class="line"> * optional 不要作为成员变量或者参数，optional只是为了应对null异常而来的</span><br><span class="line"> */</span><br><span class="line">public class OptionalTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        OptionalTest OptionalTest = new OptionalTest();</span><br><span class="line">        OptionalTest.optionalA();</span><br><span class="line">        OptionalTest.optionalB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void optionalA()&#123;</span><br><span class="line">        //Optional optional = Optional.of(&quot;hello&quot;);</span><br><span class="line">        Optional optional = Optional.ofNullable(null);//创建一个空的对象</span><br><span class="line">        optional.ifPresent(item -&gt; System.out.println(item));//如果为空此行代码不会报错。</span><br><span class="line"></span><br><span class="line">        System.out.println(optional.orElse(&quot;world&quot;));//如果为空输出word</span><br><span class="line">        System.out.println(optional.orElseGet(() -&gt; &quot;opop&quot;));//如果为空，取Supplier提供的值</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void optionalB()&#123;</span><br><span class="line">        Company company = new Company();</span><br><span class="line">        Employee e1 = new Employee();</span><br><span class="line">        Employee e2 = new Employee();</span><br><span class="line">        company.setEmployyee(Arrays.asList(e1,e2));</span><br><span class="line"></span><br><span class="line">        Optional&lt;Company&gt; optional = Optional.ofNullable(company);</span><br><span class="line">        System.out.println(optional.map(icompany -&gt; icompany.getEmployyee()).orElse(Collections.emptyList()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数式编程和以往的面向对象的方式有一定的区别，函数式编程方法的参数可以传递行为，这些行为包括但不限于以上介绍的这些，jdk8提供的函数式编程的辅助类在java.util.function包下边：<br><img src="/2018/10/04/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%88jdk8-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%B1%BB%EF%BC%89/20170326140327392.png" alt="这里写图片描述"></p>
<p>这些针对于函数式编程的辅助类，对以后的收集器，流是基础，后续的jdk新加的框架都是使用这些基类展开的。</p>
<p><strong>jdk8新加入的default方法</strong><br>default方法的加入是为了兼容jdk8以前的版本的需要。<br>（1）当前有两个接口MyInterface和MyInterface1，它们都有相同名字的default方法，之后实现类Myclass同时implements了MyInterface和MyInterface1，同时Myclass实现了default方法，此时Myclass调用default调的是谁的？<br>（2）一个接口I有一个default方法，另一个实现类A实现了了此接口，并且重写了default方法，之后另一个类B继承了实现类A并且实现了接口I，那么在这种情况下，实现类B调用的default方法又是谁的呢？针对这两种情况编写测试代码：</p>
<p>接口MyInterface</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by CeaserWang on 2017/1/16.</span><br><span class="line"> */</span><br><span class="line">public interface MyInterface &#123;</span><br><span class="line">default void  meyhod()&#123;</span><br><span class="line">    System.out.println(&quot;MyInterface&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口MyInterface1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface MyInterface1 &#123;</span><br><span class="line">    default void  meyhod()&#123;</span><br><span class="line">        System.out.println(&quot;MyInterface1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现类ExtendsClass</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ExtendsClass implements  MyInterface &#123;</span><br><span class="line"></span><br><span class="line">    public void  meyhod()&#123;</span><br><span class="line">        System.out.println(&quot;ExtendsClass&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类FixClass</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FixClass extends  ExtendsClass implements  MyInterface1 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类Myclass</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Myclass implements  MyInterface,MyInterface1 &#123;</span><br><span class="line"></span><br><span class="line">  public  void  meyhod()&#123;</span><br><span class="line">       System.out.println(&quot;Myclass&quot;);</span><br><span class="line">      //MyInterface1.super.meyhod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Myclass myclass = new Myclass();</span><br><span class="line">        myclass.meyhod();</span><br><span class="line"></span><br><span class="line">        FixClass fixClass = new FixClass();</span><br><span class="line">        fixClass.meyhod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行Myclass 结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Myclass</span><br><span class="line">ExtendsClass</span><br></pre></td></tr></table></figure>

<p>结论:<br>针对于第一种情况，default方法调用的是自身的实现的default方法。<br>针对于第二种情况，default方法调用的是“就近原则”，ExtendsClass 首先被实现，那么首选是ExtendsClass 的default方法，因此输出“ExtendsClass”。</p>
<p><strong>jdk8-方法引用</strong></p>
<p><strong>方法引用的形式</strong><br>方法引用的标准形式是:类名::方法名。（注意：只需要写方法名，不需要写括号）</p>
<p>有以下四种形式的方法引用:</p>
<p>类型	示例<br>引用静态方法	ContainingClass::staticMethodName<br>引用某个对象的实例方法	containingObject::instanceMethodName<br>引用某个类型的任意对象的实例方法	ContainingType::methodName<br>引用构造方法	ClassName::new</p>
<p>下面我们通过一个小Demo来分别学习这几种形式的方法引用:<br>Student 类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int score;</span><br><span class="line"></span><br><span class="line">    public Student(String name, int score) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getScore() &#123;</span><br><span class="line">        return score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setScore(int score) &#123;</span><br><span class="line">        this.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static int coompareStudentByScore(Student student1,Student student2)&#123;</span><br><span class="line">        return student1.getScore() - student2.getScore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static int coompareStudentByName(Student student1,Student student2)&#123;</span><br><span class="line">        return student1.getName().compareToIgnoreCase(student2.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int compareScore(Student student)&#123;</span><br><span class="line">        return this.score-student.getScore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StudentComparator 比较器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class StudentComparator &#123;</span><br><span class="line"></span><br><span class="line">    public  int coompareStudentByScore(Student student1,Student student2)&#123;</span><br><span class="line">        return student1.getScore() - student2.getScore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public  int coompareStudentByName(Student student1,Student student2)&#123;</span><br><span class="line">        return student1.getName().compareToIgnoreCase(student2.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类：MethodReferenceTest</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> * Created by CeaserWang on 2017/1/15.</span><br><span class="line"> */</span><br><span class="line">public class MethodReferenceTest &#123;</span><br><span class="line"></span><br><span class="line">    public String toString(Supplier&lt;String&gt; supplier)&#123;</span><br><span class="line">        return supplier.get()+&quot;test&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString2(String str, Function&lt;String,String&gt; function)&#123;</span><br><span class="line">        return function.apply(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student student1   = new Student(&quot;zhangsan&quot;,20);</span><br><span class="line">        Student student2   = new Student(&quot;lisi&quot;,90);</span><br><span class="line">        Student student3   = new Student(&quot;wangwu&quot;,50);</span><br><span class="line">        Student student4   = new Student(&quot;zhaoliu&quot;,60);</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; students = Arrays.asList(student1,student2,student3,student4);</span><br><span class="line">		//lambda形式</span><br><span class="line">       students.sort((studentparam1,studentparam2) -&gt; Student.coompareStudentByName(studentparam1,studentparam2));</span><br><span class="line">        students.forEach(student -&gt; System.out.println(student.getName()));*/</span><br><span class="line">       // 引用静态方法</span><br><span class="line">       /* students.sort( Student::coompareStudentByName);</span><br><span class="line">        students.forEach(student -&gt; System.out.println(student.getName()));</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;----------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">		//引用某个对象的实例方法</span><br><span class="line">        StudentComparator studentComparator = new StudentComparator();</span><br><span class="line">        students.sort(studentComparator::coompareStudentByScore);</span><br><span class="line">        students.forEach(student -&gt; System.out.println(student.getScore()));</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;----------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        //引用某个类型的任意对象的实例方法</span><br><span class="line">        students.sort(Student::compareScore);</span><br><span class="line">        students.forEach(student -&gt; System.out.println(student.getScore()));</span><br><span class="line">        MethodReferenceTest methodReferenceTest =  new MethodReferenceTest();</span><br><span class="line">        //引用构造方法</span><br><span class="line">        System.out.println( methodReferenceTest.toString(String::new));</span><br><span class="line">        System.out.println( methodReferenceTest.toString2(&quot;hello&quot;,String::new));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javaBase</category>
      </categories>
      <tags>
        <tag>jdk8 lambda FunctionalInterface</tag>
      </tags>
  </entry>
  <entry>
    <title>生产者与消费者问题【java实现】</title>
    <url>/2018/09/28/%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E3%80%90java%E5%AE%9E%E7%8E%B0%E3%80%91/</url>
    <content><![CDATA[<p><strong>定义面包类：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br><span class="line">package ProducerAndConsumer;</span><br><span class="line"></span><br><span class="line">public class Bread &#123;</span><br><span class="line">public int id;</span><br><span class="line">public int producerid;</span><br><span class="line">public Bread(int id,int producerid)&#123;</span><br><span class="line">	this.id = id;</span><br><span class="line">	this.producerid = producerid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>定义一个篮子，里边放一个数组存放面包：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package ProducerAndConsumer;</span><br><span class="line"></span><br><span class="line">public class Basket &#123;</span><br><span class="line">	private Bread[] basket = new Bread[10];</span><br><span class="line">    private int index = 0;</span><br><span class="line">	public synchronized void push(Bread bread) &#123;</span><br><span class="line">	//发现篮子满了，就在那里不停的等着</span><br><span class="line">	System.out.println(&quot;生产者等待。。。。。。&quot;);</span><br><span class="line">		while(this.index==basket.length)&#123;</span><br><span class="line">			try &#123;</span><br><span class="line">			//（一个生产线程）开始不停等待  </span><br><span class="line">                // 他需要等待顾客(一个消费线程)把它叫醒</span><br><span class="line">				this.wait();</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				// TODO Auto-generated catch block</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		     // 唤醒一个正在等待的线程，如果唤醒的线程为生产线程，则又会进入等待状态，  </span><br><span class="line">        // 如果为消费线程，则因生产线程生产了面包的缘故，消费线程可以进行消费  </span><br><span class="line">		this.notify();</span><br><span class="line">		basket[this.index] = bread;</span><br><span class="line">		this.index++;</span><br><span class="line">		System.out.println(&quot;生产者&quot;+bread.producerid+&quot;生产一个面包&quot;);		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public synchronized void pop(int index)&#123;</span><br><span class="line">		while(this.index==0)&#123;</span><br><span class="line">			System.out.println(&quot;消费者等待。。。。。。。。&quot;);</span><br><span class="line">			try &#123;</span><br><span class="line">				this.wait();</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				// TODO Auto-generated catch block</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		this.notify();</span><br><span class="line">		basket[this.index]=null;</span><br><span class="line">		this.index--;</span><br><span class="line">		System.out.println(&quot;消费者&quot;+index+&quot;取走一个面包&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>定义生产者者：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package ProducerAndConsumer;</span><br><span class="line"></span><br><span class="line">public class Producer implements Runnable&#123;</span><br><span class="line">private int id;</span><br><span class="line">private Basket basket;</span><br><span class="line">public Producer(int id,Basket basket)&#123;</span><br><span class="line">	this.id = id;</span><br><span class="line">	this.basket = basket;</span><br><span class="line">&#125;</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		for(int i=0;i&lt;=10;i++)&#123;</span><br><span class="line">			Bread bread = new Bread(i,this.id);</span><br><span class="line">			basket.push(bread);</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(1);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				// TODO Auto-generated catch block</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>定义消费者：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package ProducerAndConsumer;</span><br><span class="line"></span><br><span class="line">public class Consumer implements Runnable&#123;</span><br><span class="line">private int id;</span><br><span class="line">private Basket basket;</span><br><span class="line">	public Consumer(int id,Basket basket)&#123;</span><br><span class="line">		this.id=id;</span><br><span class="line">		this.basket = basket;</span><br><span class="line">	&#125;</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		for(int i=0;i&lt;=10;i++)&#123;</span><br><span class="line">			basket.pop(id);</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(1);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				// TODO Auto-generated catch block</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>测试类：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package ProducerAndConsumer;</span><br><span class="line"></span><br><span class="line">public class Launcher &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Basket basket = new Basket();</span><br><span class="line">		Producer p1 = new Producer(1,basket);</span><br><span class="line">		Producer p2 = new Producer(2,basket);</span><br><span class="line"></span><br><span class="line">		Consumer c1 = new Consumer(1,basket);</span><br><span class="line">		Consumer c2 = new Consumer(2,basket);</span><br><span class="line"></span><br><span class="line">		new Thread(p1).start();</span><br><span class="line">		new Thread(p2).start();</span><br><span class="line">		new Thread(c1).start();</span><br><span class="line">		new Thread(c2).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">生产者1生产一个面包</span><br><span class="line">生产者2生产一个面包</span><br><span class="line">消费者1取走一个面包</span><br><span class="line">消费者2取走一个面包</span><br><span class="line">生产者2生产一个面包</span><br><span class="line">消费者1取走一个面包</span><br><span class="line">消费者等待。。。。。。。。</span><br><span class="line">生产者1生产一个面包</span><br><span class="line">消费者2取走一个面包</span><br><span class="line">生产者2生产一个面包</span><br><span class="line">消费者2取走一个面包</span><br><span class="line">生产者1生产一个面包</span><br><span class="line">消费者1取走一个面包</span><br><span class="line">生产者1生产一个面包</span><br><span class="line">消费者1取走一个面包</span><br><span class="line">消费者等待。。。。。。。。</span><br><span class="line">生产者2生产一个面包</span><br><span class="line">消费者2取走一个面包</span><br><span class="line">生产者2生产一个面包</span><br><span class="line">消费者2取走一个面包</span><br><span class="line">消费者等待。。。。。。。。</span><br><span class="line">生产者1生产一个面包</span><br><span class="line">消费者1取走一个面包</span><br><span class="line">生产者2生产一个面包</span><br><span class="line">消费者2取走一个面包</span><br><span class="line">消费者等待。。。。。。。。</span><br><span class="line">生产者1生产一个面包</span><br><span class="line">消费者1取走一个面包</span><br><span class="line">消费者等待。。。。。。。。</span><br><span class="line">消费者等待。。。。。。。。</span><br><span class="line">生产者2生产一个面包</span><br><span class="line">消费者2取走一个面包</span><br><span class="line">消费者等待。。。。。。。。</span><br><span class="line">生产者1生产一个面包</span><br><span class="line">消费者1取走一个面包</span><br><span class="line">生产者2生产一个面包</span><br><span class="line">生产者1生产一个面包</span><br><span class="line">消费者2取走一个面包</span><br><span class="line">消费者1取走一个面包</span><br><span class="line">生产者2生产一个面包</span><br><span class="line">消费者2取走一个面包</span><br><span class="line">消费者等待。。。。。。。。</span><br><span class="line">生产者1生产一个面包</span><br><span class="line">消费者1取走一个面包</span><br><span class="line">消费者等待。。。。。。。。</span><br><span class="line">生产者2生产一个面包</span><br><span class="line">生产者1生产一个面包</span><br><span class="line">消费者2取走一个面包</span><br><span class="line">消费者1取走一个面包</span><br><span class="line">生产者2生产一个面包</span><br><span class="line">消费者2取走一个面包</span><br><span class="line">消费者等待。。。。。。。。</span><br><span class="line">生产者1生产一个面包</span><br><span class="line">消费者1取走一个面包</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Thread</category>
      </categories>
      <tags>
        <tag>Producer Consumer</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树原理（RB-Tree Principle）</title>
    <url>/2018/09/27/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%EF%BC%88RB-Tree-Principle%EF%BC%89/</url>
    <content><![CDATA[<p>RB-Tree Principle<br>          Create by 疯子 济南高新区</p>
<span id="more"></span>
<p>最近项目组不是很忙，闲暇之际，学了点数据结构的知识。</p>
<p>其实早就列入The Toad Of Alibaba计划之中了，只是这个知识点比较繁杂，单独拿出时间和文章阐述一下，红黑树在大学的数据结构没有涉及，他是AVL的变种和升级，大学着重基本原理就只有AVL，而红黑树是为了满足企业级的开发捣鼓出来的为了节省成本的一种数据结构，本文讲解的RBTree只有插入部分，没有删除部分，因为只有插入比较易懂，而且诠释了红黑树的基本原理，而删除不论是在AVL还是在RBTree中都是最复杂的一步，此文只讲原理不讲代码。</p>
<p>** <strong>关键词以及概念准备</strong>**</p>
<p>在讨论之前先定义本文所使用的结点命名以及树的规则如下<br>命名：<br>X:要插入的结点，或者是特殊的结点<br>P：X结点的父结点<br>G：P的父结点<br>RBTree的规则：<br>（1）每一个结点不是红色的就是黑色的。<br>（2）根总是黑色的。<br>（3）如果结点是红色的，那么他的子结点必须是黑色的（反之倒不一定必须为真）。<br>（4）从根到叶结点或空子结点的每条路径，必须包含相同数目的黑色结点。<br>子结点类型：<br><img src="/2018-09-27/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%EF%BC%88RB-Tree-Principle%EF%BC%89/20150408203244588.png" alt="（1）外侧子孙节点（左子节点）"><br>（1）外侧子孙节点（左子节点）<br><img src="/2018-09-27/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%EF%BC%88RB-Tree-Principle%EF%BC%89/20150408203633846.png" alt="（2）右侧子孙节点（右子节点）"><br>（2）右侧子孙节点（右子节点）<br><img src="/2018-09-27/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%EF%BC%88RB-Tree-Principle%EF%BC%89/20150408203845354.png" alt="（3）外侧子孙节点（右子节点）"><br>（3）外侧子孙节点（右子节点）<br><img src="/2018-09-27/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%EF%BC%88RB-Tree-Principle%EF%BC%89/20150408203945008.png" alt="（4）内侧子孙节点（左子节点）"><br>（4）内侧子孙节点（左子节点）<br>图中说明了将要插入子结点X的位置的的四种情况，总结为内侧子孙节点和外侧子孙节点。</p>
<p>当我们要往树里边插入一个节点的的时候分下边3个步骤：<br>（1）	在下行路途中的颜色变换。<br>（2）	在向下路途上的旋转<br>（3）	插入结点之后的旋转。<br><strong>但是第二步和第三步顺序我们颠倒过来讲解，因为第三步的旋转理解之后对第四部的旋转的理解是轻而易举的。</strong></p>
<p><strong>1、  在下行路途中的颜色变换。</strong></p>
<p>解释：<br>从root根结点开始向下搜索，当碰到如下情况是要进行颜色的变换<br>发现一个黑色结点有2个红色子结点，把2个红色子结点颜色变为黑色，父结点颜色变为红色（如果父结点为根，那么父结点还是黑色，遵守规则一）。<br>如图：<br><img src="/2018-09-27/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%EF%BC%88RB-Tree-Principle%EF%BC%89/20150408204314938.png" alt="这里写图片描述"></p>
<p><strong>2、  插入结点之后的旋转。</strong></p>
<p>2.1解释：<br>结点插入之后可能会造成树的规则的破坏，需要对树重新调整。<br>2.2调整策略：<br>新插入的节点有3中可能的情况：<br>如图：<br><img src="/2018-09-27/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%EF%BC%88RB-Tree-Principle%EF%BC%89/20150408204407810.png" alt="这里写图片描述"><br>（1）	P是黑色的。<br>（2）	P是红色的，X是G的外侧子孙节点。<br>（3）	P是红色的，X是G的内侧子孙节点。<br>调整方案：<br>（1）	P是黑色的。<br>如果P是黑色的什么事也不做 直接把节点插入即可。<br>（2）	P是红色的，X是G的外侧子孙节点。<br>如图：<br><img src="/2018-09-27/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%EF%BC%88RB-Tree-Principle%EF%BC%89/20150408204640811.png" alt="这里写图片描述"><br>调整方法：<br>1）	改变X的祖父节点G（本例中是25）的颜色。<br>2）	改变X的父节点P（12）的颜色。<br>3）	以X的祖父节点G（25）为顶旋转，向X（6）上升的方向，在本例中是右旋。<br>如图是调整后的树：</p>
<p><img src="/2018-09-27/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%EF%BC%88RB-Tree-Principle%EF%BC%89/20150408204705104.png" alt="这里写图片描述"></p>
<p>（3）P是红色的，X是G的内侧子孙节点。<br>调整步骤：<br>1）	改变X的祖父节点（本例中为25）的颜色。<br>2）	改变X（18）的颜色。<br>3）	用X的父节点P（12）作为顶旋转，向X上升的方向旋转，本例是左旋。<br>4）	再以X的祖父节点（25）为顶旋转，向X上升的方向旋转（本例为右旋）。<br><img src="/2018-09-27/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%EF%BC%88RB-Tree-Principle%EF%BC%89/20150408205236445.png" alt="这里写图片描述"><br><img src="/2018-09-27/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%EF%BC%88RB-Tree-Principle%EF%BC%89/20150408205305524.png" alt="这里写图片描述"><br><img src="/2018-09-27/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%EF%BC%88RB-Tree-Principle%EF%BC%89/20150408205302735.png" alt="这里写图片描述"></p>
<p><strong>3、 在向下路途上的旋转</strong></p>
<p>解释：在从根结点向下搜索遍历寻找插入位置的时候，会进行中途结点颜色的调整（即步骤一），以便于搜索继续向下进行，旋转之后可能会造成红-红冲突（规则三），出现冲突就需要进行树的旋转调整。<br>在向下的路径上有2中旋转的可能性：<br>（1）	外侧子孙节点。<br>（2）	内侧子孙节点。<br><strong>3.1 外侧子孙节点</strong><br>先说外侧子孙节点的情况，开始的时候只有一个根节点50，依次插入25,75,12,37,6,18。记住每次插入的新结点X颜色都是红色的。<br>注意：在插入12和6时需要进行颜色变换， 现在要插入值为3的节点，必须对12 以及他的子节点6和18 做颜色变换，下面会讲到。讲解的过程中遇到上边的第一种情况时会着重提醒。<br>本过程连带插入的过程，这也是先将插入过程的原因。<br><img src="/2018-09-27/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%EF%BC%88RB-Tree-Principle%EF%BC%89/20150408205644723.png" alt="这里写图片描述"><br><img src="/2018-09-27/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%EF%BC%88RB-Tree-Principle%EF%BC%89/20150408205803297.png" alt="这里写图片描述"><br>（3）	插入结点X（12）此时与父节点P发生红-红冲突（规则三），要先进行颜色变换才能将12插入，前边说过在向下搜索的时候如果遇到这种冲突就要进行颜色变换（根节点不变总是黑的）。<br><img src="/2018-09-27/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%EF%BC%88RB-Tree-Principle%EF%BC%89/20150408205801210.png" alt="这里写图片描述"><br><img src="/2018-09-27/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%EF%BC%88RB-Tree-Principle%EF%BC%89/20150408205914043.png" alt="这里写图片描述"><br><img src="/20150408205951093.png" alt="这里写图片描述"><br>（6）在将要插入6的时候有遇到第三步的情况出现红-红冲突。按照第三步的做法进行调整（25为非根节点此时变为红色）。<br><img src="/2018-09-27/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%EF%BC%88RB-Tree-Principle%EF%BC%89/20150408210000659.png" alt="这里写图片描述"><br><img src="/2018-09-27/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%EF%BC%88RB-Tree-Principle%EF%BC%89/20150408210035104.png" alt="这里写图片描述"><br><img src="/2018-09-27/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%EF%BC%88RB-Tree-Principle%EF%BC%89/20150408210154240.png" alt="这里写图片描述"><br><img src="/2018-09-27/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%EF%BC%88RB-Tree-Principle%EF%BC%89/20150408210234332.png" alt="这里写图片描述"><br>（10）颜色变换后会出现红-红颜色冲突，即12和他的父亲25颜色冲突，此时遇到前边说的第一种情况（在向下路途上的旋转遇到的外侧子孙节点的情况）这种情况的解决方案如下：<br>（10.1）改变X的祖父节点G（50）的颜色，忽略根必须是黑色的规则。<br>（10.2）改变X的父节点P（25）的颜色。<br>（10.3）以X的祖父节点G（50）为顶旋转，向X上升的方向旋转（右旋）。</p>
<p><img src="/2018-09-27/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%EF%BC%88RB-Tree-Principle%EF%BC%89/20150408210330149.png" alt="这里写图片描述"><br>（11）调整后的RB-Tree，此时要插入节点3，又会遇到一个黑色加点下边有2个红色节点的情况，那么就改变25、12、50的颜色，然后插入节点3，见下一步。<br><img src="/2018-09-27/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%EF%BC%88RB-Tree-Principle%EF%BC%89/20150408210334661.png" alt="这里写图片描述"><br>（12）变换颜色后插入节点3。<br>至此一颗树从一个节点到构件完成的过程走完了（为了讲解在向下路途上的旋转遇到<strong>外侧子孙节点</strong>的情况，顺便把前边的知识串了一下），接下来再说在向下路途上的旋转遇到<strong>内侧子孙节点</strong>的情况。</p>
<p><strong>3.2 内侧子孙节点</strong></p>
<p>树的构件过程在这一步不再细致的说明了，在3.1已经过了一遍，只说最后遇到内侧子孙节点的情况。<br>解决方案：<br>（1）<br>根为50，依次插入25,75,12,37,31,43，在插入12和31之前需要变换颜色。<br>现在试着插入一个新的节点，值为28，需要做颜色变换（节点37处），这时会出现红-红冲突，如图：<br><img src="/2018-09-27/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%EF%BC%88RB-Tree-Principle%EF%BC%89/20150408210511303.png" alt="这里写图片描述"><br>变换之后：<br><img src="/2018-09-27/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%EF%BC%88RB-Tree-Principle%EF%BC%89/20150408210613578.png" alt="这里写图片描述"><br>最后插入节点28之后：<br><img src="/2018-09-27/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%EF%BC%88RB-Tree-Principle%EF%BC%89/20150408210701252.png" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title>自旋锁、排队自旋锁、MCS锁、CLH锁</title>
    <url>/2018/10/04/%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E6%8E%92%E9%98%9F%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81MCS%E9%94%81%E3%80%81CLH%E9%94%81/</url>
    <content><![CDATA[<p><strong>自旋锁（Spin lock）</strong><br>自旋锁是指当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否被释放，而不是进入线程挂起或睡眠状态。</p>
<span id="more"></span>
<p>自旋锁适用于锁保护的临界区很小的情况，临界区很小的话，锁占用的时间就很短。<br><strong>简单的实现：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line">public class SpinLock &#123;</span><br><span class="line">   private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;Thread&gt;();</span><br><span class="line"></span><br><span class="line">   public void lock() &#123;</span><br><span class="line">       Thread currentThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">              // 如果锁未被占用，则设置当前线程为锁的拥有者</span><br><span class="line">       while (owner.compareAndSet(null, currentThread)) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void unlock() &#123;</span><br><span class="line">       Thread currentThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">              // 只有锁的拥有者才能释放锁</span><br><span class="line">       owner.compareAndSet(currentThread, null);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SimpleSpinLock里有一个owner属性持有锁当前拥有者的线程的引用，如果该引用为null，则表示锁未被占用，不为null则被占用。<br>这里用AtomicReference是为了使用它的原子性的compareAndSet方法（CAS操作），解决了多线程并发操作导致数据不一致的问题，确保其他线程可以看到锁的真实状态。</p>
<p><strong>缺点</strong></p>
<ol>
<li>CAS操作需要硬件的配合；</li>
<li>保证各个CPU的缓存（L1、L2、L3、跨CPU Socket、主存）的数据一致性，通讯开销很大，在多处理器系统上更严重；</li>
<li>没法保证公平性，不保证等待进程&#x2F;线程按照FIFO顺序获得锁。</li>
</ol>
<p> <strong>Ticket Lock</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class TicketLock &#123;</span><br><span class="line">   private AtomicInteger serviceNum = new AtomicInteger(); // 服务号</span><br><span class="line">   private AtomicInteger ticketNum = new AtomicInteger(); // 排队号</span><br><span class="line"></span><br><span class="line">   public int lock() &#123;</span><br><span class="line">         // 首先原子性地获得一个排队号</span><br><span class="line">         int myTicketNum = ticketNum.getAndIncrement();</span><br><span class="line"></span><br><span class="line">              // 只要当前服务号不是自己的就不断轮询</span><br><span class="line">       while (serviceNum.get() != myTicketNum) &#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return myTicketNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock(int myTicket) &#123;</span><br><span class="line">        // 只有当前线程拥有者才能释放锁</span><br><span class="line">        int next = myTicket + 1;</span><br><span class="line">        serviceNum.compareAndSet(myTicket, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>缺点</strong><br>Ticket Lock 虽然解决了公平性的问题，但是多处理器系统上，每个进程&#x2F;线程占用的处理器都在读写同一个变量serviceNum ，每次读写操作都必须在多个处理器缓存之间进行缓存同步，这会导致繁重的系统总线和内存的流量，大大降低系统整体的性能。<br>下面介绍的CLH锁和MCS锁都是为了解决这个问题的。<br>MCS 来自于其发明人名字的首字母： John Mellor-Crummey和Michael Scott。<br>CLH的发明人是：Craig，Landin and Hagersten。</p>
<p><strong>MCS锁</strong><br>MCS Spinlock 是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，直接前驱负责通知其结束自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;</span><br><span class="line"></span><br><span class="line">public class MCSLock &#123;</span><br><span class="line">    public static class MCSNode &#123;</span><br><span class="line">        volatile MCSNode next;</span><br><span class="line">        volatile boolean isBlock = true; // 默认是在等待锁</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    volatile MCSNode queue;// 指向最后一个申请锁的MCSNode</span><br><span class="line">    private static final AtomicReferenceFieldUpdater UPDATER = AtomicReferenceFieldUpdater</span><br><span class="line">            .newUpdater(MCSLock.class, MCSNode.class, &quot;queue&quot;);</span><br><span class="line"></span><br><span class="line">    public void lock(MCSNode currentThread) &#123;</span><br><span class="line">        MCSNode predecessor = UPDATER.getAndSet(this, currentThread);// step 1</span><br><span class="line">        if (predecessor != null) &#123;</span><br><span class="line">            predecessor.next = currentThread;// step 2</span><br><span class="line"></span><br><span class="line">            while (currentThread.isBlock) &#123;// step 3</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock(MCSNode currentThread) &#123;</span><br><span class="line">        if (currentThread.isBlock) &#123;// 锁拥有者进行释放锁才有意义</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (currentThread.next == null) &#123;// 检查是否有人排在自己后面</span><br><span class="line">            if (UPDATER.compareAndSet(this, currentThread, null)) &#123;// step 4</span><br><span class="line">                // compareAndSet返回true表示确实没有人排在自己后面</span><br><span class="line">                return;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 突然有人排在自己后面了，可能还不知道是谁，下面是等待后续者</span><br><span class="line">                // 这里之所以要忙等是因为：step 1执行完后，step 2可能还没执行完</span><br><span class="line">                while (currentThread.next == null) &#123; // step 5</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        currentThread.next.isBlock = false;</span><br><span class="line">        currentThread.next = null;// for GC</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CLH锁</strong><br>CLH锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;</span><br><span class="line"></span><br><span class="line">public class CLHLock &#123;</span><br><span class="line">    public static class CLHNode &#123;</span><br><span class="line">        private boolean isLocked = true; // 默认是在等待锁</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unused&quot; )</span><br><span class="line">    private volatile CLHNode tail ;</span><br><span class="line">    private static final AtomicReferenceFieldUpdater&lt;CLHLock, CLHNode&gt; UPDATER = AtomicReferenceFieldUpdater</span><br><span class="line">                  . newUpdater(CLHLock.class, CLHNode .class , &quot;tail&quot; );</span><br><span class="line"></span><br><span class="line">    public void lock(CLHNode currentThread) &#123;</span><br><span class="line">        CLHNode preNode = UPDATER.getAndSet( this, currentThread);</span><br><span class="line">        if(preNode != null) &#123;//已有线程占用了锁，进入自旋</span><br><span class="line">            while(preNode.isLocked ) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock(CLHNode currentThread) &#123;</span><br><span class="line">        // 如果队列里只有当前线程，则释放对当前线程的引用（for GC）。</span><br><span class="line">        if (!UPDATER .compareAndSet(this, currentThread, null)) &#123;</span><br><span class="line">            // 还有后续线程</span><br><span class="line">            currentThread. isLocked = false ;// 改变状态，让后续线程结束自旋</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CLH锁 与 MCS锁 的比较</strong><br>下图是CLH锁和MCS锁队列图示：<br><img src="/2018/10/04/%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E6%8E%92%E9%98%9F%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81MCS%E9%94%81%E3%80%81CLH%E9%94%81/20160821171227925.png" alt="这里写图片描述"><br>差异：</p>
<ol>
<li>从代码实现来看，CLH比MCS要简单得多。</li>
<li>从自旋的条件来看，CLH是在前驱节点的属性上自旋，而MCS是在本地属性变量上自旋。</li>
<li>从链表队列来看，CLH的队列是隐式的，CLHNode并不实际持有下一个节点；MCS的队列是物理存在的。</li>
<li>CLH锁释放时只需要改变自己的属性，MCS锁释放则需要改变后继节点的属性。</li>
</ol>
<p> 注意：这里实现的锁都是独占的，且不能重入的。</p>
]]></content>
      <categories>
        <category>Lock</category>
      </categories>
      <tags>
        <tag>自旋锁 排队自旋锁 MCS锁 CLH锁</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(1)-单例模式Singleton</title>
    <url>/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8FSingleton/</url>
    <content><![CDATA[<p><img src="/2018-09-28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8FSingleton/20151010111725317.png" alt="这里写图片描述"><br>单例模式的四种实现方式：<br><strong>1、饿汉模式</strong></p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton2&#123;</span><br><span class="line">        //饿汉模式，声明时不创建实例对象</span><br><span class="line">	public static Singleton2 instance;</span><br><span class="line">	//单类模式的构造方法必须为private，以避免通过构造方法创建对象实例，</span><br><span class="line">        //并且必须显示声明构造方法，以防止使用默认构造方法</span><br><span class="line">	private Singleton2()&#123;&#125;</span><br><span class="line">        //单类模式必须对外提供获取实例对象的方法，延迟初始化的单类模式必须使用synchronized同步关键字，否则多线程情况下很容易产生多个实例对象</span><br><span class="line">        public static synchronized Singleton2 geInstance()&#123;</span><br><span class="line">	       //延迟初始化，只有当第一次使用时才创建对象实例</span><br><span class="line">	       if(instance == null)&#123;</span><br><span class="line">	           return new Singleton2();</span><br><span class="line">                &#125;</span><br><span class="line">               return instance;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>2、饱汉模式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton1&#123;</span><br><span class="line">        //饱汉模式，声明时就创建实例对象</span><br><span class="line">	public static final Singleton1 instance = new Singleton1();</span><br><span class="line">	//单类模式的构造方法必须为private，以避免通过构造方法创建对象实例，</span><br><span class="line">        //并且必须显示声明构造方法，以防止使用默认构造方法</span><br><span class="line">	private Singleton1()&#123;&#125;</span><br><span class="line">        //单类模式必须对外提供获取实例对象的方法</span><br><span class="line">        public static Singleton1 geInstance()&#123;</span><br><span class="line">	       return instance;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>3、使用枚举</strong><br>枚举可以保证真个程序生命周期中只有一个实例对象存在，同时还避免了常规Singleton单类模式private构造方法被反射调用和序列化问题(枚举提供了序列化保证机制，确保多次序列化和反序列化不会创建多个实例对象)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum Singleton4&#123;</span><br><span class="line">	INSTANCE&#123;</span><br><span class="line">		public void doSomething()&#123;</span><br><span class="line">			……</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	public abstract void doSomething();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4】静态内部类的实现方式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> public class Singleton3 &#123;  </span><br><span class="line">    /**</span><br><span class="line">     * 类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例</span><br><span class="line">     * 没有绑定关系，而且只有被调用到才会装载，从而实现了延迟加载</span><br><span class="line">     */  </span><br><span class="line">    private static class SingletonHolder&#123;  </span><br><span class="line">        /**</span><br><span class="line">         * 静态初始化器，由JVM来保证线程安全</span><br><span class="line">         */  </span><br><span class="line">        private static Singleton3 instance = new Singleton3();  </span><br><span class="line">    &#125;  </span><br><span class="line">    /**</span><br><span class="line">     * 私有化构造方法</span><br><span class="line">     */  </span><br><span class="line">    private Singleton3()&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static  Singleton3 getInstance()&#123;  </span><br><span class="line">        return SingletonHolder.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(2)-代理模式</title>
    <url>/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="/2018-09-28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/20151010130746987.png" alt="这里写图片描述"><br><strong>1、静态代理：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br><span class="line">interface ProxyBase&#123;</span><br><span class="line">	public void f();</span><br><span class="line">	public void g();</span><br><span class="line">	public void h();</span><br><span class="line">&#125;</span><br><span class="line">//代理程序</span><br><span class="line">class Proxy implement ProxyBase&#123;</span><br><span class="line">	private ProxyBase implementation;</span><br><span class="line">	public Proxy()&#123;</span><br><span class="line">		//目标程序</span><br><span class="line">		implementation = new ProxyImplementation();</span><br><span class="line">	&#125;</span><br><span class="line">	public void f()&#123;</span><br><span class="line">		implementation.f();</span><br><span class="line">	&#125;</span><br><span class="line">	public void g()&#123;</span><br><span class="line">		implementation.g();</span><br><span class="line">	&#125;</span><br><span class="line">	public void h()&#123;</span><br><span class="line">		implementation.h();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//目标程序</span><br><span class="line">class ProxyImplementation implements ProxyBase&#123;</span><br><span class="line">	public void f()&#123;</span><br><span class="line">		System.out.println(“ProxyImplementation.f()”);</span><br><span class="line">	&#125;</span><br><span class="line">	public void g()&#123;</span><br><span class="line">		System.out.println(“ProxyImplementation.g()”);</span><br><span class="line">	&#125;</span><br><span class="line">	public void h()&#123;</span><br><span class="line">		System.out.println(“ProxyImplementation.h()”);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//客户端程序调用代理</span><br><span class="line">public class ProxyDemo&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		//客户端调用代理程序</span><br><span class="line">		Proxy p = new Proxy();</span><br><span class="line">		p.f();</span><br><span class="line">		p.g();</span><br><span class="line">		p.h();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、动态代理</strong><br>动态代理分为JDK的接口动态代理和CGLIB的基于类的动态代理，<br>JDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。<br><strong>jdk动态代理：</strong><br><strong><span class="exturl" data-url="aHR0cDovL3Jlam95Lml0ZXllLmNvbS9ibG9nLzE2Mjc0MDU=">jdk动态代理的实现原理参考<i class="fa fa-external-link-alt"></i></span></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//代理接口</span><br><span class="line">interface Foo&#123;</span><br><span class="line">	public void f(String s);</span><br><span class="line">	public void g(int i);</span><br><span class="line">	public void h(int i, String s);</span><br><span class="line">&#125;</span><br><span class="line">//接口实现类，即被代理类</span><br><span class="line">class FooImpl implements Foo&#123;</span><br><span class="line">	public void f(String s)&#123;</span><br><span class="line">		System.out.println(“FooImpl.f(), s=” + s);</span><br><span class="line">	&#125;</span><br><span class="line">	public void g(int i) &#123;</span><br><span class="line">		System.out.println(“FooImpl.g(), i=” + i);</span><br><span class="line">	&#125;</span><br><span class="line">	public void h(int i, String s) &#123;</span><br><span class="line">		System.out.println(“FooImpl.h(), i=” + i + “, s=” + s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//动态代理处理类</span><br><span class="line">class ProxyHandler implements InvocationHandler&#123;</span><br><span class="line">	//代理实现类</span><br><span class="line">	private Object delegate;            </span><br><span class="line">     	public ProxyHandler (Object obj) &#123;    </span><br><span class="line">         	delegate = obj;    </span><br><span class="line">     	&#125;    </span><br><span class="line">	public Object invoke(Object proxy, Method method, Object[] args)&#123;</span><br><span class="line">  		System.out.println(“Before mothod:” + method);</span><br><span class="line">  		method.invoke(this.delegate, args);</span><br><span class="line">  		System.out.println(“After mothod:” + method);</span><br><span class="line">  		return null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class DynamicProxyDemo&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Foo foo = new FooImpl();</span><br><span class="line">		ProxyHandler handler = new ProxyHandler(foo);</span><br><span class="line">		//产生动态代理</span><br><span class="line">	Foo proxy = (Foo)Proxy.newProxyInstance(Foo.class.getClassLoader(), new Class[]&#123;Foo.class&#125;, handler);</span><br><span class="line">		proxy.f(“f”);</span><br><span class="line">		proxy.g(1);</span><br><span class="line">		proxy.h(“h”, 2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CGLIB动态代理</strong><br>在使用CGLIB时需引入cglib-nodep-2.1_3.jar包<br>被代理对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.ljq.test;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 定义一个HelloWorld类</span><br><span class="line"> *</span><br><span class="line"> * @author jiqinlin</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public void sayHelloWorld() &#123;</span><br><span class="line">        System.out.println(&quot;HelloWorld!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.ljq.test;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 通过Cglib实现在方法调用前后向控制台输出两句字符串</span><br><span class="line"> *</span><br><span class="line"> * @author jiqinlin</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class CglibProxy implements MethodInterceptor &#123;</span><br><span class="line">    //要代理的原始对象</span><br><span class="line">    private Object obj;</span><br><span class="line"></span><br><span class="line">    public Object createProxy(Object target) &#123;</span><br><span class="line">        this.obj = target;</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        enhancer.setSuperclass(this.obj.getClass());// 设置代理目标</span><br><span class="line">        enhancer.setCallback(this);// 设置回调</span><br><span class="line">        enhancer.setClassLoader(target.getClass().getClassLoader());</span><br><span class="line">        return enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在代理实例上处理方法调用并返回结果</span><br><span class="line">     *</span><br><span class="line">     * @param proxy</span><br><span class="line">     *            代理类</span><br><span class="line">     * @param method</span><br><span class="line">     *            被代理的方法</span><br><span class="line">     * @param params</span><br><span class="line">     *            该方法的参数数组</span><br><span class="line">     * @param methodProxy</span><br><span class="line">     */</span><br><span class="line">    public Object intercept(Object proxy, Method method, Object[] params,</span><br><span class="line">            MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        Object result = null;</span><br><span class="line">        // 调用之前</span><br><span class="line">        doBefore();</span><br><span class="line">        // 调用原始对象的方法</span><br><span class="line">        result = methodProxy.invokeSuper(proxy, params);</span><br><span class="line">        // 调用之后</span><br><span class="line">        doAfter();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void doBefore() &#123;</span><br><span class="line">        System.out.println(&quot;before method invoke&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void doAfter() &#123;</span><br><span class="line">        System.out.println(&quot;after method invoke&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.ljq.test;</span><br><span class="line"></span><br><span class="line">public class HelloWorldTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HelloWorld helloWorld=new HelloWorld();</span><br><span class="line">        CglibProxy cglibProxy=new CglibProxy();</span><br><span class="line">        HelloWorld hw=(HelloWorld)cglibProxy.createProxy(helloWorld);</span><br><span class="line">        hw.sayHelloWorld();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(10)-适配器Adapter</title>
    <url>/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-10-%E9%80%82%E9%85%8D%E5%99%A8Adapter/</url>
    <content><![CDATA[<p>思想：将一个类的接口转换成另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br>场景：该 模式的应用场景太多了，很多需要的功能模块的接口和我们需要的不完全一致或者有多余或不足，但是需要和我们的系统协同工作，通过Adapter把 它包装一下就能让使它接口兼容了。<br>实现：定 义一个Adapter类，包含需要包装的类，实现需要的其它接口，调用被包装的类的方法来实现需要 的接口。</p>
<span id="more"></span>
<p>重构成本：低。<br>Adapter适配器模式是将两个不兼容的类组合在一起使用。生活中笔记本电脑和手机等数码产品的充电器就是一个适配器，将家用220V的交流电转换为笔记本或手机正常工作所需的目标电压和电流。适配器起到一种转换和包装的作用。<br>Adapter设计模式主要目的组合两个不相干类，常用有两种方法：第一种解决方案是修改各自类的接口。但是如果没有源码，或者不愿意为了一个应用而修改各自的接口，则需要使用Adapter适配器，在两种接口之间创建一个混合接口。<br>Adapter适配器设计模式中有3个重要角色：被适配者Adaptee，适配器Adapter和目标对象Target。其中两个现存的想要组合到一起的类分别是被适配者Adaptee和目标对象Target角色，我们需要创建一个适配器Adapter将其组合在一起。<br>实现Adapter适配器设计模式有两种方式：组合(compositon, has-a关系)和继承(inheritance,is-a关系)。<br>对象适配器模式使用组合和继承，UML图如下：<br><img src="/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-10-%E9%80%82%E9%85%8D%E5%99%A8Adapter/20151031170024613.png" alt="这里写图片描述"><br>假设要画图形，有圆形和方形两个类，现在需要一个既可以画圆形又可以画方形的类。<br>组合关系的Adapter适配器模式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//圆形，目标对象</span><br><span class="line">class Cirecle&#123;</span><br><span class="line">	public void drawCircle()&#123;</span><br><span class="line">	System.out.println(“Draw circle”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//方形，被适配对象</span><br><span class="line">class Square&#123;</span><br><span class="line">	public void drawSquare()&#123;</span><br><span class="line">	System.out.println(“Draw square”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//既可以画圆形，又可以画方形，适配器</span><br><span class="line">public class HybridShape extends Circle&#123;</span><br><span class="line">	private Square square;</span><br><span class="line">	public HybridShape(Square square)&#123;</span><br><span class="line">	this.square = square;</span><br><span class="line">&#125;</span><br><span class="line">public void drawSquare()&#123;</span><br><span class="line">	square.drawSquare();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>适配器继承目标对象，同时组合被适配对象，如果需要画圆时，直接调用父类的画圆方法即可，如果需要画方，则调用被适配对象的画方形方法。<br>继承关系的Adapter适配器模式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface ICircle&#123;</span><br><span class="line">	public void drawCircle();</span><br><span class="line">&#125;</span><br><span class="line">interface ISquare&#123;</span><br><span class="line">	public void drawSquare();</span><br><span class="line">&#125;</span><br><span class="line">//圆形</span><br><span class="line">class Cirecle implements ICircle&#123;</span><br><span class="line">	public void drawCircle()&#123;</span><br><span class="line">	System.out.println(“Draw circle”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//方形</span><br><span class="line">class Square implements ISquare&#123;</span><br><span class="line">	public void drawSquare()&#123;</span><br><span class="line">	System.out.println(“Draw square”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//既可以画圆形，又可以画方形，适配器</span><br><span class="line">public class HybridShape implements ICircle, ISquare&#123;</span><br><span class="line">	private ISquare square;</span><br><span class="line">	private ICircle circle;</span><br><span class="line">	public HybridShape(Square square)&#123;</span><br><span class="line">	this.square = square;</span><br><span class="line">&#125;</span><br><span class="line">public HybridShape(Circle circle)&#123;</span><br><span class="line">	this.circle = circle;</span><br><span class="line">&#125;</span><br><span class="line">public void drawSquare()&#123;</span><br><span class="line">	square.drawSquare();</span><br><span class="line">&#125;</span><br><span class="line">public void drawCircle()&#123;</span><br><span class="line">	circle.drawCircle();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java中类不允许多继承，但是可以实现多个接口，继承关系的Adapter适配器设计模式就是利用java可以实现多个接口的特性。<br>另外在spring中也存在使用适配器的地方，比如<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3pxNjU3ODcwMi9hcnRpY2xlL2RldGFpbHMvNDU4OTgwODM=">AOP拦截器部分<i class="fa fa-external-link-alt"></i></span><br>JDK里面的适配器模式应用：<br>•java.util.Arrays#asList()<br>•java.io.InputStreamReader(InputStream)<br>•java.io.OutputStreamWriter(OutputStream)<br>•javax.xml.bind.annotation.adapters.XmlAdapter#marshal()<br>•javax.xml.bind.annotation.adapters.XmlAdapter#unmarshal()</p>
]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(3)- 状态设计模式State</title>
    <url>/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-3-%E7%8A%B6%E6%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FState/</url>
    <content><![CDATA[<p><img src="/2018-09-28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-3-%E7%8A%B6%E6%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FState/20151010152832034.png" alt="这里写图片描述"><br><img src="/2018-09-28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-3-%E7%8A%B6%E6%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FState/20151010145641255.png" alt="这里写图片描述"><br>状态模式用来改变对象的行为，当状态发生变化时，行为也随着发生变化，和switch分支语句有点类似，比如如下的代码：</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Creature&#123;</span><br><span class="line">     private Boolean isFrog = true;//标识</span><br><span class="line">     public void greet()&#123;</span><br><span class="line">           if(isForg)&#123;</span><br><span class="line">		System.out.println(“Ribbet!”);</span><br><span class="line">	   &#125;else&#123;</span><br><span class="line">		System.out.println(“Darling!”);</span><br><span class="line">	   &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     //转换标识</span><br><span class="line">     public void kiss()&#123;</span><br><span class="line">	isForg = false;</span><br><span class="line">     &#125;</span><br><span class="line">     public static void main(String[] args)&#123;</span><br><span class="line">           Creature creature = new Creature();</span><br><span class="line">           creature.greet();</span><br><span class="line">           creature.kiss();</span><br><span class="line">           creature.greet();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>greet()方法在业务复杂的时候if else会很多，而替换为状态模式就变得优雅了许多：<br>简单的状态模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Creature&#123;</span><br><span class="line">    //状态接口</span><br><span class="line">    private interface State&#123;</span><br><span class="line">          String response();</span><br><span class="line">    &#125;</span><br><span class="line">    private class Forg implements State&#123;</span><br><span class="line">          public String response()&#123;</span><br><span class="line">	   return “Ribbet!”;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private class Prince implements State&#123;</span><br><span class="line">          public String response()&#123;</span><br><span class="line">	   return “Darling!”;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private State state = new Forg();</span><br><span class="line">    public void greet()&#123;</span><br><span class="line">          System.out.println(state.response);</span><br><span class="line">    &#125;</span><br><span class="line">    public void kiss()&#123;</span><br><span class="line">          state = new Prince();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">          Creature creature = new Creature();</span><br><span class="line">          creature.greet();</span><br><span class="line">          creature.kiss();</span><br><span class="line">          creature.greet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在状态模式中可以有多个状态，同时对应多个分支程序;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//状态接口</span><br><span class="line">interface State&#123;</span><br><span class="line">    void operation1();</span><br><span class="line">    void operation2();</span><br><span class="line">    void operation3();</span><br><span class="line">&#125;</span><br><span class="line">//状态实现类1</span><br><span class="line">class implementation1 implements State&#123;</span><br><span class="line">    public void operation1()&#123;</span><br><span class="line">        System.out.println(“Implementation1.operation1()”);</span><br><span class="line">    &#125;</span><br><span class="line">    public void operation2()&#123;</span><br><span class="line">        System.out.println(“Implementation1.operation2()”);</span><br><span class="line">    &#125;</span><br><span class="line">   public void operation3()&#123;</span><br><span class="line">        System.out.println(“Implementation1.operation3()”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//状态实现类2</span><br><span class="line">class implementation2 implements State&#123;</span><br><span class="line">    public void operation1()&#123;</span><br><span class="line">        System.out.println(“Implementation2.operation1()”);</span><br><span class="line">    &#125;</span><br><span class="line">    public void operation2()&#123;</span><br><span class="line">        System.out.println(“Implementation2.operation2()”);</span><br><span class="line">    &#125;</span><br><span class="line">   public void operation3()&#123;</span><br><span class="line">        System.out.println(“Implementation2.operation3()”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//服务提供者</span><br><span class="line">class ServiceProvider&#123;</span><br><span class="line">    private State state;</span><br><span class="line">    public ServiceProvider(State state)&#123;</span><br><span class="line">         this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    //状态更改</span><br><span class="line">    public void changeState(State newState)&#123;</span><br><span class="line">         state = newState;</span><br><span class="line">    &#125;</span><br><span class="line">    public void service1()&#123;</span><br><span class="line">          //……</span><br><span class="line">          state.operation1();</span><br><span class="line">          //……</span><br><span class="line">          state.operation3();</span><br><span class="line">    &#125;</span><br><span class="line">    public void service2()&#123;</span><br><span class="line">          //……</span><br><span class="line">          state.operation1();</span><br><span class="line">          //……</span><br><span class="line">          state.operation2();</span><br><span class="line">    &#125;</span><br><span class="line">    public void service3()&#123;</span><br><span class="line">          //……</span><br><span class="line">          state.operation3();</span><br><span class="line">          //……</span><br><span class="line">          state.operation2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class StateDemo&#123;</span><br><span class="line">    private ServiceProvider sp = new ServiceProvider(new Implementation1());</span><br><span class="line">    private void run(ServiceProvider sp)&#123;</span><br><span class="line">         sp.service1();</span><br><span class="line">         sp.service2();</span><br><span class="line">         sp.service3();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        StateDemo demo = new StateDemo();</span><br><span class="line">        demo.run(sp);</span><br><span class="line">        sp.changeState(new Implementation2());</span><br><span class="line">        demo.run(sp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>状态模式和代理模式有相似之处，都有目标对象和代理的相似概念<br>但是他们之间是有区别的：<br>1.代理模式目标对象只有一个，而状态模式可以有多个目标对象，即，多个状态。<br>2.代理模式是为了控制目标对象的访问，状态模式是为了根据状态或者标示判断使用哪个目标。</p>
]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(4)-迭代器模式Itarator</title>
    <url>/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8FItarator/</url>
    <content><![CDATA[<p><strong>思想</strong>：提 供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。<br><strong>场景</strong>：访 问一个聚合对象的内容而无需暴露它的内部表示。支持对聚合对象的多种遍历。为遍历不同的聚合结构提供一个统一的接口(即, 支持多态迭代)。<br><strong>实现</strong>：其 实就是定义一个逻辑上类似一个指针的迭代类。专门用于这种迭代工作。如果对C++ STL火锅功夫 学习的朋友一定不会陌生啦。实际使用过一下就明白了。除了功能之外，他给我最大的感受就是他让我熟悉的for语句，变长了好多。^-^</p>
<span id="more"></span>
<p>迭代器模式由以下角色组成：<br>1 迭代器角色（Iterator）：迭代器角色负责定义访问和遍历元素的接口。<br>2 具体迭代器角色（Concrete Iterator）：具体迭代器角色要实现迭代器接口，并要记录遍历中的当前位置。<br>3 容器角色（Container）：容器角色负责提供创建具体迭代器角色的接口。<br>4 具体容器角色（Concrete Container）：具体容器角色实现创建具体迭代器角色的接口——这个具体迭代器角色于该容器的结构相关。<br>迭代器模式UML图如下：<br><img src="/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8FItarator/20151010164947153.png" alt="这里写图片描述"></p>
<p>迭代器模式在java中的集合框架中用的非常极致：<br><img src="/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8FItarator/20151010165653094.png" alt="这里写图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//迭代器 ，该接口提供了迭代遍历的通用方法</span><br><span class="line">public interface Iterator &#123;</span><br><span class="line">      boolean hasNext();</span><br><span class="line">      Object next();</span><br><span class="line">      void remove();</span><br><span class="line">&#125;</span><br><span class="line">//容器迭代化接口，凡是实现此接口的集合容器距可以生成相应的迭代器</span><br><span class="line">public interface Iterable&lt;T&gt;&#123;</span><br><span class="line">      //产生迭代器，将容器对象转换为迭代器对象</span><br><span class="line">      Iterator&lt;T&gt; interator();</span><br><span class="line">&#125;</span><br><span class="line">//java集合框架的根接口，该接口继承了容器迭代化接口，因此java中的集合都可以被迭代</span><br><span class="line">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt;</span><br></pre></td></tr></table></figure>
<p>自定义迭代器：<br>以ArrayList为例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyIterator implements Iterable &#123;</span><br><span class="line">      //存放数据的集合</span><br><span class="line">      private ArrayList list;</span><br><span class="line">     //负责创建具体迭代器角色的工厂方法</span><br><span class="line">     public Iterator iterator() &#123;</span><br><span class="line">          return new Itr(list);</span><br><span class="line">     &#125;</span><br><span class="line">    //作为内部类的具体迭代器角色</span><br><span class="line">    private class Itr implements Iterator &#123;</span><br><span class="line">           ArrayList myList;</span><br><span class="line">          int position = 0;</span><br><span class="line">           public Itr(ArrayList list) &#123;</span><br><span class="line">                  this.myList = list;</span><br><span class="line">           &#125;</span><br><span class="line">           public Object next() &#123;</span><br><span class="line">                  Object obj = myList.get(position);</span><br><span class="line">                  position++;</span><br><span class="line">                  return obj;</span><br><span class="line">          &#125;</span><br><span class="line">          public boolean hasNext() &#123;</span><br><span class="line">                 if (position &gt;= myList.size()) &#123;</span><br><span class="line">                       return false;</span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">                     return true;</span><br><span class="line">                 &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        //不支持remove操作</span><br><span class="line">        public void remove()&#123;</span><br><span class="line">              throw new UnsupportedOperationException(</span><br><span class="line">            &quot;Alternating MyIterator does not support remove()&quot;);</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>此处可以为MyIterator 指定被迭代对象的构造器。<br>Iterator模式的优点：<br>(1).实现功能分离，简化容器接口。让容器只实现本身的基本功能，把迭代功能委让给外部类实现，符合类的设计原则。<br>(2).隐藏容器的实现细节。<br>(3).为容器或其子容器提供了一个统一接口，一方面方便调用；另一方面使得调用者不必关注迭代器的实现细节。<br>(4).可以为容器或其子容器实现不同的迭代方法或多个迭代方法。</p>
]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(5)-策略模式Strategy</title>
    <url>/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-5-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8FStrategy/</url>
    <content><![CDATA[<p><img src="/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-5-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8FStrategy/20151011142912495.png" alt="这里写图片描述"><br><strong>思想：</strong>定 义一系列的算法,把它们一个个封装起来, 并 且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。<br><strong>场景：</strong>该 模式实际上也可以理解为一种Bridge模式的变种。只是它突出的是，一般当我们把一个类或者一组 类的一些代码独立成一个Strategy类的时候，我们可能会为同样接口的这些算法定义多个接口一 致，但是实现方法不同的版本，并在需要的时候灵活的替换这些算法。</p>
<span id="more"></span>
<p><strong>实现：</strong>实 现方式同Bridge模式。<br><strong>重构成本：</strong>中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//文本替换策略</span><br><span class="line">abstract class TextStrategy &#123;</span><br><span class="line">    protected String text;</span><br><span class="line"></span><br><span class="line">    public TextStrategy(String text) &#123;</span><br><span class="line">        this.text = text;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract String replace();</span><br><span class="line">&#125;  </span><br><span class="line">//替换算法1：将文本中&quot;@r@n&quot;替换为&quot;@n&quot;</span><br><span class="line">class StrategyOne extends TextStrategy &#123;</span><br><span class="line">    public StrategyOne(String text) &#123;</span><br><span class="line">        super(text);</span><br><span class="line">    &#125;</span><br><span class="line">    public String replace() &#123;</span><br><span class="line">        System.out.println(“StrategyOne:”);</span><br><span class="line">        String result = text.replaceAll(&quot;@r@n&quot;, &quot;@n&quot;));</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line">//替换算法2：将文本中&quot;@n&quot;替换为&quot;@r@n&quot;</span><br><span class="line">class StrategyTwo extends TextStrategy &#123;</span><br><span class="line">    public StrategyTwo(String text) &#123;</span><br><span class="line">        super(text);</span><br><span class="line">    &#125;</span><br><span class="line">    public String replace() &#123;</span><br><span class="line">        System.out.println(“StrategyTwo:”);</span><br><span class="line">        String result = text.replaceAll(“@n&quot;, &quot;@r@n&quot;));</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line">public class TextCharChange &#123;</span><br><span class="line">    public static void replace(TextStrategy strategy) &#123;</span><br><span class="line">        strategy.replace();</span><br><span class="line">    &#125;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">	String testText1 = &quot;This is a test text!!@n Oh! Line Return!!@n&quot;;</span><br><span class="line">        String testText2 = This is a test text!!@r@n Oh! Line Return@r@n&quot;;</span><br><span class="line">TextCharChange.replace(new StrategyOne(testText2));</span><br><span class="line">    TextCharChange.replace(new StrategyTwo(testText1));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>State状态模式和Strategy策略模式非常类似，但是有如下区别：<br>(1).State状态模式重点在于设定状态变化，根据状态，返回相应的响应。<br>(2).Strategy策略模式重点在于根据需求直接采用设定的策略，即根据场景选择合适的处理算法，而不需要改变状态。<br>JDK中策略模式的应用：<br>•java.util.concurrent.ThreadPoolExecutor.AbortPolicy<br>•java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy<br>•java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy<br>•java.util.concurrent.ThreadPoolExecutor.DiscardPolicy<br>•java.util.Comparator</p>
]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(6)-工厂模式Factory</title>
    <url>/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-6-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FFactory/</url>
    <content><![CDATA[<p>工厂模式有三种：简单工厂模式，抽象工厂模式和工厂方法模式。<br>1、简单工厂模式<br><img src="/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-6-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FFactory/20151011152009034.png" alt="这里写图片描述"></p>
<span id="more"></span>
<p>以图形为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//图形接口</span><br><span class="line">interface Shape()&#123;</span><br><span class="line">	public void draw();</span><br><span class="line">&#125;</span><br><span class="line">//圆形</span><br><span class="line">class Circle implements Shape&#123;</span><br><span class="line">	public void draw()&#123;</span><br><span class="line">	System.out.println(“Circle is drawing”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//矩形</span><br><span class="line">class Rectangle implements Shape&#123;</span><br><span class="line">	public void draw()&#123;</span><br><span class="line">	System.out.println(“Rectangle is drawing”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//图形工厂</span><br><span class="line">class ShapeFactory&#123;</span><br><span class="line">	public static Shape createShape(String name) throws InstantiationException,</span><br><span class="line">                                      IllegalAccessException,</span><br><span class="line">                                      ClassNotFoundException</span><br><span class="line"> 	&#123;</span><br><span class="line">	//使用java的反射机制来产生对象实例</span><br><span class="line">	return (Shape)class.forName(name).newInstance();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ShapeDemo&#123;</span><br><span class="line">	public static void draw(Shape shape)&#123;</span><br><span class="line">	shape.draw();</span><br><span class="line">&#125;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">	draw(ShapeFactory.createShape(“Circle”));</span><br><span class="line">	draw(ShapeFactory.createShape(“Rectangle”));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、抽象工厂模式<br>抽象工厂模式中可以包括多个抽象产品类，每个抽象产品类可以产生出多个具体产品类，一个抽象工厂用于定义所需产品的组合形式，抽象工厂派生具体工厂类，这些具体工厂类就是简单工厂模式中的工厂类，具体工厂类负责具体产品实例的创建：</p>
<p><img src="/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-6-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FFactory/20151011153515037.png" alt="这里写图片描述"><br>以换肤为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//软件皮肤类</span><br><span class="line">class Skin&#123;</span><br><span class="line">	private SkinFactory skinFactory;</span><br><span class="line">	public Skin(SkinFactory factory)&#123;</span><br><span class="line">	setSkinFactory(factory);</span><br><span class="line">&#125;</span><br><span class="line">public void setSkinFactory(SkinFactory factory)&#123;</span><br><span class="line">	this.skinFactory = factory</span><br><span class="line">&#125;</span><br><span class="line">public void showSkin()&#123;</span><br><span class="line">	System.out.println(“Style=” + factory.getStyle().showStyle() + “, color=” + factory.getColor().showColor());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//软件Style</span><br><span class="line">interface Style()&#123;</span><br><span class="line">	public void showStyle();</span><br><span class="line">&#125;</span><br><span class="line">//IOS style</span><br><span class="line">class IOSStyle implements Style&#123;</span><br><span class="line">	public void showStyle()&#123;</span><br><span class="line">	System.out.println(“This is IOS style”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//Android style</span><br><span class="line">class AndroidStyle implements Style&#123;</span><br><span class="line">	public void showStyle()&#123;</span><br><span class="line">	System.out.println(“This is Android style”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//软件Color</span><br><span class="line">interface Color()&#123;</span><br><span class="line">	public void showColor();</span><br><span class="line">&#125;</span><br><span class="line">//IOS color</span><br><span class="line">class IOSColor implements Color&#123;</span><br><span class="line">	public void showColor()&#123;</span><br><span class="line">	System.out.println(“This is IOS color”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//Android color</span><br><span class="line">class AndroidColor implements Color&#123;</span><br><span class="line">	public void showColor()&#123;</span><br><span class="line">	System.out.println(“This is Android color”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//抽象皮肤工厂</span><br><span class="line">interface SkinFactory&#123;</span><br><span class="line">	public Style getStyle();</span><br><span class="line">	public Color getColor();</span><br><span class="line">&#125;</span><br><span class="line">//IOS皮肤工厂</span><br><span class="line">class IOSSkinFactory implements SkinFactory&#123;</span><br><span class="line">	public Style getStyle()&#123;</span><br><span class="line">		return new IOSStyle();</span><br><span class="line">&#125;</span><br><span class="line">	public Color getColor()&#123;</span><br><span class="line">		return new IOSColor();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//Android皮肤工厂</span><br><span class="line">class AndroidSkinFactory implements SkinFactory&#123;</span><br><span class="line">	public Style getStyle()&#123;</span><br><span class="line">		return new AndroidStyle();</span><br><span class="line">&#125;</span><br><span class="line">	public Color getColor()&#123;</span><br><span class="line">		return new AndroidColor();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class SkinDemo&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		//显示一套IOS皮肤</span><br><span class="line">	Skin skin = new Skin(new IOSSkinFactory());</span><br><span class="line">	skin.showSkin();</span><br><span class="line">	//换一套Android的皮肤</span><br><span class="line">	skin.setSkinFactory(new AndroidSkinFactory());</span><br><span class="line">	skin.showSkin();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、工厂方法模式<br>工厂方法中也只包含一个抽象产品类，抽象产品类可以派生出多个具体产品类。工厂方法定义一个用于创建产品的接口，让子类决定实例化哪一个类，使得类的实例化延迟到子类。<br><img src="/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-6-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FFactory/20151011154239096.png" alt="这里写图片描述"><br>以汽车制造为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//汽车接口</span><br><span class="line">interface ICar&#123;</span><br><span class="line">	public void run();</span><br><span class="line">&#125;</span><br><span class="line">//奔驰车</span><br><span class="line">class BenzCar implements ICar&#123;</span><br><span class="line">	public void run()&#123;</span><br><span class="line">	System.out.println(“Benz car run”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//宝马车</span><br><span class="line">class BMWCar implements ICar&#123;</span><br><span class="line">	public void run()&#123;</span><br><span class="line">	System.out.println(“BMW car run”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//抽象汽车工厂</span><br><span class="line">abstract class CarFactory&#123;</span><br><span class="line">	public abstract ICar createCar();</span><br><span class="line">&#125;</span><br><span class="line">//奔驰车工厂</span><br><span class="line">class BenzCarFactory extends CarFactory&#123;</span><br><span class="line">	public ICar createCar()&#123;</span><br><span class="line">	return new BenzCar();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//宝马车工厂</span><br><span class="line">class BMWCarFactory extends CarFactory&#123;</span><br><span class="line">	public ICar createCar()&#123;</span><br><span class="line">	return new BMWCar();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class FactoryMethodDemo&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">	CarFactory factory = new BenzCarFactory();</span><br><span class="line">	ICar car = factory.createCar();</span><br><span class="line">	car.run();</span><br><span class="line">	factory = new BMWCarFactory();</span><br><span class="line">	car = factory.createCar();</span><br><span class="line">	car.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工厂模式中，重要的是工厂类，而不是产品类。产品类可以是多种形式，多层继承或者是单个类都是可以的。但要明确的，工厂模式的接口只会返回一种类型的实例，这是在设计产品类的时候需要注意的，最好是有父类或者共同实现的接口。<br>使用工厂模式，返回的实例一定是工厂创建的，而不是从其他对象中获取的。工厂模式返回的实例可以不是新创建的，返回由工厂创建好的实例也是可以的。<br>三种工厂模式的区别：<br>简单工厂 ： 用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力。<br>工厂方法 ：用来生产同一等级结构中的固定产品，支持增加任意产品。<br>抽象工厂 ：用来生产不同产品族(由不同产品组合成的一套产品)的全部产品，对于增加新的产品，无能为力；支持增加产品族。</p>
]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title> 设计模式(7)-原型模式</title>
    <url>/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-7-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-7-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/20151011162526441.png" alt="这里写图片描述"><br><strong>思想：</strong>克 隆一个已有的类的实例（大家相比都用过甚至写过类的Clone实现，应该很容易理解了）。<br><strong>场景：</strong>应 用Clone的场景应该说非常多，理想情况下我当然希望任何类都能Clone， 需要的时候就能Clone一份一模一样的出来。</p>
<span id="more"></span>
<p><strong>实现：</strong>这 里将的实现主要之实现的表现形式，而不是如何用具体的语言来实现。因此，只要为需要Clone能力 的类定义一个Clone方法就行。当然，一般，主流的程序语言框架都已经定义了通用的Clone接 口（当然也可以自己定义），继承并实现该接口和方法就好。<br><strong>重构成本：</strong>极低。不多解释了吧。<br>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//抽象原型类</span><br><span class="line">abstract class Shape implements Colneable&#123;</span><br><span class="line">	String shapeName;</span><br><span class="line">	public String getShapeName()&#123;</span><br><span class="line">	retun shapeName;</span><br><span class="line">&#125;</span><br><span class="line">public void setShapeName(String shapeName)&#123;</span><br><span class="line">     this.shapeName = shapeName;</span><br><span class="line">&#125;</span><br><span class="line">//实现了Colneable接口的类，可以使用clone()方法复制对象</span><br><span class="line">public Object clone()&#123;</span><br><span class="line">	try&#123;</span><br><span class="line">	return super.clone();</span><br><span class="line">&#125;catch(CloneNotSupportedException e)&#123;</span><br><span class="line">	System.err.println(“此对象不支持复制”);</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//具体原型类</span><br><span class="line">publc class Circle extends Shape&#123;</span><br><span class="line">	public Circle()&#123;</span><br><span class="line">	setShapeName(“Circle shape”);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">	Shape shape = new Circle();</span><br><span class="line">	System.out.println(shape.getShapeName());</span><br><span class="line">	//通过clone()方法获得一个对象拷贝</span><br><span class="line">	Shape shape2 = (Shape)shape.clone();</span><br><span class="line">	System.out.println(shape2.getShapeName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Cloneable为标记接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package java.lang;</span><br><span class="line">pubilc interface Cloneable&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>clone()方法是在Object中定义的,而且是protected的，只有实现了Cloneable接口的类才可以在其实例上调用clone()方法，否则会抛出CloneNotSupportException。<br>为了获取对象的一份拷贝，我们可以利用Object类的clone()方法，也可以实现Cloneable接口，覆盖基类的clone()方法，在clone()方法中，调用super.clone()。<br><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3pxNjU3ODcwMi9hcnRpY2xlL2RldGFpbHMvNDkwNDg4NTE=">关于拷贝详见：http://blog.csdn.net/wzq6578702/article/details/49048851<i class="fa fa-external-link-alt"></i></span><br>JDK中原型模式的应用：<br>java.lang.Object#clone()<br>java.lang.Cloneable</p>
]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(8)-建造者模式</title>
    <url>/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-8-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>思想：将一个类的创建过程和他的主体部分分离。<br>场景：该模式的典型的应用场景是：一个类的创建过程可能比较复杂，或者创建过程中的某些阶段可能会容易变化；或者多个类的创建过程比较类似， 但是主体不同。</p>
<span id="more"></span>
<p>实现：在 以上提到的两种场景中，我们就可以取出一个类的创建过程的代码，定义一个专门的Builder类， 而在原来创建类对象实例的地方，将这个Builder类的实例作为参数传入。还有第二个重点，就是Builder类 可以将将整个创建过程分为几个阶段，每个阶段不必在类中直接实现，而可以通过继承体系在子类中实现，或者通过子类的方法过载来修改创建过程中的某个阶段， 但是重用其他的阶段。可以发现，该模式将一个对象的复杂创建过程重用到非常高的层次。这正是它的意义所在。<br>重构成本：低。该模式的重构成本我觉得是非常低的，因为一般来讲，创建过程的代码本来也就应该在原来的类的构造函数中，把它Extract出 来就好了。如果发现多个类的创建过程有比较多的代码重复或类似，那么就可以重用这些提取出来的Builder类 或者Builder类中的某些阶段。</p>
<p>Builder建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。Builder模式是一步一步创建一个复杂的对象，它允许用户可以只通过指定复杂对象的类型和内容就可以构建它们，用户不需要了解所构建对象的内部具体构建细节，Builder建造设计模式的目的是为了将构造复杂对象的过程和它的部件解耦。<br>Builder建造者设计模式中有两个重要角色：Director指导者和Builder建造者。Director指导者相当于设计师或架构师，拥有整个产品各个部件之间关系的构建蓝图。Builder建造者是部件的具体创建者，Builder建造者根据Director指导者的指示创建产品的各个部件，最终由Director构建出完整产品。Builder建造者设计模式的UML图如下：<img src="/2018-09-28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-8-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/20151031101846683.png" alt="这里写图片描述"><br>用一个类表示包装食品外面显示的营养成分，其中每份含量和每罐含量是必须的，卡洛里，脂肪，纳和碳水化合物是可选参数。<br>大家一般习惯使用重载构造方法来解决该问题，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class NutritionFacts&#123;</span><br><span class="line">	//必须参数</span><br><span class="line">	private final int servingSize;</span><br><span class="line">	private final int servings;</span><br><span class="line">	//可选参数</span><br><span class="line">	private final int calories;</span><br><span class="line">	private final int fat;</span><br><span class="line">	private final int sodium;</span><br><span class="line">	private final int carbohydrate;</span><br><span class="line">	public NutritionFacts(int servingSize, int servings)&#123;</span><br><span class="line">		this(servingSize, servings, 0);</span><br><span class="line">	&#125;</span><br><span class="line">	public NutritionFacts(int servingSize, int servings, int calories)&#123;</span><br><span class="line">		this(servingSize, servings, calories, 0);</span><br><span class="line">	&#125;</span><br><span class="line">	public NutritionFacts(int servingSize, int servings, int calories,</span><br><span class="line">						  int fat)&#123;</span><br><span class="line">		this(servingSize, servings, calories, fat, 0);</span><br><span class="line">	&#125;</span><br><span class="line">	public NutritionFacts(int servingSize, int servings, int calories,</span><br><span class="line">						  int fat, int sodium)&#123;</span><br><span class="line">		this(servingSize, servings, calories, fat, sodium, 0);</span><br><span class="line">	&#125;</span><br><span class="line">	public NutritionFacts(int servingSize, int servings, int calories,</span><br><span class="line">						  int fat, int sodium, int carbohydrate)&#123;</span><br><span class="line">		this.servingSize = servingSize;</span><br><span class="line">		this.servings = servings;</span><br><span class="line">		this.calories = calories;</span><br><span class="line">		this.fat = fat;</span><br><span class="line">		this.sodium = sodium;</span><br><span class="line">		this.carbohydrate = carbohydrate;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要创建实例对象的时候，就利用参数列表最短的构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NutritionFacts cocaCola = new NutritionFacts(240, 8, 100, 0, 35, 27);</span><br></pre></td></tr></table></figure>
<p>如果可选参数很多的时候就难以控制，客户端代码变得很难编写，且难以阅读，如果不小心参数顺序混淆了，在编译的时候很难发现问题，在运行时出错时难以调试。<br>第二种大家都会想到的办法是使用setter方法设置每个需要的参数，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class NutritionFacts&#123;</span><br><span class="line">	//必须参数</span><br><span class="line">	private int servingSize = -1;</span><br><span class="line">	private int servings = -1;</span><br><span class="line">	//可选参数</span><br><span class="line">	private int calories = 0;</span><br><span class="line">	private int fat = 0;</span><br><span class="line">	private int sodium = 0;</span><br><span class="line">	private int carbohydrate = 0;</span><br><span class="line">	public NutritionFacts()&#123;&#125;</span><br><span class="line">	public void setServingSize(int val)&#123;</span><br><span class="line">		this.servingSize = val;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setServings(int val)&#123;</span><br><span class="line">		this.servings = val;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setCalories(int val)&#123;</span><br><span class="line">		this.calories = val;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setFat(int val)&#123;</span><br><span class="line">		this.fat = val;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setSodium(int val)&#123;</span><br><span class="line">		this.sodium = val;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setCarbohydrate(int val)&#123;</span><br><span class="line">		this.carbohydrate = val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用setter方法可以弥补重载构造方法的缺陷，创建实例对象很容易，并且代码也容易阅读：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NutritionFacts cocaCola = new NutritionFacts();</span><br><span class="line">cocaCola.setServingSize(240);</span><br><span class="line">cocaCola.setServings(8);</span><br><span class="line">cocaCola.setCalories(100);</span><br><span class="line">cocaCola.setFat(27);</span><br></pre></td></tr></table></figure>
<p>由于javaBean自身有着很严重的缺点，构造过程被分到了几个调用中，在构造过程中java Bean可能处于不一致的状态，类无法仅仅通过检验构造方法参数的有效性来保证一致性，使用处于不一致状态的对象将会导致失败。另外javaBean阻止了把类做成不可变的可能，因此很难确保线程安全。<br>解决构造参数多问题的最佳方案是使用建造者模式，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class NutritionFacts&#123;</span><br><span class="line">	//必须参数</span><br><span class="line">	private final int servingSize;</span><br><span class="line">	private final int servings;</span><br><span class="line">	//可选参数</span><br><span class="line">	private final int calories;</span><br><span class="line">	private final int fat;</span><br><span class="line">	private final int sodium;</span><br><span class="line">	private final int carbohydrate;</span><br><span class="line">	//建造者</span><br><span class="line">	public static class Builder&#123;</span><br><span class="line">		//必须参数</span><br><span class="line">		private final int servingSize;</span><br><span class="line">		private final int servings;</span><br><span class="line">		//可选参数</span><br><span class="line">		private final int calories = 0;</span><br><span class="line">		private final int fat = 0;</span><br><span class="line">		private final int sodium = 0;</span><br><span class="line">		private final int carbohydrate = 0;</span><br><span class="line">		public Builder(int servingSize, int servings)&#123;</span><br><span class="line">			this.servingSize = servingSize;</span><br><span class="line">			this.servings = servings;</span><br><span class="line">		&#125;</span><br><span class="line">		public Builder calories(int val)&#123;</span><br><span class="line">			this.calories = val;</span><br><span class="line">			return this;</span><br><span class="line">		&#125;</span><br><span class="line">		public Builder fat(int val)&#123;</span><br><span class="line">			this.fat = val;</span><br><span class="line">			return this;</span><br><span class="line">		&#125;</span><br><span class="line">		public Builder sodium(int val)&#123;</span><br><span class="line">			this.sodium = val;</span><br><span class="line">			return this;</span><br><span class="line">		&#125;</span><br><span class="line">		public Builder carbohydrate(int val)&#123;</span><br><span class="line">			this.carbohydrate = val;</span><br><span class="line">			return this;</span><br><span class="line">		&#125;</span><br><span class="line">		public NutritionFacts build()&#123;</span><br><span class="line">			return new NutritionFacts(this);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	private NutritionFacts(Builder builder)&#123;</span><br><span class="line">		this.servingSize = builder.servingSize;</span><br><span class="line">		this.servings = builder.servings;</span><br><span class="line">		this.calories = builder.calories;</span><br><span class="line">		this.fat = builder.fat;</span><br><span class="line">		this.sodium = builder.sodium;</span><br><span class="line">		this.carbohydrate = builder.carbohydrate;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用建造者模式创建实例对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NutritionFacts cocaCola = new NutritionFacts().Build(240, 8).calories(100).sodium(35)</span><br><span class="line">											  .carbohydrate(27).build();</span><br></pre></td></tr></table></figure>
<p>建造者模式可以有多个可变参数，可以利用建造器构建多个对象，参数可以在创建时动态调整。<br>Builder建造者模式和AbstraceFactory抽象工厂模式的区别：<br>Builder建造者模式和AbstraceFactory抽象工厂模式非常类似，很多人经常分不清楚，区别如下：<br>(1).抽象工厂模式中，每一次工厂物件被呼叫时都会传回一个完整的产品物件，而使用端有可能会决定把这些产品组装成一个更大的和复杂的产品，也有可能不会。工厂物件是没有状态的，不知道上一次构建的是哪一个产品，也没有未来的概念，不知道下一次构建的是哪一个产品，更不知道自己构建的产品在更高层的产品结构蓝图中是什么位置。<br>(2). 建造者模式不同，建造模式的重点在指导者(Director)角色。指导者是有状态的，它知道整体蓝图，知道上一次、这一次和下一次交给建造者(Builder)角色去构建的零件是什么，以便能够将这些零件组装成一个更大规模的产品。它一点一点地建造出一个复杂的产品，而这个产品的组装程式就发生在指导者角色内部。建造者模式的使用端拿到的是一个完整的最后产品。<br> 换言之，虽然抽象工厂模式与建造模式都是设计模式，但是抽象工厂模式处在更加具体的尺度上，而建造模式则处于更加宏观的尺度上。一个系统可以由一个建造模式和一个抽象工厂模式组成，使用端通过呼叫这个导演角色，间接地呼叫另一个抽象工厂模式的工厂角色。工厂样式传回不同产品族的零件，而建造者模式则把它们组装起来。<br>JDK中建造者模式的应用：<br>StringBuilder和StringBuffer的append()方法使用了建造者模式。<br>StringBuilder把构建者的角色交给了其的父类AbstractStringBuilder</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class StringBuilder</span><br><span class="line">    extends AbstractStringBuilder</span><br><span class="line">    implements java.io.Serializable, CharSequence</span><br><span class="line">&#123;</span><br><span class="line">。。。。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以append方法为例，最终调用的是父类的append（）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public StringBuilder append(String str) &#123;</span><br><span class="line">    super.append(str);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父类AbstractStringBuilder的实现代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public AbstractStringBuilder append(String str) &#123;</span><br><span class="line">    if (str == null) str = &quot;null&quot;;</span><br><span class="line">    int len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(0, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    return this;//返回构建对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（11）-组合模式</title>
    <url>/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8811%EF%BC%89-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>思想</strong>：将 对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致 性。<br><strong>场景</strong>：该 模式的应用场景极其类似，比如像图形系统，如电路设计、UML建模系统，或者像web的 显示元素等，都是那种需要整体和部分具有使用接口上的一定的一致性的需求的结构，实际上，我觉得这样的系统如果不使用Composite模 式将会是惨不忍睹的。</p>
<span id="more"></span>
<p><strong>实现</strong>：该模式的实现主要就是要表示整体或部分的所有类都继承自同一的基类或接口，从而拥有使用接口上一定的一致性。<br><strong>重构成本</strong>：高。</p>
<p>Composite组合设计模式属于对象的结构模式，有时又叫做部分－整体（Part－Whole）模式。<br>组合设计模式将对象组织到树型结构中，可以用来描述整体与部分的关系。组合模式可以使客户端将单纯元素与复合元素同等看待。<br>组合设计模式涉及到的三个角色<br>(1).抽象构件（Component）角色：这是一个抽象角色，它给参加组合的对象规定一个接口。这个角色给出共有的接口机器默认行为。<br>(2).树叶构件（Leaf）角色：代表参加组合的树叶对象。一个树叶没有下级的子对象。定义出参加组合的原始对象的行为。<br>(3).树枝构件（Composite）角色：代表参加组合的有子对象的对象，并给出树枝构件对象的行为。<br>Composite组合设计模式的实现根据所实现接口的区别分为两种形式，分别称为安全式和透明式：<br>(1).透明方式<br>   作为第一种选择，在Compotent里面声明所有的用来管理子类对象的方法，包括add()、remove()、以及getChild()方法。<br>   这样做的好处是所有的构件类都有相同的接口。在客户端看来，树叶类对象与合成类对象的区别起码在接口层次上消失了，客户端 可以同等地对待所有的对象。这就是透明形式的合成模式。 这个选择的缺点是不够安全，因为树叶对象和组合类对象的在本质上是有区别的。树叶类对象不可能有下一个层次的对象， 因此add() remove() getChild()方法没有意义，但是在编译时期不会出错，而只会在运行期出错。<br>Composite组合设计模式的透明方式结构如下：<br><img src="/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8811%EF%BC%89-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/20160102200840852.png" alt="这里写图片描述"><br>Composite组合设计模式的透明方式例子代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Component&#123;</span><br><span class="line">	public void operation();</span><br><span class="line">	composite getComposite();</span><br><span class="line">	public void add(Component component);</span><br><span class="line">	public void remove(Component component);</span><br><span class="line">	public Iterator iter();</span><br><span class="line">&#125;</span><br><span class="line">class Composite implements Component()&#123;</span><br><span class="line">	private List&lt; Component&gt; components = new ArrayList&lt; Component&gt;();</span><br><span class="line">	composite getComposite()&#123;</span><br><span class="line">	return this;</span><br><span class="line">&#125;</span><br><span class="line">public void operation()&#123;</span><br><span class="line">	Iterator iter = iter ();</span><br><span class="line">	while(iter.hasNext())&#123;</span><br><span class="line">	((Component)iter.next()).operation();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	public void add(Component component)&#123;</span><br><span class="line">	components.add(component);</span><br><span class="line">&#125;</span><br><span class="line">	public void remove(Component component)&#123;</span><br><span class="line">	components.remove(component);</span><br><span class="line">&#125;</span><br><span class="line">	public Iterator iter()&#123;</span><br><span class="line">	return components.iterator();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Leaf implements Component&#123;</span><br><span class="line">composite getComposite()&#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void operation()&#123;</span><br><span class="line">System.out.println(“Leaf component operation”);</span><br><span class="line">&#125;</span><br><span class="line">public void add(Component component)&#123;&#125;</span><br><span class="line">public void remove(Component component)&#123;&#125;</span><br><span class="line">public Iterator iter()&#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2).安全方式<br>   第二种选择是在Composite类里而声明所有的用来管理子类对象的方法。这样的做法是安全的做法。树叶类型的对象根本就没有管理子类对象的方法，因此，如果客户端对树叶类对象使用这些方法时，程序会在编译时期出错。  这个方式的缺点就是不够透明，因为树叶类和合成类将具有不同的接口。<br>Composite组合设计模式的安全方式结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Component&#123;</span><br><span class="line">	public void operation();</span><br><span class="line">	composite getComposite();</span><br><span class="line">&#125;</span><br><span class="line">class Composite implements Component()&#123;</span><br><span class="line">	private List&lt; Component&gt; components = new ArrayList&lt; Component&gt;();</span><br><span class="line">	composite getComposite()&#123;</span><br><span class="line">	return this;</span><br><span class="line">&#125;</span><br><span class="line">public void operation()&#123;</span><br><span class="line">	Iterator iter = iter ();</span><br><span class="line">	while(iter.hasNext())&#123;</span><br><span class="line">	((Component)iter.next()).operation();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//管理方法只存在于Composite中</span><br><span class="line">	public void add(Component component)&#123;</span><br><span class="line">	components.add(component);</span><br><span class="line">&#125;</span><br><span class="line">	public void remove(Component component)&#123;</span><br><span class="line">	components.remove(component);</span><br><span class="line">&#125;</span><br><span class="line">	public Iterator iter()&#123;</span><br><span class="line">	return components.iterator();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Leaf implements Component&#123;</span><br><span class="line">	composite getComposite()&#123;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br><span class="line">public void operation()&#123;</span><br><span class="line">	System.out.println(“Leaf component operation”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>组合模式通常和迭代器模式联合使用。<br>JDK中组合模式的应用：<br>•javax.swing.JComponent#add(Component)<br>•java.awt.Container#add(Component)<br>•java.util.Map#putAll(Map)<br>•java.util.List#addAll(Collection)<br>•java.util.Set#addAll(Collection)<br>•org.w3c.dom</p>
]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（12）-装饰模式</title>
    <url>/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8812%EF%BC%89-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>思想</strong>：为一个对象已有的子类添加一些额外的职责。<br><strong>场景</strong>：该模式的使用场景，主要是有的时候我们不愿意定义逻辑上新的子类，因为没有新的逻辑含义上的子类概念，而只是想为一个已存在的子类附加 一些职责。<br><strong>实现</strong>：该 模式的实现主要就是定义一个物理上的新的子类，但是，它只是包含要附加职责的类，传递外部对相同接口的调用，在这个传递调用的通道上附加额外的功能。突然 想到，Decorator模式是不是一定程度上也能代替DynamicProxy模 式，从而成为一种AOP实现的方案呢？</p>
<span id="more"></span>
<p><strong>重构成本</strong>：低。定义一个Decorator和一个已有类的逻辑上的子类，物理 表现形式上都是一个子类，重构也确实不是难事。</p>
<p>Decorator装饰设计模式是动态给一个对象添加一些额外的职责，但同时又不影响对象本身已有的功能。<br>通常使用继承来实现功能的扩展，但是如果这些需要扩展的功能的种类很烦多，就会生成很多子类，增加系统复杂性。同时由于使用继承实现功能的扩展时，必须可预见这些扩展功能，这些功能是编译时就确定的了，是静态的。使用Decorator装饰设计模式就可以根据功能需要有用户动态决定加入的方式和时机，实现“即插即用”的功能，在运行时动态决定增加何种功能。<br>Decorator装饰设计模式中的两种角色：<br>Decoratee被装饰者：即需要功能增强的原始对象，即目标对象。<br>Decorator装饰者：为原始对象提供功能增强的对象。<br>装饰者模式UML图如下：<br><img src="/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8812%EF%BC%89-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/20160102203012389.png" alt="这里写图片描述"><br>Java swing中的JTextArea组件默认没有滚动条和边框，我们使用Decorator装饰设计模式动态为其加上滚动条和边框，使用Decorator装饰设计模式例子实现的例子代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">interface VisualComponent&#123;</span><br><span class="line">	public void draw();</span><br><span class="line">&#125;</span><br><span class="line">//Decoratee</span><br><span class="line">class TextArea implements VisualComponent &#123;</span><br><span class="line">	public void draw()&#123;</span><br><span class="line">	System.out.println(“Draw TextArea”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//抽象Decorator</span><br><span class="line">abstract class Decorator implements VisualComponent &#123;</span><br><span class="line">	protected VisualComponent component;</span><br><span class="line">	public Decorator(VisualComponent component)&#123;</span><br><span class="line">	this.component = component;</span><br><span class="line">&#125;</span><br><span class="line">public void draw()&#123;</span><br><span class="line">	component.draw();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//滚动条Decorator</span><br><span class="line">class ScrollDecorator extends Decorator&#123;</span><br><span class="line">	public ScrollDecorator (VisualComponent component)&#123;</span><br><span class="line">	super(component);</span><br><span class="line">&#125;</span><br><span class="line">public void draw()&#123;</span><br><span class="line">	super.draw();</span><br><span class="line">	scrollTo();</span><br><span class="line">&#125;</span><br><span class="line">public void scrollTo()&#123;</span><br><span class="line">	System.out.println(“TextArea scroll to…”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//边框Decorator</span><br><span class="line">class BorderDecorator extends Decorator&#123;</span><br><span class="line">	public BorderDecorator(VisualComponent component)&#123;</span><br><span class="line">	super(component);</span><br><span class="line">&#125;</span><br><span class="line">public void draw()&#123;</span><br><span class="line">	super.draw();</span><br><span class="line">	drawBorder();</span><br><span class="line">&#125;</span><br><span class="line">public void drawBorder ()&#123;</span><br><span class="line">	System.out.println(“Draw border for TextArea …”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class DecoratorDemo&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">	//画一个普通的TextArea</span><br><span class="line">	TextArea textArea = new TextArea();</span><br><span class="line">	textArea.draw();</span><br><span class="line">	//画一个带滚动条的TextArea</span><br><span class="line">	ScrollDecorator scroll = new ScrollDecorator(new TextArea());</span><br><span class="line">	scroll.draw();</span><br><span class="line">	//画一个带边框的TextArea</span><br><span class="line">	BorderDecorator border = new BorderDecorator(new TextArea());</span><br><span class="line">	border.draw();</span><br><span class="line">	//画一个既带边框又带滚动条的TextArea</span><br><span class="line">	BorderDecorator border2 = new BorderDecorator(new ScrollDecorator(new TextArea()));</span><br><span class="line">	border2.draw();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Decorator装饰设计模式和Proxy代理模式的区别：<br>Decorator装饰设计模式和Proxy代理模式非常类似，都可以对目标对象做一些动态改变，以致于很多初学者分不清楚Decorator装饰设计模式和Proxy代理模式，个人觉得二者简单区别如下：<br>(1).Proxy代理模式中，客户端不直接调用服务端程序，而是通过一个代理对象来调用服务端程序，类似一个请求转发的作用。<br>(2). Decorator装饰设计模式中，被装饰对象可以不用添加任何装饰而直接使用，也可以通过装饰器的包装动态增强功能。<br>JDK中装饰者模式的应用：<br>•java.io包<br>•java.util.Collections#synchronizedList(List)<br>•AWT和Swing图形组件</p>
]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式(9)-门面设计模式</title>
    <url>/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-9-%E9%97%A8%E9%9D%A2%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>思想：为子系统中的一组接口提供一个一致的界面，这个接口使得这一子系统更加容易使用。<br>场景：当 你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性， 也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。Facade可 以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过Facade层。 客户程序与抽象类的实现部分之间存在着很大的依赖性。引入Facade将这个子系统与客户以及其他 的子系统分离，可以提高子系统的独立性和可移植性。当你需要构建一个层次结构的子系统时，使用Facade模 式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过Facade进行通 讯，从而简化了它们之间的依赖关系。（这里直接引用了《设计模式迷你手册》，因为觉得它确实已经说得很明了了，下面类似的情形我直接引用原文的就不再注明 了，这里先说明一下，感谢《手册》作者的这些优秀总结。当然，本文的绝大多数文字都是Teddy本 人的原创看法，绝非抄袭，您可以比较本文和附件《手册》，附件同时也会提供本文的Word版本下 载。）<br>实现：该 模式的实现需要定义一个新的系统构架上的Layer，该层向上提供一组新的接口，向下调用子系统原 有的接口。</p>
<span id="more"></span>
<p>重构成本：高。要修改所有直接对子系统的地调用为对Façade层的调用还是 有很多事情要做的。不过，现代IDE中，如果我们删除调用层对子系统的程序集引用，那么所有这些我 们需要修改的调用都能标示出来，因为编译不能通过了嘛，因此，重构的风险还不算特别大，只是工作量着实不小。<br>Façade门面设计模式为子系统中的一组接口提供一个一致的界面，应用程序本身将不再直接依赖于子系统原件，而是依赖一个门面，当想要修改某个原件的行为时，只需要修改实现类即可，应用程序本身不需要做任何修改。Façade门面设计模式结构如下：<br><img src="http://img.blog.csdn.net/20151031105346867" alt="这里写图片描述"><br>以JDBC为例演示Façade门面设计模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//JDBC Facade</span><br><span class="line">interface JDBCUtil&#123;</span><br><span class="line">	public Statement getStatement() ;</span><br><span class="line">	public ResultSet getResult(String sql);</span><br><span class="line">public static void close();</span><br><span class="line">&#125;</span><br><span class="line">//MySql JDBC</span><br><span class="line">class MySqlUtil implements JDBCUtil&#123;</span><br><span class="line">	private static Connection conn = null;</span><br><span class="line">	private static Statement st = null;</span><br><span class="line">private static ResultSet rs = null;</span><br><span class="line">private static final String DRIVER = &quot;com.mysql.jdbc.Driver&quot;;</span><br><span class="line">private static final String URL = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">private static final String USERNAME = &quot;root&quot;;</span><br><span class="line">	private static final String PASSWORD = &quot;root&quot;;</span><br><span class="line">	static&#123;</span><br><span class="line">		// 写入驱动所在处，打开驱动</span><br><span class="line">		try &#123;</span><br><span class="line">			Class.forName(DRIVER);</span><br><span class="line">			conn = DriverManager.getConnection(URL, USERNAME, PASSWORD);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			System.err.println(&quot;MySql数据库连接失败，失败原因：&quot; + e.getMessage());</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public Statement getStatement() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			st = conn.createStatement();</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			System.err.println(&quot;MySql获取Statement失败，失败原因：&quot; + e.getMessage());</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		return st;</span><br><span class="line">	&#125;</span><br><span class="line">	public ResultSet getResult(Statement st, String sql)&#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			rs = st.executeQuery(sql);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			System.err.println(&quot;MySql获取ResultSet失败，失败原因：&quot; + e.getMessage());</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		return rs;</span><br><span class="line">&#125;</span><br><span class="line">public void close(Statement st, ResultSet rs) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			if (rs != null)</span><br><span class="line">				rs.close();</span><br><span class="line">			if (st != null)</span><br><span class="line">				st.close();</span><br><span class="line">			if (conn != null)</span><br><span class="line">				conn.close();</span><br><span class="line">			&#125; catch (Exception e) &#123;</span><br><span class="line">			System.err.println(&quot;MySql数据库连接关闭失败，失败原因：&quot; + e.getMessage());</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//Oracle JDBC</span><br><span class="line">class OracleUtil implements JDBCUtil&#123;</span><br><span class="line">	private static Connection conn = null;</span><br><span class="line">	private static Statement st = null;</span><br><span class="line">private static ResultSet rs = null;</span><br><span class="line">private static final String DRIVER = &quot;oracle.jdbc.driver.OracleDriver&quot;;</span><br><span class="line">private static final String USERNAME = &quot;scott&quot;;</span><br><span class="line">private static final String PASSWORD = &quot;tiger&quot;;</span><br><span class="line">private static final String URL = &quot;jdbc:oracle:thin:@10.9.143.59:1521:oss&quot;;</span><br><span class="line">static&#123;</span><br><span class="line">		// 写入驱动所在处，打开驱动</span><br><span class="line">		try &#123;</span><br><span class="line">			Class.forName(DRIVER);</span><br><span class="line">			conn = DriverManager.getConnection(URL, USERNAME, PASSWORD);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			System.err.println(&quot;Oracle数据库连接失败，失败原因：&quot; + e.getMessage());</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public Statement getStatement() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			st = conn.createStatement();</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			System.err.println(&quot;Oracle获取Statement失败，失败原因：&quot; + e.getMessage());</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		return st;</span><br><span class="line">	&#125;</span><br><span class="line">	public ResultSet getResult(Statement st, String sql)&#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			rs = st.executeQuery(sql);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			System.err.println(&quot;Oracle获取ResultSet失败，失败原因：&quot; + e.getMessage());</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		return rs;</span><br><span class="line">&#125;</span><br><span class="line">public void close(Statement st, ResultSet rs) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			if (rs != null)</span><br><span class="line">				rs.close();</span><br><span class="line">			if (st != null)</span><br><span class="line">				st.close();</span><br><span class="line">			if (conn != null)</span><br><span class="line">				conn.close();</span><br><span class="line">			&#125; catch (Exception e) &#123;</span><br><span class="line">			System.err.println(&quot;Oracle数据库连接关闭失败，失败原因：&quot; + e.getMessage());</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class JDBCDemo&#123;</span><br><span class="line">	private static final String SQL = “select * from aaa”;</span><br><span class="line">	private static Statement st;</span><br><span class="line">	private Static ResultSet rs;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">	//MySql</span><br><span class="line">	JDBCUtil util = new MySqlUtil();</span><br><span class="line">	st = util.getStatement();</span><br><span class="line">	rs = util.getResultSet(st, SQL);</span><br><span class="line">	util.close(st, rs);</span><br><span class="line">	//Oracle</span><br><span class="line">	JDBCUtil util = new OracleUtil();</span><br><span class="line">	st = util.getStatement();</span><br><span class="line">	rs = util.getResultSet(st, SQL);</span><br><span class="line">	util.close(st, rs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MySql和Oracle不但JDBC连接的属性不同，一些sql语法也不太相同，使用门面模式之后，将MySql换成Oracle，只需要将具体的实现类替换就可以了，不会影响应用程序。<br>Façade门面设计模式隐藏了程序内部各个原件之间的合作行为，以及原件本身的操作与设定细节。<br>门面设计模式优缺点：<br>•门面模式可以简化程序库的使用，隐藏所依赖​​的程序库，降低对程序库的耦合，有利于分工合作。<br>•门面模式隐藏了各个元件之间的合作行为，以及元件本身的操作与设定细节，失去了一些直接操作元件的方便性。</p>
<p>另外在初始化servlet容器的时候，tomcat把包装了StandardWrapper的StandardWrapperFacade的对象作为servletconfig传给servlet，这里StandardWrapperFacade就是servletconfig的门面类。<br>在tomcat内部有很多容器组件，他们之间信息的传递使用的也是门面设计模式,从Request和Response对象的封装、StandardWrapper到ServletConfig封装（前面提到的servlet容器的初始化）、ApplicationContext到ServletContext封装都用到了门面设计模式。<br>以tomcat中Request对象的封装为例：<br><img src="http://img.blog.csdn.net/20151031110351762" alt="这里写图片描述"><br>从图中可以看出，HttpRequestFacade类封装了HttpRequest借口，能够提供数据，通过HttpREquestFacade访问到的数据都被代理到HttpRequest中，通常封装的对象都被设置为P日阿特或者Protect的，防止在Facade中被直接访问。</p>
<p>JDK中门面模式应用：<br>•java.util.logging<br>•java.lang.Class</p>
]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（13）-桥接模式</title>
    <url>/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8813%EF%BC%89-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>思想</strong>：将一个类的抽象定义和具体实现解耦。<br><strong>场景</strong>：该 模式的典型应用场景是：一个类的抽象定义已经确定，但是，其实现代码甚至原理可能会不同。比如：我们最熟悉的图形界面中的window的 实现，无论在什么操作系统，什么平台的机器上，一个window应具有的抽象定义基本上是一致的， 但是，其实现代码肯定会因为平台不同，机器的代码指令不同而不同。此时，如果希望您写的window类 能跨平台，应用Bridge模式就是一个好主意。<br><strong>实现</strong>：该 模式的实现方法很简单，就是除了定义类的抽象定义之外，将一个类的所有实现代码独立出一个实现类。这样一来，无论是抽象定义还是实现类都能分别修改和重 用，但只要两部分的交互接口不变，还是可以方便的互相组装。当然，实际上也没有必要隔离出“所有实现代码”，只需要隔离需要的部分就行了。因此，也可以 说，从代码结构来看，Builder模式是一种变种的Bridge模 式的。也经常有人将Bridge模式和接口相比较，如果隔离出所有的实现，那么的确接口的方式也能 做到抽象定义和实现分离，但是，Bridge有其优势如下：一、究竟隔离多少代码到Bridge类 中可以灵活确定，二、减少了总的类的数目，三、允许被隔离出来的Bridge类被其它的类直接共享 使用。</p>
<span id="more"></span>
<p><strong>重构成本</strong>：中。将所有的（或很大部分）实现代码分离开来总还是一件不大，但是，也不小的事。所以标个“中”在这里。：）<br>Bridge桥接设计模式是将一组功能(实现)与另一组使用该功能的其他对象(行为)分离开来,以便达到单一因素变化，然后使用对象调用的方式将这两组关联系起来，将问题的行为和实现分离开来实现，通过用聚合代替继承来解决子类爆炸性增长的问题。 Bridge桥接设计模式结构如下：<br><img src="/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8813%EF%BC%89-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/20160102205014103.png" alt="这里写图片描述"><br>还是以画图为例演示Bridge桥接设计模式，例子代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//行为</span><br><span class="line">interface Shape&#123;</span><br><span class="line">public void doDraw();</span><br><span class="line">&#125;</span><br><span class="line">class Circle implements Shape&#123;</span><br><span class="line">	private Drawing draw</span><br><span class="line">	public Circle(Drawing draw)&#123;</span><br><span class="line">	this.draw = draw;</span><br><span class="line">&#125;</span><br><span class="line">public void doDraw()&#123;</span><br><span class="line">	draw.draw();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Rectangle implements Shape&#123;</span><br><span class="line">	private Drawing draw</span><br><span class="line">	public Rectangle(Drawing draw)&#123;</span><br><span class="line">	this.draw = draw;</span><br><span class="line">&#125;</span><br><span class="line">public void doDraw()&#123;</span><br><span class="line">	draw.draw();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//实现</span><br><span class="line">interface Drawing&#123;</span><br><span class="line">	public void draw();</span><br><span class="line">&#125;</span><br><span class="line">class SolidDrawing implements Drawing&#123;</span><br><span class="line">	public void draw()&#123;</span><br><span class="line">	System.out.println(“Drawing solide line…”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class DashDrawing implements Drawing&#123;</span><br><span class="line">	public void draw()&#123;</span><br><span class="line">	System.out.println(“Drawing dash line…”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class BridgeDemo&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">	//画一个实线的圆</span><br><span class="line">	Drawing draw1 = new SolidDrawing();</span><br><span class="line">	Shape shape1 = new Circle(draw1);</span><br><span class="line">	shape1.doDraw();</span><br><span class="line">//画一个虚线的矩形</span><br><span class="line">	Drawing draw2 = new DashDrawing();</span><br><span class="line">	Shape shape2 = new Rectangle(draw2);</span><br><span class="line">	shape2.doDraw();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只从上面的例子代码可能还无法完全理解Bridge桥接设计模式，上面的圆形和矩形是行为，而实线画法和虚线画法则是实现，行为接口Shape通过聚合方式引用实现接口Drawing从而达到了行为和实现的桥接。如果需要增加第三种图形三角形，则不会影响实现部分。如果增加第三种画法折线画法，则不会影响图形行为部分，将行为与实现松耦合分离。当系统有两个可变因素时，即问题行为和问题实现都在变化时，传统实现方式可能组合情况太多造成类爆炸，适合使用桥梁模式。<br>学习设计模式的人经常分不清Bridge桥接设计模式和Strategy策略设计模式，个人感觉两者简单的区别如下：<br>(1).Bridge桥接设计模式中不但实现可以变化，问题行为也是可以变化的，且两者的变化是相互独立的，在两个维度都存在变化情况下优先考虑使用桥接模式。<br>(2).Strategy策略设计模式中，仅仅存在算法实现策略的变化，问题行为是不变的，即仅有一个维度的变化。另外策略模式中考虑的算法层次的变化，是无状态，无数据的。<br>JDK中桥接模式的应用：<br>•AWT<br>•JDBC</p>
]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（14）-享元模式</title>
    <url>/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8814%EF%BC%89-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>思想</strong>：说Flyweight可 能有的朋友第一次看到想象不到是什么样子，其实说他就是一个Pool，你可能就明白了。也就是由一 个Flyweight Factory来管理一族一定数目逻辑上经常需要构建和销毁的细颗粒对象， 例如我们常见的数据库连接池。在Factory内部，并不物理销毁这些对象，而在接到实例化请求时 返回这些被关系对象的实例，从而减少创建销毁这些细颗粒对象的开销。<br><strong>场景</strong>：基 本上所有的需要Pool这个概念的环境都能应用。<br><strong>实现</strong>：实现的底层方式可以千变万化，在接口上就是如上图所示，花样不多。这里就不多解释。</p>
<span id="more"></span>
<p><strong>重构成本</strong>：低。<br>Flyweight享元设计模式是为了避免大量拥有相同内容的小类重复创建，而使大家共享一个类的模式。Flyweight享元设计模式实质是运用一个简单工厂方法模式，外加一个单类模式实现细粒度原件的共享。享元模式结构如下：<br><img src="/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8814%EF%BC%89-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/20160723174754843.png" alt="这里写图片描述"><br>Flyweight享元设计模式有两个重要概念：</p>
<p>以文字处理软件中对象为例<br>内部状态intrinsic：可以共享的对象，如相同的字。<br>外部状态extrinsic：不能共享的对象，如每个字的位置，大小等等。<br>Flyweight享元设计模式使用对象池存放内部对象，当需要内部对象时首先判断对象池中是否存在，如果存在直接返回，如果不存在创建一个对象放入对象池中返回。<br>书有书名，作者和价格三个常用的属性，其中作者有可能是同一个人，使用Flyweight享元设计模式的例子代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Book&#123;</span><br><span class="line">	private String title;</span><br><span class="line">	private float price;</span><br><span class="line">	private Author author;</span><br><span class="line">	public String getTitle()&#123;</span><br><span class="line">		return title;</span><br><span class="line">&#125;</span><br><span class="line">public float getPrice()&#123;</span><br><span class="line">	return price;</span><br><span class="line">&#125;</span><br><span class="line">public Author getAuthor()&#123;</span><br><span class="line">	return author;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//将Author作者类设计为可共享的享元</span><br><span class="line">class Author&#123;</span><br><span class="line">	//内部状态</span><br><span class="line">	private String name;</span><br><span class="line">	public String getName()&#123;</span><br><span class="line">		return name;</span><br><span class="line">&#125;</span><br><span class="line">public Author(String name)&#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//享元工厂</span><br><span class="line">public class AuthorFactory&#123;</span><br><span class="line">	private static Map&lt;String, Author&gt; authors = new HashMap&lt;String, Author&gt;();</span><br><span class="line">	public static Author getAuthor(String name)&#123;</span><br><span class="line">	Author author = authors.get(name);</span><br><span class="line">	if(author == null)&#123;</span><br><span class="line">	author = new Author(name);</span><br><span class="line">	authors.put(name, author);</span><br><span class="line">&#125;</span><br><span class="line">return author;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Flyweight享元设计模式非常适合文字处理软件，因为像文字这种小对象重用的可能性很高，如果不共享对象，就会生成数量巨大的小对象消耗内存，享元模式则可以使重复概率高的对象重用，大大提高程序效率和性能。</p>
<p>享元模式特点：<br>•享元模式基本是单例模式+简单工厂模式。<br>•减少运行时对象实例的个数，节省内存。</p>
<p>JDK中享元模式的应用：<br>•java.lang.Integer#valueOf(int)<br>•java.lang.Boolean#valueOf(boolean)<br>•java.lang.Byte#valueOf(byte)<br>•java.lang.Character#valueOf(char)<br>•String常量池</p>
]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（15）-模板模式</title>
    <url>/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8815%EF%BC%89-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>思想</strong>：定 义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Te m p l a t e M e t h o d 使 得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br><strong>场景</strong>：该 模式实际上是一种非常直观和可理解的OO思想下的代码重用的实现。只需一次性实现一个算法的不变的 部分，并将可变的行为留给子类来实现。各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。模板方法只允许在特定点计算法的某个阶段被 过载，这样也就只允许在这些点进行扩展。</p>
<span id="more"></span>
<p>实现：见下图，太简单了，就不多说了。<br><strong>重构成本</strong>：低。<br>Template Method模板方法设计模式定义一个操作中算法的骨架，将具体步骤的执行延迟到子类中实现。Java中的抽象类就是使用了模板方法设计模式。模板方法设计模式结构如下：<br><img src="/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8815%EF%BC%89-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/20160723181450412.png" alt="这里写图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> public abstract class Person &#123;</span><br><span class="line">	//模板方法，该方法定义具有相同的内容部分</span><br><span class="line">	public void say() &#123;</span><br><span class="line">		System.out.println(&quot;Hello &quot;);</span><br><span class="line">		System.out.println(&quot;My name is :&quot;+getName());</span><br><span class="line">		System.out.println(&quot;Intruduce myself :&quot;+getInfo());</span><br><span class="line">		System.out.println(&quot;Thanks...bye :&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	//抽象方法，模板方法中细节不同的内容</span><br><span class="line">	public abstract String getName();</span><br><span class="line">	public abstract String getInfo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *模板模式</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Student extends Person&#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String getInfo() &#123;</span><br><span class="line"></span><br><span class="line">		return &quot;I`m a student &quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String getName() &#123;</span><br><span class="line"></span><br><span class="line">		return &quot;jack&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> *模板模式</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Teacher extends Person&#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String getInfo() &#123;</span><br><span class="line"></span><br><span class="line">		return &quot;I`m a teacher &quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String getName() &#123;</span><br><span class="line"></span><br><span class="line">		return &quot;Tom&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> *模板模式测试类</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class TestPersonOfMould &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Student s = new Student();</span><br><span class="line">		s.say();</span><br><span class="line">		Teacher t =new Teacher();</span><br><span class="line">		t.say();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>很多学习设计模式的人看到上面的例子后，觉得Template Method模板方法设计模式非常类似Façade门面设计模式，Template Method模板方法设计模式和Façade门面设计模式的区别如下：</p>
<p>(1).Template Method模板方法设计模式可以先将一些流程和框架规定好，将这些流程和框架作为程序除了的模版。具体的细节除了留给子类去实现。</p>
<p>(2).Façade门面设计模式仅仅只定义对外操作接口，具体的实现全部交给子类。</p>
<p>策略模式使用组合，模板方法模式使用继承。工厂方法模式是模板模式的一种变体。</p>
<p>模板方法使得子类可以在不改变算法结构的情况下，重启定义算法中的某些步骤，模板方法有以下3种变体：<br>•模板方法模式中必须子类实现的方法定义为抽象方法。<br>•子类可选的方法可以在父类中提供默认版本即钩子（hook）。<br>•不希望子类重写的方法定义为final。<br>•</p>
<p>JDK中模板方法模式应用：</p>
<p>java.util.Collections#sort()</p>
<p>Java swing&#x2F;applet#paint()</p>
<p>Java applet&#x2F;servlet#init(), destory()</p>
<p>XML SAX#startDocument(), startElement(),endElement, endDocument()</p>
]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（16）-备忘录模式</title>
    <url>/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8816%EF%BC%89-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>Memento备忘录设计模式是一个保存另外一个对象内部状态拷贝的对象，这样以后就可以将该对象恢复到以前保存的状态。Memento备忘录设计模式的结构如下：<br><img src="/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8816%EF%BC%89-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/20160723184322291.png" alt="这里写图片描述"></p>
<span id="more"></span>
<p>Memento备忘录设计模式有以下3个重要角色：</p>
<p>Originator：需要保存内部状态的对象。</p>
<p>Caretaker：为Originator保存并恢复状态的对象。</p>
<p>Memento：存放Originator内部状态的对象，由Originator进行读写，并且Caretaker进行维护。</p>
<p>Memento备忘录设计模式例子代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Memento</span><br><span class="line">class Memento&#123;</span><br><span class="line">	private String state;</span><br><span class="line">	public Memento(String state)&#123;</span><br><span class="line">	this.state = state;</span><br><span class="line">&#125;</span><br><span class="line">public String getState()&#123;</span><br><span class="line">	return state;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// Caretaker</span><br><span class="line">class Caretaker&#123;</span><br><span class="line">	private Stack&lt;Memento&gt; mementos = new Stack&lt;Memento&gt;();</span><br><span class="line">	public void addMemento(Memento m)&#123;</span><br><span class="line">	mementos.push(m);</span><br><span class="line">&#125;</span><br><span class="line">public Memento getMemento()&#123;</span><br><span class="line">	if(!mementos.empty())&#123;</span><br><span class="line">	return mementos.pop();</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// Originator</span><br><span class="line">public class Originator&#123;</span><br><span class="line">	private String state;</span><br><span class="line">	public Originator(String state)&#123;</span><br><span class="line">	this.state = state;</span><br><span class="line">&#125;</span><br><span class="line">public void setState()&#123;</span><br><span class="line">	this.state = state;</span><br><span class="line">&#125;</span><br><span class="line">public String getState()&#123;</span><br><span class="line">	return state;</span><br><span class="line">&#125;</span><br><span class="line">public Memento createMemento(String state)&#123;</span><br><span class="line">	return new Memento(state);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">	Originator originator = new Originator(“State1”);</span><br><span class="line">	Caretaker caretaker = new Caretaker();</span><br><span class="line">	caretaker.addMemento(originator. createMemento(originator.getState()));</span><br><span class="line">	originator.setState(“State2”);</span><br><span class="line">	String restore = caretaker. getMemento().getState();</span><br><span class="line">	System.out.println(“Current originator state=” + originator.getState() + “,restore state=” + restore);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果：</p>
<p>Currentoriginator state&#x3D; State2,restore state&#x3D; State1</p>
<p>Memento备忘录设计模式常用于文字编辑软件&#x2F;IDE集成开发环境中的撤销和恢复操作。</p>
]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（17）-观察者模式</title>
    <url>/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8817%EF%BC%89-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>Observer<br><strong>思想：</strong>定 义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所 有依赖于它的对象都得到通知并被自动更新。<br><strong>场景：</strong>上面描述该模式思想的文字可能显得有些拗口，实际上你也不用想得过于复杂。只要你写过任何的基于图形界面的程序，那么实际上您对他是一 点也不该陌生的。它就是我们每一次鼠标键盘敲击都在我们的程序内部流转着的事件机制的基础。当一个事件发生，则通知订阅该事件的对象。</p>
<span id="more"></span>
<p><strong>实现：</strong>上 面的UML图看似复杂，实际上，去理解它的最好的办法就是试着思考和使用任何一种OO语 言来定义一个拥有事件机制的类。比如，.Net下，你只要好好去看看关于delegate的 文档，尝试着根据MSDN写写看一个最简单的自定义事件。那么，上面的UML图， 我敢保证你能很轻易的看明白。<br>重构成本：高。</p>
<p>Observer观察者设计模式用于将对象的变化通知给感兴趣的用户。在Observer模式中的角色为主题（subject）与观察者（observer），观察者订阅它感兴趣的主题，一个主题可以被多个观 察者订阅，当主题的状态发生变化时，它必须通知（notify）所有订阅它的观察者，观察者检视主题的状态变化，并作出对应的动作，所以Observer模式也称之为Publish-Subscribe模式。 Observer观察者设计模式结构如下：<br><img src="/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8817%EF%BC%89-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/20161027184708005.png" alt="这里写图片描述"></p>
<p>以一个电子商务网站商品价格变时通知订阅用户为例，演示Observer观察者设计模式，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//主题</span><br><span class="line">interface Subject&#123;</span><br><span class="line">	//注册观察者</span><br><span class="line">	public void registerObserver(Observer o);</span><br><span class="line">	//注销观察者</span><br><span class="line">	public void unregisterObserver(Observer o);</span><br><span class="line">	//通知观察者</span><br><span class="line">	public void notifyObservers();</span><br><span class="line">&#125;</span><br><span class="line">//观察者</span><br><span class="line">interface Observer&#123;</span><br><span class="line">	//更新价格信息</span><br><span class="line">	public void update(float price);</span><br><span class="line">&#125;</span><br><span class="line">//商品</span><br><span class="line">class Product implements Subject&#123;</span><br><span class="line">	//观察者列表</span><br><span class="line">	private List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;();</span><br><span class="line">	private float price;</span><br><span class="line">	public void registerObserver(Observer o)&#123;</span><br><span class="line">	observers.add(o);</span><br><span class="line">&#125;</span><br><span class="line">public void unregisterObserver(Observer o)&#123;</span><br><span class="line">	observers.remove(o);</span><br><span class="line">&#125;</span><br><span class="line">public void notifyObservers()&#123;</span><br><span class="line">	for(Observer observer : observers)&#123;</span><br><span class="line">		//主题向观察者推送更新数据</span><br><span class="line">	observer.update(price);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public void priceChanged()&#123;</span><br><span class="line">	notifyObservers();</span><br><span class="line">&#125;</span><br><span class="line">public void setPrice(float price)&#123;</span><br><span class="line">	this.price = price;</span><br><span class="line">	priceChanged();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//订阅者</span><br><span class="line">class Subscriber implements Observer&#123;</span><br><span class="line">	private float currentPrice;</span><br><span class="line">	//观察者引用主题</span><br><span class="line">	private Subject product;</span><br><span class="line">	public Subscriber(Subject product)&#123;</span><br><span class="line">	this.product = product;</span><br><span class="line">	//主题注册观察者</span><br><span class="line">	product.registerObserver(this);</span><br><span class="line">&#125;</span><br><span class="line">public void update(float price)&#123;</span><br><span class="line">	this. currentPrice = price;</span><br><span class="line">	System.out.println(“Current price change to:” + currentPrice);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ObserverDemo&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">	Subject product = new Product();</span><br><span class="line">	Subscriber subscriber = new Subscriber(product);</span><br><span class="line">	product.setPrice(10.98);</span><br><span class="line">	product.setPrice(998.15);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Java的java.util中内置了Observer观察者设计模式，其中：<br>(1).java.util.Observable是主题类，所有继承了该类的类是事件发生的主题，也是被观察的对象。java.util.Observable的常用方法有：<br>a.public void addObserver(Observer o)：为主题添加观察者。<br>b.publicvoid deleteObserver(Observer o)：删除某个观察者。<br>c.publicvoid deleteObservers()：删除主题上的所有观察者。<br>d.publicboolean hasChanged()：测试主题是否改变。<br>e.protectedvoid setChanged()：标记该主题对象已经改变。<br>f.publicvoid notifyObservers()：通知所有观察者对象已经已经改变。<br>(2).java.util.Observer接口是观察者，所有实现了该接口的类都是主题事件的观察者，该接口只有一个方法需要实现：<br>publicvoid update(Observable o,  Object arg)：通知观察者更新已经改变的主题。<br>使用JDK内置的Observer观察者设计模式，演示电子商务网站商品价格的例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在Java的java.util中内置了Observer观察者设计模式，其中：</span><br><span class="line">(1).java.util.Observable是主题类，所有继承了该类的类是事件发生的主题，也是被观察的对象。java.util.Observable的常用方法有：</span><br><span class="line">a.public void addObserver(Observer o)：为主题添加观察者。</span><br><span class="line">b.publicvoid deleteObserver(Observer o)：删除某个观察者。</span><br><span class="line">c.publicvoid deleteObservers()：删除主题上的所有观察者。</span><br><span class="line">d.publicboolean hasChanged()：测试主题是否改变。</span><br><span class="line">e.protectedvoid setChanged()：标记该主题对象已经改变。</span><br><span class="line">f.publicvoid notifyObservers()：通知所有观察者对象已经已经改变。</span><br><span class="line">(2).java.util.Observer接口是观察者，所有实现了该接口的类都是主题事件的观察者，该接口只有一个方法需要实现：</span><br><span class="line">publicvoid update(Observable o,  Object arg)：通知观察者更新已经改变的主题。</span><br><span class="line">使用JDK内置的Observer观察者设计模式，演示电子商务网站商品价格的例子如下：</span><br></pre></td></tr></table></figure>
<p>Observer观察者设计模式在界面编程中应用广泛，一个button往往会注册一个onclickListener，里面有onclickAction方法对点击进行响应，此时button充当的就是主题，而onclickListener就是观察者，而onclickAction就对应着观察者中对事件进行响应的update方法。<br>JDK中观察者模式的应用：<br>•java.util.Observer<br>•java.util.Observable<br>•java.util.EventListener<br>•javax.servlet.http.HttpSessionBindingListener<br>•javax.servlet.http.HttpSessionAttributeListener<br>•javax.faces.event.PhaseListener</p>
]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（18）-责任链模式</title>
    <url>/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8818%EF%BC%89-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>Chain of Responsibility<br><strong>思想：</strong>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一 个对象处理它为止。<br><strong>场景：</strong>该模式实际上是对人们常会不自觉地去做的一种代码组织方式的总结而已。有的时候一条消息需要被处理，我们当然可以在一个雷的一个方法中 对他进行所有需要的处理。但是，如果要做的处理很复杂的情形，甚至能够按照一定的逻辑醒来分类所有这些处理，则不要在一个雷一个函数里处以一切会更好，我 们可以定义多个处理类类表示逻辑上的不同的处理，然后一个个处理类的传递这个消息对象，让希望处理该消息的类自己决定是不是要处理。这样，就能将一个难以 维护的复杂处理过程，分解为一系列简单明了，易于维护的类了。</p>
<span id="more"></span>
<p><strong>实现：</strong>上图是实现方式之一。即，使所有可能处理该请求的对象继承自一个基类，实际上，只要逻辑语义上我们保持这样一种让每个处理类自己决定何 时处理，并传递请求的思想，实现方式也可以千变万化，无论是用接口代替，或者甚至只是简单的定义相同结构的处理函数而通过反射机制来调用处理函数和传递处 理请求，都是可选的方案。<br><strong>重构成本：</strong>中。<br>Chain of Responsibility(CoR)责任链设计模式是用一系列请求处理器试图处理一个请求，这些请求处理器之间是一个松散耦合，唯一的共同点是在他们之间传递请求。例如客户端发送一个请求，请求处理器A先处理，如果A没有处理或者无法处理，就将请求传递给请求处理器B，如果B没有处理或者无法处理，就将请求传递到请求处理器C去处理，所有这些请求处理器构成一条请求处理责任链。Chain of Responsibility责任链设计模式的结构如下：<br><img src="/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8818%EF%BC%89-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/20161027185955526.png" alt="这里写图片描述"></p>
<p>一个处理数字，字母和特殊符号的例子演示Chain of Responsibility，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//抽象请求处理器</span><br><span class="line">abstract class Handler&#123;</span><br><span class="line">	private Handler successor;</span><br><span class="line">	public Handler(Handler successor)&#123;</span><br><span class="line">	this.successor = successor;</span><br><span class="line">&#125;</span><br><span class="line">	public Handler getSuccessor()&#123;</span><br><span class="line">	return successor;</span><br><span class="line">&#125;</span><br><span class="line">public void handRequest(Request request);</span><br><span class="line">&#125;</span><br><span class="line">//Request请求类</span><br><span class="line">class Request&#123;</span><br><span class="line">	private String type;</span><br><span class="line">	public Request(String type)&#123;</span><br><span class="line">	this.type = type;</span><br><span class="line">&#125;</span><br><span class="line">public String getType()&#123;</span><br><span class="line">	return type;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//数字请求处理器</span><br><span class="line">class NumberHandler extends Handler&#123;</span><br><span class="line">	public NumberHandler()&#123;</span><br><span class="line">&#125;</span><br><span class="line">	public NumberHandler(Handler successor)&#123;</span><br><span class="line">	super(successor);</span><br><span class="line">&#125;</span><br><span class="line">public void handRequest(Request request)&#123;</span><br><span class="line">	if(request.getType().equals(“Number”))&#123;</span><br><span class="line">	System.out.println(“Number has been handled”);</span><br><span class="line">&#125;</span><br><span class="line">//传递到下一个请求处理器处理</span><br><span class="line">else&#123;</span><br><span class="line">	getSuccessor().handRequest(request);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//字母请求处理器</span><br><span class="line">class CharacterHandler extends Handler&#123;</span><br><span class="line">	public CharacterHandler()&#123;</span><br><span class="line">&#125;</span><br><span class="line">	public CharacterHandler(Handler successor)&#123;</span><br><span class="line">	super(successor);</span><br><span class="line">&#125;</span><br><span class="line">public void handRequest(Request request)&#123;</span><br><span class="line">	if(request.getType().equals(“Character”))&#123;</span><br><span class="line">	System.out.println(“Character has been handled”);</span><br><span class="line">&#125;</span><br><span class="line">//传递到下一个请求处理器处理</span><br><span class="line">else&#123;</span><br><span class="line">	getSuccessor().handRequest(request);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//特殊符号请求处理器</span><br><span class="line">class SymbolHandler extends Handler&#123;</span><br><span class="line">	public SymbolHandler()&#123;</span><br><span class="line">&#125;</span><br><span class="line">	public SymbolHandler(Handler successor)&#123;</span><br><span class="line">	super(successor);</span><br><span class="line">&#125;</span><br><span class="line">public void handRequest(Request request)&#123;</span><br><span class="line">	if(request.getType().equals(“Symbol”))&#123;</span><br><span class="line">	System.out.println(“Symbol has been handled”);</span><br><span class="line">&#125;</span><br><span class="line">//传递到下一个请求处理器处理</span><br><span class="line">else&#123;</span><br><span class="line">	getSuccessor().handRequest(request);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Application&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Handler numberHandler = new NumberHandler();</span><br><span class="line">		Handler characterHandler = new CharacterHandler();</span><br><span class="line">		Handler symbolHandler = new SymbolHandler();</span><br><span class="line"></span><br><span class="line">		numberHandler.setSuccessor(characterHandler);</span><br><span class="line">		characterHandler.setSuccessor(symbolHandler);</span><br><span class="line">		Request request1 = new Request(“Number”);</span><br><span class="line">		Request request2 = new Request(“Character”);</span><br><span class="line">		Request request3 = new Request(“Symbol”);</span><br><span class="line"></span><br><span class="line">		numberHandler. handRequest(request1);</span><br><span class="line">numberHandler. handRequest(request2);</span><br><span class="line">numberHandler. handRequest(request3);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java中Chain of Responsibility的两个应用例子：<br>(1).Java的异常处理机制，当程序中发生异常时，try-catch会比较所捕捉的异常是否符合异常类型，如果符合就执行所设定的处理，如果都没有比对到适当的异常，就会将异常丢出try-catch区块之外。<br>(2).Struts1.x中的filter过滤器链，Struts2.x中拦截器链等等，将HTTP请求处理中的字符编码转换，加密&#x2F;解密等常用功能分别作为一个个的请求处理器，接收到客户端请求时对其进行处理，同时在向客户端返回服务端响应时也使用这些处理器进行处理。</p>
]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（19）-命令模式</title>
    <url>/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8819%EF%BC%89-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>Command<br><strong>思想：</strong>将一个动态的执行过程封装成一个对象，可以像处理数据来处理和管理这样的对象，在需要的时候激发该对象的方法就能执行被封装的执行过 程。<br><strong>场景：</strong>该模式在很多时候非常有用，它使得我们对逻辑上已经激发的行为进行优化成为可能，我们不仅可以根据需要改变一组逻辑上以经济法的活动的 顺序，消冗余操作，撤销不必要的操作等。也可以把活动和操作视为资源一样来管理和重用。同时该模式也是许多事务处理机制的基础。</p>
<span id="more"></span>
<p><strong>实现：</strong>实现很简单，只是定义一些能够通过指定接口被激发的对活动进行封装的类，然后我们按照需要管理这些类，并在需要的时候激发这些活动。您 还是应该更多地去体会，为什么他是事务处理机制的基础，当我们可以这样来管理一组活动的时候，可以对这些活动进行那些有趣的控制。<br><strong>重构成本：</strong>高。</p>
<p>Command命令设计模式将一个请求封装成一个对象，从而使你可用不同的请求对客户进行操作。Command命令设计模式是对命令的封装。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。每一个命令都是一个操作，命令请求发出请求要求执行一个操作；命令接受方收到请求，并执行操作。命令模式允许命令请求方和命令接收方独立开来，使得命令请求方不必 知道命令接收方的接口，更不必知道请求是怎么被接收，以及操作是否被执行，何时被执行，以及是怎么被执行的。<br>Command命令设计模式结构如下：<br><img src="/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8819%EF%BC%89-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/20161027192244443.png" alt="这里写图片描述"></p>
<p>Command命令设计模式中5个角色：<br>(1).客户角色：创建了一个具体命令对象并确定其接收者。<br>(2).命令角色：声明了一个给所有具体命令类的抽象接口。这是一个抽象角色，通常由一个Java接口或java抽象类实现。<br>(3).具体命令角色：定义一个接受者和行为之间的弱耦合；实现execute方法，负责调用接收者的相应操作。execute方法通常叫做 执行方法。<br>(4).请求者（Invoke）角色：负责调用命令对象执行请求，相关的方法叫做行动方法。<br>(5).接收者（Receiver）角色：负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法。<br>Command命令设计模式例子代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//请求者角色  </span><br><span class="line">class Invoker&#123;  </span><br><span class="line">private Command command;  </span><br><span class="line">        public Invoker(Command command)&#123;  </span><br><span class="line">                this.command = command;  </span><br><span class="line">        &#125;  </span><br><span class="line">public void action()&#123;  </span><br><span class="line">                command.execute();  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">//接收者  </span><br><span class="line">class Receiver&#123;  </span><br><span class="line">//行动方法  </span><br><span class="line">        public void action()&#123;  </span><br><span class="line">                System.out.println(&quot;Action has been taken.&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">//抽象命令角色  </span><br><span class="line">interface Command&#123;  </span><br><span class="line">void execute();  </span><br><span class="line">&#125;  </span><br><span class="line">//具体命令类  </span><br><span class="line">class ConcreteCommand implements Command&#123;  </span><br><span class="line">private Receiver receiver;  </span><br><span class="line">public ConcreteCommand(Receiver receiver)&#123;  </span><br><span class="line">                this.receiver = receiver;  </span><br><span class="line">&#125;  </span><br><span class="line">public void execute()&#123;  </span><br><span class="line">                receiver.action();  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">//客户端  </span><br><span class="line">public class Client&#123;  </span><br><span class="line">public static void main(String[] args)&#123;  </span><br><span class="line">	//客户端创建命令接受者</span><br><span class="line">        	Receiver receiver = new Receiver();  </span><br><span class="line">		//客户端创建具体命令，并指定命令接受者</span><br><span class="line">                Command command = new ConcreteCommand(receiver);  </span><br><span class="line">		//客户端创建请求者，并给请求者指定具体命令</span><br><span class="line">                Invoker invoker = new Invoker(command);  </span><br><span class="line">		//命令请求者发出命令请求</span><br><span class="line">                invoker.action();         </span><br><span class="line">&#125;  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>Command命令设计模式的优缺点：<br>优点: 解耦了命令请求者和接受者之间联系。请求者调用一个命令，接受者接受请求并执行相应的动作，因为使用Command模式解耦，请求者无需知道接受者任何接口。<br>缺点: 造成出现过多的具体命令类。<br>JDK中命令模式的应用：<br>•java.lang.Runnable<br>•javax.swing.Action</p>
]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（20）-中介者模式</title>
    <url>/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8820%EF%BC%89-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>Mediator<br><strong>思想：</strong>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
<span id="more"></span>
<p><strong>场景：</strong>该模式主要用来进行降低一组相互关联调用的对象间的耦合度。如果您发现您的系统的某部分的一组对象间调用极其频繁的坏味道的话，可能您 需要考虑使用该模式来进行一些解耦，否则，这些对象中的任何一个的修改，都将可能导致其他对象许多地方的修改，可维护性就降低了。<br><strong>实现：</strong>定义一个专门的中介对象来封装和传递一组对象间的调用。<br><strong>重构成本：中。</strong></p>
<p>Mediator中介者设计模式是通过一个中介对象封装一系列关于对象交互行为.<br>Mediator中介者设计模式中的角色如下：<br>(1).中介者（Mediator）：抽象定义了“同事”（colleagues，稍后有定义）们通信的接口。<br>(2).具体中介者（Concrete Mediator）：实现了“同事”间的通信接口。<br>(3).同事（Colleague）：参与通信的实体抽象。<br>(4).具体同事（Concrete Colleague）：实现的参与通信的实体。<br>Mediator中介者设计模式结构如下：<br><img src="/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8820%EF%BC%89-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/20161027202246524.png" alt="这里写图片描述"></p>
<p>以私信聊天为例来简单演示Mediator中介者设计模式，例子代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//中介者</span><br><span class="line">interface Mediator&#123;</span><br><span class="line">	public void send(String msg, Person person);</span><br><span class="line">&#125;</span><br><span class="line">//具体中介者</span><br><span class="line">class ConcreteMediator implements Mediator&#123;</span><br><span class="line">	//中介者所联系的交互对象</span><br><span class="line">	private PersonA personA;</span><br><span class="line">	private PersonA personB;</span><br><span class="line">	public void setPersonA(PersonA  personA)&#123;</span><br><span class="line">	this.personA = personA;</span><br><span class="line">&#125;</span><br><span class="line">Public void setPersonB(PersonB personB)&#123;</span><br><span class="line">	this.personB = personB;</span><br><span class="line">&#125;</span><br><span class="line">public void send(String msg, Person person)&#123;</span><br><span class="line">	if(person.equals(personA))&#123;</span><br><span class="line">	personA.greeting(msg);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">	personB.greeting(msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//抽象同事</span><br><span class="line">abstract class Person&#123;</span><br><span class="line">	//同事和中介者打交道</span><br><span class="line">	protected Mediator mediator;</span><br><span class="line">	public Person(Mediator mediator)&#123;</span><br><span class="line">	this.mediator = mediator;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//具体同事</span><br><span class="line">class PersonA extends Person&#123;</span><br><span class="line">	public PersonA(Mediator mediator)&#123;</span><br><span class="line">	super(mediator);</span><br><span class="line">&#125;</span><br><span class="line">public void send(String msg)&#123;</span><br><span class="line">	mediator.send(msg, this);</span><br><span class="line">&#125;</span><br><span class="line">public void greeting(string msg)&#123;</span><br><span class="line">	System.out.println(“PersonA: ” + msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class PersonB extends Person&#123;</span><br><span class="line">	public PersonB(Mediator mediator)&#123;</span><br><span class="line">	super(mediator);</span><br><span class="line">&#125;</span><br><span class="line">public void send(String msg)&#123;</span><br><span class="line">	mediator.send(msg, this);</span><br><span class="line">&#125;</span><br><span class="line">public void greeting(string msg)&#123;</span><br><span class="line">	System.out.println(“PersonB: ” + msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class MediatorDemo&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		//创建中介</span><br><span class="line">		Mediator mediator = new ConcreteMediator();</span><br><span class="line">//创建同事，并为同事设置中介</span><br><span class="line">Person personA = new PersonA(mediator);</span><br><span class="line">Person personB = new PersonB(mediator);</span><br><span class="line"></span><br><span class="line">//向中介设置同事</span><br><span class="line">mediator.setPersonA(personA);</span><br><span class="line">mediator.setPersonB(personB);</span><br><span class="line"></span><br><span class="line">//开始聊天</span><br><span class="line">personA.send(“Hi, B!”);</span><br><span class="line">personB.send(“Hello, A!”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在对象之间的交互操作非常多的情况下;每个对象的行为操作都可能依赖很多其他对象,修改一个对象的行为的同时可能会影响到很多其他对象的行为,如果使用Mediator模式,可以使各个对象间的耦合松散,只需关心和 Mediator的关系,使多对多的关系变成了一对多的关系,在降低系统复杂性的同时提高可修改扩展性.</p>
]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（21）-解释器模式</title>
    <url>/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8821%EF%BC%89-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>思想：</strong>当 有一个语言需要解释执行, 并且你可将该语言中的句子表示为一个抽象语法树时，定义一个解释器，这 个解释器使用该表示来解释语言中的句子。<br><strong>场景：</strong>其 实，从物理结构上，该模式的代码架构看起来可能和Composite模式一模一样，致使其针对的逻 辑语义不同。Composite模式描述一种一般的整体和部分使用接口上的一致性，而Interpreter模 式则侧重于语言解释器的实现构架。<br><strong>实现</strong>：如 上图，基本同Composite模式。</p>
<span id="more"></span>
<p><strong>重构成本：</strong>高。<br>Interpreter解释器设计模式的定义：给定一个语言，定义其文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。<br>Interpreter解释器设计模式角色如下：<br>(1).抽象表达式(AbstractExpression)角色：声明一个所有的具体表达式角色都需要实现的抽象接口。这个接口主要定义一个interpret()方法，称做解释操作。<br>(2).终结符表达式(TerminalExpression)角色：没有子节点的表达式。<br>(3).非终结符表达式(NonterminalExpression)角色：有子节点的表达式，解释操作以递归方式调用其子节点表达式。<br>(4).上下文(Context)角色：上下文提供解释器之外的一些全局信息，比如变量的真实量值等。<br>Interpreter解释器设计模式结构如下：<br><img src="/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8821%EF%BC%89-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/20161027204106492.png" alt="这里写图片描述"><br>通过编写一个模拟Java中日期格式化为指定字符串的例子来演示Interpreter解释器设计模式，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//抽象表达式</span><br><span class="line">interface AbstractExpression&#123;</span><br><span class="line">	public String format(Date date);</span><br><span class="line">&#125;</span><br><span class="line">//具体的日期格式化表达式</span><br><span class="line">class DataFormatExpression implements AbstractExpression&#123;</span><br><span class="line">	private static final String pattern1 = “yyyy-MM-dd”;</span><br><span class="line">	private static final String pattern2 = “yyyy/MM/dd”;</span><br><span class="line">	private static final Calendar calendar = Calendar.getInstance();</span><br><span class="line">	//默认日期不分隔，如：20120606</span><br><span class="line">	private String separator = “”;</span><br><span class="line">	public DataFormatExpression()&#123;&#125;</span><br><span class="line">	public DataFormatExpression(String pattern)&#123;</span><br><span class="line">	if(pattern1.equals(pattern))&#123;</span><br><span class="line">	separator = “-”;</span><br><span class="line">&#125;</span><br><span class="line">else if(pattern2.equals(pattern))&#123;</span><br><span class="line">	separator = “/”;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public String getYear(Calendar cal)&#123;</span><br><span class="line">	return cal.get(Calendar.YEAR) + “”;</span><br><span class="line">&#125;</span><br><span class="line">public String getMonth(Calendar cal)&#123;</span><br><span class="line">	int month = cal.get(Calendar.MONTH) + 1;</span><br><span class="line">	return month &lt; 10 ? “0” + month : “” + month;</span><br><span class="line">&#125;</span><br><span class="line">public String getDay(Calendar cal)&#123;</span><br><span class="line">	int day = cal.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">	return day &lt; 10 ? “0” + day : “” + day;</span><br><span class="line">&#125;</span><br><span class="line">public String format(Date date)&#123;</span><br><span class="line">	calendar.setTime(date);</span><br><span class="line">	return getYear(calendar) + separator + getMonth(calendar) + separator + getDay(calendar);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class InterpreterDemo&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Date date = new Date();</span><br><span class="line">	AbstractExpression expression1 = new DataFormatExpression()</span><br><span class="line">	System.out.println(expression1.format(date));</span><br><span class="line"></span><br><span class="line">AbstractExpression expression2 = new DataFormatExpression(“yyyy-MM-dd”)</span><br><span class="line">	System.out.println(expression2.format(date));</span><br><span class="line"></span><br><span class="line">AbstractExpression expression3 = new DataFormatExpression(“yyyy/MM/dd”)</span><br><span class="line">	System.out.println(expression3.format(date));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Interpreter解释器设计模式的应用场景：<br>在软件构建过程中，若果某一特定领域的问题比较复杂，类似的模式不断重复出现，如果使用普通的编程方式来实现将面临非常频繁的变化。在这种情况下，将特定领域的问题表达为某种语法规则下的句子，再构建一个解释器来解释这样的句子，从而达到解决问题的目的。<br>JDK中解释器模式的应用：<br>•java.util.Pattern<br>•java.text.Normalizer<br>•java.text.DateFormat<br>•java.text.MessageFormat<br>•java.text.NumberFormat</p>
]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式（22）-访问者模式</title>
    <url>/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8822%EF%BC%89-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>Visitor<br><strong>思想：</strong>表 示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。<br><strong>场景：</strong>其 实你不用去理解上面这句话。该模式其实又是一个在代码的物理结构上和Bridge模式很相似的模 式。但是，其语义，其目的，在逻辑上又是不同的。如果说Bridge，以及上述我称为可视为Bridge扩 展的模式中，作为参数的Bridge类，是作为调用类的被访问对象的话，Visitor， 在大多数情形下，如其英文含义，它在语义上是完全相反的。不是他被调用的类处理，更大程度上它处于主动状态，是它去访问，去处理调用它的类。调用它的类， 把自己对别人隐藏起来的东西，暴露给Visitor品尝，任君蹂躏（这个，这个~~千 万别想歪了;-））。另一方面，即使逻辑上没有这种Visitor主 动去访问调用类的语义，只要Visitor类中的操作，是依赖于调用类的具体实现类（它本身或他某 个层次的子类）的某些状态或者方法的，那么，就可以应用该模式来分离出这样的可重用的操作。</p>
<span id="more"></span>
<p><strong>实现：</strong>类 似Bridge模式。<br><strong>重构成本：</strong>中。<br>Visitor访问者设计模式是在不修改已有程序结构的前提下，通过添加额外的“访问者”来完成对已有代码功能的提升。<br> Visitor访问者设计模式的角色：<br>(1) 访问者角色（Visitor）：声明一个访问接口。接口的名称和方法的参数标识了向访问者发送请求的元素角色。这样访问者就可以通过该元素角色的特定接口直接访问它。<br>(2) 具体访问者角色（Concrete Visitor）：实现访问者角色（Visitor）接口<br>(3)元素角色（Element）：定义一个Accept操作，它以一个访问者为参数。<br>(4) 具体元素角色（Concrete Element）：实现元素角色（Element）接口。<br>(5) 对象结构角色（Object Structure）：具体元素的集合，提供一个高层的接口允许访问者角色访问它的元素。<br>Visitor访问者设计模式结构如下：<br><img src="/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8822%EF%BC%89-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/20161027210622521.png" alt="这里写图片描述"><br>Visitor访问者设计模式例子代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//抽象元素</span><br><span class="line">interface IElement&#123;</span><br><span class="line">	public void accept(IVisitor visitor);</span><br><span class="line">&#125;</span><br><span class="line">//具体元素</span><br><span class="line">class ElementA implements IElement&#123;</span><br><span class="line">	public void accept(IVisitor visitor)&#123;</span><br><span class="line">	visitor.visit(this);</span><br><span class="line">&#125;</span><br><span class="line">public void operationA()&#123;</span><br><span class="line">	System.out.println(“ElementA do operationA()……”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class ElementB implements IElement&#123;</span><br><span class="line">	public void accept(IVisitor visitor)&#123;</span><br><span class="line">	visitor.visit(this);</span><br><span class="line">&#125;</span><br><span class="line">public void operationB()&#123;</span><br><span class="line">	System.out.println(“ElementB do operationB()……”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class ElementC implements IElement&#123;</span><br><span class="line">	public void accept(IVisitor visitor)&#123;</span><br><span class="line">	visitor.visit(this);</span><br><span class="line">&#125;</span><br><span class="line">public void operationC()&#123;</span><br><span class="line">	System.out.println(“ElementC do operationC()……”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//抽象访问者</span><br><span class="line">interface IVisitor&#123;</span><br><span class="line">	public void visit(ElementA element);</span><br><span class="line">public void visit(ElementB element);</span><br><span class="line">public void visit(ElementC element);</span><br><span class="line">&#125;</span><br><span class="line">//具体访问者</span><br><span class="line">class MyVisitor implements IVisitor&#123;</span><br><span class="line">	public void visit(ElementA element)&#123;</span><br><span class="line">	element.operationA();</span><br><span class="line">&#125;</span><br><span class="line">public void visit(ElementB element)&#123;</span><br><span class="line">	element.operationB();</span><br><span class="line">&#125;</span><br><span class="line">public void visit(ElementC element)&#123;</span><br><span class="line">	element.operationC();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Public class VisitorDemo&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		IElement[] list = &#123;new ElementA(), new ElementB(), new ElementC()&#125;;</span><br><span class="line">		IVisitor visitor = new MyVisitor();</span><br><span class="line">		for(int i = 0; i &lt; list.length; i++)&#123;</span><br><span class="line">	list[i].accept(visitor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Visitor访问者设计模式有以下两个特点：<br>(1).对元素的访问不是访问者主动发起的，而是通过元素接收访问者来访问自己。<br>(2).对元素的操作不是元素自己主动调用，而是通过访问者的访问方法来操作元素。<br>JDK中访问者模式的应用：<br>•javax.lang.model.element.Element和javax.lang.model.element.ElementVisitor<br>•javax.lang.model.type.TypeMirror和javax.lang.model.type.TypeVisitor<br>•javax.lang.model.element.AnnotationValue和javax.lang.model.element.AnnotationValueVisitor</p>
]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title>concurrency(1)Object类相关方法解读</title>
    <url>/2019/08/11/Concurrent/concurrency(1)Object%E7%B1%BB%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<h3 id="Object类的并发相关方法"><a href="#Object类的并发相关方法" class="headerlink" title="Object类的并发相关方法"></a>Object类的并发相关方法</h3><span id="more"></span>
<p>-Object</p>
<ul>
<li>clone</li>
<li>equals(Object)</li>
<li>finalize</li>
<li>getClass</li>
<li>hashCode</li>
<li>notify            *</li>
<li>notifyAll         *</li>
<li>registerNatives</li>
<li>toString</li>
<li>wait              *</li>
<li>wait(long)        *</li>
<li>wait(long,int)    *</li>
</ul>
<h4 id="wait-方法"><a href="#wait-方法" class="headerlink" title="wait()方法"></a>wait()方法</h4><h4 id="public-final-native-void-wait-long-timeout-throws-InterruptedException"><a href="#public-final-native-void-wait-long-timeout-throws-InterruptedException" class="headerlink" title="public final native void wait(long timeout) throws InterruptedException;"></a>public final native void wait(long timeout) throws InterruptedException;</h4><p>Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object. In other words, this method behaves exactly as if it simply performs the call wait(0).<br>The current thread must own this object’s monitor. The thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object’s monitor to wake up either through a call to the notify method or the notifyAll method. The thread then waits until it can re-obtain ownership of the monitor and resumes execution.<br>As in the one argument version, interrupts and spurious wakeups are possible, and this method should always be used in a loop:<br>           synchronized (obj) {<br>               while (<condition does not hold>)<br>                   obj.wait();<br>               … &#x2F;&#x2F; Perform action appropriate to condition<br>           }</p>
<p>This method should only be called by a thread that is the owner of this object’s monitor. See the notify method for a description of the ways in which a thread can become the owner of a monitor.</p>
<p>Throws:<br>IllegalMonitorStateException – if the current thread is not the owner of the object’s monitor.<br>InterruptedException – if any thread interrupted the current thread before or while the current thread was waiting for a notification. The interrupted status of the current thread is cleared when this exception is thrown.<br>See Also:<br>notify(), notifyAll()</p>
<p>wait()方法会让当前线程等待，直到其他线程调用了Object的notify()或者notifyAll()方法。<br>换句话说，这个方法和执行wait(0)的效果是一样的。</p>
<p>当前线程必须要拥有对象(Object对象)的监视器(锁)，当调用了wait()方法的时候会释放锁的拥有权，然后进入等待，直到拥有这把锁的其他线程调用了这个对象的锁的notify或者notifyAll方法才会被唤醒，线程进入等待，直到可以重新获取锁的拥有权，并且回复执行。<br>对于单参数的版本来说，中断和虚假的唤醒是可能发生的，这个方法会用于一个循环当中：<br>synchronized (obj) {<br>    while (<condition does not hold>)<br>        obj.wait();<br>    … &#x2F;&#x2F; Perform action appropriate to condition<br>}<br>wait放只能被拥有当前对象锁的线程去执行，请参看notify方法的描述一个线程怎么获取到一把锁。</p>
<h5 id="验证wait方法必须获取锁"><a href="#验证wait方法必须获取锁" class="headerlink" title="验证wait方法必须获取锁"></a>验证wait方法必须获取锁</h5><p>编写代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest1 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Object object = new Object();</span><br><span class="line">        object.wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抛出异常：<br>Exception in thread “main” java.lang.IllegalMonitorStateException<br>    at java.lang.Object.wait(Native Method)<br>    at java.lang.Object.wait(Object.java:502)<br>    at com.twodragonlake.concurrency1.MyTest1.main(MyTest1.java:13)</p>
<p>如果我们先获取锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Object object = new Object();</span><br><span class="line">    synchronized (object)&#123;</span><br><span class="line">        object.wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样不会出现异常。</p>
<h4 id="Object-wait-和Thread-sleep-的区别"><a href="#Object-wait-和Thread-sleep-的区别" class="headerlink" title="Object.wait()和Thread.sleep()的区别"></a>Object.wait()和Thread.sleep()的区别</h4><p>Thread的sleep()的doc：<br>Causes the currently executing thread to sleep (temporarily cease execution) for the specified number of milliseconds, subject to the precision and accuracy of system timers and schedulers. The thread does not lose ownership of any monitors.</p>
<p>让当前线程睡眠用户指定的毫秒数，当前线程不会丢失锁的拥有权。</p>
<p>而Object的wait方法调用之后会释放锁。</p>
<h4 id="通过字节码观察"><a href="#通过字节码观察" class="headerlink" title="通过字节码观察"></a>通过字节码观察</h4><p>反编译测试类MyTest1<br>javap -c  com.twodragonlake.concurrency1.MyTest1</p>
<p>找到main方法的反编译部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(java.lang.String[]) throws java.lang.InterruptedException;</span><br><span class="line">  Code:</span><br><span class="line">     0: new           #2                  // class java/lang/Object</span><br><span class="line">     3: dup</span><br><span class="line">     4: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">     7: astore_1</span><br><span class="line">     8: aload_1</span><br><span class="line">     9: dup</span><br><span class="line">    10: astore_2</span><br><span class="line">    11: monitorenter                     //synchronized开始的时候，获取监视器</span><br><span class="line">    12: aload_1</span><br><span class="line">    13: invokevirtual #3                  // Method java/lang/Object.wait:()V</span><br><span class="line">    16: aload_2</span><br><span class="line">    17: monitorexit</span><br><span class="line">    18: goto          26</span><br><span class="line">    21: astore_3</span><br><span class="line">    22: aload_2</span><br><span class="line">    23: monitorexit                      //监视器的退出。</span><br><span class="line">    24: aload_3</span><br><span class="line">    25: athrow</span><br><span class="line">    26: return</span><br><span class="line">  Exception table:</span><br><span class="line">     from    to  target type</span><br><span class="line">        12    18    21   any</span><br><span class="line">        21    24    21   any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="public-final-void-wait-long-timeout-throws-InterruptedException"><a href="#public-final-void-wait-long-timeout-throws-InterruptedException" class="headerlink" title="public final void wait(long timeout) throws InterruptedException"></a>public final void wait(long timeout) throws InterruptedException</h4><p>doc：</p>
<p>Causes the current thread to wait until either another thread invokes the notify() method or the notifyAll() method for this object, or a specified amount of time has elapsed.<br>The current thread must own this object’s monitor.<br>This method causes the current thread (call it T) to place itself in the wait set for this object and then to relinquish(放弃) any and all synchronization claims on this object. Thread T becomes disabled for thread scheduling purposes and lies dormant until one of four things happens:<br>Some other thread invokes the notify method for this object and thread T happens to be arbitrarily chosen as the thread to be awakened(唤醒).<br>Some other thread invokes the notifyAll method for this object.<br>Some other thread interrupts thread T.<br>The specified amount of real time has elapsed, more or less. If timeout is zero, however, then real time is not taken into consideration and the thread simply waits until notified.<br>The thread T is then removed from the wait set for this object and re-enabled for thread scheduling. It then competes in the usual manner with other threads for the right to synchronize on the object; once it has gained control of the object, all its synchronization claims on the object are restored to the status quo ante - that is, to the situation as of the time that the wait method was invoked. Thread T then returns from the invocation of the wait method. Thus, on return from the wait method, the synchronization state of the object and of thread T is exactly as it was when the wait method was invoked.<br>A thread can also wake up without being notified, interrupted, or timing out, a so-called spurious wakeup. While this will rarely occur in practice, applications must guard against it by testing for the condition that should have caused the thread to be awakened, and continuing to wait if the condition is not satisfied. In other words, waits should always occur in loops, like this one:<br>           synchronized (obj) {<br>               while (<condition does not hold>)<br>                   obj.wait(timeout);<br>               … &#x2F;&#x2F; Perform action appropriate to condition<br>           }</p>
<p>(For more information on this topic, see Section 3.2.3 in Doug Lea’s “Concurrent Programming in Java (Second Edition)” (Addison-Wesley, 2000), or Item 50 in Joshua Bloch’s “Effective Java Programming Language Guide” (Addison-Wesley, 2001).<br>If the current thread is interrupted by any thread before or while it is waiting, then an InterruptedException is thrown. This exception is not thrown until the lock status of this object has been restored as described above.<br>Note that the wait method, as it places the current thread into the wait set for this object, unlocks only this object; any other objects on which the current thread may be synchronized remain locked while the thread waits.<br>This method should only be called by a thread that is the owner of this object’s monitor. See the notify method for a description of the ways in which a thread can become the owner of a monitor.</p>
<p>此方法会导致当前线程等待，直到其他线程调用object对象的notify或者notifyall方法，或者时间超时。<br>当前线程必须拥有obect对象的锁。<br>这个方法会导致当前线程将它自己放在一个object对象的等待集合当中，放弃对这个对象的同步声明，即放弃锁，这个线程无法进行线程调度，会进入休眠等待，直到下面的四件事情发生：</p>
<ul>
<li>其他线程调用了这个对象的notify方法，当前线程碰巧被选中成为被唤醒的线程。</li>
<li>其他的额线程调用了对象的notifyall方法</li>
<li>其他线程中断了当前线程。</li>
<li>指定的时间超时，不过呢，如果timeout的值是0，实际上时间是不会考虑的，会一直等待。</li>
</ul>
<p>如果发生以上四件事情，当前线程就会从当前对象的等待队列移除，然后又可以进行线程的调度，会按照通常的方式和其他的线程进行竞争，竞争这个对象的同步控制权， 一旦获取了对象的控制权，所有对这个对象的同步声明都会恢复，恢复到wait方法曾经被调用的时候的状态。线程就会从wait方法调用当中返回， 这个时候对象和线程的状态和被调用wait方法的时候的状态是一模一样的。<br> 一个线程被唤醒也可以不通过notify，中断，或者超时，即一个虚假的唤醒，虽然在实际当中很少出现，但是应用也要做一些规避措施来避免线程被不正当的唤醒，即，wait应该总是发生在循环当中，就像如下：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">synchronized (obj) &#123;</span><br><span class="line">    while (&lt;condition does not hold&gt;)</span><br><span class="line">        obj.wait(timeout);</span><br><span class="line">    ... // Perform action appropriate to condition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>(更多的信息参考Doug Lea’sjava并发编程第二章节，或者Joshua Bloch’s的高效java 语言指南的50章节)</p>
<p>如果当前线程在等待之前和等待过程之中被其他线程中断了，InterruptedException就会被抛出，异常会在对象的锁的状态已经恢复到之前描述的样子才会抛出，而不是立马抛出。</p>
<p>这个wait方法会把当前的线程放到对象的等待集合当中，只会解锁这个对象，这个线程等待的其他锁所在的对象不会受到影响。</p>
<p>这个方法应该被获取到对象锁的线程被调用，参考notify方法的介绍，了解对象怎么获取对象的锁。</p>
<h4 id="public-final-void-wait-long-timeout-int-nanos"><a href="#public-final-void-wait-long-timeout-int-nanos" class="headerlink" title="public final void wait(long timeout, int nanos)"></a>public final void wait(long timeout, int nanos)</h4><p>nanos的范围是 0-999999.<br>会调用【public final void wait(long timeout) throws InterruptedException】</p>
<h3 id="notify-方法"><a href="#notify-方法" class="headerlink" title="notify()方法"></a>notify()方法</h3><p>doc：<br>Wakes up a single thread that is waiting on this object’s monitor. If any threads are waiting on this object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the implementation. A thread waits on an object’s monitor by calling one of the wait methods.<br>The awakened thread will not be able to proceed until the current thread relinquishes the lock on this object. The awakened thread will compete in the usual manner with any other threads that might be actively competing to synchronize on this object; for example, the awakened thread enjoys no reliable privilege or disadvantage in being the next thread to lock this object.<br>This method should only be called by a thread that is the owner of this object’s monitor. A thread becomes the owner of the object’s monitor in one of three ways:<br>By executing a synchronized instance method of that object.<br>By executing the body of a synchronized statement that synchronizes on the object.<br>For objects of type Class, by executing a synchronized static method of that class.<br>Only one thread at a time can own an object’s monitor.</p>
<p>唤醒等待在对象锁上的一个线程。<br>如果有多个等在在对象锁上，选择一个被唤醒。选择的随意性和慎重行根据不同的实现而不同。一个线程会通过调用对象的wait去等待。<br>被唤醒的线程是无法被执行的，除非它获取了正在执行的线程放弃的对象锁。被唤醒的线程会按照通常的方式和其他的线程进行竞争， 竞争对这个对象的同步权（谁拿到了锁 ，谁就有控制权），比如一个没有权限的或者没有缺陷的线程都有可能成为获取锁的线程。</p>
<p>这个方法只能被获取了对象锁的线程所调用，一个线程获取锁的方式有如下三种方式：</p>
<ul>
<li>执行对象的synchronized的方法获取锁。</li>
<li>执行对象当中synchronized代码块获取锁。</li>
<li>对于class类型的对象，调用class的静态的synchronized方法获取锁。</li>
</ul>
<p>在某一时刻只有一个线程才持有对象的锁。</p>
<h3 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll"></a>notifyAll</h3><p>Wakes up all threads that are waiting on this object’s monitor. A thread waits on an object’s monitor by calling one of the wait methods.<br>The awakened threads will not be able to proceed until the current thread relinquishes the lock on this object. The awakened threads will compete in the usual manner with any other threads that might be actively competing to synchronize on this object; for example, the awakened threads enjoy no reliable privilege or disadvantage in being the next thread to lock this object.<br>This method should only be called by a thread that is the owner of this object’s monitor. See the notify method for a description of the ways in which a thread can become the owner of a monitor.</p>
<p>唤醒所有等待在对象锁的所有线程，每个线程都是一个等在对象的锁上，通过调用对象的wait方法。<br>被释放的线程不能被继续处理，知道当前的线程释放了锁才可以。被唤醒的线程就会一种通常的方式和其他线程进行锁的竞争，比如，一个没有权限没有缺陷的线程都有可能成为获取到锁的线程。<br>这个方法只能被持有锁的线程调用，请参见notify方法描述一个线程是怎么成为锁的持有者。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>但我们调用wait方法时，首先需要确保调用wait方法的线程已经持有了对象的锁。</li>
<li>当调用wait后，该线程就会释放掉这个对象的锁，然后进入等待状态（wait set）。</li>
<li>当线程调用了wait后进入等待状态时，他就可以等待其他线程调用相同对象的notify或notifyall方法使得自己被唤醒。</li>
<li>一旦这个线程被其他线程唤醒后，该线程就会与其他线程一同开始竞争这个对象的锁（公平锁），只有当该线程获取到了对象的锁后，线程才会继续执行。</li>
<li>调用wait方法的代码片段需要放在一个synchronized块或是synchronized方法中，，这样才可以确保线程在调用wait方法前已经获取了对象的锁。</li>
<li>当调用对象的notify方法时，它会随机唤醒该对象等待集合（wait set）中的任意一个线程，当某个线程被唤醒后，它就会与其他线程一同竞争对象的锁。</li>
<li>当调用对象的notifyall方法时，它会唤醒该对象等待集合（wait set）中的所有线程，这些线程被唤醒后，又会开始竞争对象的锁。</li>
<li>在某一时刻，只有唯一一个线程可以拥有对象的锁。</li>
</ul>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>编写一个多线程程序，实现这样一个目标：<br>1、存在一个对象，该对象有一个int类型的成员变量counter，该成员变量的初始值为0.<br>2、创建2个线程，其中一个线程对你该对象的成员变量counter增1，另一个线程对该对象的成员变量减一。<br>3、输出该对象成员变量counter每次变化后的值。<br>4、最终输出的结果应为：10101010101010.</p>
<h4 id="定义一个对象，管理锁的获取和释放，以及加减计数"><a href="#定义一个对象，管理锁的获取和释放，以及加减计数" class="headerlink" title="定义一个对象，管理锁的获取和释放，以及加减计数"></a>定义一个对象，管理锁的获取和释放，以及加减计数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyObject &#123;</span><br><span class="line"></span><br><span class="line">    private int counter;</span><br><span class="line"></span><br><span class="line">    public  synchronized  void increase()&#123;</span><br><span class="line">        if(0 != this.counter)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.counter++;</span><br><span class="line">        System.out.println(this.counter);</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized  void  decrease()&#123;</span><br><span class="line">        if(this.counter == 0)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.counter--;</span><br><span class="line">        System.out.println(this.counter);</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="加一计数器"><a href="#加一计数器" class="headerlink" title="加一计数器"></a>加一计数器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class IncreaseThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    private MyObject myObject;</span><br><span class="line"></span><br><span class="line">    public  IncreaseThread(MyObject myObject)&#123;</span><br><span class="line">        this.myObject = myObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for(int i=0;i&lt;30;i++)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep((long)Math.random() *1000 );</span><br><span class="line">                myObject.increase();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="减一计数器"><a href="#减一计数器" class="headerlink" title="减一计数器"></a>减一计数器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DecreaseThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    private MyObject myObject;</span><br><span class="line"></span><br><span class="line">    public DecreaseThread(MyObject myObject)&#123;</span><br><span class="line">        this.myObject  = myObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for(int i=0;i&lt;30;i++)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep((long)Math.random() *1000 );</span><br><span class="line">                myObject.decrease();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="启动方法"><a href="#启动方法" class="headerlink" title="启动方法"></a>启动方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyObject myObject = new MyObject();</span><br><span class="line"></span><br><span class="line">        IncreaseThread increaseThread = new IncreaseThread(myObject);</span><br><span class="line">        DecreaseThread decreaseThread = new DecreaseThread(myObject);</span><br><span class="line"></span><br><span class="line">        increaseThread.start();</span><br><span class="line">        decreaseThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：<br>1<br>0<br>1<br>0<br>1<br>略</p>
<h4 id="多线程生产和消费"><a href="#多线程生产和消费" class="headerlink" title="多线程生产和消费"></a>多线程生产和消费</h4><p>现在我们打算由多个加法线程和多个减法线程同时运行，那么结果会是怎样的呢？<br>修改main函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyObject myObject = new MyObject();</span><br><span class="line"></span><br><span class="line">        IncreaseThread increaseThread = new IncreaseThread(myObject);</span><br><span class="line">        DecreaseThread decreaseThread = new DecreaseThread(myObject);</span><br><span class="line"></span><br><span class="line">        increaseThread.start();</span><br><span class="line">        decreaseThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br>1<br>0<br>1<br>0<br>-1<br>-2<br>-3<br>-4<br>-5<br>-6<br>略<br>明显可以看到和之前的输出不一样，造成的这样的输出的原因是什么？<br>原因：<br>MyObject的increase和decrease，加入有2个减法线程都同时阻塞在decrease的wait方法上（wait会释放锁 ），这个时候有一个减法线程被加法线程唤醒，然后其中一个减法线程从wait方法返回，继续往下执行，使得counter变为0，然后同时执行了notify，但是被唤醒的是另一个减法线程，这个减法线程也从wait阻塞中返回，继续往下执行，这个时候counter是0又被减了一次变为-1，这就是出现负数的原因。<br>即，调wait之前counter是一个值，但是wait返回之后，这个值可能已经变了，我们不能用if去判断counter的值，而应该用while循环，修改MyObject的加法和减法方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public  synchronized  void increase()&#123;</span><br><span class="line">    while(0 != this.counter)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.counter++;</span><br><span class="line">    System.out.println(this.counter);</span><br><span class="line">    notify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public synchronized  void  decrease()&#123;</span><br><span class="line">    while (this.counter == 0)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.counter--;</span><br><span class="line">    System.out.println(this.counter);</span><br><span class="line">    notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br>1<br>0<br>1<br>0<br>1<br>0<br>略</p>
]]></content>
      <categories>
        <category>concurrency</category>
      </categories>
      <tags>
        <tag>Object 并发</tag>
      </tags>
  </entry>
  <entry>
    <title>concurrency(10)Future和CompletableFuture</title>
    <url>/2020/05/05/Concurrent/concurrency(10)Future%E5%92%8CCompletableFuture/</url>
    <content><![CDATA[<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><span id="more"></span>
<p>A Future represents the result of an asynchronous computation. Methods are provided to check if the computation is complete, to wait for its completion, and to retrieve the result of the computation. The result can only be retrieved using method get when the computation has completed, blocking if necessary until it is ready. Cancellation is performed by the cancel method. Additional methods are provided to determine if the task completed normally or was cancelled. Once a computation has completed, the computation cannot be cancelled. If you would like to use a Future for the sake of cancellability but not provide a usable result, you can declare types of the form Future&lt;?&gt; and return null as a result of the underlying task.<br>Sample Usage (Note that the following classes are all made-up.)</p>
<!-- more -->

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ArchiveSearcher</span> &#123; String <span class="title function_">search</span><span class="params">(String target)</span>; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line"> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> ...</span><br><span class="line"> <span class="type">ArchiveSearcher</span> <span class="variable">searcher</span> <span class="operator">=</span> ...</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">showSearch</span><span class="params">(<span class="keyword">final</span> String target)</span></span><br><span class="line">     <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">   Future&lt;String&gt; future</span><br><span class="line">     = executor.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">       <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> searcher.search(target);</span><br><span class="line">       &#125;&#125;);</span><br><span class="line">   displayOtherThings(); <span class="comment">// do other things while searching</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     displayText(future.get()); <span class="comment">// use future</span></span><br><span class="line">   &#125; <span class="keyword">catch</span> (ExecutionException ex) &#123; cleanup(); <span class="keyword">return</span>; &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The FutureTask class is an implementation of Future that implements Runnable, and so may be executed by an Executor. For example, the above construction with submit could be replaced by:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FutureTask&lt;String&gt; future = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> searcher.search(target);</span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>executor.execute(future);<br>Memory consistency effects: Actions taken by the asynchronous computation happen-before actions following the corresponding Future.get() in another thread.<br>代表一个异步计算的结果，提供的方法用来检查计算是否完成，等待计算完成，以及返回计算的结果，当计算完毕的时候只能通过get方法返回，如果没有计算完成那么get方法将会一直阻塞，cancel用来取消操作，此外提供了其他的方法用来检查是正常完成还是取消完成，如果一个 计算已经完成了，那么这个计算不能再进行取消操作，如果一个计算只是为了取消，而不想得到计算结果，你可以声明为Future&lt;?&gt;，那么底层执行任务就会返回一个null的计算结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取消</span></span><br><span class="line"> <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line"> <span class="comment">//是否被取消</span></span><br><span class="line"> <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line"> <span class="comment">//是否完成</span></span><br><span class="line"> <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line"> <span class="comment">//返回异步任务的计算结果，</span></span><br><span class="line"> <span class="comment">//Waits if necessary for the computation to complete, and then retrieves its result.</span></span><br><span class="line"> <span class="comment">//如果任务计算完成，直接返回结果，否则，get会阻塞等待计算完成，然后返回结果</span></span><br><span class="line"> V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line"> <span class="comment">//返回异步任务的执行结果，带超时参数，如果超时，那么抛出TimeoutException异常</span></span><br><span class="line"> V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span>  <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br></pre></td></tr></table></figure>

<h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><h4 id="正常的使用"><a href="#正常的使用" class="headerlink" title="正常的使用"></a>正常的使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Callable&lt;Integer&gt; callable =  () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;pre execute&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">randomNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">500</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;post execute&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> randomNumber;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">        System.out.println(<span class="string">&quot;thread has started&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(futureTask.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br>thread has started<br>pre execute<br>post execute<br>282</p>
<h4 id="get方法阻塞一段时间"><a href="#get方法阻塞一段时间" class="headerlink" title="get方法阻塞一段时间"></a>get方法阻塞一段时间</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Callable&lt;Integer&gt; callable =  () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;pre execute&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">randomNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">500</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;post execute&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> randomNumber;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">        System.out.println(<span class="string">&quot;thread has started&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(futureTask.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：<br>thread has started<br>pre execute<br>post execute<br>218<br>实际运行的时候会在get方法阻塞等待一段时间</p>
<h4 id="get等待超时"><a href="#get等待超时" class="headerlink" title="get等待超时"></a>get等待超时</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Callable&lt;Integer&gt; callable =  () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;pre execute&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">randomNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">500</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;post execute&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> randomNumber;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">        System.out.println(<span class="string">&quot;thread has started&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(futureTask.get(<span class="number">1</span>, TimeUnit.MILLISECONDS));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：<br>thread has started<br>pre execute<br>java.util.concurrent.TimeoutException<br>    at java.util.concurrent.FutureTask.get(FutureTask.java:205)<br>    at com.twodragonlake.concurrency7.MyTest1.main(MyTest1.java:21)<br>post execute</p>
<p>即超时会抛出异常</p>
<h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p>Future的不足就是get方法会阻塞。CompletableFuture解决了这个问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现了Future，所以具备Future的功能和特点，CompletionStage是说明：</span></span><br><span class="line"><span class="comment">//A stage of a possibly asynchronous computation, that performs an action or computes a value when another //////////CompletionStage completes.</span></span><br><span class="line"><span class="comment">// 异步计算的一个阶段，当一个阶段完成时，代表一个动作或者一个计算的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFuture</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Future</span>&lt;T&gt;, CompletionStage&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CompletableFuture doc：<br>A Future that may be explicitly completed (setting its value and status), and may be used as a CompletionStage, supporting dependent functions and actions that trigger upon its completion.<br>When two or more threads attempt to complete, completeExceptionally, or cancel a CompletableFuture, only one of them succeeds.<br>一个可以被显式设置为完成的Future, 除了是一个Future以外，可以被当做一个CompletionStage去使用，依赖函数和动作的完成触发。<br>当有2个或以上的线程去完成，完成异常，取消CompletableFuture的时候，只有一个会成功。</p>
<h4 id="实例1："><a href="#实例1：" class="headerlink" title="实例1："></a>实例1：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> CompletableFuture.supplyAsync(()-&gt;<span class="string">&quot;hello&quot;</span> )</span><br><span class="line">                .thenApplyAsync((x) -&gt; x + <span class="string">&quot;world&quot;</span>).join();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br>helloworld</p>
<h4 id="实例2："><a href="#实例2：" class="headerlink" title="实例2："></a>实例2：</h4><p>supplyAsync需要返回执行结果，runAsync不需要返回结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">        .thenAccept(value -&gt; System.out.println(<span class="string">&quot;welcome&quot;</span> + value));</span><br></pre></td></tr></table></figure>
<p>输出： welcomehello<br>thenAccept不返回结果，直接把结果处理掉</p>
<h4 id="实例3"><a href="#实例3" class="headerlink" title="实例3"></a>实例3</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">result2</span> <span class="operator">=</span> CompletableFuture.supplyAsync(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        &#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        &#125;),(s1,s2) -&gt; s1+<span class="string">&quot; &quot;</span>+s2).join();</span><br><span class="line">        System.out.println(result2);</span><br></pre></td></tr></table></figure>
<p>输出：<br>hello world</p>
<p>thenCombine是对两个 CompletableFuture.supplyAsync执行结果的合并，CompletableFuture.supplyAsync都是异步的，他们之间可以并行执行。</p>
<h4 id="实例4"><a href="#实例4" class="headerlink" title="实例4"></a>实例4</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;task finish&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">completableFuture.whenComplete((s1,s2) -&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行完成&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;主线程执行完毕&quot;</span>);</span><br><span class="line">TimeUnit.MILLISECONDS.sleep(<span class="number">7000</span>);</span><br></pre></td></tr></table></figure>
<p>输出：<br>主线程执行完<br>task finish<br>执行完成</p>
<p>completableFuture.whenComplete不会阻塞，会继续往下执行，这个解决了Future的get方法阻塞弊病。</p>
]]></content>
      <categories>
        <category>concurrency</category>
      </categories>
      <tags>
        <tag>Future CompletableFuture</tag>
      </tags>
  </entry>
  <entry>
    <title>concurrency(11)AQS-可重入锁</title>
    <url>/2020/05/10/Concurrent/concurrency(11)AQS-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/</url>
    <content><![CDATA[<h3 id="AQS-AbstractQueuedSynchronizer"><a href="#AQS-AbstractQueuedSynchronizer" class="headerlink" title="AQS(AbstractQueuedSynchronizer)"></a>AQS(AbstractQueuedSynchronizer)</h3><p>AQS和synchronized关键字C++的实现原理相似度是80%左右。</p>
<h4 id="AbstractQueuedSynchronizer主要成员"><a href="#AbstractQueuedSynchronizer主要成员" class="headerlink" title="AbstractQueuedSynchronizer主要成员"></a>AbstractQueuedSynchronizer主要成员</h4><p><img src="/aqs1.png" alt="aqs1.png"></p>
<ul>
<li>public class ConditionObject implements Condition, java.io.Serializable<br>一个AQS可以有多个Condition对象，也就意味着有多个等待队列</li>
<li>static final class Node<br>Node是对阻塞线程的封装，Node内部有一个Thread的引用。</li>
<li>private volatile int state; 同步状态,在不同的场景有不同的含义，精妙所在<span id="more"></span>
<h4 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h4></li>
</ul>
<ol>
<li>protected boolean tryAcquire(int arg)<br>Attempts to acquire in exclusive mode<br>排它锁的获取。</li>
<li>protected boolean tryRelease(int arg)<br>Attempts to set the state to reflect a release in exclusive mode.<br>排它锁的释放。</li>
<li>protected int tryAcquireShared(int arg)<br>Attempts to acquire in shared mode.<br>共享模式获取锁。</li>
<li>protected boolean tryReleaseShared(int arg)<br>Attempts to set the state to reflect a release in shared mode.<br>在共享模式下释放锁。</li>
<li>protected boolean isHeldExclusively()<br>排它锁的情况返回true，共享锁的情况返回false。</li>
</ol>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>当前线程获取到了锁还可以再次获取锁。</p>
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest1 &#123;</span><br><span class="line">    private Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public void menthod()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyTest1 myTest1 = new MyTest1();</span><br><span class="line">        IntStream.range(0,10).forEach(x -&gt;&#123;</span><br><span class="line">            new Thread(() -&gt;&#123;</span><br><span class="line">                myTest1.menthod();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="锁的主要实现是内部的Syn："><a href="#锁的主要实现是内部的Syn：" class="headerlink" title="锁的主要实现是内部的Syn："></a>锁的主要实现是内部的Syn：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">  private static final long serialVersionUID = -5179523762034025860L;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Performs &#123;@link Lock#lock&#125;. The main reason for subclassing</span><br><span class="line">   * is to allow fast path for nonfair version.</span><br><span class="line">   */</span><br><span class="line">  abstract void lock();</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Performs non-fair tryLock.  tryAcquire is implemented in</span><br><span class="line">   * subclasses, but both need nonfair try for trylock method.</span><br><span class="line">   */</span><br><span class="line">  final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">      final Thread current = Thread.currentThread();</span><br><span class="line">      int c = getState();</span><br><span class="line">      if (c == 0) &#123;</span><br><span class="line">          if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">              setExclusiveOwnerThread(current);</span><br><span class="line">              return true;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">          int nextc = c + acquires;</span><br><span class="line">          if (nextc &lt; 0) // overflow</span><br><span class="line">              throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">          setState(nextc);</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">      int c = getState() - releases;</span><br><span class="line">      if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">          throw new IllegalMonitorStateException();</span><br><span class="line">      boolean free = false;</span><br><span class="line">      if (c == 0) &#123;</span><br><span class="line">          free = true;</span><br><span class="line">          setExclusiveOwnerThread(null);</span><br><span class="line">      &#125;</span><br><span class="line">      setState(c);</span><br><span class="line">      return free;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected final boolean isHeldExclusively() &#123;</span><br><span class="line">      // While we must in general read state before owner,</span><br><span class="line">      // we don&#x27;t need to do so to check if current thread is owner</span><br><span class="line">      return getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  final ConditionObject newCondition() &#123;</span><br><span class="line">      return new ConditionObject();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Methods relayed from outer class</span><br><span class="line"></span><br><span class="line">  final Thread getOwner() &#123;</span><br><span class="line">      return getState() == 0 ? null : getExclusiveOwnerThread();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  final int getHoldCount() &#123;</span><br><span class="line">      return isHeldExclusively() ? getState() : 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  final boolean isLocked() &#123;</span><br><span class="line">      return getState() != 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Reconstitutes the instance from a stream (that is, deserializes it).</span><br><span class="line">   */</span><br><span class="line">  private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">      throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">      s.defaultReadObject();</span><br><span class="line">      setState(0); // reset to unlocked state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReentrantLock.Sync为什么没有 <strong>tryAcquire</strong> 和 <strong>tryRelease</strong> 呢，因为ReentrantLock支持公平锁和非公平锁的实现，在重载的构造方法上就能看出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync = new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Creates an instance of &#123;@code ReentrantLock&#125; with the</span><br><span class="line"> * given fairness policy.</span><br><span class="line"> *</span><br><span class="line"> * @param fair &#123;@code true&#125; if this lock should use a fair ordering policy</span><br><span class="line"> */</span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果是公平的那么就老老实实的等待队列前边的线程执行完毕，如果是非公平的就需要插队。</p>
<h4 id="公平锁的实现-ReentrantLock-FairSync"><a href="#公平锁的实现-ReentrantLock-FairSync" class="headerlink" title="公平锁的实现,ReentrantLock.FairSync:"></a>公平锁的实现,ReentrantLock.FairSync:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">    private static final long serialVersionUID = -3000897897090466540L;</span><br><span class="line"></span><br><span class="line">    final void lock() &#123;</span><br><span class="line">        acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Fair version of tryAcquire.  Don&#x27;t grant access unless</span><br><span class="line">     * recursive call or no waiters or is first.</span><br><span class="line">     */</span><br><span class="line">    protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        final Thread current = Thread.currentThread();</span><br><span class="line">        int c = getState();//持有锁的线程个数</span><br><span class="line">        if (c == 0) &#123;//没有线程获取到锁</span><br><span class="line">          //判断当前线程在队列里边，它前边是否有线程正在执行，排队，保证锁的获取是公平的</span><br><span class="line">            if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            int nextc = c + acquires;</span><br><span class="line">            if (nextc &lt; 0)</span><br><span class="line">                throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReentrantLock.FairSync继承了ReentrantLock.Sync.</p>
<h4 id="非公平锁的实现ReentrantLock-NonfairSync"><a href="#非公平锁的实现ReentrantLock-NonfairSync" class="headerlink" title="非公平锁的实现ReentrantLock.NonfairSync:"></a>非公平锁的实现ReentrantLock.NonfairSync:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">    private static final long serialVersionUID = 7316153563782823691L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Performs lock.  Try immediate barge, backing up to normal</span><br><span class="line">     * acquire on failure.</span><br><span class="line">     */</span><br><span class="line">    final void lock() &#123;</span><br><span class="line">      //不排队直接CAS替换操作。</span><br><span class="line">        if (compareAndSetState(0, 1))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        else</span><br><span class="line">            acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">      //调用父类的nonfairTryAcquire获取。</span><br><span class="line">        return nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReentrantLock.NonfairSync同样实现了ReentrantLock.Sync。</p>
<h4 id="ReentrantLock-lock调用流程"><a href="#ReentrantLock-lock调用流程" class="headerlink" title="ReentrantLock.lock调用流程"></a>ReentrantLock.lock调用流程</h4><p>ReentrantLock.lock:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void lock() &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sync分为NonfairSync和FairSync的实现。<br>Sync:<br>  FairSync<br>  NonfairSync</p>
<h5 id="FairSync的lock实现"><a href="#FairSync的lock实现" class="headerlink" title="FairSync的lock实现:"></a>FairSync的lock实现:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>acquire(1)调用的是AQS的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Acquires in exclusive mode, ignoring interrupts.  排他模式获取锁</span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) 如果获取不到锁，那么就放到等待队列等待</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tryAcquire的实现类是FairSync，进入到公平锁的获取实现逻辑:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();//持有锁的线程个数</span><br><span class="line">    if (c == 0) &#123;//没有线程获取到锁</span><br><span class="line">        if (!hasQueuedPredecessors() &amp;&amp; //判断当前线程在队列里边，它前边是否有线程正在执行，排队，保证锁的获取是公平的</span><br><span class="line">            compareAndSetState(0, acquires)) &#123;//CAS成功，把0改成1成功，意味着获取锁成功</span><br><span class="line">            setExclusiveOwnerThread(current);//设置排它锁，表示当前线程正在执行</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //当前线程是否是排他线程的拥有者</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">      //加和，比如由1变成2</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        //重新CAS设置</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hasQueuedPredecessors判断当前线程在队列里边，它前边是否有线程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">    // The correctness of this depends on head being initialized</span><br><span class="line">    // before tail and on head.next being accurate if the current</span><br><span class="line">    // thread is first in queue.</span><br><span class="line">    Node t = tail; // Read fields in reverse initialization order</span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    return h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == null || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="NonfairSync的lock实现"><a href="#NonfairSync的lock实现" class="headerlink" title="NonfairSync的lock实现:"></a>NonfairSync的lock实现:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    //不排队直接CAS替换操作。CAS替换</span><br><span class="line">    if (compareAndSetState(0, 1))</span><br><span class="line">    //设置排他</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    else</span><br><span class="line">        acquire(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">  //调用父类的nonfairTryAcquire获取。</span><br><span class="line">    return nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Syn的nonfairTryAcquire：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    if (c == 0) &#123;//没有线程持有锁</span><br><span class="line">      //非公平锁的获取，直接CAS替换，不会判断等待队列有没有线程。</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0) // overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Node的状态值"><a href="#Node的状态值" class="headerlink" title="Node的状态值"></a>Node的状态值</h4><p>Node里边有几个成员变量是Node的状态值:<br>static final Node SHARED &#x3D; new Node(); &#x2F;&#x2F;共享锁<br>static final Node EXCLUSIVE &#x3D; null;&#x2F;&#x2F;排它锁<br>static final int CANCELLED &#x3D;  1;&#x2F;&#x2F;被取消掉<br>static final int SIGNAL    &#x3D; -1;&#x2F;&#x2F;<br>static final int CONDITION &#x3D; -2;<br>static final int PROPAGATE &#x3D; -3;&#x2F;&#x2F;</p>
<h4 id="阻塞线程唤醒"><a href="#阻塞线程唤醒" class="headerlink" title="阻塞线程唤醒"></a>阻塞线程唤醒</h4><p>ReentrantLock.unlock触发锁的释放，看一下unlock的实现：<br>public void unlock() {<br>    sync.release(1);<br>}<br>sync分为NonfairSync和FairSync的实现。<br>Sync:<br>  FairSync<br>  NonfairSync</p>
<p>sync调用了AQS的release：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Releases in exclusive mode.  排他模式释放锁</span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">  //释放成功(没有任何线程持有锁)</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        //等待队列的头结点</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">        //唤醒当前线程后边的线程</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>unparkSuccessor的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Wakes up node&#x27;s successor, if one exists.</span><br><span class="line">//如果当前线程的后继存在，那么唤醒后继线程</span><br><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    /*</span><br><span class="line">     * If status is negative (i.e., possibly needing signal) try</span><br><span class="line">     * to clear in anticipation of signalling.  It is OK if this</span><br><span class="line">     * fails or if status is changed by waiting thread.</span><br><span class="line">     */</span><br><span class="line">    int ws = node.waitStatus;</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Thread to unpark is held in successor, which is normally</span><br><span class="line">     * just the next node.  But if cancelled or apparently null,</span><br><span class="line">     * traverse backwards from tail to find the actual</span><br><span class="line">     * non-cancelled successor.</span><br><span class="line">     */</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s = null;</span><br><span class="line">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            if (t.waitStatus &lt;= 0)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    if (s != null)</span><br><span class="line">        //执行唤醒</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LockSupport.unpark实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//os.linux.vm.oslinux.cpp=&gt;parker.unpark</span><br><span class="line">public static void unpark(Thread thread) &#123;</span><br><span class="line">    if (thread != null)</span><br><span class="line">        UNSAFE.unpark(thread);//negative方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tryRelease会使用 FairSync父类Syn的重写的tryRelease方法</p>
<h5 id="FairSync的unlock实现"><a href="#FairSync的unlock实现" class="headerlink" title="FairSync的unlock实现:"></a>FairSync的unlock实现:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    int c = getState() - releases;//状态减一，比如由2变成1</span><br><span class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())//A线程获取到了锁，必须是由A释放锁</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    boolean free = false;</span><br><span class="line">    if (c == 0) &#123;//当前没有线程持有锁</span><br><span class="line">        free = true;//锁是自由的状态</span><br><span class="line">        setExclusiveOwnerThread(null);//排它锁持有者设置为空</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);//CAS设置state</span><br><span class="line">    return free;//为false，是重入状态，true是自由状态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ReentrantLock的执行逻辑"><a href="#ReentrantLock的执行逻辑" class="headerlink" title="ReentrantLock的执行逻辑"></a>ReentrantLock的执行逻辑</h4><ol>
<li>尝试获取对象的锁，，如果获取不到（意味着已经有其他线程持有了锁，并且尚未释放锁），那么它就会进入到AQS的阻塞队列当中。</li>
<li>如果获取到，那么根据锁是不公平锁还是非公平锁进行不同的处理<br>  2.1 如果是公平的，那么线程会直接放置到AQS阻塞队列的末尾<br>  2.2 如果是非公平锁，那么线程会首先尝试进行CAS计算，如果成功，则直接获取到锁。<br> 如果失败，则与公平锁的处理方式一致，被放到阻塞队列末尾。</li>
<li>当锁释放时（调用了unlock方法），那么底层会调用release方法对state成员变量值进行减一操作，如果减一后，state值不为0，那么release操作就执行完毕；如果减一操作后，state值为0，则调用LockSupport的unpark方法唤醒该线程后的等待队列中的第一个后继线程(pthread mutex_unlock)，将其唤醒，使之能够获取到对象的锁(release时，对于公平锁与非公平锁的处理逻辑是一致的)；之所以调用release方法后state值可能不为0，原因在于ReentrantLock是可重入锁，表示线程可以多次调用lock方法，导致每调用一次，state值都会加一。</li>
</ol>
<p>在于ReentrantLock来说，所谓的上锁，本质上就是对AQS中的state成员变量的操作，对该成员变量+1，表示上锁，对该成员变量-1，表示释放锁。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>concurrency</category>
      </categories>
      <tags>
        <tag>AQS 可重入锁</tag>
      </tags>
  </entry>
  <entry>
    <title>concurrency(12)可重入读写锁对于AQS的实现分析</title>
    <url>/2020/05/10/Concurrent/concurrency(12)%E5%8F%AF%E9%87%8D%E5%85%A5%E8%AF%BB%E5%86%99%E9%94%81%E5%AF%B9%E4%BA%8EAQS%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>实例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest2 &#123;</span><br><span class="line">    private ReadWriteLock lock = new ReentrantReadWriteLock();</span><br><span class="line">    public void method()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            lock.readLock().lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;method&quot;);</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyTest2 myTest2 = new MyTest2();</span><br><span class="line">        IntStream.range(0,10).forEach(i -&gt; new Thread(myTest2::method).start());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>输出：<br>method<br>method<br>method<br>method<br>method<br>method<br>method<br>method<br>method<br>method</p>
<p>如果将  lock.readLock().lock();换成 lock.writeLock().lock();再去运行，就会看出读锁和写锁的区别,<br>readLock打印输出结果的速度很快，因为读锁不需要阻塞是共享的，writeLock打印结果的结果很慢，有输出的时间顺序，因为写锁是互斥的，需要挨个执行。</p>
<h4 id="ReentrantReadWriteLock分析"><a href="#ReentrantReadWriteLock分析" class="headerlink" title="ReentrantReadWriteLock分析"></a>ReentrantReadWriteLock分析</h4><p>ReentrantReadWriteLock岁state的使用是划分了2部分去使用，state的高16位表示的是读锁，低1位表示的是写锁。<br>ReentrantReadWriteLock的构造器:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ReentrantReadWriteLock() &#123;</span><br><span class="line">        this(false);</span><br><span class="line">&#125;</span><br><span class="line">public ReentrantReadWriteLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">    readerLock = new ReadLock(this);</span><br><span class="line">    writerLock = new WriteLock(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReentrantReadWriteLock默认使用的还是公平锁。</p>
<h5 id="ReadLock的lock"><a href="#ReadLock的lock" class="headerlink" title="ReadLock的lock"></a>ReadLock的lock</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void lock() &#123;</span><br><span class="line">    sync.acquireShared(1);//共享锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>acquireShared调用的是AQS的acquireShared实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Acquires in shared mode, ignoring interrupts.  共享模式下去获取</span><br><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tryAcquireShared的实现是子类(Sync)的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final int tryAcquireShared(int unused) &#123;</span><br><span class="line">    /*</span><br><span class="line">     * Walkthrough:</span><br><span class="line">     * 1. If write lock held by another thread, fail.//写锁存在，直接失败</span><br><span class="line">     * 2. Otherwise, this thread is eligible for</span><br><span class="line">     *    lock wrt state, so ask if it should block</span><br><span class="line">     *    because of queue policy. If not, try</span><br><span class="line">     *    to grant by CASing state and updating count.</span><br><span class="line">     *    Note that step does not check for reentrant</span><br><span class="line">     *    acquires, which is postponed to full version</span><br><span class="line">     *    to avoid having to check hold count in</span><br><span class="line">     *    the more typical non-reentrant case.</span><br><span class="line">     *    </span><br><span class="line">     * 3. If step 2 fails either because thread</span><br><span class="line">     *    apparently not eligible or CAS fails or count</span><br><span class="line">     *    saturated, chain to version with full retry loop.</span><br><span class="line">     */</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    //映射第一步：1. If write lock held by another thread, fail.</span><br><span class="line">    if (exclusiveCount(c) != 0 &amp;&amp;//返回低16位记录的数量，写锁的数量不等于0</span><br><span class="line">        getExclusiveOwnerThread() != current) // 排它锁的持有者不是当前线程，直接失败</span><br><span class="line">        return -1;</span><br><span class="line">    int r = sharedCount(c);//程序走到这，意味着没有写锁，读取高16位</span><br><span class="line">    if (!readerShouldBlock() &amp;&amp; // 判断阻塞队列前边是否有线程，公平锁和非公平锁的实现会不一样</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp; //不管是读锁还是写锁，锁的数量是有限制的。</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;//CAS操作，增加数量</span><br><span class="line">        if (r == 0) &#123;//之前没有读锁</span><br><span class="line">            firstReader = current;//当前线程是第一个获取读锁的线程</span><br><span class="line">            firstReaderHoldCount = 1;//读锁的数量</span><br><span class="line">        &#125; else if (firstReader == current) &#123; //当前线程就是firstReader</span><br><span class="line">            firstReaderHoldCount++; //持有数量+1</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            if (rh == null || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            else if (rh.count == 0)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    //CAS的补救措施的一些操作</span><br><span class="line">    return fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="WriteLock的lock"><a href="#WriteLock的lock" class="headerlink" title="WriteLock的lock"></a>WriteLock的lock</h5><p>WriteLock的lock的lock实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void lock() &#123;</span><br><span class="line">      sync.acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AQS的实现:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Acquires in exclusive mode, ignoring interrupts.   排他模式下使用</span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tryAcquire在子类ReentrantReadWriteLock.Sync实现的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    /*</span><br><span class="line">     * Walkthrough:</span><br><span class="line">     * 1. If read count nonzero or write count nonzero</span><br><span class="line">     *    and owner is a different thread, fail.</span><br><span class="line">     * 读的线程数量非0，写的线程数量非0，直接失败，因为写锁是互斥的</span><br><span class="line">     * 2. If count would saturate, fail. (This can only</span><br><span class="line">     *    happen if count is already nonzero.)</span><br><span class="line">     * 3. Otherwise, this thread is eligible for lock if</span><br><span class="line">     *    it is either a reentrant acquire or</span><br><span class="line">     *    queue policy allows it. If so, update state</span><br><span class="line">     *    and set owner.</span><br><span class="line">     */</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    int w = exclusiveCount(c);//写锁的数量</span><br><span class="line">    if (c != 0) &#123;//排它锁被线程持有</span><br><span class="line">        // (Note: if c != 0 and w == 0 then shared count != 0)</span><br><span class="line">        if (w == 0 || current != getExclusiveOwnerThread())//持有线程是其他线程，不是自己</span><br><span class="line">            return false; //直接返回false</span><br><span class="line">        if (w + exclusiveCount(acquires) &gt; MAX_COUNT) //写锁数量超过锁的数量最大值</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;); //直接异常</span><br><span class="line">        // Reentrant acquire</span><br><span class="line">        setState(c + acquires); // 可重入的获取（已经有线程持有锁，并且持有锁的线程就是自己，那么就是重入性的获取锁）</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //</span><br><span class="line">    if (writerShouldBlock() || // 是否需要阻塞(排队)，公平锁和非公平锁的实现是不一样的</span><br><span class="line">        !compareAndSetState(c, c + acquires))//CAS失败，意味着存在一个竞争的获取写锁的线程</span><br><span class="line">        return false;</span><br><span class="line">    setExclusiveOwnerThread(current);//获取排它锁成功，设置锁的持有者是当前线程</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ReentrantReadWriteLock的lock操作逻辑"><a href="#ReentrantReadWriteLock的lock操作逻辑" class="headerlink" title="ReentrantReadWriteLock的lock操作逻辑"></a>ReentrantReadWriteLock的lock操作逻辑</h5><p>读锁：</p>
<ol>
<li>在获取读锁时，会尝试判断当前对象是否拥有了写锁，如果已经拥有，则直接失败。</li>
<li>如果没有写锁，，就表示当前对象没有排它锁，则当前线程会尝试给对象加锁。</li>
<li>如果当前线程已经持有了该对象的锁，那么直接将读锁数量+1.</li>
</ol>
<p>写锁：</p>
<ol>
<li>在获取写锁时，会尝试判断当前对象是否拥有了锁（读锁和写锁），如果已经拥有并且持有的线程并非当前线程，直接失败。</li>
<li>如果当前对象没有被加锁，，那么写锁就会为了当前对象上锁，并且将写锁的个数+1.</li>
<li>将当前对象的排它锁线程持有者设为自己。</li>
</ol>
<h5 id="ReadLock的unlock"><a href="#ReadLock的unlock" class="headerlink" title="ReadLock的unlock"></a>ReadLock的unlock</h5><p>ReentrantReadWriteLock读锁的unlock：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Attempts to release this lock. 尝试释放锁</span><br><span class="line">//If the number of readers is now zero then the lock is made available for write lock attempts</span><br><span class="line">// 读锁的数量是0，那么写锁操作可以尝试去获取锁</span><br><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>releaseShared的实现在AQS里边</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Releases in shared mode.   共享模式下释放锁</span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    //读锁和写锁都被释放掉</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tryReleaseShared的实现在ReentrantReadWriteLock的Sync实现的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final boolean tryReleaseShared(int unused) &#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    if (firstReader == current) &#123;// 当前线程是第一个获取读锁的线程</span><br><span class="line">        // assert firstReaderHoldCount &gt; 0;</span><br><span class="line">        if (firstReaderHoldCount == 1)//firstReaderHoldCount是第一个获取读锁线程重入的次数</span><br><span class="line">            firstReader = null;//只有一个读线程(自己本身)，firstReader置空</span><br><span class="line">        else</span><br><span class="line">            firstReaderHoldCount--;//重入的情况，减一</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      //非第一个读取者</span><br><span class="line">        HoldCounter rh = cachedHoldCounter;//一个HoldCounter代表一个读线程的实例，记录了读线程持有锁的数量</span><br><span class="line">        if (rh == null || rh.tid != getThreadId(current))//如果当前线程不是最后一个获取读锁的线程</span><br><span class="line">            rh = readHolds.get();//从ThreadLocal里边获取当前线程持有锁的数量计数器</span><br><span class="line">        int count = rh.count;//得到当前线程持有锁的数量</span><br><span class="line">        if (count &lt;= 1) &#123;</span><br><span class="line">            readHolds.remove();//从ThreadLocal里边删除</span><br><span class="line">            if (count &lt;= 0)//二次判断</span><br><span class="line">                throw unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count;//当前线程持有锁的数量减一</span><br><span class="line">    &#125;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = getState();</span><br><span class="line">        int nextc = c - SHARED_UNIT;</span><br><span class="line">        if (compareAndSetState(c, nextc))//CAS替换</span><br><span class="line">            // Releasing the read lock has no effect on readers,</span><br><span class="line">            // but it may allow waiting writers to proceed if</span><br><span class="line">            // both read and write locks are now free.</span><br><span class="line">            //对于读锁时无关紧要的</span><br><span class="line">            //状态为0的时候，让写和读有一个条件获取到写锁或者读锁，这里状态为0，会存在读锁和写锁的一块竞争</span><br><span class="line">            return nextc == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果读锁和写锁都被释放掉，那么就会进入到AQS的doReleaseShared：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Release action for shared mode 共享模式下释放锁的操作</span><br><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    /*</span><br><span class="line">     * Ensure that a release propagates, even if there are other</span><br><span class="line">     * in-progress acquires/releases.  This proceeds in the usual</span><br><span class="line">     * way of trying to unparkSuccessor of head if it needs</span><br><span class="line">     * signal. But if it does not, status is set to PROPAGATE to</span><br><span class="line">     * ensure that upon release, propagation continues.</span><br><span class="line">     * Additionally, we must loop in case a new node is added</span><br><span class="line">     * while we are doing this. Also, unlike other uses of</span><br><span class="line">     * unparkSuccessor, we need to know if CAS to reset status</span><br><span class="line">     * fails, if so rechecking.</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h != tail) &#123;//队列里边是有元素的</span><br><span class="line">            int ws = h.waitStatus;//等待状态</span><br><span class="line">            if (ws == Node.SIGNAL) &#123;//线程正在等待得到通知</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            // loop to recheck cases</span><br><span class="line">                unparkSuccessor(h);//唤醒当前节点的下一个节点的线程</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws == 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                // loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        if (h == head)                   // loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//Wakes up node&#x27;s successor, if one exists.</span><br><span class="line">//如果节点存在，那么将其唤醒</span><br><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    /*</span><br><span class="line">     * If status is negative (i.e., possibly needing signal) try</span><br><span class="line">     * to clear in anticipation of signalling.  It is OK if this</span><br><span class="line">     * fails or if status is changed by waiting thread.</span><br><span class="line">     */</span><br><span class="line">    int ws = node.waitStatus;</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Thread to unpark is held in successor, which is normally</span><br><span class="line">     * just the next node.  But if cancelled or apparently null,</span><br><span class="line">     * traverse backwards from tail to find the actual</span><br><span class="line">     * non-cancelled successor.</span><br><span class="line">     */</span><br><span class="line">     //当前节点的后继节点</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s = null;</span><br><span class="line">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            if (t.waitStatus &lt;= 0)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    if (s != null)</span><br><span class="line">        //唤醒线程</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h3><p>LockSupport封装了线程的一些等待或者唤醒的操作，中间会调用 <strong>sun.misc.Unsafe</strong> 的native代码是实现，上一节的锁的释放，唤醒后继节点的动作就是使用了LockSupport.本次我们看一下方法，本次我们看一下unpark的openjdk的底层C++实现。<br>具体实现代码：<span class="exturl" data-url="aHR0cDovL2hnLm9wZW5qZGsuamF2YS5uZXQvamRrOHUvamRrOHUvaG90c3BvdC9maWxlLzZmMzNlNDUwOTk5Yy9zcmMvb3MvbGludXgvdm0vb3NfbGludXguY3Bw">http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/6f33e450999c/src/os/linux/vm/os_linux.cpp<i class="fa fa-external-link-alt"></i></span><br>park方法会调用pthread_mutex_trylock，这个是内核实现。<br>因此不管是synchronized关键字还是AQS都是需要切换到内核态。</p>
<h5 id="WriteLock的unlock"><a href="#WriteLock的unlock" class="headerlink" title="WriteLock的unlock"></a>WriteLock的unlock</h5><p>实现:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Attempts to release this lock.</span><br><span class="line">//尝试释放锁</span><br><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sync.release(1)的实现在AQS里边：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Releases in exclusive mode.</span><br><span class="line">// 在排他模式下释放锁</span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;//释放锁成功</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            unparkSuccessor(h);//唤醒后继节点</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tryRelease的实现在ReentrantReadWriteLock里边:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">  //当前排它锁持有者的线程是不是当前线程，不是直接异常</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    int nextc = getState() - releases;//释放锁，状态减一</span><br><span class="line">    boolean free = exclusiveCount(nextc) == 0;//exclusiveCount得到排它锁的数量，如果等于，意味着没有任何线程持有排它锁</span><br><span class="line">    if (free)</span><br><span class="line">        setExclusiveOwnerThread(null);//将持有排他锁的线程清空</span><br><span class="line">    setState(nextc);//保存状态</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final boolean isHeldExclusively() &#123;</span><br><span class="line">    // While we must in general read state before owner,</span><br><span class="line">    // we don&#x27;t need to do so to check if current thread is owner</span><br><span class="line">    return getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AQS的锁获取直观图"><a href="#AQS的锁获取直观图" class="headerlink" title="AQS的锁获取直观图"></a>AQS的锁获取直观图</h3><p><img src="/aqs1.png" alt="aqs1.png"><br>上面的知识点介绍的是阻塞队列的部分，接下来是条件队列的介绍。</p>
<h4 id="条件队列"><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h4><p>ReentrantReadWriteLock里边的读锁和写锁的条件队列都是使用的Condition来实现的。<br><img src="/condition.png" alt="condition.png"></p>
<h3 id="AQS设计哲学解析及synchronized思想变迁"><a href="#AQS设计哲学解析及synchronized思想变迁" class="headerlink" title="AQS设计哲学解析及synchronized思想变迁"></a>AQS设计哲学解析及synchronized思想变迁</h3><h4 id="Conditiond-await-实现："><a href="#Conditiond-await-实现：" class="headerlink" title="Conditiond.await()实现："></a>Conditiond.await()实现：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Implements interruptible condition wait.</span><br><span class="line"> * &lt;ol&gt;</span><br><span class="line"> * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span><br><span class="line"> * &lt;li&gt; Save lock state returned by &#123;@link #getState&#125;.</span><br><span class="line"> * &lt;li&gt; Invoke &#123;@link #release&#125; with saved state as argument,</span><br><span class="line"> *      throwing IllegalMonitorStateException if it fails.</span><br><span class="line"> * &lt;li&gt; Block until signalled or interrupted.</span><br><span class="line"> * &lt;li&gt; Reacquire by invoking specialized version of</span><br><span class="line"> *      &#123;@link #acquire&#125; with saved state as argument.</span><br><span class="line"> * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span><br><span class="line"> * &lt;/ol&gt;</span><br><span class="line"> */</span><br><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    int savedState = fullyRelease(node);</span><br><span class="line">    int interruptMode = 0;</span><br><span class="line">    //中断的一些判断</span><br><span class="line">    while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    if (node.nextWaiter != null) // clean up if cancelled</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    if (interruptMode != 0)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br><span class="line">//构造一个等待节点加入到等待队列</span><br><span class="line">private Node addConditionWaiter() &#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    // If lastWaiter is cancelled, clean out.</span><br><span class="line">    if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    //包装了一个线程</span><br><span class="line">    Node node = new Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    if (t == null)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    else</span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/condition1.png" alt="condition1.png"><br>当我们newCondition()的时候就会在AQS上创建一个等待队列，当一个线程调用condation.await()的时候就会在等待队列里边创建一个Node节点。</p>
<h4 id="signal方法的实现"><a href="#signal方法的实现" class="headerlink" title="signal方法的实现"></a>signal方法的实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Moves the longest-waiting thread, if one exists, from the</span><br><span class="line"> * wait queue for this condition to the wait queue for the</span><br><span class="line"> * owning lock.</span><br><span class="line"> *</span><br><span class="line"> * @throws IllegalMonitorStateException if &#123;@link #isHeldExclusively&#125;</span><br><span class="line"> *         returns &#123;@code false&#125;</span><br><span class="line"> */</span><br><span class="line"> 将等待时间最长的线程移出去，放到阻塞队列</span><br><span class="line">public final void signal() &#123;</span><br><span class="line">  //是不是排它锁</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    //获取到阻塞队列的第一个等待者，如果不是空的，证明这个阻塞队列头部有一个node</span><br><span class="line">    if (first != null)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Removes and transfers nodes until hit non-cancelled one or</span><br><span class="line"> * null. Split out from signal in part to encourage compilers</span><br><span class="line"> * to inline the case of no waiters.</span><br><span class="line"> * @param first (non-null) the first node on condition queue</span><br><span class="line"> */</span><br><span class="line">private void doSignal(Node first) &#123;</span><br><span class="line">  //</span><br><span class="line">    do &#123;</span><br><span class="line">        if ( (firstWaiter = first.nextWaiter) == null)</span><br><span class="line">            lastWaiter = null;</span><br><span class="line">        first.nextWaiter = null;</span><br><span class="line">    &#125; while (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Transfers a node from a condition queue onto sync queue.</span><br><span class="line"> * Returns true if successful.</span><br><span class="line"> * @param node the node</span><br><span class="line"> * @return true if successfully transferred (else the node was</span><br><span class="line"> * cancelled before signal)</span><br><span class="line"> */</span><br><span class="line"> 将一个node从等待队列当中移动到阻塞队列当中</span><br><span class="line">final boolean transferForSignal(Node node) &#123;</span><br><span class="line">    /*</span><br><span class="line">     * If cannot change waitStatus, the node has been cancelled.</span><br><span class="line">     */</span><br><span class="line">    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Splice onto queue and try to set waitStatus of predecessor to</span><br><span class="line">     * indicate that thread is (probably) waiting. If cancelled or</span><br><span class="line">     * attempt to set waitStatus fails, wake up to resync (in which</span><br><span class="line">     * case the waitStatus can be transiently and harmlessly wrong).</span><br><span class="line">     */</span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    int ws = p.waitStatus;</span><br><span class="line">    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">// 具体的节点的处理</span><br><span class="line">/**</span><br><span class="line"> * Inserts node into queue, initializing if necessary. See picture above.</span><br><span class="line"> * @param node the node to insert</span><br><span class="line"> * @return node&#x27;s predecessor</span><br><span class="line"> */</span><br><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        if (t == null) &#123; // Must initialize</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>await就是在等待队列中创建一个节点，signal就是将等待队列里边的节点移动到阻塞队列。<br><img src="/condition2.png" alt="condition2.png"></p>
<h4 id="AQS和synchronized关键字之间的关系"><a href="#AQS和synchronized关键字之间的关系" class="headerlink" title="AQS和synchronized关键字之间的关系"></a>AQS和synchronized关键字之间的关系</h4><p>synchronized：</p>
<ol>
<li>synchronized关键字在底层的c++实现中，存在2个重要的数据结构(集合)，WaitSet、EntryList。</li>
<li>WaitSet中存放的是调用了Object的wait方法的线程对象（被封装成了c++的Node对象）</li>
<li>EntryList中存在是陷入阻塞状态、需要获取monitor的那些线程对象。</li>
<li>进入到EntryList后，该线程依然需要与其他线程争抢Monitor对象。</li>
<li>如果争抢到，就表示该线程获取到了对象的锁，它就可以排他方式执行对应的同步代码。</li>
</ol>
<p>AQS</p>
<ol>
<li>AQS中存在两种队列，分别是Condition对象的条件队列，以及AQS本身的阻塞队列</li>
<li>这两个队列中的每一个对象都是Node实例(里面封装了线程对象)</li>
<li>当位于Condition条件队列中的线程被其他线程signal后，该线程就会从条件队列移动到AQS的阻塞队列中。</li>
<li>位于AQS阻塞队列中的Node对象本质上都是由一个双向链表来构成的。</li>
<li>在获取到AQS锁时，这些进入到阻塞队列中的线程会按照在队列中的排序先后尝试获取。</li>
<li>当AQS阻塞队列中的线程获取到锁后，就表示该线程已经可以正常执行了</li>
<li>陷入到阻塞状态的线程，依然需要进入到操作系统的内核态，进入阻塞(park方法实现)</li>
</ol>
]]></content>
      <categories>
        <category>concurrency</category>
      </categories>
      <tags>
        <tag>AQS 可重入读写锁 ReentrantReadWriteLock</tag>
      </tags>
  </entry>
  <entry>
    <title>concurrency(13)ThreadPool</title>
    <url>/2020/06/26/Concurrent/concurrency(13)ThreadPool/</url>
    <content><![CDATA[<h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>An object that executes submitted Runnable tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc. An Executor is normally used instead of explicitly creating threads. For example, rather than invoking new Thread(new(RunnableTask())).start() for each of a set of tasks, you might use:</p>
<span id="more"></span>
<p>Executor是一个可运行提交任务的对象，这个接口提供了一种将任务的提交和每个任务的运行机制解耦的方式，包括线程的具体使用，调度等，一个Executor一般用于替代手动创建线程的方式，可以使用如下的方式：<br>   Executor executor &#x3D; anExecutor;<br>   executor.execute(new RunnableTask1());<br>   executor.execute(new RunnableTask2());<br>   …</p>
<p>However, the Executor interface does not strictly require that execution be asynchronous. In the simplest case, an executor can run the submitted task immediately in the caller’s thread:</p>
<p> class DirectExecutor implements Executor {<br>   public void execute(Runnable r) {<br>     r.run();<br>   }<br> }<br>More typically, tasks are executed in some thread other than the caller’s thread. The executor below spawns a new thread for each task.</p>
<p> class ThreadPerTaskExecutor implements Executor {<br>   public void execute(Runnable r) {<br>     new Thread(r).start();<br>   }<br> }<br>Many Executor implementations impose some sort of limitation on how and when tasks are scheduled. The executor below serializes the submission of tasks to a second executor, illustrating a composite executor.</p>
<p> class SerialExecutor implements Executor {<br>   final Queue<Runnable> tasks &#x3D; new ArrayDeque<Runnable>();<br>   final Executor executor;<br>   Runnable active;</p>
<p>   SerialExecutor(Executor executor) {<br>     this.executor &#x3D; executor;<br>   }</p>
<p>   public synchronized void execute(final Runnable r) {<br>     tasks.offer(new Runnable() {<br>       public void run() {<br>         try {<br>           r.run();<br>         } finally {<br>           scheduleNext();<br>         }<br>       }<br>     });<br>     if (active &#x3D;&#x3D; null) {<br>       scheduleNext();<br>     }<br>   }</p>
<p>   protected synchronized void scheduleNext() {<br>     if ((active &#x3D; tasks.poll()) !&#x3D; null) {<br>       executor.execute(active);<br>     }<br>   }<br> }<br>The Executor implementations provided in this package implement ExecutorService, which is a more extensive interface. The ThreadPoolExecutor class provides an extensible thread pool implementation. The Executors class provides convenient factory methods for these Executors.<br>Memory consistency effects: Actions in a thread prior to submitting a Runnable object to an Executor happen-before its execution begins, perhaps in another thread</p>
<p>Executor包含的方法：<br>  execute</p>
<h4 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h4><p>An Executor that provides methods to manage termination and methods that can produce a Future for tracking progress of one or more asynchronous tasks.<br>一个Executor的实现，提供了一些管理终止任务和返回一个用来追踪处理过程或者更多异步任务future的方法。<br>An ExecutorService can be shut down, which will cause it to reject new tasks. Two different methods are provided for shutting down an ExecutorService. The shutdown method will allow previously submitted tasks to execute before terminating, while the shutdownNow method prevents waiting tasks from starting and attempts to stop currently executing tasks. Upon termination, an executor has no tasks actively executing, no tasks awaiting execution, and no new tasks can be submitted. An unused ExecutorService should be shut down to allow reclamation of its resources.<br>Method submit extends base method Executor.execute(Runnable) by creating and returning a Future that can be used to cancel execution and&#x2F;or wait for completion. Methods invokeAny and invokeAll perform the most commonly useful forms of bulk execution, executing a collection of tasks and then waiting for at least one, or all, to complete. (Class ExecutorCompletionService can be used to write customized variants of these methods.)<br>一个ExecutorService是可以被关闭的，这样的话拒绝一些新的任务，提供了shutdow和shutdownnow方法。<br>The Executors class provides factory methods for the executor services provided in this package</p>
<p>java.util.concurrent.ExecutorService<br>java.util.concurrent.ExecutorService#shutdown<br>java.util.concurrent.ExecutorService#shutdownNow<br>java.util.concurrent.ExecutorService#isShutdown<br>java.util.concurrent.ExecutorService#isTerminated<br>java.util.concurrent.ExecutorService#awaitTermination<br>java.util.concurrent.ExecutorService#submit(java.util.concurrent.Callable<T>)<br>java.util.concurrent.ExecutorService#submit(java.lang.Runnable, T)<br>java.util.concurrent.ExecutorService#submit(java.lang.Runnable)<br>java.util.concurrent.ExecutorService#invokeAll(java.util.Collection&lt;? extends java.util.concurrent.Callable<T>&gt;)<br>java.util.concurrent.ExecutorService#invokeAll(java.util.Collection&lt;? extends java.util.concurrent.Callable<T>&gt;, long, java.util.concurrent.TimeUnit)<br>java.util.concurrent.ExecutorService#invokeAny(java.util.Collection&lt;? extends java.util.concurrent.Callable<T>&gt;)<br>java.util.concurrent.ExecutorService#invokeAny(java.util.Collection&lt;? extends java.util.concurrent.Callable<T>&gt;, long, java.util.concurrent.TimeUnit)</p>
<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p>具体是线程池实现是由ThreadPoolExecutor实现，ThreadPoolExecutor是间接的实现了ExecutorService，ThreadPoolExecutor继承了AbstractExecutorService，AbstractExecutorService实现了ExecutorService。<br>AbstractExecutorService的实现方法：<br>java.util.concurrent.AbstractExecutorService<br>java.util.concurrent.AbstractExecutorService#newTaskFor(java.lang.Runnable, T)<br>java.util.concurrent.AbstractExecutorService#newTaskFor(java.util.concurrent.Callable<T>)<br>java.util.concurrent.AbstractExecutorService#submit(java.lang.Runnable)<br>java.util.concurrent.AbstractExecutorService#submit(java.lang.Runnable, T)<br>java.util.concurrent.AbstractExecutorService#submit(java.util.concurrent.Callable<T>)<br>java.util.concurrent.AbstractExecutorService#doInvokeAny<br>java.util.concurrent.AbstractExecutorService#invokeAny(java.util.Collection&lt;? extends java.util.concurrent.Callable<T>&gt;)<br>java.util.concurrent.AbstractExecutorService#invokeAny(java.util.Collection&lt;? extends java.util.concurrent.Callable<T>&gt;, long, java.util.concurrent.TimeUnit)<br>java.util.concurrent.AbstractExecutorService#invokeAll(java.util.Collection&lt;? extends java.util.concurrent.Callable<T>&gt;)<br>java.util.concurrent.AbstractExecutorService#invokeAll(java.util.Collection&lt;? extends java.util.concurrent.Callable<T>&gt;, long, java.util.concurrent.TimeUnit)</p>
<p>AbstractExecutorService是线程池实现的基础，提供了一些默认的实现。</p>
<h5 id="线程池需要管理的数据"><a href="#线程池需要管理的数据" class="headerlink" title="线程池需要管理的数据"></a>线程池需要管理的数据</h5><ul>
<li>线程池本身的状态</li>
<li>执行的线程的状态<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ctl存储了【线程池的状态】以及【线程池里边线程的数量】</span><br><span class="line">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line">// 减去的3位是存储的是线程池的状态剩下的是管理的线程的数量：COUNT_BITS = 32-3=29</span><br><span class="line">private static final int COUNT_BITS = Integer.SIZE - 3;</span><br><span class="line">private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class="line"></span><br><span class="line">// runState is stored in the high-order bits</span><br><span class="line">private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int STOP       =  1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>
线程池里边的worker线程实现了AQS：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private final class Worker extends AbstractQueuedSynchronizer  implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h4><h5 id="ThreadPoolExecutor的构造器"><a href="#ThreadPoolExecutor的构造器" class="headerlink" title="ThreadPoolExecutor的构造器"></a>ThreadPoolExecutor的构造器</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial</span><br><span class="line"> * parameters.</span><br><span class="line"> *</span><br><span class="line"> * @param corePoolSize the number of threads to keep in the pool, even</span><br><span class="line"> *        if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set</span><br><span class="line"> * @param maximumPoolSize the maximum number of threads to allow in the</span><br><span class="line"> *        pool</span><br><span class="line"> * @param keepAliveTime when the number of threads is greater than</span><br><span class="line"> *        the core, this is the maximum time that excess idle threads</span><br><span class="line"> *        will wait for new tasks before terminating.</span><br><span class="line"> * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument</span><br><span class="line"> * @param workQueue the queue to use for holding tasks before they are</span><br><span class="line"> *        executed.  This queue will hold only the &#123;@code Runnable&#125;</span><br><span class="line"> *        tasks submitted by the &#123;@code execute&#125; method.</span><br><span class="line"> * @param threadFactory the factory to use when the executor</span><br><span class="line"> *        creates a new thread</span><br><span class="line"> * @param handler the handler to use when execution is blocked</span><br><span class="line"> *        because the thread bounds and queue capacities are reached</span><br><span class="line"> * @throws IllegalArgumentException if one of the following holds:&lt;br&gt;</span><br><span class="line"> *         &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt;</span><br><span class="line"> *         &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt;</span><br><span class="line"> *         &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span><br><span class="line"> *         &#123;@code maximumPoolSize &lt; corePoolSize&#125;</span><br><span class="line"> * @throws NullPointerException if &#123;@code workQueue&#125;</span><br><span class="line"> *         or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null</span><br><span class="line"> */</span><br><span class="line">public ThreadPoolExecutor(</span><br><span class="line">    int corePoolSize,  //核心的线程数量，即使没有任务执行也不会关闭</span><br><span class="line">    int maximumPoolSize, 最大的线程数量</span><br><span class="line">    long keepAliveTime, //线程等待新任务到来的时间超过keepAliveTime就会回收掉</span><br><span class="line">    TimeUnit unit, //时间单位</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; workQueue, //缓存提交的任务的队列</span><br><span class="line">    ThreadFactory threadFactory, //线程工厂</span><br><span class="line">    RejectedExecutionHandler handler // 拒绝策略</span><br><span class="line">                          ) &#123;</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;= 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.corePoolSize = corePoolSize;</span><br><span class="line">    this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    this.workQueue = workQueue;</span><br><span class="line">    this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory = threadFactory;</span><br><span class="line">    this.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
int corePoolSize：<br>核心的线程数量，即使没有任务执行也不会关闭。<br>int maximumPoolSize：<br>线程池当中维护的最大的线程数量<br>long keepAliveTime：<br>线程等待新任务到来的时间超过keepAliveTime就会被回收掉，回收的底线是corePoolSize。<br>TimeUnit unit：<br>keepAliveTime的时间单位<br>BlockingQueue<Runnable> workQueue：<br>缓存提交的任务的队列<br>ThreadFactory threadFactory：<br>线程工厂，推荐使用Executors#defaultThreadFactory。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static class DefaultThreadFactory implements ThreadFactory &#123;</span><br><span class="line">  //poolNumber是静态的，原因是系统中所有的线程池都是共享这个AtomicInteger，这样就不会出现名称相同的线程池</span><br><span class="line">  private static final AtomicInteger poolNumber = new AtomicInteger(1);</span><br><span class="line">  private final ThreadGroup group;</span><br><span class="line">  private final AtomicInteger threadNumber = new AtomicInteger(1);</span><br><span class="line">  private final String namePrefix;</span><br><span class="line"></span><br><span class="line">  DefaultThreadFactory() &#123;</span><br><span class="line">      SecurityManager s = System.getSecurityManager();</span><br><span class="line">      group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();</span><br><span class="line">      namePrefix = &quot;pool-&quot; + poolNumber.getAndIncrement() + &quot;-thread-&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Thread newThread(Runnable r) &#123;</span><br><span class="line">      Thread t = new Thread(group, r,</span><br><span class="line">                            namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                            0);</span><br><span class="line">      if (t.isDaemon())</span><br><span class="line">          t.setDaemon(false);//非守护线程，即为用户线程，main执行完之后，不会退出</span><br><span class="line">      if (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">          t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">      return t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
RejectedExecutionHandler handler：<br>拒绝策略，当达到队列上限或者再也不能创建现线程的时候被调用。<ul>
<li>AbortPolicy 直接抛出运行期异常，一直抛给执行execute的调用者，rejectedExecution抛出RejectedExecutionException</li>
<li>CallerRunsPolicy<br>调用者线程去执行<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">  if (!e.isShutdown()) &#123;</span><br><span class="line">      r.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>DiscardOldestPolicy<br>将最老的一个未被处理的任务丢弃，然后让线程池执行当前的任务<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">    if (!e.isShutdown()) &#123;</span><br><span class="line">        //将最老的一个拿出来，不做处理，丢弃</span><br><span class="line">        e.getQueue().poll();</span><br><span class="line">        //执行当前的任务</span><br><span class="line">        e.execute(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>DiscardPolicy 直接丢弃，也不会抛出任何异常，rejectedExecution是空实现</li>
</ul>
</li>
</ul>
<h5 id="Executors工厂"><a href="#Executors工厂" class="headerlink" title="Executors工厂"></a>Executors工厂</h5><p>java.util.concurrent.Executors<br>java.util.concurrent.Executors#newFixedThreadPool(int)<br>java.util.concurrent.Executors#newWorkStealingPool(int)<br>java.util.concurrent.Executors#newWorkStealingPool()<br>java.util.concurrent.Executors#newFixedThreadPool(int, java.util.concurrent.ThreadFactory)<br>java.util.concurrent.Executors#newSingleThreadExecutor()<br>java.util.concurrent.Executors#newSingleThreadExecutor(java.util.concurrent.ThreadFactory)<br>java.util.concurrent.Executors#newCachedThreadPool()<br>java.util.concurrent.Executors#newCachedThreadPool(java.util.concurrent.ThreadFactory)<br>java.util.concurrent.Executors#newSingleThreadScheduledExecutor()<br>java.util.concurrent.Executors#newSingleThreadScheduledExecutor(java.util.concurrent.ThreadFactory)<br>java.util.concurrent.Executors#newScheduledThreadPool(int)<br>java.util.concurrent.Executors#newScheduledThreadPool(int, java.util.concurrent.ThreadFactory)<br>java.util.concurrent.Executors#unconfigurableExecutorService<br>java.util.concurrent.Executors#unconfigurableScheduledExecutorService<br>java.util.concurrent.Executors#defaultThreadFactory<br>java.util.concurrent.Executors#privilegedThreadFactory<br>java.util.concurrent.Executors#callable(java.lang.Runnable, T)<br>java.util.concurrent.Executors#callable(java.lang.Runnable)<br>java.util.concurrent.Executors#callable(java.security.PrivilegedAction<?>)
java.util.concurrent.Executors#callable(java.security.PrivilegedExceptionAction<?>)<br>java.util.concurrent.Executors#privilegedCallable<br>java.util.concurrent.Executors#privilegedCallableUsingCurrentClassLoader</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(3);</span><br><span class="line">        executorService.submit(() -&gt;&#123;</span><br><span class="line">            IntStream.range(0,50).forEach(i -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印的线程名称都是同一个名称，以为只提交了一个任务，会使用其中一个线程去执行。<br>代码运行之后，jvm线程并不会退出，那是因为线程池创建的线程都是用户线程，而非守护线程，我们只有显式的调用线程池的shutdow之类的方法停止线程池。<br>Executors.newFixedThreadPool(3):创建只有三个线程的线程池，永远不会增加减少<br>Executors.newSingleThreadExecutor():创建只有1个线程的线程池，永远不会增加减少<br>Executors.newCachedThreadPool(): 带缓冲的线程池，它里边的线程的数量会根据提交的任务的多少来动态创建线程。</p>
<p>提交多个任务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(3);</span><br><span class="line">        IntStream.range(0,10).forEach(i -&gt;&#123;</span><br><span class="line">            executorService.submit(() -&gt;&#123;</span><br><span class="line">                IntStream.range(0,50).forEach(j -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);  </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果会出现3个线程的名称，因为提交了多个任务，会有线程的复用。<br>如果使用的是newSingleThreadExecutor()，那么打印结果只会出现一个线程的名称，所有的任务都是由这一个线程去执行。<br>如果使用newCachedThreadPool()，打印结果会出现很多线程的名称。</p>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool()"></a>newCachedThreadPool()</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    //最小线程数量是0，最大线程数量是Integer的最大值，AbortPolicy拒绝策略</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SynchronousQueue即同步的队列，插入操作必须等待移除操作的完成才能进行，返回来也是，里边只有一个元素。<br>由于核心线程数是0，因此回往SynchronousQueue添加任务，但是SynchronousQueue是同步的必须立刻执行，<br>因此新提交过来的任务会不断的创建线程去执行。</p>
<h4 id="Executors-newSingleThreadExecutor"><a href="#Executors-newSingleThreadExecutor" class="headerlink" title="Executors.newSingleThreadExecutor()"></a>Executors.newSingleThreadExecutor()</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">  //最小和最大线程数量被限制成了1个，AbortPolicy拒绝策略，无界队列</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Executors-newFixedThreadPool-n"><a href="#Executors-newFixedThreadPool-n" class="headerlink" title="Executors.newFixedThreadPool(n)"></a>Executors.newFixedThreadPool(n)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nThreads限制了最小和最大线程数量，AbortPolicy拒绝策略，无界队列</span><br><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工厂方法底层都是调用的ThreadPoolExecutor的构造器。实际使用线程池不推荐使用工厂的方式，因为：</p>
<ul>
<li>这些工厂创建的线程池拒绝策略都是抛出异常</li>
<li>newSingleThreadExecutor、newFixedThreadPool中的任务缓冲队列都是无界的，很容易出现oom异常。</li>
</ul>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>在线程池当中，尽量把偏向锁关闭</p>
<h4 id="自定义ThreadPoolExecutor参数"><a href="#自定义ThreadPoolExecutor参数" class="headerlink" title="自定义ThreadPoolExecutor参数"></a>自定义ThreadPoolExecutor参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService executorService = new ThreadPoolExecutor(3,5,</span><br><span class="line">                0,</span><br><span class="line">                TimeUnit.SECONDS,new LinkedBlockingDeque&lt;&gt;(3),</span><br><span class="line">                new ThreadPoolExecutor.CallerRunsPolicy()</span><br><span class="line">                );</span><br><span class="line">        int number = 9;</span><br><span class="line">        IntStream.range(0,number).forEach(i -&gt;&#123;</span><br><span class="line">            executorService.submit(() -&gt;&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                IntStream.range(0,1).forEach(j -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>number小于等于3的时候，日志最多打印三个线程在执行任务。<br>number大于3小于等于6的时候，日志最多打印三个线程在执行任务。<br>number大于6小于等于8的时候，日志最多打印8个线程在执行任务。<br>number大于8的时候最多会出现8个线程在执行任务，并且可能会出现拒绝执行任务的异常。<br>如果拒绝策略使用DiscardPolicy，那么程序不会抛出异常，但是会有一些任务被静默丢弃。<br>如实拒绝策略使用DiscardOldestPolicy，那么程序也不会抛出异常，但是会将阻塞队列里边的最老的任务丢弃，然后执行当前任务。<br>如果拒绝策略使用CallerRunsPolicy，那么打印结果里边会出现一个main的线程名称，即，使用调用者的线程去执行任务:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pool-1-thread-3</span><br><span class="line">pool-1-thread-4</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-5</span><br><span class="line">pool-1-thread-2</span><br><span class="line">main</span><br><span class="line">pool-1-thread-3</span><br><span class="line">pool-1-thread-4</span><br><span class="line">pool-1-thread-1</span><br></pre></td></tr></table></figure>

<h4 id="线程池任务创建与执行任务的核心逻辑"><a href="#线程池任务创建与执行任务的核心逻辑" class="headerlink" title="线程池任务创建与执行任务的核心逻辑"></a>线程池任务创建与执行任务的核心逻辑</h4><p>ThreadPoolExecutor的submit有三种实现方式：</p>
<ul>
<li><T> Future<T> submit(Callable<T> task); &#x2F;&#x2F;Future是线程run方法真正的返回值.</li>
<li><T> Future<T> submit(Runnable task, T result); &#x2F;&#x2F; Future.get()返回的是参数result.</li>
<li>Future&lt;?&gt; submit(Runnable task); &#x2F;&#x2F;Future.get()返回为null.</li>
</ul>
<p>submit方法会调用execute方法去执行任务。<br>对于线程池来说，其提供了execute与submit两种方式来向线程池提交任务。<br>总体来说，submit方法是可以提供execute方法的，因为它既可以接收callable任务，也可以接收Runnable任务。</p>
<p>关于线程池的总体的执行策略：</p>
<ol>
<li>如果线程池中正在执行的线程数 &lt; corePoolSize，那么线程池就会优先选择创建新的线程而非将提交的任务加到阻塞队列中。</li>
<li>如果线程池中正在执行的线程数数 &gt;&#x3D; corePoolSize，那么线程池就会优先选择对提交的任务进行阻塞排队而非创建新的线程。</li>
<li>如果提交的任务无法加入到阻塞队列当中，那么线程池就会创建新的线程；如果创建的线程数超过了maximumPoolSize，那么拒绝策略就会起作用。</li>
</ol>
<p>执行submit过程:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    if (task == null) throw new NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    return ftask;</span><br><span class="line">&#125;</span><br><span class="line">protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123;</span><br><span class="line">    return new FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FutureTask的构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public FutureTask(Runnable runnable, V result) &#123;</span><br><span class="line">    this.callable = Executors.callable(runnable, result);</span><br><span class="line">    this.state = NEW;       // ensure visibility of callable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> Executors.callable(runnable, result)逻辑是对callable创建的封装:<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) &#123;</span><br><span class="line">    if (task == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    return new RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>RunnableAdapter实际上是一个Callable，call方法是实际任务的执行:<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; &#123;</span><br><span class="line">    final Runnable task;</span><br><span class="line">    final T result;</span><br><span class="line">    RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">        this.task = task;</span><br><span class="line">        this.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    public T call() &#123;</span><br><span class="line">        task.run();</span><br><span class="line">        // 等待任务执行完毕(task.run()),然后直接返回result</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 其他的重载的submit方法执行逻辑都是一样的，不管是runnbale或者callable都会转换为callable，只不过参数是Callable的时候不需要RunnableAdapter。<br>newTaskFor返回的是RunnableFuture，RunnableFuture的实现类FutureTask封装了执行和返回的结构的一个集合体:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123;</span><br><span class="line">  java.util.concurrent.FutureTask#FutureTask(java.util.concurrent.Callable&lt;V&gt;)</span><br><span class="line">  java.util.concurrent.FutureTask#FutureTask(java.lang.Runnable, V)</span><br><span class="line">  java.util.concurrent.FutureTask#report</span><br><span class="line">  java.util.concurrent.FutureTask#isCancelled</span><br><span class="line">  java.util.concurrent.FutureTask#isDone</span><br><span class="line">  java.util.concurrent.FutureTask#cancel</span><br><span class="line">  java.util.concurrent.FutureTask#get()</span><br><span class="line">  java.util.concurrent.FutureTask#get(long, java.util.concurrent.TimeUnit)</span><br><span class="line">  java.util.concurrent.FutureTask#done</span><br><span class="line">  java.util.concurrent.FutureTask#set</span><br><span class="line">  java.util.concurrent.FutureTask#setException</span><br><span class="line">  java.util.concurrent.FutureTask#run</span><br><span class="line">  java.util.concurrent.FutureTask#runAndReset</span><br><span class="line">  java.util.concurrent.FutureTask#handlePossibleCancellationInterrupt</span><br><span class="line">  java.util.concurrent.FutureTask#finishCompletion</span><br><span class="line">  java.util.concurrent.FutureTask#awaitDone</span><br><span class="line">  java.util.concurrent.FutureTask#removeWaiter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RunnableFuture是一个可取消的异步的计算，提供了Future的基础的实现，提供了开始、取消、查询、获取运算结构的方法，运算结果只有运算完成之后才能获取，如果运算还没有完成，那么get方法是阻塞，任务一旦计算完成就不能重新开始或者取消，除非计算的时候调用了runAndReset方法。</p>
<h5 id="关于线程池任务的提交"><a href="#关于线程池任务的提交" class="headerlink" title="关于线程池任务的提交"></a>关于线程池任务的提交</h5><ol>
<li>两种提交方式:submit与execute</li>
<li>submit有三种方式，无论是哪种方式，最终都是将传递将来的任务转换为一个callable对象进行处理</li>
<li>当callable对象构造完毕后，最终都会调用Executor提供接口中声明的execute方法进行统一的处理</li>
</ol>
<p>execute()方法是主要的逻辑，它的实现【java.util.concurrent.ThreadPoolExecutor.execute()】。</p>
<p>介绍【java.util.concurrent.ThreadPoolExecutor.execute()】之前先了解下ThreadPoolExecutor的一些成员变量。</p>
<ul>
<li>对于线程池来说，有2个状态需要维护：<ul>
<li>线程池本身的状态</li>
<li>线程池所运行着的线程的数量</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ctl是一个原子整型变量，表示了线程池本身的状态、线程池所运行着的线程的数量</span><br><span class="line">// 高三位表示【 线程池本身的状态】，低29位表示【线程池所运行着的线程的数量】</span><br><span class="line">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line">private static final int COUNT_BITS = Integer.SIZE - 3;</span><br><span class="line">private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class="line"></span><br><span class="line">// runState is stored in the high-order bits</span><br><span class="line">// 线程池一共有5种状态</span><br><span class="line">private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int STOP       =  1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">// Packing and unpacking ctl</span><br><span class="line">// runStateOf是线程池的状态</span><br><span class="line">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</span><br><span class="line">// workerCountOf是当前线程池工作线程的数量</span><br><span class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</span><br><span class="line">// ctlOf重新计算ctl的值</span><br><span class="line">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span><br></pre></td></tr></table></figure>

<p>线程池的状态:</p>
<ol>
<li>RUNNING: 线程池可以接受新的任务提交，并且还可以正常处理阻塞队列。</li>
<li>SHUTDOWN: 不再接收新的任务提交，不过线程池还可以继续处理阻塞队列中的任务。</li>
<li>STOP：不再接收新的任务，同时还会丢弃阻塞队列中的既有任务，它还会中断正在处理中的任务。SHUTDOWNNOW会将状态置位stop状态。</li>
<li>TIDYING：所有的任务都执行完毕后（同时也涵盖了阻塞队列中的任务），当前线程池的活动的线程数量降为0，将会调用terminated方法。</li>
<li>TERMINATED：线程池的终止状态，当terminated方法执行完毕后，线程池将会处于该状态之下。</li>
</ol>
<p>线程池的状态切换:<br>RUNNING -&gt; SHUTDOWN: 当调用了线程池的SHUTDOWN方法，或者finalize方法被隐式调用后(该方法内部会调用shutdown方法)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void shutdown() &#123;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); // hook for ScheduledThreadPoolExecutor</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void finalize() &#123;</span><br><span class="line">    shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RUNNING&#x2F;SHUTDOWN -&gt; STOP: 当调用了线程池的shutdownNow方法时。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public List&lt;Runnable&gt; shutdownNow() &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        interruptWorkers();</span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    return tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SHUTDOWN -&gt; TIDYING: 在线程池与阻塞队列均变成空时。</p>
<p>STOP -&gt; TIDYING: 在线程池变成空时。</p>
<p>TIDYING -&gt; TERMINATED: 在terminated方法被执行完毕时。</p>
<p>ThreadPoolExecutor.execute()执行逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Executes the given task sometime in the future.  The task</span><br><span class="line">   * may execute in a new thread or in an existing pooled thread.</span><br><span class="line">   * 在将来某个时刻执行给定的任务，任务可能在一个新的线程里边被执行，也可能在已有的线程里边被执行</span><br><span class="line">   * If the task cannot be submitted for execution, either because this</span><br><span class="line">   * executor has been shutdown or because its capacity has been reached,</span><br><span class="line">   * the task is handled by the current &#123;@code RejectedExecutionHandler&#125;.</span><br><span class="line">   * 如果任务无法被提交执行，原因可能是executor已经被关闭，或者阻塞队列容量已经满了，</span><br><span class="line">   * 那么任务就会交给RejectedExecutionHandler处理。</span><br><span class="line">   * @param command the task to execute</span><br><span class="line">   * @throws RejectedExecutionException at discretion of</span><br><span class="line">   *         &#123;@code RejectedExecutionHandler&#125;, if the task</span><br><span class="line">   *         cannot be accepted for execution</span><br><span class="line">   * @throws NullPointerException if &#123;@code command&#125; is null</span><br><span class="line">   */</span><br><span class="line">  public void execute(Runnable command) &#123;</span><br><span class="line">      if (command == null)</span><br><span class="line">          throw new NullPointerException();</span><br><span class="line">      /*</span><br><span class="line">       * Proceed in 3 steps:</span><br><span class="line">       *</span><br><span class="line">       * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="line">       * start a new thread with the given command as its first</span><br><span class="line">       * task.  The call to addWorker atomically checks runState and</span><br><span class="line">       * workerCount, and so prevents false alarms that would add</span><br><span class="line">       * threads when it shouldn&#x27;t, by returning false.</span><br><span class="line">       * 如果线程池运行的线程数如果少于corePoolSize，线程池会尝试创建新的线程，</span><br><span class="line">       * 并且用新的线程去执行给定的任务，对于addWorker会使用原子的方式去调用。</span><br><span class="line">       * 2. If a task can be successfully queued, then we still need</span><br><span class="line">       * to double-check whether we should have added a thread</span><br><span class="line">       * (because existing ones died since last checking) or that</span><br><span class="line">       * the pool shut down since entry into this method. So we</span><br><span class="line">       * recheck state and if necessary roll back the enqueuing if</span><br><span class="line">       * stopped, or start a new thread if there are none.</span><br><span class="line">       * 如果一个任务能够被成功的添加到任务队列中，会尝试双重检查是否已经添加了一个新的线程，</span><br><span class="line">       * 或者线程池被关闭了等，如果不行就会回</span><br><span class="line">       * 滚带入队之前的状态；</span><br><span class="line">       * 3. If we cannot queue task, then we try to add a new</span><br><span class="line">       * thread.  If it fails, we know we are shut down or saturated</span><br><span class="line">       * and so reject the task.</span><br><span class="line">       * 如果不能进行入队操作，那么就会创建新的线程。如果失败，执行拒绝策略</span><br><span class="line">       */</span><br><span class="line">      int c = ctl.get();</span><br><span class="line">      // workerCountOf返回线程池存活的线程的数量，如果小于corePoolSize核心线程数量</span><br><span class="line">      if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">          //创建一个新的线程去执行当前任务</span><br><span class="line">          if (addWorker(command, true))</span><br><span class="line">              //执行成功直接返回</span><br><span class="line">              return;</span><br><span class="line">          //因为线程池可能会把其他线程使用，所以在此获取ctl的值</span><br><span class="line">          c = ctl.get();</span><br><span class="line">      &#125;</span><br><span class="line">      // 线程的线程数大于等于corePoolSize，并且线程池正在运行isRunning=true,</span><br><span class="line">      // 并且任务入队成功：workQueue.offer(command)  = true</span><br><span class="line">      if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        // 重新获取ctl检查</span><br><span class="line">          int recheck = ctl.get();</span><br><span class="line">          //线程池已经关闭并且可以将刚才入队的【workQueue.offer(command)】删除掉成功</span><br><span class="line">          //(回滚操作)</span><br><span class="line">          if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">              // 执行拒绝策略</span><br><span class="line">              reject(command);</span><br><span class="line">          // 线程池正在运行，线程池可用线程数等于0</span><br><span class="line">          else if (workerCountOf(recheck) == 0)</span><br><span class="line">              // 创建新的线程去执行当前任务</span><br><span class="line">              addWorker(null, false);</span><br><span class="line">      &#125;</span><br><span class="line">      // 线程池被关闭，并且创建新的线程失败</span><br><span class="line">      else if (!addWorker(command, false))</span><br><span class="line">          // 拒绝策略</span><br><span class="line">          reject(command);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>addWorker方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Checks if a new worker can be added with respect to current</span><br><span class="line"> * pool state and the given bound (either core or maximum). If so,</span><br><span class="line"> * the worker count is adjusted accordingly, and, if possible, a</span><br><span class="line"> * new worker is created and started, running firstTask as its</span><br><span class="line"> * first task. This method returns false if the pool is stopped or</span><br><span class="line"> * eligible to shut down. It also returns false if the thread</span><br><span class="line"> * factory fails to create a thread when asked.  If the thread</span><br><span class="line"> * creation fails, either due to the thread factory returning</span><br><span class="line"> * null, or due to an exception (typically OutOfMemoryError in</span><br><span class="line"> * Thread.start()), we roll back cleanly.</span><br><span class="line"> * 检查一个新的word而是否能够添加进来，并且还会考虑当前线程池的状态以及边界</span><br><span class="line"> * （核心线程数和最大线程数），如果能够添加成功，那么wordercount就会被调整，新的worker</span><br><span class="line"> * 会被创建和启动，参数firstTask作为worder的第一个任务，如果线程池被停止了那么这个方法返回false，</span><br><span class="line"> * 如果线程工厂无法创建一个新的线程也会返回false，如果线程创建失败，可能是由于线程工厂创建失败，或者</span><br><span class="line"> * 由于一些异常导致，比如线程启动的时候出现OutOfMemoryError，这个时候程序就会进行回滚清理操作</span><br><span class="line"> * @param firstTask the task the new thread should run first (or</span><br><span class="line"> * null if none). Workers are created with an initial first task</span><br><span class="line"> * (in method execute()) to bypass queuing when there are fewer</span><br><span class="line"> * than corePoolSize threads (in which case we always start one),</span><br><span class="line"> * or when the queue is full (in which case we must bypass queue).</span><br><span class="line"> * Initially idle threads are usually created via</span><br><span class="line"> * prestartCoreThread or to replace other dying workers.</span><br><span class="line"> * 新创建的线程应该被执行的任务，worker会被创建出来，并且会有第一个任务(参数firstTask)</span><br><span class="line"> * 当总的线程数小于corePoolSize，会跳过加入阻塞队列的逻辑，会直接执行这个任务，如果阻塞</span><br><span class="line"> * 队列满了，也会绕过队列的加入逻辑，</span><br><span class="line"> * @param core if true use corePoolSize as bound, else</span><br><span class="line"> * maximumPoolSize. (A boolean indicator is used here rather than a</span><br><span class="line"> * value to ensure reads of fresh values after checking other pool</span><br><span class="line"> * state). 如果是true，使用corePoolSize作为边界，如果是false使用maximumPoolSize作为</span><br><span class="line"> * 边界，这个参数决定了线程是怎么创建，任务怎么往阻塞队列里边插入等等逻辑。</span><br><span class="line"> * @return true if successful</span><br><span class="line"> */</span><br><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">    //标签</span><br><span class="line">    retry:</span><br><span class="line">    //外层死循环</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">      //得到状态</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        //线程池运行状态</span><br><span class="line">        int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        // Check if queue empty only if necessary.</span><br><span class="line">        //条件A： 线程池状态是SHUTDOWN、STOP、TIDYING、TERMINATED</span><br><span class="line">        //条件B： 【线程池状态是SHUTDOWN 并且参数firstTask是空，并且任务阻塞不是空的】取反</span><br><span class="line">        if (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == null &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">               //创建失败</span><br><span class="line">            return false;</span><br><span class="line">        // 内存死循环</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            // 当前线程池的线程数量</span><br><span class="line">            int wc = workerCountOf(c);</span><br><span class="line">            // 线程数量大于等于线程数最大能表示的上限数量，或者大于等于上限，返回false，创建失败</span><br><span class="line">            if (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                // 创建失败</span><br><span class="line">                return false;</span><br><span class="line">            //增加线程池线程数量+1成功，退出到外层循环，程序往下走</span><br><span class="line">            if (compareAndIncrementWorkerCount(c))</span><br><span class="line">                break retry;</span><br><span class="line">            // 获取线程池ctl</span><br><span class="line">            c = ctl.get();  // Re-read ctl</span><br><span class="line">            // 线程池状态发生了变化</span><br><span class="line">            if (runStateOf(c) != rs)</span><br><span class="line">                // 外层循环执行，重新执行addWorker方法</span><br><span class="line">                continue retry;</span><br><span class="line">            //CAS失败，即，增加线程池线程数量CAS失败，内层循环执行一遍</span><br><span class="line">            // else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 工作线程是否启动</span><br><span class="line">    boolean workerStarted = false;</span><br><span class="line">    // 工作线程是否添加</span><br><span class="line">    boolean workerAdded = false;</span><br><span class="line">    Worker w = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        // Worker继承了AQS,代表了工作线程</span><br><span class="line">        w = new Worker(firstTask);</span><br><span class="line">        //得到线程对象</span><br><span class="line">        final Thread t = w.thread;</span><br><span class="line">        // 线程工厂创建线程失败</span><br><span class="line">        if (t != null) &#123;</span><br><span class="line">            // 获取到重入锁(排它锁)</span><br><span class="line">            final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">            //加锁</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                // Recheck while holding lock.</span><br><span class="line">                // Back out on ThreadFactory failure or if</span><br><span class="line">                // shut down before lock acquired.</span><br><span class="line">                // 再次检查线程池状态</span><br><span class="line">                int rs = runStateOf(ctl.get());</span><br><span class="line">                // 线程池状态是RUNNING，或者（线程池状态是SHUTDOWN 并且参数firstTask是空）</span><br><span class="line">                if (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</span><br><span class="line">                    //再次判断线程工厂创建的线程是可以启动的，如果不可用，直接抛出异常</span><br><span class="line">                    if (t.isAlive()) // precheck that t is startable</span><br><span class="line">                        throw new IllegalThreadStateException();</span><br><span class="line">                    //将新创建的线程添加到HashSet里边</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    //得到工作线程的数量</span><br><span class="line">                    int s = workers.size();</span><br><span class="line">                    //工作线程的数量大于largestPoolSize</span><br><span class="line">                    if (s &gt; largestPoolSize)</span><br><span class="line">                        //记录曾经最大的线程池的数量</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    // 标记新创建的线程添加成功</span><br><span class="line">                    workerAdded = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">              //解锁</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            //如果工作线程添加成功</span><br><span class="line">            if (workerAdded) &#123;</span><br><span class="line">                //启动工作线程</span><br><span class="line">                t.start();</span><br><span class="line">                //标记工作线程已经启动成功</span><br><span class="line">                workerStarted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      // 如果工作线程没有启动成功</span><br><span class="line">        if (! workerStarted)</span><br><span class="line">            //将线程从工作线程集合里边移除。相当于回滚</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    return workerStarted;</span><br><span class="line">&#125;</span><br><span class="line">private void addWorkerFailed(Worker w) &#123;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (w != null)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        //工作线程数量CAS减1</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        //尝试终止线程池</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Worker的构造器以及worker的主流程：<br>Worker继承了AbstractQueuedSynchronizer</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private final class Worker extends AbstractQueuedSynchronizer implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">  Worker(Runnable firstTask) &#123;</span><br><span class="line">      //执行线程之前，线程不能被中断，其实是设置了AQS的state，中断的情况就是项城市的shutdown，</span><br><span class="line">      // stop之类的方法，这类方法在执行的时候会判断state是否大约等于0，小于0的-1不会被中断</span><br><span class="line">      setState(-1); // inhibit interrupts until runWorker</span><br><span class="line">      this.firstTask = firstTask;</span><br><span class="line">      this.thread = getThreadFactory().newThread(this);</span><br><span class="line">  &#125;</span><br><span class="line">  public void run() &#123;</span><br><span class="line">      runWorker(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意， getThreadFactory().newThread(this)传递的是this，也就是worker，当执行thread.start()的时候就会执行worker的run方法。<br>ThreadPoolExecutor当中的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  /**</span><br><span class="line"> * Main worker run loop.  Repeatedly gets tasks from queue and</span><br><span class="line"> * executes them, while coping with a number of issues:</span><br><span class="line"> * 主要的worker循环，重复不断的从阻塞队列里边获取和执行任务。</span><br><span class="line"> * 1. We may start out with an initial task, in which case we</span><br><span class="line"> * don&#x27;t need to get the first one. Otherwise, as long as pool is</span><br><span class="line"> * running, we get tasks from getTask. If it returns null then the</span><br><span class="line"> * worker exits due to changed pool state or configuration</span><br><span class="line"> * parameters.  Other exits result from exception throws in</span><br><span class="line"> * external code, in which case completedAbruptly holds, which</span><br><span class="line"> * usually leads processWorkerExit to replace this thread.</span><br><span class="line"> *</span><br><span class="line"> * 2. Before running any task, the lock is acquired to prevent</span><br><span class="line"> * other pool interrupts while the task is executing, and then we</span><br><span class="line"> * ensure that unless pool is stopping, this thread does not have</span><br><span class="line"> * its interrupt set.</span><br><span class="line"> *</span><br><span class="line"> * 3. Each task run is preceded by a call to beforeExecute, which</span><br><span class="line"> * might throw an exception, in which case we cause thread to die</span><br><span class="line"> * (breaking loop with completedAbruptly true) without processing</span><br><span class="line"> * the task.</span><br><span class="line"> *</span><br><span class="line"> * 4. Assuming beforeExecute completes normally, we run the task,</span><br><span class="line"> * gathering any of its thrown exceptions to send to afterExecute.</span><br><span class="line"> * We separately handle RuntimeException, Error (both of which the</span><br><span class="line"> * specs guarantee that we trap) and arbitrary Throwables.</span><br><span class="line"> * Because we cannot rethrow Throwables within Runnable.run, we</span><br><span class="line"> * wrap them within Errors on the way out (to the thread&#x27;s</span><br><span class="line"> * UncaughtExceptionHandler).  Any thrown exception also</span><br><span class="line"> * conservatively causes thread to die.</span><br><span class="line"> *</span><br><span class="line"> * 5. After task.run completes, we call afterExecute, which may</span><br><span class="line"> * also throw an exception, which will also cause thread to</span><br><span class="line"> * die. According to JLS Sec 14.20, this exception is the one that</span><br><span class="line"> * will be in effect even if task.run throws.</span><br><span class="line"> *</span><br><span class="line"> * The net effect of the exception mechanics is that afterExecute</span><br><span class="line"> * and the thread&#x27;s UncaughtExceptionHandler have as accurate</span><br><span class="line"> * information as we can provide about any problems encountered by</span><br><span class="line"> * user code.</span><br><span class="line"> *</span><br><span class="line"> * @param w the worker</span><br><span class="line"> */</span><br><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">    //获取到当前线程对象</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    // worker创建后，第一个任务</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    // 任务已经已经暂存，防止下次再次传递进来，造成错乱</span><br><span class="line">    w.firstTask = null;</span><br><span class="line">    // aqs的解锁，将aqs的state设置为0，即，设置线程可以被中断（线程可以被shutdown），实现在Worker的tryRelease</span><br><span class="line">    // 方法里边对state设置为0</span><br><span class="line">    w.unlock(); // allow interrupts</span><br><span class="line">    //完成标记</span><br><span class="line">    boolean completedAbruptly = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        //初始任务不是空，优先执行第一个任务，否则再去阻塞队列拉取任务执行。</span><br><span class="line">        while (task != null || (task = getTask()) != null) &#123;</span><br><span class="line">            // 加锁处理，将aqs的state由0设置为1</span><br><span class="line">            w.lock();</span><br><span class="line">            // If pool is stopping, ensure thread is interrupted;</span><br><span class="line">            // if not, ensure thread is not interrupted.  This</span><br><span class="line">            // requires a recheck in second case to deal with</span><br><span class="line">            // shutdownNow race while clearing interrupt</span><br><span class="line">            // 如果线程池停止了，要确保线程是中断的，</span><br><span class="line">            // 如果线程池不是停止状态，要确保线程没有被中断</span><br><span class="line">            // 这里二次确认shutdownnow导致的停止</span><br><span class="line">            if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            try &#123;</span><br><span class="line">                // 在执行任务之前的一些预先的逻辑，默认空实现，用于继承ThreadPoolExecutor的子类去实现</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //真正执行任务</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Error x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Throwable x) &#123;</span><br><span class="line">                    thrown = x; throw new Error(x);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    //真正的任务执行之后的逻辑，默认空实现，用于继承ThreadPoolExecutor的子类去实现</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                // 执行完毕置空，help GC</span><br><span class="line">                task = null;</span><br><span class="line">                //woker成功执行完毕的任务数量，是woker的一个计数器</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                //解锁</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 处理worker的退出</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void processWorkerExit(Worker w, boolean completedAbruptly) &#123;</span><br><span class="line">    // 如果woker处理任务完毕，那么将线程池线程数量减一</span><br><span class="line">    if (completedAbruptly) // If abrupt, then workerCount wasn&#x27;t adjusted</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">    // 得到排它锁</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    //加锁</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 线程池完成的总的任务数</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        //线程从集合当中删除</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      //解锁</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    //尝试终止</span><br><span class="line">    tryTerminate();</span><br><span class="line">    //再次获取线程池状态</span><br><span class="line">    int c = ctl.get();</span><br><span class="line">    //状态是running或者shutdown状态，之后判断是否要创建新的线程去完成一些工作</span><br><span class="line">    if (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        if (!completedAbruptly) &#123;</span><br><span class="line">            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;</span><br><span class="line">            if (min == 0 &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = 1;</span><br><span class="line">            if (workerCountOf(c) &gt;= min)</span><br><span class="line">                return; // replacement not needed</span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h5 id="关于线程池的关闭"><a href="#关于线程池的关闭" class="headerlink" title="关于线程池的关闭"></a>关于线程池的关闭</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将已经积存的任务执行完毕，不接受新的任务，重复执行这个方法没有任何副作用</span><br><span class="line">public void shutdown() &#123;</span><br><span class="line">    // 获取线程池的排它锁</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    //加锁</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        //权限检查，是否当前线程可以进行一些操作</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        //将线程池状态设置为shutdown状态</span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        // 中断空闲的worker线程</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        //回调函数，默认空实现</span><br><span class="line">        onShutdown(); // hook for ScheduledThreadPoolExecutor</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//无限循环cas设置状态，runStateAtLeast意思是检查运行中的状态至少是targetState这个状态</span><br><span class="line">private void advanceRunState(int targetState) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        if (runStateAtLeast(c, targetState) ||</span><br><span class="line">            ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void interruptIdleWorkers() &#123;</span><br><span class="line">    interruptIdleWorkers(false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void interruptIdleWorkers(boolean onlyOne) &#123;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        for (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            //工作线程没有被中断，并且能获取锁（woker执行run的时候是加锁的，这里能得到锁的都是空闲线程）</span><br><span class="line">            if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                   //执行中断</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; catch (SecurityException ignore) &#123;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    //解锁</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (onlyOne)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final void tryTerminate() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        // 对不能Terminate的线程池状态执行程序返回</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        if (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            return;</span><br><span class="line">        if (workerCountOf(c) != 0) &#123; // Eligible to terminate</span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            //当前是TIDYING状态才能置为terminate</span><br><span class="line">            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, 0));</span><br><span class="line">                    // private final Condition termination = mainLock.newCondition();</span><br><span class="line">                    // 尝试阻塞在调用终止线程池方法的线程，将他们唤醒，其中有一个方法是awaitTermination</span><br><span class="line">                    // awaitTermination阻塞在termination上</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        // else retry on failed CAS</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //</span><br><span class="line">  public List&lt;Runnable&gt; shutdownNow() &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        //状态置位stop</span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        //中断所有线程，无论是否在执行</span><br><span class="line">        interruptWorkers();</span><br><span class="line">        //将阻塞队列里边的任务清空，丢弃，返回</span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    //</span><br><span class="line">    tryTerminate();</span><br><span class="line">    return tasks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void interruptWorkers() &#123;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">      //不区分是否空闲，直接循环工作线程集合，全部中断</span><br><span class="line">        for (Worker w : workers)</span><br><span class="line">            w.interruptIfStarted();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Blocks until all tasks have completed execution after a shutdown request, or the timeout occurs, or the current thread is interrupted, whichever happens first.</span><br><span class="line">//当调用了shutdown请求后，阻塞等待所有的任务完成，或者超时发生返回，或者当前线程被中断返回</span><br><span class="line">public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">    long nanos = unit.toNanos(timeout);</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            if (runStateAtLeast(ctl.get(), TERMINATED))</span><br><span class="line">                return true;</span><br><span class="line">            if (nanos &lt;= 0)</span><br><span class="line">                return false;</span><br><span class="line">            //tryTerminate方法里边 termination.signalAll()会唤醒这里的wait</span><br><span class="line">            nanos = termination.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="等待任务完成"><a href="#等待任务完成" class="headerlink" title="等待任务完成"></a>等待任务完成</h5><p>ThreadPoolExecutor的submit方法通过newTaskFor方法返回一个FutureTask对象，提交任务到线程池之后调用FutureTask的get方法阻塞得到返回值，等待任务的完成，那么怎样才算是任务完成呢，其实state状态取值标志了任务是否完成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The run state of this task, initially NEW.  The run state</span><br><span class="line"> * transitions to a terminal state only in methods set,</span><br><span class="line"> * setException, and cancel.  During completion, state may take on</span><br><span class="line"> * transient values of COMPLETING (while outcome is being set) or</span><br><span class="line"> * INTERRUPTING (only while interrupting the runner to satisfy a</span><br><span class="line"> * cancel(true)). Transitions from these intermediate to final</span><br><span class="line"> * states use cheaper ordered/lazy writes because values are unique</span><br><span class="line"> * and cannot be further modified.</span><br><span class="line"> *</span><br><span class="line"> * Possible state transitions:</span><br><span class="line"> * NEW -&gt; COMPLETING -&gt; NORMAL</span><br><span class="line"> * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span><br><span class="line"> * NEW -&gt; CANCELLED</span><br><span class="line"> * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span><br><span class="line"> */</span><br><span class="line">private volatile int state;</span><br><span class="line">private static final int NEW          = 0;</span><br><span class="line">private static final int COMPLETING   = 1;</span><br><span class="line">private static final int NORMAL       = 2;</span><br><span class="line">private static final int EXCEPTIONAL  = 3;</span><br><span class="line">private static final int CANCELLED    = 4;</span><br><span class="line">private static final int INTERRUPTING = 5;</span><br><span class="line">private static final int INTERRUPTED  = 6;</span><br><span class="line"></span><br><span class="line">//FutureTask创建的时候state是NEW</span><br><span class="line">public FutureTask(Runnable runnable, V result) &#123;</span><br><span class="line">    this.callable = Executors.callable(runnable, result);</span><br><span class="line">    this.state = NEW;       // ensure visibility of callable</span><br><span class="line">&#125;</span><br><span class="line">public V get() throws InterruptedException, ExecutionException &#123;</span><br><span class="line">    int s = state;</span><br><span class="line">    //状态是NEW、COMPLETING执行等待</span><br><span class="line">    if (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(false, 0L);</span><br><span class="line">    //report返回任务执行的结果</span><br><span class="line">    return report(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//run方法是对任务执行过程外层抽象逻辑的封装</span><br><span class="line">public void run() &#123;</span><br><span class="line">  //状态校验</span><br><span class="line">    if (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(this, runnerOffset,</span><br><span class="line">                                     null, Thread.currentThread()))</span><br><span class="line">        return;</span><br><span class="line">    try &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        if (c != null &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            boolean ran;</span><br><span class="line">            try &#123;</span><br><span class="line">                //任务执行</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = true;</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                result = null;</span><br><span class="line">                ran = false;</span><br><span class="line">                //设置state为任务执行失败</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            if (ran)</span><br><span class="line">            //设置状态为完成</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // runner must be non-null until state is settled to</span><br><span class="line">        // prevent concurrent calls to run()</span><br><span class="line">        runner = null;</span><br><span class="line">        // state must be re-read after nulling runner to prevent</span><br><span class="line">        // leaked interrupts</span><br><span class="line">        int s = state;</span><br><span class="line">        if (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当我们把一个任务扔到了线程池当中，我们可以通过get方法获取任务的执行结果，倘若我们的线程池满了，会回调拒绝策略，而恰好我们拒绝策略是DiscardPolicy无声丢弃或者DiscardOldestPolicy，DiscardPolicy的rejectedExecution方法是一个空实现，被丢弃的任务(FutureTask)的默认状态是NEW，此时我们调用get方法等待任务返回结果，后果就是get方法永远也不会返回！</strong></p>
<p>因此建议使用带有超时时间的get方法。</p>
<h4 id="forkjoin框架"><a href="#forkjoin框架" class="headerlink" title="forkjoin框架"></a>forkjoin框架</h4><p>ForkJoinPool的主要使用场景比如：<br>一批任务，有的任务很快执行完毕，有的任务会执行的很慢，这样导致了普通的线程池存在部分线程很忙，部分线程很闲，出现了分配不均衡的现象。<br>ForkJoinPool也是间接实现了ExecutorService</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ForkJoinPool extends AbstractExecutorService &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>forkjoin会对一个大任务进行不断的拆解，拆解的过程就是fork的过程，直到fork的粒度足够小，然后对这些小任务进行执行，最后将执行完毕的小人物的结果进行合并，即，join的过程，最后会合并成一个结果，这个结果就是大任务的结果：<br><img src="/fork-join.png" alt="fork-join.png"></p>
<h5 id="任务窃取"><a href="#任务窃取" class="headerlink" title="任务窃取"></a>任务窃取</h5><p><img src="/fork-join-task-steal.png" alt="fork-join-task-steal.png"></p>
<p>线程池每个线程都有一个任务队列，但是实际情况当中，有些任务比较简单，有些任务比较复杂，他们各自的执行时间长短不同，当一个线程执行完他自己的队列里边的任务的时候，会从其他线程的队列里边窃取任务执行，这里的队列都是双向的队列，两端都可以pop一个任务，当然这个要保证是线程安全的。</p>
<h4 id="源码介绍"><a href="#源码介绍" class="headerlink" title="源码介绍"></a>源码介绍</h4><p>ForkJoinPool构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private ForkJoinPool(int parallelism,</span><br><span class="line">                     ForkJoinWorkerThreadFactory factory,</span><br><span class="line">                     UncaughtExceptionHandler handler,</span><br><span class="line">                     int mode,</span><br><span class="line">                     String workerNamePrefix) &#123;</span><br><span class="line">    this.workerNamePrefix = workerNamePrefix; //线程名字前缀</span><br><span class="line">    this.factory = factory; //类似于线程池里边的线程工厂</span><br><span class="line">    this.ueh = handler;</span><br><span class="line">    this.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">    long np = (long)(-parallelism); // offset ctl counts</span><br><span class="line">    this.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ForkJoinWorkerThreadFactory创建的时候，会创建一个队列:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected ForkJoinWorkerThread(ForkJoinPool pool) &#123;</span><br><span class="line">    // Use a placeholder until a useful name can be set in registerWorker</span><br><span class="line">    super(&quot;aForkJoinWorkerThread&quot;);</span><br><span class="line">    this.pool = pool;</span><br><span class="line">    this.workQueue = pool.registerWorker(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个队列就是线程对应的任务队列。</p>
<h5 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h5><p>ForkJoinTask是forkjoinpool执行的任务的抽象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class ForkJoinTask&lt;V&gt; implements Future&lt;V&gt;, Serializable &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RecursiveAction和RecursiveTask都实现了ForkJoinTask，RecursiveAction的compute没有返回值，RecursiveTask的compute方法是有返回值的。<br>在使用ForkJoinPool的时候，任务抽象的时候，如果任务有返回值，那么就是用RecursiveTask，否则使用RecursiveAction。</p>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = new ForkJoinPool();</span><br><span class="line">        MyTask myTask = new MyTask(1,100);</span><br><span class="line">        int  result = forkJoinPool.invoke(myTask);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        forkJoinPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyTask extends RecursiveTask&lt;Integer&gt;&#123;</span><br><span class="line"></span><br><span class="line">    private int limit = 4;</span><br><span class="line">    private int firstIndex;</span><br><span class="line">    private int lastIndex ;</span><br><span class="line">    MyTask(int firstIndex,int lastIndex)&#123;</span><br><span class="line">        this.firstIndex = firstIndex;</span><br><span class="line">        this.lastIndex = lastIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Integer compute() &#123;</span><br><span class="line">        int gap = this.lastIndex - this.firstIndex;</span><br><span class="line">        boolean flag = gap &lt;= this.limit;</span><br><span class="line">        int result = 0;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            for(int i=this.firstIndex;i&lt;=this.lastIndex;++i)&#123;</span><br><span class="line">                result +=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            int middleIndex = (this.firstIndex + this.lastIndex)/2;</span><br><span class="line">            MyTask leftTask = new MyTask(this.firstIndex,middleIndex);</span><br><span class="line">            MyTask rightTask = new MyTask(middleIndex + 1,this.lastIndex);</span><br><span class="line">            invokeAll(leftTask, rightTask);</span><br><span class="line">            result = leftTask.join() + rightTask.join();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果:<br>ForkJoinPool-1-worker-1<br>ForkJoinPool-1-worker-1<br>ForkJoinPool-1-worker-1<br>ForkJoinPool-1-worker-4<br>ForkJoinPool-1-worker-3<br>ForkJoinPool-1-worker-3<br>ForkJoinPool-1-worker-1<br>ForkJoinPool-1-worker-7<br>ForkJoinPool-1-worker-7<br>ForkJoinPool-1-worker-3<br>ForkJoinPool-1-worker-3<br>ForkJoinPool-1-worker-2<br>ForkJoinPool-1-worker-2<br>ForkJoinPool-1-worker-5<br>ForkJoinPool-1-worker-5<br>ForkJoinPool-1-worker-4<br>ForkJoinPool-1-worker-4<br>ForkJoinPool-1-worker-4<br>ForkJoinPool-1-worker-5<br>ForkJoinPool-1-worker-2<br>ForkJoinPool-1-worker-2<br>ForkJoinPool-1-worker-3<br>ForkJoinPool-1-worker-3<br>ForkJoinPool-1-worker-7<br>ForkJoinPool-1-worker-0<br>ForkJoinPool-1-worker-0<br>ForkJoinPool-1-worker-6<br>ForkJoinPool-1-worker-1<br>ForkJoinPool-1-worker-0<br>ForkJoinPool-1-worker-3<br>ForkJoinPool-1-worker-2<br>ForkJoinPool-1-worker-4<br>5050</p>
]]></content>
      <categories>
        <category>concurrency</category>
      </categories>
      <tags>
        <tag>ThreadPool ForkJoinPool</tag>
      </tags>
  </entry>
  <entry>
    <title>concurrency(14)CompletionService</title>
    <url>/2020/06/30/Concurrent/concurrency(14)CompletionService/</url>
    <content><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>我们在向线程池提交任务的时候，提交的顺序是ABCD，提交之后任务执行完毕的时间都是不确定的，比如执行完毕的顺序是CBAD，然后实际开发中有这样的需求是，只要得到第一个任务的执行结果，其他任务的执行结果就不考虑了，试想，如果没有jdk的实现的api的话，我们也可以操作，增加一个队列，让任务执行完毕之后，将任务的执行结果放入到队列的头部，第二执行完毕的任务的执行结果放在结果队列的第二个位置，以此类推，队列头部的就是第一个任务执行的结果。</p>
<span id="more"></span>
<h3 id="CompletionService的实现"><a href="#CompletionService的实现" class="headerlink" title="CompletionService的实现"></a>CompletionService的实现</h3><p>A service that decouples the production of new asynchronous tasks from the consumption of the results of completed tasks.<br>Producers submit tasks for execution. Consumers take completed tasks and process their results in the order they complete.<br>A CompletionService can for example be used to manage asynchronous I&#x2F;O, in which tasks that perform reads are submitted in one part of a program or system, and then acted upon in a different part of the program when the reads complete, possibly in a different order than they were requested.<br>Typically, a CompletionService relies on a separate Executor to actually execute the tasks, in which case the CompletionService only manages an internal completion queue. The ExecutorCompletionService class provides an implementation of this approach.<br>将异步任务的生产和任务结果的完成解耦。<br>生产者提交对任务的执行，消费者按照任务的执行完毕的时间顺序对结果进行处理。<br>CompletionService 可以用于管理异步的io，读取的任务会作为系统或者程序的一部分进行提交，当读取完成的时候可以在程序的不同部分去执行，他们的执行顺序和请求顺序是不一样的。<br>典型的情况，一个CompletionService依赖独立的线程池去执行任务。这种情况，CompletionService仅仅管理一个内部的任务完成队列，ExecutorCompletionService类提供了一个这种放是的实现。</p>
<p>java.util.concurrent.CompletionService<br>java.util.concurrent.CompletionService#submit(java.util.concurrent.Callable<V>)<br>java.util.concurrent.CompletionService#submit(java.lang.Runnable, V)<br>java.util.concurrent.CompletionService#take 从完成队列得到并且移除一个队头的数据，如果不存在就一直等待<br>java.util.concurrent.CompletionService#poll() 和take类似，不同的是poll如果元素不存在就会返回空。<br>java.util.concurrent.CompletionService#poll(long, java.util.concurrent.TimeUnit)  如果元素为空，会等待一段指定的时间</p>
<h4 id="ExecutorCompletionService"><a href="#ExecutorCompletionService" class="headerlink" title="ExecutorCompletionService"></a>ExecutorCompletionService</h4><p>ExecutorCompletionService在已有线程池基础上加了一个任务完成队列completionQueue。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ExecutorCompletionService&lt;V&gt; implements CompletionService&lt;V&gt; &#123;</span><br><span class="line">    private final Executor executor;</span><br><span class="line">    private final AbstractExecutorService aes;</span><br><span class="line">    private final BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>使用ExecutorCompletionService前需要向构造一个线程池,ExecutorCompletionService提交的任务最终提交给线程池:</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest4 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</span><br><span class="line">        ExecutorService executorService = new ThreadPoolExecutor(4,</span><br><span class="line">                10, 10, TimeUnit.SECONDS,</span><br><span class="line">                new LinkedBlockingDeque&lt;&gt;(20), new ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        CompletionService completionService = new ExecutorCompletionService(executorService);</span><br><span class="line">        IntStream.range(0, 10).forEach(i -&gt; &#123;</span><br><span class="line">            completionService.submit(() -&gt; &#123;</span><br><span class="line">                Thread.sleep((long) (Math.random() * 1000));</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">                return i * i;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(&quot;==========================================&quot;);</span><br><span class="line">        for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">            System.out.println(completionService.take().get());</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pool-1-thread-1<br>0<br>pool-1-thread-2<br>1<br>pool-1-thread-3<br>4<br>pool-1-thread-4<br>9<br>pool-1-thread-1<br>16<br>pool-1-thread-3<br>36<br>pool-1-thread-1<br>64<br>pool-1-thread-2<br>25<br>pool-1-thread-4<br>49<br>pool-1-thread-3<br>81</p>
<p>可以看到任务的提交顺序和结果的获取顺序是不一样的。</p>
]]></content>
      <categories>
        <category>concurrency</category>
      </categories>
      <tags>
        <tag>CompletionService</tag>
      </tags>
  </entry>
  <entry>
    <title>concurrency(15)ThreadLocalRandom在多线程竞争环境下的实现策略</title>
    <url>/2020/07/01/Concurrent/concurrency(15)ThreadLocalRandom%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AB%9E%E4%BA%89%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><p>我们在实际开发过程中，不可避免的会使用随机数，jdk提供了Random类用来实现随机数的生成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest5 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Random random = new Random();</span><br><span class="line">        IntStream.range(0,10).forEach(i -&gt; &#123;</span><br><span class="line">            System.out.println(random.nextInt(10));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>看一下Random的nextInt：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Random implements java.io.Serializable &#123;</span><br><span class="line">  private final AtomicLong seed;</span><br><span class="line"></span><br><span class="line">  public int nextInt(int bound) &#123;</span><br><span class="line">      if (bound &lt;= 0)</span><br><span class="line">          throw new IllegalArgumentException(BadBound);</span><br><span class="line"></span><br><span class="line">      int r = next(31);</span><br><span class="line">      int m = bound - 1;</span><br><span class="line">      if ((bound &amp; m) == 0)  // i.e., bound is a power of 2</span><br><span class="line">          r = (int)((bound * (long)r) &gt;&gt; 31);</span><br><span class="line">      else &#123;</span><br><span class="line">          for (int u = r;</span><br><span class="line">               u - (r = u % bound) + m &lt; 0;</span><br><span class="line">               u = next(31))</span><br><span class="line">              ;</span><br><span class="line">      &#125;</span><br><span class="line">      return r;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次生成随机数的时候，都会生成一个种子，然后使用这个种子再去做一些运算得到的结果作为随机数的返回结果，<br>nextInt当中的next方法就是我了得到种子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected int next(int bits) &#123;</span><br><span class="line">    long oldseed, nextseed;</span><br><span class="line">    //this.seed是原始的种子，是一个原子性的</span><br><span class="line">    AtomicLong seed = this.seed;</span><br><span class="line">    do &#123;</span><br><span class="line">        oldseed = seed.get();</span><br><span class="line">        //对种子的生成使用cas的方式进行更新</span><br><span class="line">        nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class="line">    &#125; while (!seed.compareAndSet(oldseed, nextseed));</span><br><span class="line">    return (int)(nextseed &gt;&gt;&gt; (48 - bits));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>老的种子被更新后，原来的种子的引用重新指向新的种子。<br>在多线程的情况下，保证了每个线程得到的种子都是不同的，在正确性上是没有任何问题的，但是问题是这样做的性能是很差的，当线程非常多的时候，会有大量的cas，接下来 就是ThreadLocalRandom登场的时候了。</p>
<h3 id="ThreadLocalRandom"><a href="#ThreadLocalRandom" class="headerlink" title="ThreadLocalRandom"></a>ThreadLocalRandom</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest5 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current();</span><br><span class="line">      IntStream.range(0,10).forEach(i -&gt; &#123;</span><br><span class="line">          System.out.println(threadLocalRandom.nextInt(10));</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>A random number generator isolated to the current thread. Like the global Random generator used by the Math class, a ThreadLocalRandom is initialized with an internally generated seed that may not otherwise be modified. When applicable, use of ThreadLocalRandom rather than shared Random objects in concurrent programs will typically encounter much less overhead and contention. Use of ThreadLocalRandom is particularly appropriate when multiple tasks (for example, each a ForkJoinTask) use random numbers in parallel in thread pools.<br>一个线程隔离的随机数生成器。就像全局的生成器一样被Math类所使用的。ThreadLocalRandom也是通过内部的种子生成器来初始化的，但是不能被其他的线程修改，更多的可能下，在并发的情况下，使用ThreadLocalRandom比共享的Random，特别是在ForkJoinTask这种情况当中，会表现出很好的性能。</p>
<p>ThreadLocalRandom只在一个线程里边使用，不会出现线程的切换。</p>
<p>对于一个随机数生成器来说，有2个要素需要考量：</p>
<ol>
<li>随机数生成器的种子</li>
<li>具体的随机数生成算法（函数）</li>
</ol>
<p>对于ThreadLocalRandom来说，器随机数生成器的种子是存放在每个线程的ThreadLocal中的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ThreadLocalRandom extends Random &#123;</span><br><span class="line">  ...</span><br><span class="line">    // 在同一个jvm 应用里边只有一个ThreadLocalRandom实例</span><br><span class="line">    static final ThreadLocalRandom instance = new ThreadLocalRandom();</span><br><span class="line">    public static ThreadLocalRandom current() &#123;</span><br><span class="line">    if (UNSAFE.getInt(Thread.currentThread(), PROBE) == 0)</span><br><span class="line">        localInit();</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int nextInt(int bound) &#123;</span><br><span class="line">      if (bound &lt;= 0)</span><br><span class="line">          throw new IllegalArgumentException(BadBound);</span><br><span class="line">      int r = mix32(nextSeed());</span><br><span class="line">      int m = bound - 1;</span><br><span class="line">      if ((bound &amp; m) == 0) // power of two</span><br><span class="line">          r &amp;= m;</span><br><span class="line">      else &#123; // reject over-represented candidates</span><br><span class="line">          for (int u = r &gt;&gt;&gt; 1;</span><br><span class="line">               u + m - (r = u % bound) &lt; 0;</span><br><span class="line">               u = mix32(nextSeed()) &gt;&gt;&gt; 1)</span><br><span class="line">              ;</span><br><span class="line">      &#125;</span><br><span class="line">      return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final long nextSeed() &#123;</span><br><span class="line">        Thread t; long r; // read and update per-thread seed</span><br><span class="line">        //对当前线程进行操作更新</span><br><span class="line">        UNSAFE.putLong(t = Thread.currentThread(), SEED,</span><br><span class="line">                       r = UNSAFE.getLong(t, SEED) + GAMMA);</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Unsafe mechanics</span><br><span class="line">    private static final sun.misc.Unsafe UNSAFE;</span><br><span class="line">    private static final long SEED;</span><br><span class="line">    private static final long PROBE;</span><br><span class="line">    private static final long SECONDARY;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; tk = Thread.class;</span><br><span class="line">            //对种子的更新是修改的Thread类里边的成员变量</span><br><span class="line">            SEED = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(&quot;threadLocalRandomSeed&quot;));</span><br><span class="line">            PROBE = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(&quot;threadLocalRandomProbe&quot;));</span><br><span class="line">            SECONDARY = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(&quot;threadLocalRandomSecondarySeed&quot;));</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread类的部分代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** The current seed for a ThreadLocalRandom */</span><br><span class="line">@sun.misc.Contended(&quot;tlr&quot;)</span><br><span class="line">long threadLocalRandomSeed;</span><br><span class="line"></span><br><span class="line">/** Probe hash value; nonzero if threadLocalRandomSeed initialized */</span><br><span class="line">@sun.misc.Contended(&quot;tlr&quot;)</span><br><span class="line">int threadLocalRandomProbe;</span><br><span class="line"></span><br><span class="line">/** Secondary seed isolated from public ThreadLocalRandom sequence */</span><br><span class="line">@sun.misc.Contended(&quot;tlr&quot;)</span><br><span class="line">int threadLocalRandomSecondarySeed;</span><br></pre></td></tr></table></figure>
<p>我们发现Thread类里边的threadLocalRandomSeed、threadLocalRandomProbe、threadLocalRandomProbe都是原生类型的long，而在Random里边的AtomicLong类型。因为threadLocalRandomSeed、threadLocalRandomProbe、threadLocalRandomProbe都是定义在线程里边的，不会发生多线程并发的问题。</p>
]]></content>
      <categories>
        <category>concurrency</category>
      </categories>
      <tags>
        <tag>ThreadLocalRandom</tag>
      </tags>
  </entry>
  <entry>
    <title>concurrency(2)synchronized关键字详解</title>
    <url>/2019/08/21/Concurrent/concurrency(2)synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="变量在多线程之间的影响"><a href="#变量在多线程之间的影响" class="headerlink" title="变量在多线程之间的影响"></a>变量在多线程之间的影响</h3><p>编写程序：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class MyThreadTest&#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runnable r = new MyThread();</span><br><span class="line">        Thread t1 = new Thread(r);</span><br><span class="line">        Thread t2 = new Thread(r);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> class MyThread implements  Runnable &#123;</span><br><span class="line">    int x;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        x= 0;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            System.out.println(&quot;result:&quot; + x++);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep((long)Math.random() * 1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            if(x == 30)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出的可能有多种：<br>A：<br>result:0<br>result:1<br>result:2<br>result:3<br>result:5</p>
<p>B：<br>result:1<br>result:0<br>result:2<br>result:3<br>result:4</p>
<p>即0和1的先后顺序是不确定的。<br>我们创建了2个线程但是他们都会执行同一个r对象的run方法，，而变量x又是公共的变量，在多线程之间都是可见的，这在多线程里边会有一些影响，这样导致了输出的不确定性。</p>
<h3 id="synchronized加锁对象导致的线程执行的不同"><a href="#synchronized加锁对象导致的线程执行的不同" class="headerlink" title="synchronized加锁对象导致的线程执行的不同"></a>synchronized加锁对象导致的线程执行的不同</h3><p>编写程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyThreadTest2 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyClass myClass = new MyClass();</span><br><span class="line">        Thread t1 = new Thread1(myClass);</span><br><span class="line">        Thread t2 = new Thread2(myClass);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(700);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyClass&#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void hello()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(4000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void world()&#123;</span><br><span class="line">        System.out.println(&quot;world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Thread1 extends Thread&#123;</span><br><span class="line">    private MyClass myClass;</span><br><span class="line"></span><br><span class="line">    public  Thread1(MyClass myClass)&#123;</span><br><span class="line">        this.myClass = myClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        this.myClass.hello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Thread2 extends Thread&#123;</span><br><span class="line">    private MyClass myClass;</span><br><span class="line"></span><br><span class="line">    public  Thread2(MyClass myClass)&#123;</span><br><span class="line">        this.myClass = myClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        this.myClass.world();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出：<br>hello<br>world</p>
<p>即 hello先于world打印。<br>现在我们修改main函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    MyClass myClass = new MyClass();</span><br><span class="line">    MyClass myClass2 = new MyClass();</span><br><span class="line">    Thread t1 = new Thread1(myClass);</span><br><span class="line">    Thread t2 = new Thread2(myClass2);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(700);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：<br>world<br>hello</p>
<p>由于t1和t2使用了2个不同的MyClass，那么synchronized锁住的对象也就不一样，线程之间互不影响，因为world首先打印出来。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>如果一个对象它里边有若干个synchronized方法，那么在某一时刻，只有一个线程能进入这里边的某一个synchronized方法，而其他线程想要进入其他的任意synchronized方法也要等待。<br>如果synchronized修饰static的方法，那么锁住的就是class对象。</p>
<h3 id="synchronized的几种不同的用法"><a href="#synchronized的几种不同的用法" class="headerlink" title="synchronized的几种不同的用法"></a>synchronized的几种不同的用法</h3><h4 id="显式加锁对象"><a href="#显式加锁对象" class="headerlink" title="显式加锁对象"></a>显式加锁对象</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest1 &#123;</span><br><span class="line"></span><br><span class="line">    private Object object = new Object();</span><br><span class="line"></span><br><span class="line">    public void method()&#123;</span><br><span class="line">        synchronized (object)&#123;</span><br><span class="line">            System.out.println(&quot;hello world&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看字节码：<br>javap -c  com.twodragonlake.concurrency3.MyTest1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void method();</span><br><span class="line">  Code:</span><br><span class="line">     0: aload_0</span><br><span class="line">     1: getfield      #3                  // Field object:Ljava/lang/Object;</span><br><span class="line">     4: dup</span><br><span class="line">     5: astore_1</span><br><span class="line">     6: monitorenter                      //进入监视器（获取锁）</span><br><span class="line">     7: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">    10: ldc           #5                  // String hello world</span><br><span class="line">    12: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">    15: aload_1</span><br><span class="line">    16: monitorexit                       //退出监视器（释放锁）</span><br><span class="line">    17: goto          25</span><br><span class="line">    20: astore_2</span><br><span class="line">    21: aload_1</span><br><span class="line">    22: monitorexit                       //防止异常的情况下保证锁一定能释放掉</span><br><span class="line">    23: aload_2</span><br><span class="line">    24: athrow</span><br><span class="line">    25: return</span><br><span class="line">  Exception table:</span><br><span class="line">     from    to  target type</span><br><span class="line">         7    17    20   any</span><br><span class="line">        20    23    20   any</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当我们使用synchronized关键字来修饰代码块时，字节码层面上是通过monitorenter和monitorexit指令来实现的锁的获取与释放动作。</p>
<p>修改method方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void method()&#123;</span><br><span class="line">    synchronized (object)&#123;</span><br><span class="line">        System.out.println(&quot;hello world&quot;);</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void method();</span><br><span class="line">  Code:</span><br><span class="line">     0: aload_0</span><br><span class="line">     1: getfield      #3                  // Field object:Ljava/lang/Object;</span><br><span class="line">     4: dup</span><br><span class="line">     5: astore_1</span><br><span class="line">     6: monitorenter                      //进入监视器</span><br><span class="line">     7: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">    10: ldc           #5                  // String hello world</span><br><span class="line">    12: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">    15: new           #7                  // class java/lang/RuntimeException</span><br><span class="line">    18: dup</span><br><span class="line">    19: invokespecial #8                  // Method java/lang/RuntimeException.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">    22: athrow</span><br><span class="line">    23: astore_2</span><br><span class="line">    24: aload_1</span><br><span class="line">    25: monitorexit                      //退出监视器，因为肯定会抛出异常，所以只有这一个monitorexit。</span><br><span class="line">    26: aload_2</span><br><span class="line">    27: athrow                           //</span><br><span class="line">  Exception table:</span><br><span class="line">     from    to  target type</span><br><span class="line">         7    26    23   any</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当前线程进入到monitorenter指令后，线程将会持有Monitor对象，退出monitorenter指令后，线程将会释放Monitor对象。</p>
<h4 id="synchronized对方法的同步"><a href="#synchronized对方法的同步" class="headerlink" title="synchronized对方法的同步"></a>synchronized对方法的同步</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest2 &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void method()&#123;</span><br><span class="line">        System.out.println(&quot;hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public synchronized void method();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String hello world</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 13: 0</span><br><span class="line">        line 14: 8</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  this   Lcom/twodragonlake/concurrency3/MyTest2;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当synchronized修饰方法的时候看不到监视器的指令，但是怎么分辨是同步的呢？其实是通过方法的标示：<br>flags: ACC_PUBLIC, ACC_SYNCHRONIZED<br>ACC_SYNCHRONIZED标示是一个同步的方法。<br>对于synchronized关键字修饰方法来说，并没有监视器的进入和退出指令，而是出现了一个ACC_SYNCHRONIZED标志。<br>jvm使用了ACC_SYNCHRONIZED访问标志来区分一个方法是否为同步方法。<br>如果有，那么执行线程将会先持有方法所在对象的monitor对象，然后再去执行方法体；在该方法执行期间，<br>其他的任何线程均无法获取到这个Monitor对象，当线程执行完该方法后，它会释放掉这个Monitor对象。</p>
<h4 id="synchronized修饰静态方法"><a href="#synchronized修饰静态方法" class="headerlink" title="synchronized修饰静态方法"></a>synchronized修饰静态方法</h4><p>编写代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest3 &#123;</span><br><span class="line"></span><br><span class="line">    public static  synchronized  void  method()&#123;</span><br><span class="line">        System.out.println(&quot;hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static synchronized void method();</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</span><br><span class="line">  Code:</span><br><span class="line">    stack=2, locals=0, args_size=0</span><br><span class="line">       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: ldc           #3                  // String hello world</span><br><span class="line">       5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       8: return</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 13: 0</span><br><span class="line">      line 14: 8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>访问标记：ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED 相比非静态方法多了一个标志 ACC_STATIC。<br>即，方法 的字节码标志存在ACC_STATIC和ACC_SYNCHRONIZED的时候就是一个静态同步方法。</p>
<p>JVM中的同步是基于进入与退出监视器对象（管程对象）来实现的，每个对象实例都会有一个Monitor对象，Monitor对象和Java对象一同创建并销毁，Monitor对象是由C++来实现的。</p>
<p>当多个线程同时访问同一段同步代码时，这些线程会被放到一个EntryList集合中，处于阻塞状态的线程都会被放到该列表当中，接下来，当前线程获取到对象的Monitor时，Monitor是依赖于底层操作系统的mutex lock来实现互斥的，线程获取mutex成功，则会持有该mutex，这时其他线程无法再获取到该mutex。</p>
<p>如果线程调用了wait方法，那么该线程就会释放掉所持有的的mutex，并且该线程会进入到wait集合（等待集合）中，，等待下一次被其他线程调用notify&#x2F;notifyall唤醒，如果当前线程顺利执行完毕方法，那么它也会释放掉所有持有mutex。</p>
<p>总结一下：同步锁在这种实现方式当中，因为Monitor是依赖于底层的操作系统实现，这样就存在用户态与内核态之间的切换，，所以会增加性能开销。<br>通过对象互斥锁的概念保证共享数据操作的完整性，每个对象都对应于一个可称为【互斥锁】的标记，这个标记用于保证在任何时刻，只能有一个线程访问该对象。</p>
<p>那些处于EntryList与waitSet中的线程均处于阻塞状态，阻塞操作是由操作系统来完成的，在inux下是通过pthread_mutex_local函数实现的。<br>线程被阻塞后便会进入到内核调度状态，这会导致系统用户态与内核态之间来回切换，严重影响锁的性能。</p>
<p>解决上述问题的办法便是自旋。其原理：当发生对Monitor的挣用时，若Owner能够在很短的时间内释放掉锁，则那些正在挣用的线程就可以稍微等待下，【即所谓的自旋】，在Owner线程释放锁之后，挣用线程可能会立刻获取到锁，从而避免了系统阻塞。不过，当Owner运行时间超过了临界值后，挣用线程自旋一段时间后依然无法获取到锁，这时挣用线程则会停止自旋从而到阻塞状态，所以总体的思想是：先自旋，不成功再进行阻塞，尽量降低阻塞的可能性，这对那些执行时间很短的代码块来说就有极大性能提升，显然，自旋在多处理器（多核心）上才有意义。<br>阻塞要进入到内核态，如果线程唤醒又会从内核态转到用户态，所以要尽量避免阻塞。</p>
<p>互斥锁的属性：</p>
<ol>
<li>PTHREAD_MUTEX_TIMED_NP: 这是缺省值，也就是普通锁，当一个线程加锁以后，，其余请求锁的线程将会形成一个等待队列，并且在解锁后按照优先级获取到锁。这种策略可以确保资源分配的公平性。</li>
<li>PTHREAD_MUTEX_RECURSIVE_NP:  嵌套锁。允许一个线程对同一个锁成功获取多次，并通过unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新进行竞争。</li>
<li>PTHREAD_MUTEX_ERRORCHECK_NP: 检错锁，如果一个线程请求同一个锁，则返回EDEADLK,否则与PTHREAD_MUTEX_TIMED_NP类型的动作相同，这样就保证了当不允许多次加锁时不会出现最简单情况下的死锁。</li>
<li>PTHREAD_MUTEX_ADAPTIVE_NP: 适应锁，动作最为简单的锁类型，仅仅等待解锁后重新竞争。</li>
</ol>
<h3 id="ObjectMonitor-openjdk-解读"><a href="#ObjectMonitor-openjdk-解读" class="headerlink" title="ObjectMonitor openjdk 解读"></a>ObjectMonitor openjdk 解读</h3><p>synchronized关键字是通过monitor管理线程的同步，那么这个monitor在openjdk里边有哪些组成，干了一些什么事情？<br>其实在c++的层面monitor对应的c++类就是ObjectMonitor，它的头文件源码如下：<br><span class="exturl" data-url="aHR0cDovL2hnLm9wZW5qZGsuamF2YS5uZXQvamRrOHUvamRrOHUvaG90c3BvdC9maWxlL2JmYWMxNmYxOGQ5Mi9zcmMvc2hhcmUvdm0vcnVudGltZS9vYmplY3RNb25pdG9yLmhwcA==">http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/bfac16f18d92/src/share/vm/runtime/objectMonitor.hpp<i class="fa fa-external-link-alt"></i></span></p>
<p>看一下初始化方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// initialize the monitor, exception the semaphore, all other fields</span><br><span class="line">// are simple integers or pointers</span><br><span class="line">ObjectMonitor() &#123;</span><br><span class="line">  _header       = NULL;</span><br><span class="line">  _count        = 0;</span><br><span class="line">  _waiters      = 0,</span><br><span class="line">  _recursions   = 0;     记录可重入锁重入的次数</span><br><span class="line">  _object       = NULL;  </span><br><span class="line">  _owner        = NULL;  当前锁的拥有者线程</span><br><span class="line">  _WaitSet      = NULL;  线程调用了wait方法，就会进入这个队列</span><br><span class="line">  _WaitSetLock  = 0 ;    简单的一个自旋锁【先自旋，自旋拿不到锁再进行内核态转换】</span><br><span class="line">  _Responsible  = NULL ;</span><br><span class="line">  _succ         = NULL ;</span><br><span class="line">  _cxq          = NULL ; 最近的一个等待线程，也是一个ObjectMonitor的线程代理</span><br><span class="line">  FreeNext      = NULL ;</span><br><span class="line">  _EntryList    = NULL ; 等待进入monitor的线程都在_EntryList集合里边</span><br><span class="line">  _SpinFreq     = 0 ;</span><br><span class="line">  _SpinClock    = 0 ;</span><br><span class="line">  OwnerIsThread = 0 ;</span><br><span class="line">  _previous_owner_tid = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下它的处理架构：<br><img src="/monitor.png" alt="monitor.png"><br>waitSet采用链表的结构存储等待的线程的好处是，只要拿到一个线程就能访问其他的线程，在有些情况下可能针对于优先级唤醒有非常好的帮助。</p>
<h3 id="wait方法的实现"><a href="#wait方法的实现" class="headerlink" title="wait方法的实现"></a>wait方法的实现</h3><p>java的Object的wait方法，在objectMonitor.cpp里边，源码位置：<br><span class="exturl" data-url="aHR0cDovL2hnLm9wZW5qZGsuamF2YS5uZXQvamRrOHUvamRrOHUvaG90c3BvdC9maWxlL2JmYWMxNmYxOGQ5Mi9zcmMvc2hhcmUvdm0vcnVudGltZS9vYmplY3RNb25pdG9yLmNwcA==">http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/bfac16f18d92/src/share/vm/runtime/objectMonitor.cpp<i class="fa fa-external-link-alt"></i></span><br>wait方法的开始是从1463—1690，定位到1508行：<br><img src="/wait.png" alt="wait.png"><br>ObjectWaiter node(Self);构建了一个ObjectWaiter的节点，然后调用 AddWaiter (&amp;node) ;将其加入到waitset里边。<br>AddWaiter:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">waitSet里边是一个双向链表，这里边都是在修改指针，将当前节点加入到链表。</span><br><span class="line">inline void ObjectMonitor::AddWaiter(ObjectWaiter* node) &#123;</span><br><span class="line">  assert(node != NULL, &quot;should not dequeue NULL node&quot;);</span><br><span class="line">  assert(node-&gt;_prev == NULL, &quot;node already in list&quot;);</span><br><span class="line">  assert(node-&gt;_next == NULL, &quot;node already in list&quot;);</span><br><span class="line">  // put node at end of queue (circular doubly linked list)</span><br><span class="line">  if (_WaitSet == NULL) &#123;</span><br><span class="line">    _WaitSet = node;</span><br><span class="line">    node-&gt;_prev = node;</span><br><span class="line">    node-&gt;_next = node;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ObjectWaiter* head = _WaitSet ;</span><br><span class="line">    ObjectWaiter* tail = head-&gt;_prev;</span><br><span class="line">    assert(tail-&gt;_next == head, &quot;invariant check&quot;);</span><br><span class="line">    tail-&gt;_next = node;</span><br><span class="line">    head-&gt;_prev = node;</span><br><span class="line">    node-&gt;_next = head;</span><br><span class="line">    node-&gt;_prev = tail;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wait方法里边的 exit (true, Self); 指的是线程进入waitSet之后就退出了monitor，释放对象的锁。</p>
<h3 id="notify方法"><a href="#notify方法" class="headerlink" title="notify方法"></a>notify方法</h3><p>notify在从1698行开始。<br><img src="/notify1.png" alt="notify1.png"><br>看一下DequeueWaiter方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">唤醒waitSet里边的第一个线程</span><br><span class="line">inline ObjectWaiter* ObjectMonitor::DequeueWaiter() &#123;</span><br><span class="line">  // dequeue the very first waiter</span><br><span class="line">  ObjectWaiter* waiter = _WaitSet;</span><br><span class="line">  if (waiter) &#123;</span><br><span class="line">    DequeueSpecificWaiter(waiter);</span><br><span class="line">  &#125;</span><br><span class="line">  return waiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在notify调用完DequeueWaiter拿到第一个线程之后，下边有一系列逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (Policy != 4) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">if (Policy == 0) &#123;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (Policy == 1) &#123;</span><br><span class="line">&#125;</span><br><span class="line">if (Policy == 2) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (Policy == 3) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (Policy &lt; 4) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Policy代表的是调度策略类型，不同的调度策略唤醒的线程会大不相同。<br>唤醒的线程会进入到EntryList,并且从waitSet移除：<br>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (Policy == 1) &#123;      // append to EntryList</span><br><span class="line">    if (List == NULL) &#123;</span><br><span class="line">        iterator-&gt;_next = iterator-&gt;_prev = NULL ;</span><br><span class="line">        _EntryList = iterator ;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       // CONSIDER:  finding the tail currently requires a linear-time walk of</span><br><span class="line">       // the EntryList.  We can make tail access constant-time by converting to</span><br><span class="line">       // a CDLL instead of using our current DLL.</span><br><span class="line">       ObjectWaiter * Tail ;</span><br><span class="line">       for (Tail = List ; Tail-&gt;_next != NULL ; Tail = Tail-&gt;_next) ;</span><br><span class="line">       assert (Tail != NULL &amp;&amp; Tail-&gt;_next == NULL, &quot;invariant&quot;) ;</span><br><span class="line">       Tail-&gt;_next = iterator ;</span><br><span class="line">       iterator-&gt;_prev = Tail ;</span><br><span class="line">       iterator-&gt;_next = NULL ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="锁升级与偏向锁深入解析"><a href="#锁升级与偏向锁深入解析" class="headerlink" title="锁升级与偏向锁深入解析"></a>锁升级与偏向锁深入解析</h3><p>在jdk1.5之前，，我们若想实现线程同步，只能通过synchronized关键字这一种方式达成，底层，java也是通过synchronized关键字来做到数据的原子性维护的；synchronized关键字是jvm实现的一种内置锁，从底层角度来说，这种锁的获取与释放都是由jvm帮助我们隐式实现的。</p>
<p>从jdk1.5开始，并发包引入了Lock锁，Lock这种同步锁是基于java来实现的，因此锁的获取与释放都是通过java代码来实现与控制的。</p>
<p>然后synchronized是基于底层操作系统的Mutex Lock来实现的，每次对锁的获取与释放动作都会带来用户态与内核态之间的切换，这种切换会极大地增加系统负担；在并发量较高时，也就是说锁的竞争比较激烈时，synchronized锁在性能上的表现就非常差。</p>
<p>从JDK1.6开始，synchronized锁的实现发生了很大的变化，JVM引入了相应的优化手段来提升synchronized锁的性能，这种提升涉及到偏向锁，轻量级锁及重量级锁等，从而减少锁的竞争锁带来的用户态与内核态之间的切换；这种锁的优化实际上是通过java对象头中的一些标志位来去实现的；对于锁的访问与改变，实际上都与对象头息息相关。</p>
<p>从JDK1.6开始，对象实例在堆当中划分为三个组成部分：对象头，实例数据与对齐填充。<br>对象头主要也是由三块内容构成：</p>
<ol>
<li>Mark Word</li>
<li>指向类的指针</li>
<li>数组长度</li>
</ol>
<p>其中Mark Word（它记录了对象，锁及垃圾回收相关的信息，在6位的jvm中，器长度也是64bit）的信息包括了如下组成部分：</p>
<ol>
<li>无锁标记</li>
<li>偏向锁标记</li>
<li>轻量级锁标记</li>
<li>重量级锁标记</li>
<li>GC标记</li>
</ol>
<p>对于synchronized锁来说，锁的升级主要是通过Mark Word中的锁标记位与是否偏向锁标志位来达成的，synchronized关键字所对应的锁都是先从偏向锁开始，随着锁竞争的不断升级，逐步演化至轻量级锁，最后则变成了重量级锁。</p>
<p>无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p>
<h4 id="偏向锁："><a href="#偏向锁：" class="headerlink" title="偏向锁："></a>偏向锁：</h4><p>针对于一个线程来说的，它的主要作用是优化同一个线程多次获取一个锁的情况；如果一个synchronized方法被一个线程访问，那么这个方法所在的对象就会在其Mark Word中的将偏向锁进行标记，同时还会有一个字段来存储该线程的ID；当这个线程再次访问同一个synchronized方法时，他会检查这个对象的Mark Word的偏向锁标记以及是否指向了气线程id，如果是的话，那么该线程就无需进入管程(Monitor)，而是直接进入到该方法体中。</p>
<p>如果是另外一个线程访问synchronized方法，那么实际情况会如何呢？</p>
<p>偏向锁会被取消掉，升级为轻量级锁。</p>
<h4 id="轻量级锁："><a href="#轻量级锁：" class="headerlink" title="轻量级锁："></a>轻量级锁：</h4><p>若第一个线程已经获取到了当前对象的锁，这时第二个线程又开始尝试争抢该对象的锁，由于该对象的锁已经被第一个线程获取到，因此它是偏向锁，而第二个线程在争抢时，会发现该对象头中的Mark Word已经是偏向锁，但是里边存储的线程id并不是自己的（是第一个线程），那么它会进行CAS（Compare and Swap），从而获取到锁，这里边存在两种情况：</p>
<ol>
<li>获取锁成功：那么它会直接将Mark Word中的线程id由第一个线程变成自己（偏向锁标记为保持不变），这样改对象依然会保存锁的状态。</li>
<li>获取锁失败：则表示这时可能会有多个线程同时尝试争抢该对象的锁，那么这时偏向锁就会进行升级，升级为轻量级锁。</li>
</ol>
<h4 id="自旋锁："><a href="#自旋锁：" class="headerlink" title="自旋锁："></a>自旋锁：</h4><p>若自旋失败（依然无法获取锁），那么锁就会转化为重量级锁，在这种情况下，无法获取到锁的线程都会进入到Monitor（即内核态）<br>自旋最大的一个特点就是避免了线程从用户态进入到内核态。</p>
<h4 id="重量级锁："><a href="#重量级锁：" class="headerlink" title="重量级锁："></a>重量级锁：</h4><p>线程最终从用户态进入到内核态。</p>
<h3 id="编译器对于锁的优化措施"><a href="#编译器对于锁的优化措施" class="headerlink" title="编译器对于锁的优化措施"></a>编译器对于锁的优化措施</h3><h4 id="锁消除："><a href="#锁消除：" class="headerlink" title="锁消除："></a>锁消除：</h4><p>程序1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest4 &#123;</span><br><span class="line">    private Object object = new Object();</span><br><span class="line">    public void method()&#123;</span><br><span class="line">       synchronized (object)&#123;</span><br><span class="line">           System.out.println(&quot;hello world&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>程序2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest4 &#123;</span><br><span class="line">    public void method()&#123;</span><br><span class="line">        Object object = new Object();</span><br><span class="line">       synchronized (object)&#123;</span><br><span class="line">           System.out.println(&quot;hello world&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序2将锁对象object作为局部变量放在方法体里边，这样就意味着每个线程都有一个自己的锁，并不会像程序1那样在成员变量object上发生锁的竞争，观察程序2的字节码还是会有synchronized的相关字节码，但是在实际运行的时候，jit编译器会进行优化，会把程序2的synchronized关键字去掉。</p>
<p>JIT编译器（Just In Time编译器）可以在动态编辑同步代码时，使用一种叫做逃逸分析的技术，来通过该项技术判别程序中所使用的锁对象是否只被一个线程所使用，而没有散布到其他线程当中；如果情况就是这样的话，那么JIT编译器在编译这个同步代码时就不会生成synchronized<br>关键字所标示的锁的申请与释放机器码，从而消除了锁的使用流程。</p>
<h4 id="锁粗化："><a href="#锁粗化：" class="headerlink" title="锁粗化："></a>锁粗化：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest5 &#123;</span><br><span class="line">    private Object object = new Object();</span><br><span class="line">    public void method()&#123;</span><br><span class="line">        synchronized (object)&#123;</span><br><span class="line">            System.out.println(&quot;hello world&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (object)&#123;</span><br><span class="line">            System.out.println(&quot;welcome&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (object)&#123;</span><br><span class="line">            System.out.println(&quot;person&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译结果：</p>
<p>javap  -c com.twodragonlake.concurrency3.MyTest5</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void method();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: getfield      #3                  // Field object:Ljava/lang/Object;</span><br><span class="line">       4: dup</span><br><span class="line">       5: astore_1</span><br><span class="line">       6: monitorenter                      【第一个synchronized的monitorenter】</span><br><span class="line">       7: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      10: ldc           #5                  // String hello world</span><br><span class="line">      12: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      15: aload_1</span><br><span class="line">      16: monitorexit                       【第一个synchronized的monitorexit】</span><br><span class="line">      17: goto          25</span><br><span class="line">      20: astore_2</span><br><span class="line">      21: aload_1</span><br><span class="line">      22: monitorexit                       【第一个synchronized的第二个monitorenter，异常情况释放锁用】</span><br><span class="line">      23: aload_2</span><br><span class="line">      24: athrow</span><br><span class="line">      25: aload_0</span><br><span class="line">      26: getfield      #3                  // Field object:Ljava/lang/Object;</span><br><span class="line">      29: dup</span><br><span class="line">      30: astore_1</span><br><span class="line">      31: monitorenter                      【第二个synchronized的monitorenter】</span><br><span class="line">      32: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      35: ldc           #7                  // String welcome</span><br><span class="line">      37: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      40: aload_1</span><br><span class="line">      41: monitorexit                       【第二个synchronized的monitorexit】</span><br><span class="line">      42: goto          50</span><br><span class="line">      45: astore_3</span><br><span class="line">      46: aload_1</span><br><span class="line">      47: monitorexit                      【第二个synchronized的第二个monitorenter，异常情况释放锁用】</span><br><span class="line">      48: aload_3</span><br><span class="line">      49: athrow</span><br><span class="line">      50: aload_0</span><br><span class="line">      51: getfield      #3                  // Field object:Ljava/lang/Object;</span><br><span class="line">      54: dup</span><br><span class="line">      55: astore_1</span><br><span class="line">      56: monitorenter                      【第三个synchronized的monitorenter】</span><br><span class="line">      57: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      60: ldc           #8                  // String person</span><br><span class="line">      62: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      65: aload_1</span><br><span class="line">      66: monitorexit                       【第三个synchronized的monitorexit】</span><br><span class="line">      67: goto          77</span><br><span class="line">      70: astore        4</span><br><span class="line">      72: aload_1</span><br><span class="line">      73: monitorexit                       【第三个synchronized的第二个monitorenter，异常情况释放锁用】</span><br><span class="line">      74: aload         4</span><br><span class="line">      76: athrow</span><br><span class="line">      77: return</span><br></pre></td></tr></table></figure>

<p>JIT编译器在执行动态编译时，若发现前后相邻的synchronized块使用的是同一个锁对象，那么它就会把这几个synchronized块给合并为一个较大的同步块，这样做的好处在于线程执行这些代码时，就无需频繁申请与释放锁了，从而达到申请与释放锁一次，就可以执行全部的同步代码块，从而提升了性能。</p>
]]></content>
      <categories>
        <category>concurrency</category>
      </categories>
      <tags>
        <tag>synchronized 并发</tag>
      </tags>
  </entry>
  <entry>
    <title>concurrency(3)死锁检测与相关工具详解</title>
    <url>/2019/08/31/Concurrent/concurrency(3)%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E4%B8%8E%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>线程1等待线程2互斥持有的资源，而线程2也在等待线程1互斥持有的资源，两个线程都无法继续执行。</p>
<span id="more"></span>

<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>线程持续重试一个总是失败的操作，导致无法继续执行。</p>
<h3 id="饿死"><a href="#饿死" class="headerlink" title="饿死"></a>饿死</h3><p>线程一直被调度延迟访问其赖以执行的资源，也许是调度器先于低优先级的线程而执行高优先级的线程，同时总是会有一个高优先级的线程可以执行，饿死也叫作无限延迟。</p>
<h3 id="死锁实例"><a href="#死锁实例" class="headerlink" title="死锁实例"></a>死锁实例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest6 &#123;</span><br><span class="line"></span><br><span class="line">    private Object lock1 = new Object();</span><br><span class="line">    private Object lock2 = new Object();</span><br><span class="line"></span><br><span class="line">    public void method1()&#123;</span><br><span class="line">        synchronized (lock1)&#123;</span><br><span class="line">            synchronized (lock2)&#123;</span><br><span class="line">                System.out.println(&quot;method1 invoked&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void method2()&#123;</span><br><span class="line">        synchronized (lock2)&#123;</span><br><span class="line">            synchronized (lock1)&#123;</span><br><span class="line">                System.out.println(&quot;method2 invoked&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyTest6 myTest6 = new MyTest6();</span><br><span class="line"></span><br><span class="line">        Runnable runnable1 = () -&gt;&#123;</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                myTest6.method1();</span><br><span class="line">                try&#123;</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t1 = new Thread(runnable1,&quot;myThread1&quot;);</span><br><span class="line"></span><br><span class="line">        Runnable runnable2 = () -&gt;&#123;</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                myTest6.method2();</span><br><span class="line">                try&#123;</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t2 = new Thread(runnable2,&quot;myThread2&quot;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：<br>method2 invoked<br>method1 invoked</p>
<h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><h4 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h4><p>这个时候我们使用jvisualvm查看死锁，在cmd里边敲入jvisualvm<br><img src="/deadlock.png" alt="deadlock.png"><br><img src="/deadlock1.png" alt="deadlock1.png"><br>myThread2持有0x000000076f1a8300，等待0x000000076f1a82f0；<br>myThread1持有0x000000076f1a82f0，等待0x000000076f1a8300；<br>死锁产生。</p>
<p>下边也有死锁的信息打印：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">&quot;myThread2&quot;:</span><br><span class="line">  waiting to lock monitor 0x000000001ce80d18 (object 0x000000076f1a82f0, a java.lang.Object),</span><br><span class="line">  which is held by &quot;myThread1&quot;</span><br><span class="line">&quot;myThread1&quot;:</span><br><span class="line">  waiting to lock monitor 0x000000001ce80c68 (object 0x000000076f1a8300, a java.lang.Object),</span><br><span class="line">  which is held by &quot;myThread2&quot;</span><br></pre></td></tr></table></figure>

<h4 id="jstack命令"><a href="#jstack命令" class="headerlink" title="jstack命令"></a>jstack命令</h4><p>首先使用jstack查看当前的java进程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;jps</span><br><span class="line">20340</span><br><span class="line">20664 Launcher</span><br><span class="line">21352 MyTest6</span><br><span class="line">19660 Jps</span><br></pre></td></tr></table></figure>
<p>我们死锁程序是MyTest6，接下来使用jstack查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jstack 21352</span><br></pre></td></tr></table></figure>
<p><img src="/deadlock2.png" alt="deadlock2.png"><br>显示的结果和jvisualvm打印的是一致的。</p>
]]></content>
      <categories>
        <category>concurrency</category>
      </categories>
      <tags>
        <tag>concurrency deadlock</tag>
      </tags>
  </entry>
  <entry>
    <title>concurrency(4)Lock锁机制深入详解</title>
    <url>/2019/12/08/Concurrent/concurrency(4)Lock%E9%94%81%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h3><p>Lock implementations provide more extensive locking operations than can be obtained using synchronized methods and statements. They allow more flexible structuring, may have quite different properties, and may support multiple associated Condition objects.</p>
<span id="more"></span>
<p>A lock is a tool for controlling access to a shared resource by multiple threads. Commonly, a lock provides exclusive access to a shared resource: only one thread at a time can acquire the lock and all access to the shared resource requires that the lock be acquired first. However, some locks may allow concurrent access to a shared resource, such as the read lock of a ReadWriteLock.<br>The use of synchronized methods or statements provides access to the implicit monitor lock associated with every object, but forces all lock acquisition and release to occur in a block-structured way: when multiple locks are acquired they must be released in the opposite order, and all locks must be released in the same lexical scope in which they were acquired.<br>While the scoping mechanism for synchronized methods and statements makes it much easier to program with monitor locks, and helps avoid many common programming errors involving locks, there are occasions where you need to work with locks in a more flexible way. For example, some algorithms for traversing concurrently accessed data structures require the use of “hand-over-hand” or “chain locking”: you acquire the lock of node A, then node B, then release A and acquire C, then release B and acquire D and so on. Implementations of the Lock interface enable the use of such techniques by allowing a lock to be acquired and released in different scopes, and allowing multiple locks to be acquired and released in any order.<br>With this increased flexibility comes additional responsibility. The absence of block-structured locking removes the automatic release of locks that occurs with synchronized methods and statements. In most cases, the following idiom should be used:</p>
<p> Lock l &#x3D; …;<br> l.lock();<br> try {<br>   &#x2F;&#x2F; access the resource protected by this lock<br> } finally {<br>   l.unlock();<br> }<br>When locking and unlocking occur in different scopes, care must be taken to ensure that all code that is executed while the lock is held is protected by try-finally or try-catch to ensure that the lock is released when necessary.<br>Lock implementations provide additional functionality over the use of synchronized methods and statements by providing a non-blocking attempt to acquire a lock (tryLock()), an attempt to acquire the lock that can be interrupted (lockInterruptibly, and an attempt to acquire the lock that can timeout (tryLock(long, TimeUnit)).<br>A Lock class can also provide behavior and semantics that is quite different from that of the implicit monitor lock, such as guaranteed ordering, non-reentrant usage, or deadlock detection. If an implementation provides such specialized semantics then the implementation must document those semantics.<br>Note that Lock instances are just normal objects and can themselves be used as the target in a synchronized statement. Acquiring the monitor lock of a Lock instance has no specified relationship with invoking any of the lock methods of that instance. It is recommended that to avoid confusion you never use Lock instances in this way, except within their own implementation.<br>Except where noted, passing a null value for any parameter will result in a NullPointerException being thrown.<br>Memory Synchronization<br>All Lock implementations must enforce the same memory synchronization semantics as provided by the built-in monitor lock, as described in The Java Language Specification (17.4 Memory Model) :<br>A successful lock operation has the same memory synchronization effects as a successful Lock action.<br>A successful unlock operation has the same memory synchronization effects as a successful Unlock action.<br>Unsuccessful locking and unlocking operations, and reentrant locking&#x2F;unlocking operations, do not require any memory synchronization effects.<br>Implementation Considerations<br>The three forms of lock acquisition (interruptible, non-interruptible, and timed) may differ in their performance characteristics, ordering guarantees, or other implementation qualities. Further, the ability to interrupt the ongoing acquisition of a lock may not be available in a given Lock class. Consequently, an implementation is not required to define exactly the same guarantees or semantics for all three forms of lock acquisition, nor is it required to support interruption of an ongoing lock acquisition. An implementation is required to clearly document the semantics and guarantees provided by each of the locking methods. It must also obey the interruption semantics as defined in this interface, to the extent that interruption of lock acquisition is supported: which is either totally, or only on method entry.<br>As interruption generally implies cancellation, and checks for interruption are often infrequent, an implementation can favor responding to an interrupt over normal method return. This is true even if it can be shown that the interrupt occurred after another action may have unblocked the thread. An implementation should document this behavior.</p>
<p>lock的实现和synchronized的方法或者代码块来说提供了更多的锁获取的扩展操作，允许更为灵活的结构化，也可能有一些十分不同的属性，并且支持更多相关联Condation对象。</p>
<p>锁是一个用于控制多个线程访问共享资源的工具，通常，一个锁会对共享资源提供排他控制访问，在一个时刻只有一个线程获取锁，所有获取共享资源的线程首先要获取锁，当然，有些锁允许共享资源的并发访问，比如读写锁。</p>
<p>synchronized的方法和语句的使用，是隐式的对每个对象关联的monitor 锁的访问控制，但是它强制所有锁的获取和释放发生在一个块结构的上方式，当有多个线程访问的时候，他们必须要以相反的顺序进行释放，并且是在他们相同获取锁的作用域进行。</p>
<p>虽然synchronized这种作用域上的获取和释放monitor的方式变得更加简单，并且会避免许多一些通常情况下的编码错误，但是也有一些情况需要比较灵活的方式操作锁，比如，一些算法用于并发遍历访问数据结构，他们需要使用手把手或者链式获取锁，你获取lockA，然后获取lockB，然后释放A，然后获取C，然后释放B，然后获取D等等，实现lock接口，让这种方式成为可能，这种锁的技术允许在不同的作用域获取和释放锁，并且允许多个锁同时获取和释放锁。</p>
<p>借助这种更加灵活性，带来更多的职责，我们不需要synchronized块结构的形式进行锁的自动释放，在大多数情况，典型的使用形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Lock l = ...;</span><br><span class="line">l.lock();</span><br><span class="line">try &#123;</span><br><span class="line">  // access the resource protected by this lock</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  l.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当锁的获取和释放在不同的作用域，我们必须要非常小心的使用，当锁被获取后，在执行的代码要在try catch里边，，在finally里边进行释放。</p>
<p>lock的实现相比synchronized会提供一些额外的功能，提供了非阻塞的方式获取锁，trylock，并且提供了可以被中断的获取锁的方式，也提供了超时敏感的获取锁的方式。<br>Lock接口的对象提供了一些和monitor不同的行为和语义，比如确保顺序性，死锁检测，可重入，如果提供了这些语义那么实现要以文档的形式呈现出来。<br>lock仅仅是一个普通的对象而已，也可以用作synchronized的目标，获取锁实例的监视器锁和调用lock的lock方式之间没有任何关联关系，推荐的做法是避免这种混淆，永远不要用这种方式去使用lock实例，除了他么自己底层实现当中。</p>
<p>除了这些我们应该注意，在所有参数当中解析到一个null值就会抛出一个npe异常。</p>
<h4 id="内存同步"><a href="#内存同步" class="headerlink" title="内存同步"></a>内存同步</h4><p>所有的锁的实现必须强制的保持内存同步语义，这一点和monitor是一致的。这一点在<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTcvaHRtbC9qbHMtMTcuaHRtbCNqbHMtMTcuNA==">java语言规范的内存模型<i class="fa fa-external-link-alt"></i></span>有定义。</p>
<ul>
<li>一个成功的lock操作，拥有相同的内存同步操作，相同的lock动作的效果。</li>
<li>一个成功的unlock操作，拥有相同的内存同步操作，相同的unlock动作的效果。</li>
</ul>
<p>不成功的锁定和解锁，以及可重入的解锁和解锁，他们不要求任何内存的同步的效果。</p>
<h4 id="实现上的考量"><a href="#实现上的考量" class="headerlink" title="实现上的考量"></a>实现上的考量</h4><p>lock获取的三种形式（可中断，不可中断的，基于时间的）在性能、保证有序性、以及其他的点上会有所不同，更进一步来说，这种可以中断获取锁的过程的能力可能不在lock类当中，因此，这个实现并不要求精确的定义前边三种lock特性的这种保证和语义，也不要求锁的获取的过程就去中断，这个实现被要求被清晰的记录语义和保证是在每个每个lock方法上面，它必须在接口上获取中断的语义，以支持获取锁的中断，仅仅是在方法层面去支持。</p>
<p>由于中断往往意味着取消，所以检查中断就不是一个频繁的操作，一个实现要响应中断，而不是等待方法的返回，这也是真的，中断可能发生在另一个动作上，可能需要解锁这个线程，一个实现需要记录这一点。</p>
<h4 id="lock接口的方法"><a href="#lock接口的方法" class="headerlink" title="lock接口的方法"></a>lock接口的方法</h4><ul>
<li>lock<br>阻塞获取</li>
<li>unlock<br>阻塞释放锁</li>
<li>lockInterruptibly<br>如果没有被中断就去获取；<br>如果锁可用，那么立刻返回；<br>如果当前锁不可用，当前线程无法进行调度，进入睡眠状态，知道如下2件事情发生就会醒来：<ul>
<li>lock被当前线程获取到了；</li>
<li>其他线程中断了当前这个线程，而且锁获取的过程是可以被中断的；<br>  如果当前线程拥有自己的中断的状态，或者它在获取的时候被支持中断，那么当前线程的状态被清除，并且抛出中断异常。</li>
</ul>
</li>
<li>newCondition<br>返回一个新的condition实例，绑定到lock实例上的condition。<br>在condition之前，lock必须被线程持有，condition的await被调用会释放锁。</li>
<li>tryLock<br>调用的时候，当锁是自由的他才会获取到锁；<br>如果锁不是可用的，那么方法会返回立刻返回false，锁可用的时候会立刻返回true，典型的使用方式：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line">if (lock.tryLock()) &#123;</span><br><span class="line"> try &#123;</span><br><span class="line">   // manipulate protected state</span><br><span class="line"> &#125; finally &#123;</span><br><span class="line">   lock.unlock();</span><br><span class="line"> &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line"> // perform alternative actions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果锁获取了，可以确保被释放，如果没有获取到锁，也没有必要去释放锁；</li>
<li>tryLock(times)<br>在给定的等待 时间之内，如果锁是可用的，线程没有被中断那么获取锁，获取成功返回true，如果没有获取到，线程会进入等待，直到如下三种情况出现才会醒来：<ul>
<li>线程获取到了锁；</li>
<li>其他的线程中断了当前的线程，并且中断是支持的；</li>
<li>等待的时间超时；<br>如果锁被获取，那么返回true。<br>如果当前线程满足：</li>
<li>当前线程设置了中断状态；</li>
<li>获取的过程被中断了，并且支持中断；<br>那么抛出中断异常，中断位被清除。<br>如果等待的时候超时，返回false，如果时间没有超时，时间小于等于0， 那么就等于没有任何等待。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>concurrency</category>
      </categories>
      <tags>
        <tag>concurrency Lock</tag>
      </tags>
  </entry>
  <entry>
    <title>concurrency(6)Condition详解</title>
    <url>/2020/01/04/Concurrent/concurrency(6)Condition%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>Lock接口里边有一个方法【Condition newCondition();】，返回的是一个Condition实例；</p>
<span id="more"></span>
<p>看一下Condition的doc：<br>Returns a new Condition instance that is bound to this Lock instance.<br>Before waiting on the condition the lock must be held by the current thread. A call to Condition.await() will atomically release the lock before waiting and re-acquire the lock before the wait returns.<br>返回一个绑定到当前锁实例的一个Condition。<br>在等待Condition之前当前线程必须要获取到Condition绑定的锁实例。<br>调用Condition.await()方法的时候将会自动释放锁，在等待重新获取锁和wait方法之前。</p>
<p>传统上，我们可以通过synchronized关键字+wait + notify&#x2F;notifyall来实现多个线程之间的协调与通信，整个 过程都是由jvm来帮助实现的，开发者无需（也是无法）了解底层实现细节。<br>从jdk1.5开始，并发包提供了lock，Condation(wait与notify&#x2F;signalAll)来实现多个线程之间协调与通信，整个过程都是由开发者来控制的 而且相比于传统方式，更加灵活，功能也更加强。</p>
<p>Thread.sleep与await（或是Object的wait方法）的本质区别：sleep方法本质上不会释放锁，而await会释放锁，并且在signal之后，还需要重新获取到锁才能继续执行（该行为与Object的wait方法完全一致）</p>
<h4 id="doc说明"><a href="#doc说明" class="headerlink" title="doc说明"></a>doc说明</h4><p>Condition factors out the Object monitor methods (wait, notify and notifyAll) into distinct objects to give the effect of having multiple wait-sets per object, by combining them with the use of arbitrary Lock implementations. Where a Lock replaces the use of synchronized methods and statements, a Condition replaces the use of the Object monitor methods.<br>Conditions (also known as condition queues or condition variables) provide a means for one thread to suspend execution (to “wait”) until notified by another thread that some state condition may now be true. Because access to this shared state information occurs in different threads, it must be protected, so a lock of some form is associated with the condition. The key property that waiting for a condition provides is that it atomically releases the associated lock and suspends the current thread, just like Object.wait.<br>A Condition instance is intrinsically bound to a lock. To obtain a Condition instance for a particular Lock instance use its newCondition() method.<br>As an example, suppose we have a bounded buffer which supports put and take methods. If a take is attempted on an empty buffer, then the thread will block until an item becomes available; if a put is attempted on a full buffer, then the thread will block until a space becomes available. We would like to keep waiting put threads and take threads in separate wait-sets so that we can use the optimization of only notifying a single thread at a time when items or spaces become available in the buffer. This can be achieved using two Condition instances.<br>   class BoundedBuffer {<br>     final Lock lock &#x3D; new ReentrantLock();<br>     final Condition notFull  &#x3D; lock.newCondition();<br>     final Condition notEmpty &#x3D; lock.newCondition();</p>
<pre><code> final Object[] items = new Object[100];
 int putptr, takeptr, count;

 public void put(Object x) throws InterruptedException &#123;
   lock.lock();
   try &#123;
     while (count == items.length)
       notFull.await();
     items[putptr] = x;
     if (++putptr == items.length) putptr = 0;
     ++count;
     notEmpty.signal();
   &#125; finally &#123;
     lock.unlock();
   &#125;
 &#125;

 public Object take() throws InterruptedException &#123;
   lock.lock();
   try &#123;
     while (count == 0)
       notEmpty.await();
     Object x = items[takeptr];
     if (++takeptr == items.length) takeptr = 0;
     --count;
     notFull.signal();
     return x;
   &#125; finally &#123;
     lock.unlock();
   &#125;
 &#125;
</code></pre>
<p>   }</p>
<p>(The java.util.concurrent.ArrayBlockingQueue class provides this functionality, so there is no reason to implement this sample usage class.)<br>A Condition implementation can provide behavior and semantics that is different from that of the Object monitor methods, such as guaranteed ordering for notifications, or not requiring a lock to be held when performing notifications. If an implementation provides such specialized semantics then the implementation must document those semantics.<br>Note that Condition instances are just normal objects and can themselves be used as the target in a synchronized statement, and can have their own monitor wait and notification methods invoked. Acquiring the monitor lock of a Condition instance, or using its monitor methods, has no specified relationship with acquiring the Lock associated with that Condition or the use of its waiting and signalling methods. It is recommended that to avoid confusion you never use Condition instances in this way, except perhaps within their own implementation.<br>Except where noted, passing a null value for any parameter will result in a NullPointerException being thrown.<br>Implementation Considerations<br>When waiting upon a Condition, a “spurious wakeup” is permitted to occur, in general, as a concession to the underlying platform semantics. This has little practical impact on most application programs as a Condition should always be waited upon in a loop, testing the state predicate that is being waited for. An implementation is free to remove the possibility of spurious wakeups but it is recommended that applications programmers always assume that they can occur and so always wait in a loop.<br>The three forms of condition waiting (interruptible, non-interruptible, and timed) may differ in their ease of implementation on some platforms and in their performance characteristics. In particular, it may be difficult to provide these features and maintain specific semantics such as ordering guarantees. Further, the ability to interrupt the actual suspension of the thread may not always be feasible to implement on all platforms.<br>Consequently, an implementation is not required to define exactly the same guarantees or semantics for all three forms of waiting, nor is it required to support interruption of the actual suspension of the thread.<br>An implementation is required to clearly document the semantics and guarantees provided by each of the waiting methods, and when an implementation does support interruption of thread suspension then it must obey the interruption semantics as defined in this interface.<br>As interruption generally implies cancellation, and checks for interruption are often infrequent, an implementation can favor responding to an interrupt over normal method return. This is true even if it can be shown that the interrupt occurred after another action that may have unblocked the thread. An implementation should document this behavior.</p>
<p>Condition相当于把Object的监控器方法(wait,notify和notifyall)插入到各种不同的对象当中，达到让每一个对象拥有多个等待集合的效果，通过任意的一个锁的实现组合起来，其中会用lock替代synchronized语句和代码块，Condition会替代Object的monitor方法的使用。</p>
<p>Condition又叫做条件队列或者条件变量，Condition提供了一种方式可以让线程挂起（等待），直到被另一个线程发现共享变量信息为true把它唤醒为止，由于共享变量的信息可以在不同的线程里边可见，因此它必须要受到保护，这样就一定要lock和Condition绑定起来。等待这个条件的属性，会自动的释放关联的锁，挂起当前的线程，就像Object的wait方法一样。</p>
<p>一个Condition实例天然的绑定到lock上，我们使用newCondition()获取一个特定的lock实例对应的Condition实例。<br>举例，假设有一个有界的缓冲区，有take和put方法，如果take的时候是一个空的buffer直到有元素可取，那么当前线程阻塞，如果put一个满的buffer的时候，当前线程阻塞直到有空闲位置可塞，这样可以保持put和take线程等待在2个不同的等待集合里边。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class BoundedBuffer &#123;</span><br><span class="line">     final Lock lock = new ReentrantLock();</span><br><span class="line">     final Condition notFull  = lock.newCondition();</span><br><span class="line">     final Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">     final Object[] items = new Object[100];</span><br><span class="line">     int putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">     public void put(Object x) throws InterruptedException &#123;</span><br><span class="line">       lock.lock();</span><br><span class="line">       try &#123;</span><br><span class="line">         while (count == items.length)</span><br><span class="line">           notFull.await();</span><br><span class="line">         items[putptr] = x;</span><br><span class="line">         if (++putptr == items.length) putptr = 0;</span><br><span class="line">         ++count;</span><br><span class="line">         notEmpty.signal();</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     public Object take() throws InterruptedException &#123;</span><br><span class="line">       lock.lock();</span><br><span class="line">       try &#123;</span><br><span class="line">         while (count == 0)</span><br><span class="line">           notEmpty.await();</span><br><span class="line">         Object x = items[takeptr];</span><br><span class="line">         if (++takeptr == items.length) takeptr = 0;</span><br><span class="line">         --count;</span><br><span class="line">         notFull.signal();</span><br><span class="line">         return x;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>java.util.concurrent.ArrayBlockingQueue已经实现了上述的功能，因此没有必要再实现相同的class。<br>Condition提供的行为或者语义和Object的monitor可以是不一样的，比如通知的确定性的排序，或者执行通知的时候不要求持有锁，如果实现实现了这样的语义，那么不需要在文档里边指明。</p>
<p>Condition仅仅是普通的对象，他们自己也可以作为synchronized的目标，可以有他们自己的wait和notify方法，获取Condition实例的监视器锁或者使用监视器方法和获取Condition绑定的锁以及使用Condition的waiting和signalling方法没有任何关联。推荐避免使用Condition的实例的监视器相关方式，除非是在他们自己的实现当中。</p>
<p>除非有说明，Condition的任何null的参数都会抛出NullPointerException 异常。</p>
<h5 id="实现上的考量"><a href="#实现上的考量" class="headerlink" title="实现上的考量"></a>实现上的考量</h5><p>在等待条件发生的时候，一种假的唤醒是允许发生的，通常作为一种所属平台的语义，这对大多数的应用程序不会产生实际的影响，Condition通常会在一个while循环当中去等待，测试等待的条件是否被满足。<br>三种条件的等待(可中断，不可中断，超时)在一些平台的实现是不一样的，我们很难实现这些语义的。<br>每一个实现要在文档中说明它所实现的语气。<br>略。</p>
<h3 id="Condition-await"><a href="#Condition-await" class="headerlink" title="Condition.await()"></a>Condition.await()</h3><p>Causes the current thread to wait until it is signalled or interrupted.<br>The lock associated with this Condition is atomically released and the current thread becomes disabled for thread scheduling purposes and lies dormant until one of four things happens:<br>Some other thread invokes the signal method for this Condition and the current thread happens to be chosen as the thread to be awakened; or<br>Some other thread invokes the signalAll method for this Condition; or<br>Some other thread interrupts the current thread, and interruption of thread suspension is supported; or<br>A “spurious wakeup” occurs.<br>In all cases, before this method can return the current thread must re-acquire the lock associated with this condition. When the thread returns it is guaranteed to hold this lock.<br>If the current thread:<br>has its interrupted status set on entry to this method; or<br>is interrupted while waiting and interruption of thread suspension is supported,<br>then InterruptedException is thrown and the current thread’s interrupted status is cleared. It is not specified, in the first case, whether or not the test for interruption occurs before the lock is released.<br>Implementation Considerations<br>The current thread is assumed to hold the lock associated with this Condition when this method is called. It is up to the implementation to determine if this is the case and if not, how to respond. Typically, an exception will be thrown (such as IllegalMonitorStateException) and the implementation must document that fact.<br>An implementation can favor responding to an interrupt over normal method return in response to a signal. In that case the implementation must ensure that the signal is redirected to another waiting thread, if there is one.<br>让当前线程挂起，直到被唤醒或者被中断。<br>和当前Condition关联到的锁自动释放，当前的线程无法得到调度，进入休眠状态，直到如下四个条件发生：</p>
<ul>
<li>其他线程调用了当前Condition的signal方法，并且当前线程被选中被唤醒。</li>
<li>其他线程调用了Condition的signalAll；</li>
<li>其他的线程中断了当前线程，并且线程中断和挂起是被支持的；</li>
<li>假唤醒发生；</li>
</ul>
<p>在所有的情况当中，在方法返回之前，当前线程必须要重新获取到Condition关联的锁，当线程返回的时候，确保线程持有锁。</p>
<p>如果当前线程满足：</p>
<ul>
<li>当前线程在进入这个方法之前设置了中断状态，或者</li>
<li>在等待的时候被中断，并且中断和挂起是被支持的。<br>InterruptedException异常将会抛出，当前线程的中断状态将会被清除。</li>
</ul>
<h3 id="Condition-awaitUninterruptibly"><a href="#Condition-awaitUninterruptibly" class="headerlink" title="Condition.awaitUninterruptibly()"></a>Condition.awaitUninterruptibly()</h3><p>等待，不可中断<br>Causes the current thread to wait until it is signalled.<br>The lock associated with this condition is atomically released and the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:<br>Some other thread invokes the signal method for this Condition and the current thread happens to be chosen as the thread to be awakened; or<br>Some other thread invokes the signalAll method for this Condition; or<br>A “spurious wakeup” occurs.<br>In all cases, before this method can return the current thread must re-acquire the lock associated with this condition. When the thread returns it is guaranteed to hold this lock.<br>If the current thread’s interrupted status is set when it enters this method, or it is interrupted while waiting, it will continue to wait until signalled. When it finally returns from this method its interrupted status will still be set.<br>让当前线程挂起，直到被唤醒<br>和当前Condition关联到的锁自动释放，当前的线程无法得到调度，进入休眠状态，直到如下四个条件发生：</p>
<ul>
<li>其他线程调用了当前Condition的signal方法，并且当前线程被选中被唤醒。</li>
<li>其他线程调用了Condition的signalAll；</li>
<li>假唤醒发生；</li>
</ul>
<p>在所有的情况当中，在方法返回之前，当前线程必须要重新获取到Condition关联的锁，当线程返回的时候，确保线程持有锁。</p>
<h3 id="long-Condition-awaitNanos-long-nanosTimeout"><a href="#long-Condition-awaitNanos-long-nanosTimeout" class="headerlink" title="long Condition.awaitNanos(long nanosTimeout)"></a>long Condition.awaitNanos(long nanosTimeout)</h3><p>等待纳秒时间<br>让当前线程挂起，直到被唤醒或者被中断，或者指定的时间已经过去了。<br>返回结果的long值的意义：比我我们的nanosTimeout是500，但是我们等了300就返回了，那么返回的long是200，就是剩余的时间。<br>如果返回值是小于等于0，就是超时了，在给定的时间并没有返回，可以重新去等待。<br>为了减少误差参数使用了纳秒，减少误差。</p>
<h3 id="boolean-await-long-time-TimeUnit-unit"><a href="#boolean-await-long-time-TimeUnit-unit" class="headerlink" title="boolean await(long time, TimeUnit unit)"></a>boolean await(long time, TimeUnit unit)</h3><h3 id="boolean-awaitUntil-Date-deadline"><a href="#boolean-awaitUntil-Date-deadline" class="headerlink" title="boolean awaitUntil(Date deadline)"></a>boolean awaitUntil(Date deadline)</h3><p>指定在未来的一个时间作为超时的判定</p>
<h3 id="void-signal"><a href="#void-signal" class="headerlink" title="void signal()"></a>void signal()</h3><p>Wakes up one waiting thread.<br>If any threads are waiting on this condition then one is selected for waking up. That thread must then re-acquire the lock before returning from await.<br>唤醒一个等待的线程。</p>
<p>如果有多个线程在condition等待，那么就选择一个去唤醒，被唤醒的线程在从wait方法返回之前必须要重新获取到锁。</p>
<h3 id="void-signalAll"><a href="#void-signalAll" class="headerlink" title="void signalAll()"></a>void signalAll()</h3><p>Wakes up all waiting threads.<br>If any threads are waiting on this condition then they are all woken up. Each thread must re-acquire the lock before it can return from await.</p>
<p>唤醒所有的等待线程，每个线程在从wait方法返回之前必须重新获取到锁。</p>
<p>注意被唤醒和继续执行是不一样的，有10个线程同时等待在一个Condition上，第11个线程调用了Condition的signalAll方法，那么另外的等待的10个线程只有一个拿到锁，并且继续执行，剩余的9个都在轮询获取锁的过程之中，并没有得到执行。</p>
<h3 id="通过Condition实现线程间通信实例剖析"><a href="#通过Condition实现线程间通信实例剖析" class="headerlink" title="通过Condition实现线程间通信实例剖析"></a>通过Condition实现线程间通信实例剖析</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BoundedContainer boundedContainer = new BoundedContainer();</span><br><span class="line">        IntStream.range(0,10).forEach(i -&gt; new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                boundedContainer.put(&quot;hello&quot;+i);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start());</span><br><span class="line"></span><br><span class="line">        IntStream.range(0,10).forEach(i -&gt; new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                boundedContainer.take();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BoundedContainer &#123;</span><br><span class="line"></span><br><span class="line">    private String[] elements = new String[10];</span><br><span class="line"></span><br><span class="line">    private Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    private Condition notEmptyCondition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    private Condition notFullCondition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    private int elementCount;//elements数组中已有元素数量</span><br><span class="line"></span><br><span class="line">    private int putIndex;</span><br><span class="line"></span><br><span class="line">    private int takeIndex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void put(String element) throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try&#123;</span><br><span class="line">            while (elementCount == elements.length)&#123;</span><br><span class="line">                notFullCondition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            elements[putIndex] = element;</span><br><span class="line">            if(++putIndex == elements.length)&#123;</span><br><span class="line">                putIndex = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            ++elementCount;</span><br><span class="line">            System.out.println(&quot;put method :&quot; + Arrays.toString(elements));</span><br><span class="line">            notEmptyCondition.signal();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String take() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        String element;</span><br><span class="line">        try&#123;</span><br><span class="line">            while (elementCount == 0)&#123;</span><br><span class="line">                notEmptyCondition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            element = elements[takeIndex];</span><br><span class="line">            elements[takeIndex] = null;</span><br><span class="line">            if(++takeIndex == elements.length)&#123;</span><br><span class="line">                takeIndex = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            --elementCount;</span><br><span class="line">            System.out.println(&quot;take method :&quot; + Arrays.toString(elements));</span><br><span class="line">            notFullCondition.signal();</span><br><span class="line">            return element;</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">put method :[hello0, null, null, null, null, null, null, null, null, null]</span><br><span class="line">put method :[hello0, hello7, null, null, null, null, null, null, null, null]</span><br><span class="line">put method :[hello0, hello7, hello8, null, null, null, null, null, null, null]</span><br><span class="line">put method :[hello0, hello7, hello8, hello1, null, null, null, null, null, null]</span><br><span class="line">put method :[hello0, hello7, hello8, hello1, hello2, null, null, null, null, null]</span><br><span class="line">put method :[hello0, hello7, hello8, hello1, hello2, hello3, null, null, null, null]</span><br><span class="line">put method :[hello0, hello7, hello8, hello1, hello2, hello3, hello4, null, null, null]</span><br><span class="line">put method :[hello0, hello7, hello8, hello1, hello2, hello3, hello4, hello6, null, null]</span><br><span class="line">put method :[hello0, hello7, hello8, hello1, hello2, hello3, hello4, hello6, hello5, null]</span><br><span class="line">put method :[hello0, hello7, hello8, hello1, hello2, hello3, hello4, hello6, hello5, hello9]</span><br><span class="line">take method :[null, hello7, hello8, hello1, hello2, hello3, hello4, hello6, hello5, hello9]</span><br><span class="line">take method :[null, null, hello8, hello1, hello2, hello3, hello4, hello6, hello5, hello9]</span><br><span class="line">take method :[null, null, null, hello1, hello2, hello3, hello4, hello6, hello5, hello9]</span><br><span class="line">take method :[null, null, null, null, hello2, hello3, hello4, hello6, hello5, hello9]</span><br><span class="line">take method :[null, null, null, null, null, hello3, hello4, hello6, hello5, hello9]</span><br><span class="line">take method :[null, null, null, null, null, null, hello4, hello6, hello5, hello9]</span><br><span class="line">take method :[null, null, null, null, null, null, null, hello6, hello5, hello9]</span><br><span class="line">take method :[null, null, null, null, null, null, null, null, hello5, hello9]</span><br><span class="line">take method :[null, null, null, null, null, null, null, null, null, hello9]</span><br><span class="line">take method :[null, null, null, null, null, null, null, null, null, null]</span><br></pre></td></tr></table></figure>

<p>修改main方法执行顺序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BoundedContainer boundedContainer = new BoundedContainer();</span><br><span class="line">IntStream.range(0,10).forEach(i -&gt; new Thread(() -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        boundedContainer.take();</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start());</span><br><span class="line">IntStream.range(0,10).forEach(i -&gt; new Thread(() -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        boundedContainer.put(&quot;hello&quot;+i);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start());</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">put method :[hello0, null, null, null, null, null, null, null, null, null]</span><br><span class="line">put method :[hello0, hello1, null, null, null, null, null, null, null, null]</span><br><span class="line">put method :[hello0, hello1, hello2, null, null, null, null, null, null, null]</span><br><span class="line">put method :[hello0, hello1, hello2, hello3, null, null, null, null, null, null]</span><br><span class="line">put method :[hello0, hello1, hello2, hello3, hello4, null, null, null, null, null]</span><br><span class="line">put method :[hello0, hello1, hello2, hello3, hello4, hello6, null, null, null, null]</span><br><span class="line">put method :[hello0, hello1, hello2, hello3, hello4, hello6, hello5, null, null, null]</span><br><span class="line">put method :[hello0, hello1, hello2, hello3, hello4, hello6, hello5, hello7, null, null]</span><br><span class="line">take method :[null, hello1, hello2, hello3, hello4, hello6, hello5, hello7, null, null]</span><br><span class="line">put method :[null, hello1, hello2, hello3, hello4, hello6, hello5, hello7, hello8, null]</span><br><span class="line">take method :[null, null, hello2, hello3, hello4, hello6, hello5, hello7, hello8, null]</span><br><span class="line">put method :[null, null, hello2, hello3, hello4, hello6, hello5, hello7, hello8, hello9]</span><br><span class="line">take method :[null, null, null, hello3, hello4, hello6, hello5, hello7, hello8, hello9]</span><br><span class="line">take method :[null, null, null, null, hello4, hello6, hello5, hello7, hello8, hello9]</span><br><span class="line">take method :[null, null, null, null, null, hello6, hello5, hello7, hello8, hello9]</span><br><span class="line">take method :[null, null, null, null, null, null, hello5, hello7, hello8, hello9]</span><br><span class="line">take method :[null, null, null, null, null, null, null, hello7, hello8, hello9]</span><br><span class="line">take method :[null, null, null, null, null, null, null, null, hello8, hello9]</span><br><span class="line">take method :[null, null, null, null, null, null, null, null, null, hello9]</span><br><span class="line">take method :[null, null, null, null, null, null, null, null, null, null]</span><br></pre></td></tr></table></figure>
<p>由于先执行的take线程，但是没有元素会一直wait，直到put线程生成元素之后，take线程才会得到执行，但是和take线程争夺所资源的还有put线程。</p>
<p>如果线程数量大于数组的长度10，也会在put方法的while方法上等待，直到可以put为止。</p>
<p>如果put线程数量小于take线程数量，那么程序不会结束，因为take线程会阻塞在while循环上面，直到有数据可以取出，但是put线程都已经完毕了，不会有元素添加，那么take线程会一直阻塞下去。</p>
]]></content>
      <categories>
        <category>concurrency</category>
      </categories>
      <tags>
        <tag>Condition Lock</tag>
      </tags>
  </entry>
  <entry>
    <title>concurrency(5)Lock锁方法原理详解以及与Synchronized关键字差别</title>
    <url>/2020/01/04/Concurrent/concurrency(5)Lock%E9%94%81%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E4%B8%8ESynchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%B7%AE%E5%88%AB/</url>
    <content><![CDATA[<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><span id="more"></span>
<p>可重入锁的example：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest1 &#123;</span><br><span class="line">    private Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public void myMethod1() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(&quot;myMethod1 invoked&quot;);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void myMethod2() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(&quot;myMethod2 invoked&quot;);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyTest1 myTest1 = new MyTest1();</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">            for(int i = 0;i&lt;10;i++)&#123;</span><br><span class="line">                myTest1.myMethod1();</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(2000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">            for(int i = 0;i&lt;10;i++)&#123;</span><br><span class="line">                myTest1.myMethod2();</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(300);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myMethod1 invoked</span><br><span class="line">myMethod2 invoked</span><br><span class="line">myMethod2 invoked</span><br><span class="line">myMethod2 invoked</span><br><span class="line">myMethod2 invoked</span><br><span class="line">myMethod2 invoked</span><br><span class="line">myMethod2 invoked</span><br><span class="line">myMethod2 invoked</span><br><span class="line">myMethod1 invoked</span><br><span class="line">myMethod2 invoked</span><br><span class="line">myMethod2 invoked</span><br><span class="line">myMethod2 invoked</span><br><span class="line">myMethod1 invoked</span><br><span class="line">myMethod1 invoked</span><br><span class="line">myMethod1 invoked</span><br><span class="line">myMethod1 invoked</span><br><span class="line">myMethod1 invoked</span><br><span class="line">myMethod1 invoked</span><br><span class="line">myMethod1 invoked</span><br><span class="line">myMethod1 invoked</span><br></pre></td></tr></table></figure>
<p>如果我们把myMethod1方法里边的  lock.unlock();注释掉。然后再去运行得到的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myMethod1 invoked</span><br><span class="line">myMethod1 invoked</span><br><span class="line">myMethod1 invoked</span><br><span class="line">myMethod1 invoked</span><br><span class="line">myMethod1 invoked</span><br><span class="line">myMethod1 invoked</span><br><span class="line">myMethod1 invoked</span><br><span class="line">myMethod1 invoked</span><br><span class="line">myMethod1 invoked</span><br><span class="line">myMethod1 invoked</span><br></pre></td></tr></table></figure>
<p>myMethod1打印了10次，但是程序还是没有退出。<br>原因是线程t1使用了ReentrantLock可重入，但是没有解锁，导致线程t2一致无法获取到锁，t1由于可以重入，所以打印了10次，而t2一直在等待获取到锁，程序一直没有结束。</p>
<p>再次改造,这次我们使用tryLock：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest1 &#123;</span><br><span class="line">    private Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public void myMethod1() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(&quot;myMethod1 invoked&quot;);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">          //  lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void myMethod2() &#123;</span><br><span class="line">        boolean result = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            result = lock.tryLock(800, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        if(result)&#123;</span><br><span class="line">            System.out.println(&quot;get the lock&quot;);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            System.out.println(&quot;can`t get the lock&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyTest1 myTest1 = new MyTest1();</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">            for(int i = 0;i&lt;10;i++)&#123;</span><br><span class="line">                myTest1.myMethod1();</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(2000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">            for(int i = 0;i&lt;10;i++)&#123;</span><br><span class="line">                myTest1.myMethod2();</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(300);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">myMethod1 invoked</span><br><span class="line">can`t get the lock</span><br><span class="line">can`t get the lock</span><br><span class="line">myMethod1 invoked</span><br><span class="line">can`t get the lock</span><br><span class="line">myMethod1 invoked</span><br><span class="line">can`t get the lock</span><br><span class="line">can`t get the lock</span><br><span class="line">myMethod1 invoked</span><br><span class="line">can`t get the lock</span><br><span class="line">can`t get the lock</span><br><span class="line">myMethod1 invoked</span><br><span class="line">can`t get the lock</span><br><span class="line">can`t get the lock</span><br><span class="line">myMethod1 invoked</span><br><span class="line">can`t get the lock</span><br><span class="line">myMethod1 invoked</span><br><span class="line">myMethod1 invoked</span><br><span class="line">myMethod1 invoked</span><br><span class="line">myMethod1 invoked</span><br></pre></td></tr></table></figure>
<p>这个时候t2就不会出现阻塞。</p>
<h3 id="关于Lock和Synchronized关键字在锁的处理方式的重要差别"><a href="#关于Lock和Synchronized关键字在锁的处理方式的重要差别" class="headerlink" title="关于Lock和Synchronized关键字在锁的处理方式的重要差别"></a>关于Lock和Synchronized关键字在锁的处理方式的重要差别</h3><ul>
<li>锁的获取方式： 前者是通过程序代码的方式由开发者手工获取，后者是通过jvm来获取（无需开发者干预）</li>
<li>具体实现方式：前者是通过java代码的方式来实现，后者是通过jvm底层来实现（无需开发者关注）</li>
<li>锁的释放方式：前者务必通过unlock()方法在finally块中手工释放，后者通过jvm来释放（无需开发者关注）</li>
<li>锁的具体类型：前者提供了多种，如公平锁，非公平锁，后者与前者均提供了可重入性。</li>
</ul>
]]></content>
      <categories>
        <category>concurrency</category>
      </categories>
      <tags>
        <tag>concurrency Lock</tag>
      </tags>
  </entry>
  <entry>
    <title>concurrency(8)CountDownLatch和CyclicBarrier</title>
    <url>/2020/05/05/Concurrent/concurrency(8)CountDownLatch%E5%92%8CCyclicBarrier/</url>
    <content><![CDATA[<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>exanple1:主线程等待3个子线程执行完毕，主线程才继续执行</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CountDownLatch countDownLatch  =  new CountDownLatch(3);</span><br><span class="line">        IntStream.range(0,3).forEach(i -&gt; new Thread(() -&gt;&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">                System.out.println(&quot;hello&quot;);</span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;finally &#123;</span><br><span class="line">              //countDown有减计数器和触发的作用</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">        System.out.println(&quot;启动子线程完毕&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;主线程执行完毕&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：<br>启动子线程完<br>hello<br>hello<br>hello<br>主线程执行完</p>
<p>打开CountDownLatch的await方法：<br>Causes the current thread to wait until the latch has counted down to zero, unless the thread is interrupted.<br>线程等待直到计数器 白为零，或者被中断。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void await() throws InterruptedException &#123;</span><br><span class="line">     sync.acquireSharedInterruptibly(1);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>AbstractQueuedSynchronizer</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CountDownLatch.Sync重写了tryAcquireShared方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">            return (getState() == 0) ? 1 : -1;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>如果tryAcquireShared返回-1那么执行doAcquireSharedInterruptibly，doAcquireSharedInterruptibly会进行阻塞，否则acquireSharedInterruptibly执行完毕，如果acquireSharedInterruptibly执行完毕意味着示例的主线程继续执行。</p>
<p>CountDownLatch的countDown方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void countDown() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即，对计数器减一。<br>AbstractQueuedSynchronizer:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">      //某一个子线程判断计数器变为了0（tryReleaseShared方法返回true），那么这个线程会唤醒被wait的线程，这里主线程在wait，///那么主线程会被唤醒。</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tryReleaseShared被重写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    // Decrement count; signal when transition to zero</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = getState();</span><br><span class="line">        if (c == 0)</span><br><span class="line">        //计数器已经归零，不需要再减</span><br><span class="line">            return false;</span><br><span class="line">        int nextc = c-1;</span><br><span class="line">        if (compareAndSetState(c, nextc))</span><br><span class="line">        //减一之后是否为0</span><br><span class="line">            return nextc == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CountDownLatch是一次性的。</p>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>等待3个线程都达到一个屏障，然后同时一块执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface MyTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = new CyclicBarrier(3);</span><br><span class="line">        for(int i=0;i&lt;3;i++)&#123;</span><br><span class="line">            new Thread(() -&gt;&#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    Thread.sleep((long )Math.random()*2000);</span><br><span class="line">                    int random = new Random().nextInt(500);</span><br><span class="line">                    System.out.println(&quot;hello&quot; + random);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    System.out.println(&quot;world&quot; + random);</span><br><span class="line">                &#125;catch (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>hello19<br>hello135<br>hello169<br>world169<br>world19<br>world135</p>
<p>CyclicBarrier是可以重复使用的。因为CyclicBarrier的所有线程冲破屏障之后，会将计数器重置为3.<br>重用实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public interface MyTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = new CyclicBarrier(3);</span><br><span class="line">        for(int i=0;i&lt;2;i++)&#123;   //重用2次</span><br><span class="line">            for(int n=0;n&lt;3;n++)&#123;//每次等待3个线程</span><br><span class="line">                new Thread(() -&gt;&#123;</span><br><span class="line">                    try&#123;</span><br><span class="line">                        Thread.sleep((long )Math.random()*2000);</span><br><span class="line">                        int random = new Random().nextInt(500);</span><br><span class="line">                        System.out.println(&quot;hello&quot;+ random);</span><br><span class="line">                        cyclicBarrier.await();</span><br><span class="line">                        System.out.println(&quot;world&quot;+random);</span><br><span class="line">                    &#125;catch (Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br>hello388<br>hello446<br>hello66<br>hello119<br>hello188<br>hello362<br>world362<br>world66<br>world388<br>world188<br>world119<br>world446</p>
<p>另一个构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CyclicBarrier cyclicBarrier = new CyclicBarrier(3, ()-&gt;&#123;</span><br><span class="line">           System.out.println(&quot;hello wold..........&quot;);</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>
<p>第二个参数是一个runnable，当所有的线程到达屏障的时候，就会执行这个runnable。</p>
<p>CyclicBarrier的await方法还有一个带超时时间的await方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int await(long timeout, TimeUnit unit)</span><br><span class="line">    throws InterruptedException,</span><br><span class="line">           BrokenBarrierException,</span><br><span class="line">           TimeoutException &#123;</span><br><span class="line">    return dowait(true, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果超时，那么屏障就会破坏掉，同时抛出BrokenBarrierException，await方法后边的代码不会执行，而CountDownLatch的await方法超时会继续执行。</p>
<p>另外看一下构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private final int parties;</span><br><span class="line">private int count;</span><br><span class="line">public CyclicBarrier(int parties, Runnable barrierAction) &#123;</span><br><span class="line">    if (parties &lt;= 0) throw new IllegalArgumentException();</span><br><span class="line">    this.parties = parties;</span><br><span class="line">    this.count = parties;</span><br><span class="line">    this.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CyclicBarrier里边有parties和count同时被参数parties赋值，目的是：parties是不可变的final的，如果一轮屏障使用完毕，复用CyclicBarrier的时候，会重新赋值给count，而count是一个计数器，会随时改变。</p>
<h4 id="Generation"><a href="#Generation" class="headerlink" title="Generation"></a>Generation</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static class Generation &#123;</span><br><span class="line">    boolean broken = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来分代的，冲破屏障的时候，意味着进入了下一代的运作。broken会重置。</p>
<h4 id="CyclicBarrier的dowait"><a href="#CyclicBarrier的dowait" class="headerlink" title="CyclicBarrier的dowait"></a>CyclicBarrier的dowait</h4><p>  dowait是CyclicBarrier的await方法调用的方法，也是CyclicBarrier的核心逻辑都在这个dowait里边。<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Main barrier code, covering the various policies.</span><br><span class="line">    */</span><br><span class="line">   private int dowait(boolean timed, long nanos)</span><br><span class="line">       throws InterruptedException, BrokenBarrierException,</span><br><span class="line">              TimeoutException &#123;</span><br><span class="line">                / 获取锁/</span><br><span class="line">       final ReentrantLock lock = this.lock;</span><br><span class="line">       lock.lock();</span><br><span class="line">       try &#123;</span><br><span class="line">           final Generation g = generation;</span><br><span class="line"></span><br><span class="line">           if (g.broken)</span><br><span class="line">               throw new BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">           if (Thread.interrupted()) &#123;</span><br><span class="line">               breakBarrier();</span><br><span class="line">               throw new InterruptedException();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           int index = --count;</span><br><span class="line">           //count==0意味着最后一个线程的到来</span><br><span class="line">           if (index == 0) &#123;  // tripped 所有的线程都已经到达屏障</span><br><span class="line">             //是否执行完命令</span><br><span class="line">               boolean ranAction = false;</span><br><span class="line">               try &#123;</span><br><span class="line">                   final Runnable command = barrierCommand;</span><br><span class="line">                   if (command != null)</span><br><span class="line">                      //执行构造器传递的Runnable</span><br><span class="line">                       command.run();</span><br><span class="line">                   ranAction = true;</span><br><span class="line">                   //</span><br><span class="line">                   nextGeneration();</span><br><span class="line">                   /**</span><br><span class="line">                   *private void nextGeneration() &#123;</span><br><span class="line">                   *    // signal completion of last generation</span><br><span class="line">                   *    当最后一个线程没有达到之前，当前到达屏障的线程都在等待trip上，当最后一个线程来了之后</span><br><span class="line">                   *    trip就会唤醒所有等待在屏障的线程继续执行。</span><br><span class="line">                   *    trip.signalAll();</span><br><span class="line">                   *     // set up next generation</span><br><span class="line">                   *    count = parties;</span><br><span class="line">                   *     generation = new Generation();</span><br><span class="line">                   * &#125;</span><br><span class="line">                   */</span><br><span class="line">                   return 0;</span><br><span class="line">               &#125; finally &#123;</span><br><span class="line">                   if (!ranAction)</span><br><span class="line">                       breakBarrier();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // loop until tripped, broken, interrupted, or timed out</span><br><span class="line">           // 非最后一个线程的到来需要等待，直到屏障被冲破，或者终止，线程中断，以及超时才会退出</span><br><span class="line">           for (;;) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   //是否配置了超时时间</span><br><span class="line">                   if (!timed)</span><br><span class="line">                   //没有配置超时时间，直接等待</span><br><span class="line">                       trip.await();</span><br><span class="line">                   else if (nanos &gt; 0L)</span><br><span class="line">                   //配置了超时时间，调用trip的awaitNanos方法</span><br><span class="line">                       nanos = trip.awaitNanos(nanos);</span><br><span class="line">               &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                   if (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                       breakBarrier();</span><br><span class="line">                       throw ie;</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       // We&#x27;re about to finish waiting even if we had not</span><br><span class="line">                       // been interrupted, so this interrupt is deemed to</span><br><span class="line">                       // &quot;belong&quot; to subsequent execution.</span><br><span class="line">                       Thread.currentThread().interrupt();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (g.broken)</span><br><span class="line">                   throw new BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">               if (g != generation)</span><br><span class="line">                   return index;</span><br><span class="line"></span><br><span class="line">               if (timed &amp;&amp; nanos &lt;= 0L) &#123;</span><br><span class="line">                   breakBarrier();</span><br><span class="line">                   throw new TimeoutException();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">         //解锁</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>关于CyclicBarrier的底层执行流程：</p>
<ol>
<li>初始化CyclicBarrier中的各种成员变量，包括parties、count以及Runnable（可选）</li>
<li>当调用await方法时，底层会先检查计数器是否已经归零，如果是的话，那么就首先执行可选的Runnable，接下来开始下一个genaration;</li>
<li>在下一个分代中，将会重置count值为parties，，唤醒所有在屏障前面等待的线程，让其开始等待执行。</li>
<li>如果计数器没有归零，那么当前的调用线程就会通过Condation方法，在屏障前进行等待。</li>
<li>以上 所有执行流程均在lock锁的控制范围内，不会出现并发情况。</li>
</ol>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><img src="/CountDownLatch-CyclicBarrier.png" alt="CountDownLatch-CyclicBarrier.png"></p>
]]></content>
      <categories>
        <category>concurrency</category>
      </categories>
      <tags>
        <tag>CountDownLatch CyclicBarrier</tag>
      </tags>
  </entry>
  <entry>
    <title>concurrency(7)volatile关键字作用与锁的关系以及内存屏障语义</title>
    <url>/2020/05/04/Concurrent/concurrency(7)volatile%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%9C%E7%94%A8%E4%B8%8E%E9%94%81%E7%9A%84%E5%85%B3%E7%B3%BB%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E8%AF%AD%E4%B9%89/</url>
    <content><![CDATA[<h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><p>volatile英文翻译：易变的，挥发物，不稳定的</p>
<span id="more"></span>
<h4 id="volatile的三个方面的作用："><a href="#volatile的三个方面的作用：" class="headerlink" title="volatile的三个方面的作用："></a>volatile的三个方面的作用：</h4><ul>
<li><p>实现long&#x2F;double类型变量的原子操作<br>valatile double a &#x3D; 1.0<br>64位的double和long的在写写和写读的时候存在中间状态，其他线程会读到这种中间状态，volatile可以让其成为原子操作。<br>volatile可以确保对变量写操作的原子性，但是不具备排他性，另外的重要一点在于：使用锁可能会导致线程上下文切换（内核态与用户态的切换），但是使用volatile比不会出现这种情况。<br>volatile int a &#x3D; b + 2; 这种情况不会保证a操作的原子性，因为可能2个线程对b 的取值会不同，即使b也是被volatile修饰也是不行的，也会存在多线程操作的场景，因此volatile不要以这种形式使用。<br>volatile int a &#x3D; a++; 也是不行的。<br>如下2中方式推荐的，符合volatile的底层的原理：<br>volatile int count &#x3D; 1;<br>volatile boolean flag &#x3D; false;</p>
<p>如果要实现volatile写操作的原子性，那么在等号右侧的赋值变量中就不能出现被多线程所共享的变量，哪怕这个变量也是个volatile也是不可以。<br>volatile Date date &#x3D; new Date();这样也是不行的，因为创建Date对象首先在堆里边创建对象，第二步是将堆的地址赋值给date变量，也不是原子性的，它只能保证堆地址赋值给date变量是原子性的。</p>
</li>
<li><p>防止指令重排序<br>在多线程的情况下，指令重排序会带来临界资源访问混乱问题，出现错乱。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">String a = &quot;hello&quot;;</span><br><span class="line">内存屏障(Release Barrier,释放屏障)</span><br><span class="line">volatile boolean v = false; //写入操作</span><br><span class="line">内存屏障(Store Barrier，存储屏障)</span><br><span class="line"></span><br><span class="line">内存屏障(Load Barrier,加载屏障)</span><br><span class="line">boolean v1 = v; // 保证v是最新的</span><br><span class="line">内存屏障(Acquire Barrier,获取屏障)</span><br><span class="line">int a = 1;</span><br><span class="line">String a = &quot;hello&quot;;</span><br></pre></td></tr></table></figure>
<p>Release Barrier：防止下面的volatile与上面的所有操作的指令重排序。volatile写操作以上的所有指令被发布，其他的线程得到共享变量都是volatile写之前的状态，防止了指令重排序。<br>Store Barrier： 重要的作用是刷新处理器的缓存，结果是可以确保该存储屏障之前的操作所生成的结果对于其他处理器来说都可见。</p>
<p>Load Barrier: 可以刷新处理器缓存，同步其他处理器对该volatile变量的修改结果。<br>PS：Store Barrier和Load Barrier一般搭配使用，刷新处理器缓存存储完毕之后就能立马加载过来，这两个屏障一起保证了数据在多处理器之间是可见的。<br>Acquire Barrier: 可以防止上面的volatile读取操作与下面的所有操作语句的指令重排序。<br>PS： Acquire Barrier和Release Barrier一般搭配使用，这两个屏障一起保证了临界区中的任何读写操作不可能被重排序到临界区之外。</p>
<p>对于volatile关键字变量的读写操作，本质上都是通过内存屏障来执行的。<br>内存屏障兼具了两方面能力：1. 防止指令重排序；2. 实现变量内存的可见性.</p>
<ol>
<li>对于读取操作，volatile可以确保该操作与其后续的所有读写操作都不会进行指令重排序。</li>
<li>对于修改操作来说，volatile可以确保该操作与其上面的所有读写操作都不会进行指令重排序。<br>PS：先读后写<br><strong>以上的屏障对于原生类型是可以的，但是对于引用类型来说是不适用的。</strong><br>比如对于一个被volatile修饰的集合对象的检索并且赋值这个过程volatile是不能保证防止其内存重排序的，但是一个集合类型的引用赋值给另一个集合类型的引用这个操作是可以防止指令重排序的。</li>
</ol>
</li>
<li><p>实现变量的可见性<br>当使用volatile修饰变量时，应用就不会从寄存器中获取该变量的值，而是从内存(高速缓存)中获取。</p>
<p><strong>防止指令重排序与实现变量可见性都是通过一种手段来实现的：内存屏障(memory barrier)</strong></p>
</li>
</ul>
<h3 id="volatile和锁"><a href="#volatile和锁" class="headerlink" title="volatile和锁"></a>volatile和锁</h3><p>volatile不是排他的，而锁是可以排他的，对一个volatile的写是可以同时多个线程进行的，只不过volatile能保证原子性而已。</p>
<h4 id="volatile和锁的相似的两个地方："><a href="#volatile和锁的相似的两个地方：" class="headerlink" title="volatile和锁的相似的两个地方："></a>volatile和锁的相似的两个地方：</h4><ul>
<li>确保变量的内存可见性</li>
<li>防止指令重排序</li>
</ul>
<p><strong>锁同样具备变量内存可见性与防止指令重排序的功能。</strong><br>monitorenter<br>  内存屏障(Acquire Barrier,获取屏障)<br>  ……<br>  内存屏障(Release Barrier,释放屏障)<br>monitorexit</p>
<p>进入monitorenter之后插入一个Acquire Barrier取得缓存当中变量最新的值;<br>在monitorexit之前插入Release Barrier，刷新处理器的缓存，使得其他的处理器能看到当前处理器对变量的修改</p>
<p>使用volatile的性能会有所消耗，如果没有使用volatile关键字，取值会从寄存器里边取出，而使用了volatile会去内存里边取值，内存的速度肯定比寄存器的速度慢，所以使用volatile的性能会有所损耗。</p>
<h3 id="JMM与happen-befor规则"><a href="#JMM与happen-befor规则" class="headerlink" title="JMM与happen-befor规则"></a>JMM与happen-befor规则</h3><ol>
<li>变量的原子性问题</li>
<li>变量的可见性问题</li>
<li>变量修改的时序问题</li>
</ol>
<h4 id="happen-befor重要规则"><a href="#happen-befor重要规则" class="headerlink" title="happen-befor重要规则"></a>happen-befor重要规则</h4><ol>
<li>顺序执行规则（限定在单个线程上的）<br>  该线程的每个动作都bappen-befor它的后面的动作。指令重排序和happen-befor是可以同时存在的。<br>  如果abc三个动作之间没有关系。a不一定必须先执行在b之前，但是如果abc之间有关系，那么肯定会防止指令重排序。</li>
<li>隐式锁(monitor)规则<br>  同一把锁，unlock一定happen-befor lock，之前的线程对于同步代码块的作用所有的执行结果对于后续获取锁的线程来说都是可见的。</li>
<li>volatile读写规则<br>  对于一个volatile变量的写操作，一定会happen-befor后续对该变量的读操作。</li>
<li>多线程的启动规则<br>  Thread对象的start方法happen-befor该线程run方法中的任何一个动作，包括在其中启动的任何子线程。</li>
<li>多线程的终止规则<br>  一个线程启动了一个子线程，并且调用了子线程的join方法等待期结束，那么当子线程结束后，父线程的接下来的所有操作都可以看到子线程run方法中的执行结果。</li>
<li>线程的中断规则<br>  可以调用interrupt方法来中断线程，这个调用happen-befor对该线程中断的检查(isInterrupted)。</li>
</ol>
]]></content>
      <categories>
        <category>concurrency</category>
      </categories>
      <tags>
        <tag>volatile 内存屏障 JMM与happen-befor规则</tag>
      </tags>
  </entry>
  <entry>
    <title>concurrency(9)CAS详解及透过字节码分析变量操作的原子性&amp;底层实现与源码剖析</title>
    <url>/2020/05/05/Concurrent/concurrency(9)CAS%E8%AF%A6%E8%A7%A3%E5%8F%8A%E9%80%8F%E8%BF%87%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%98%E9%87%8F%E6%93%8D%E4%BD%9C%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7&amp;%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><ol>
<li>synchronized关键字与lock等锁机制都是悲观锁：无论做任何操作，首先都需要先上锁，接下来再去执行后续操作，从而确保了接下来的所有操作都是由当前这个线程来执行的。<span id="more"></span>
<!-- more --></li>
<li>乐观锁：线程在操作之前不会做任何预先的处理，而是直接去执行；当在最后执行变量更新的时候，当前线程需要一种机制来确保当前被操作的变量是没有被其他线程修改的；CAS是乐观锁的一种极为重要的实现方式。</li>
</ol>
<p>CAS(Compare And Swap)<br>比较与交换：这是一个不断循环的过程，一直到变量值修改成功为止。CAS本身是有硬件指令来提供支持的，换句话说，硬件是通过一个原子指令来实现比较与交换的；因此，CAS可以确保变量操作的原子性的。<br>在IA64，x86 指令集中有 cmpxchg 指令完成 CAS 功能，在 sparc-TSO 也有 casa 指令实现，而在 ARM 和 PowerPC 架构下，则需要使用一对 ldrex&#x2F;strex 指令来完成 LL&#x2F;SC 的功能。在精简指令集的体系架构中，则通常是靠一对儿指令，如：load and reserve 和 store conditional 实现的，在大多数处理器上 CAS 都是个非常轻量级的操作，这也是其优势所在。</p>
<h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>编写一个计数器的程序，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest1 &#123;</span><br><span class="line">    private int count;</span><br><span class="line"></span><br><span class="line">    public int getCount() &#123;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void incrementCount()&#123;</span><br><span class="line">        ++this.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序在多线程的情况下会存在问题，问题就在【++this.count;】这行代码。<br>那么我们看一下这个程序incrementCount方法的字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void incrementCount();</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=3, locals=1, args_size=1</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: dup</span><br><span class="line">       2: getfield      #2                  // Field count:I 读取count的值，放到栈顶</span><br><span class="line">       5: iconst_1                          //数字1放入栈顶</span><br><span class="line">       6: iadd                              // 在当前栈顶的2个数字求和 this.count+1</span><br><span class="line">       7: putfield      #2                  // Field count:I 将加1之后的和放在栈顶，赋值给count</span><br><span class="line">      10: return</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 11: 0</span><br><span class="line">      line 12: 10</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          0      11     0  this   Lcom/twodragonlake/concurrency6/MyTest1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;读取 -&gt; 修改 -&gt; 写入: 这三个操作并非原子性<br>public void incrementCount(){<br>    ++this.count;<br>}<br><strong>怎么解决？</strong></p>
<ol>
<li>使用synchronized关键字<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public synchronized int getCount() &#123;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line">public synchronized void incrementCount()&#123;</span><br><span class="line">    ++this.count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
但这不是最佳的解决方案。<br>我们在getCount方法也加锁了，导致写的时候无法读。<br>如果我们把getCount的synchronized去掉是否可行呢？<br>也是不行的。。<br>synchronized会增加内存屏障，会将保证内存的可见性和原子性。<br>monitorenter<br>  内存屏障(Acquire Barrier,获取屏障)<br>  ……<br>  内存屏障(Release Barrier,释放屏障)<br>monitorexit<br>如果我们把getCount的synchronized去掉，那么getCount得到值可能数老的值，导致数据的不一致性。</li>
</ol>
<h3 id="CAS的操作数"><a href="#CAS的操作数" class="headerlink" title="CAS的操作数"></a>CAS的操作数</h3><p>对于CAS来说，器操作数主要涉及到如下三个：</p>
<ol>
<li>需要被操作的内存值V。</li>
<li>需要进行比较的值A。</li>
<li>需要进行写入的值B</li>
</ol>
<p>只有当V&#x3D;&#x3D;A 的时候，CAS才会通过原子操作的手段来将V的值更新为B。</p>
<p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AtomicInteger atomicInteger = new AtomicInteger(5);</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">        System.out.println(atomicInteger.getAndSet(8));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">        System.out.println(atomicInteger.getAndIncrement());</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br>5<br>5<br>8<br>8<br>9</p>
<h4 id="AtomicInteger实现"><a href="#AtomicInteger实现" class="headerlink" title="AtomicInteger实现"></a>AtomicInteger实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AtomicInteger extends Number implements java.io.Serializable &#123;</span><br><span class="line">  // Unsafe非开源的，只能在jkd内部调用</span><br><span class="line">  private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">  //值在对象里边的内存偏移量，即 value在AtomicInteger对象里边的内存偏移量。</span><br><span class="line">  private static final long valueOffset;</span><br><span class="line">  //AtomicInteger包装的数值，比如实例包装的是数字5，volatile为了保证可见性</span><br><span class="line">  private volatile int value;</span><br><span class="line"></span><br><span class="line">  public final int getAndSet(int newValue) &#123;</span><br><span class="line">    //this是AtomicInteger对象，valueOffset是偏移量，将要写入的值是newValue</span><br><span class="line">    return unsafe.getAndSetInt(this, valueOffset, newValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>unsafe的getAndAddLong：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final long getAndAddLong(Object var1, long var2, long var4) &#123;</span><br><span class="line">    long var6;</span><br><span class="line">    //循环重试【循环开销问题】</span><br><span class="line">    do &#123;</span><br><span class="line">        var6 = this.getLongVolatile(var1, var2);</span><br><span class="line">    &#125; while(!this.compareAndSwapLong(var1, var2, var6, var6 + var4));</span><br><span class="line">    return var6;</span><br><span class="line">&#125;</span><br><span class="line">//var1：我们号操作的对象，AtomicInteger对象，在C++里边就是AtomicInteger的内存位置</span><br><span class="line">//var2：要操作的变量在AtomicInteger里边内存便宜位置，即valueOffset。</span><br><span class="line">//var6：变量的预期的值</span><br><span class="line">//var6 + var4：将要写入的新的值</span><br><span class="line">// 此方法是通过一个cpu指令来完成的，是可以保证原子性。</span><br><span class="line">this.compareAndSwapLong(var1, var2, var6, var6 + var4)</span><br></pre></td></tr></table></figure>

<h4 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//构造器是私有的，不能通过new得到对象</span><br><span class="line">private Unsafe() &#123;</span><br><span class="line">&#125;</span><br><span class="line">public static Unsafe getUnsafe() &#123;</span><br><span class="line">    //获取调用此getUnsafe方法的对象的Class对象</span><br><span class="line">    Class var0 = Reflection.getCallerClass();</span><br><span class="line">    //调用者类的类加载器不是启动类加载器，则抛出异常</span><br><span class="line">    if (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">        throw new SecurityException(&quot;Unsafe&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //正常返回</span><br><span class="line">        return theUnsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CAS的限制或者问题"><a href="#CAS的限制或者问题" class="headerlink" title="CAS的限制或者问题"></a>CAS的限制或者问题</h4><ol>
<li>循环开销问题<br>  并发量大的情况会导致线程一直自旋</li>
<li>只能保证一个变量的原子操作，但是可以使用AtomicReference，来保证对象的原子操作。</li>
<li>ABA问题：从程序正确度来说是可以的，但是从CAS语义来说是不OK的，可以使用AtomicStampedReference解决，即增加了一个版本号（或者说是时间戳）来区分。</li>
</ol>
]]></content>
      <categories>
        <category>concurrency</category>
      </categories>
      <tags>
        <tag>cas</tag>
      </tags>
  </entry>
  <entry>
    <title>如何写好一篇好的技术方案</title>
    <url>/2022/06/25/architecture/how_write_a_tech_plan/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2022/06/25/5g3GeQ9nRz6f2bF.webp" alt="641.png"></p>
<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h1><p>近期在写某个项目的技术方案时，来来回回修改许多版，同时也将之前自己写的&amp;别人写的技术方案都翻出来看了几遍，其实也很苦恼，于是也产生了一个想法：为什么我们需要写技术方案？<br>总结下来无非是几点，从不同人的视角来看：</p>
<ol>
<li><p>产品-验证技术方案是否能够match上产品方案</p>
</li>
<li><p>测试-验证技术方案是否足够&amp;准确的输入写测试方案</p>
</li>
<li><p>同事&amp;leader-参与技术方案评审,验证技术方案的合理性</p>
</li>
<li><p>新人（不单单指新同学也指新接触这一块的同学）-拿到技术方案可以很快对某一块的事情熟悉起来</p>
<span id="more"></span>
<h1 id="2-什么样的技术方案是一个好的技术方案"><a href="#2-什么样的技术方案是一个好的技术方案" class="headerlink" title="2 什么样的技术方案是一个好的技术方案"></a>2 什么样的技术方案是一个好的技术方案</h1></li>
</ol>
<p>我们都知道技术方案是指导我们开发的，那么我们就分别从开发的事前、事中、事后来讨论这个问题</p>
<h2 id="1-事前"><a href="#1-事前" class="headerlink" title="1.事前"></a>1.事前</h2><h3 id="a-明确的目标——整个技术方案要达成什么目的"><a href="#a-明确的目标——整个技术方案要达成什么目的" class="headerlink" title="a.明确的目标——整个技术方案要达成什么目的"></a>a.明确的目标——整个技术方案要达成什么目的</h3><h3 id="b-低沟通成本——产品测试能从技术方案上获取足够的输入，不需要反复找你确认"><a href="#b-低沟通成本——产品测试能从技术方案上获取足够的输入，不需要反复找你确认" class="headerlink" title="b.低沟通成本——产品测试能从技术方案上获取足够的输入，不需要反复找你确认"></a>b.低沟通成本——产品测试能从技术方案上获取足够的输入，不需要反复找你确认</h3><h3 id="c-技术选型思考——为什么要这么做？和业内方案相比有什么好处和坏处，如何权衡的"><a href="#c-技术选型思考——为什么要这么做？和业内方案相比有什么好处和坏处，如何权衡的" class="headerlink" title="c.技术选型思考——为什么要这么做？和业内方案相比有什么好处和坏处，如何权衡的"></a>c.技术选型思考——为什么要这么做？和业内方案相比有什么好处和坏处，如何权衡的</h3><h2 id="2-事中"><a href="#2-事中" class="headerlink" title="2.事中"></a>2.事中</h2><h3 id="a-少调整-尽可能少的技术方案需要调整，-否则无法完成开发任务"><a href="#a-少调整-尽可能少的技术方案需要调整，-否则无法完成开发任务" class="headerlink" title="a.少调整-尽可能少的技术方案需要调整， 否则无法完成开发任务"></a>a.少调整-尽可能少的技术方案需要调整， 否则无法完成开发任务</h3><h2 id="3-事后"><a href="#3-事后" class="headerlink" title="3.事后"></a>3.事后</h2><h3 id="a-少补丁-尽可能少的bug或者遗漏"><a href="#a-少补丁-尽可能少的bug或者遗漏" class="headerlink" title="a.少补丁-尽可能少的bug或者遗漏"></a>a.少补丁-尽可能少的bug或者遗漏</h3><h3 id="b-可扩展-amp-可复用-相对简单的改动就能支持新增的需求、类似的场景可复用不需要重复开发"><a href="#b-可扩展-amp-可复用-相对简单的改动就能支持新增的需求、类似的场景可复用不需要重复开发" class="headerlink" title="b.可扩展&amp;可复用-相对简单的改动就能支持新增的需求、类似的场景可复用不需要重复开发"></a>b.可扩展&amp;可复用-相对简单的改动就能支持新增的需求、类似的场景可复用不需要重复开发</h3><p>﻿<br>一篇好的技术方案是可以贯穿整个研发的生命周期，并且起到很好的指导意义的，就如果写网络小说之前作者必须出一个大纲的逻辑是一致的。</p>
<h1 id="3-如何写好一篇好的技术方案"><a href="#3-如何写好一篇好的技术方案" class="headerlink" title="3 如何写好一篇好的技术方案"></a>3 如何写好一篇好的技术方案</h1><p>那么如何写出一篇好的技术方案呢？下面列举出笔者认为技术方案应该做到的一些点</p>
<h2 id="3-1-清晰的目标"><a href="#3-1-清晰的目标" class="headerlink" title="3.1 清晰的目标"></a>3.1 清晰的目标</h2><p>一份技术文档我认为是需要有一个清晰的目标的（业务需求建议自己总结而不是copy from prd，技术自发的那肯定得自己总结），那目标怎么来的呢？是从需求里转为过来的，那么如何将对应的需求转化为一个清晰的目标呢？我认为最重要的是要尽量定义一个可衡量的标准。需求的种类一般来说就2种，分别是</p>
<h3 id="1-产品类需求——业务方or产品方发起提给技术，包括且不限于以下几种"><a href="#1-产品类需求——业务方or产品方发起提给技术，包括且不限于以下几种" class="headerlink" title="1.产品类需求——业务方or产品方发起提给技术，包括且不限于以下几种"></a>1.产品类需求——业务方or产品方发起提给技术，包括且不限于以下几种</h3><h4 id="a-页面交互——能提升多少的运营操作效率，多少PVUV这种可量化的数字"><a href="#a-页面交互——能提升多少的运营操作效率，多少PVUV这种可量化的数字" class="headerlink" title="a.页面交互——能提升多少的运营操作效率，多少PVUV这种可量化的数字"></a>a.页面交互——能提升多少的运营操作效率，多少PVUV这种可量化的数字</h4><h4 id="b-业务sop调整——带来的业务价值是什么？是能降多少本还是提升多少时效？"><a href="#b-业务sop调整——带来的业务价值是什么？是能降多少本还是提升多少时效？" class="headerlink" title="b.业务sop调整——带来的业务价值是什么？是能降多少本还是提升多少时效？"></a>b.业务sop调整——带来的业务价值是什么？是能降多少本还是提升多少时效？</h4><h4 id="c-数据订正——订正能解决什么问题？防止多少钱未结算？又或者是防止多少客诉？"><a href="#c-数据订正——订正能解决什么问题？防止多少钱未结算？又或者是防止多少客诉？" class="headerlink" title="c.数据订正——订正能解决什么问题？防止多少钱未结算？又或者是防止多少客诉？"></a>c.数据订正——订正能解决什么问题？防止多少钱未结算？又或者是防止多少客诉？</h4><h3 id="2-技术类需求——技术自发提出，包括且不限于以下几种"><a href="#2-技术类需求——技术自发提出，包括且不限于以下几种" class="headerlink" title="2.技术类需求——技术自发提出，包括且不限于以下几种"></a>2.技术类需求——技术自发提出，包括且不限于以下几种</h3><h4 id="a-性能优化——优化多少？20-、30-还是50-？"><a href="#a-性能优化——优化多少？20-、30-还是50-？" class="headerlink" title="a.性能优化——优化多少？20%、30%还是50%？"></a>a.性能优化——优化多少？20%、30%还是50%？</h4><h4 id="b-数据隔离——隔离的范围是什么，涉及多少张表，多少数据？可以减少当前的什么问题？减少多少"><a href="#b-数据隔离——隔离的范围是什么，涉及多少张表，多少数据？可以减少当前的什么问题？减少多少" class="headerlink" title="b.数据隔离——隔离的范围是什么，涉及多少张表，多少数据？可以减少当前的什么问题？减少多少"></a>b.数据隔离——隔离的范围是什么，涉及多少张表，多少数据？可以减少当前的什么问题？减少多少</h4><h4 id="c-各种小工具——没有小工具之前是什么样？有之后是什么样？可以带来什么好处？"><a href="#c-各种小工具——没有小工具之前是什么样？有之后是什么样？可以带来什么好处？" class="headerlink" title="c.各种小工具——没有小工具之前是什么样？有之后是什么样？可以带来什么好处？"></a>c.各种小工具——没有小工具之前是什么样？有之后是什么样？可以带来什么好处？</h4><h4 id="d-研发效能提升——提升多少？有没有可以量化的指标？而不是为了做而做"><a href="#d-研发效能提升——提升多少？有没有可以量化的指标？而不是为了做而做" class="headerlink" title="d.研发效能提升——提升多少？有没有可以量化的指标？而不是为了做而做"></a>d.研发效能提升——提升多少？有没有可以量化的指标？而不是为了做而做</h4><p>﻿<br>在众多的需求当中还有一些是我们要去辨别的伪需求——不是真正的用户想要的，如用户想要将一个飞机改造成火箭，但是产品可能提过来的仅仅是把飞机的两个翅膀砍掉，那么砍掉翅膀就能变成火箭了嘛？明显不能，所以这种需求一定要注意鉴别。</p>
<h2 id="3-2-大纲图"><a href="#3-2-大纲图" class="headerlink" title="3.2 大纲图"></a>3.2 大纲图</h2><p>有句话叫“不谋全局者,不足谋一域”，在技术方案中我想也是如此。在一个技术方案中，一个大纲图是不可或缺的 ，有的人叫它技术架构图，有的人叫它数据流转图，这都不重要，重要的是我们能从这张图中看到整体的脉络，那么这张图需要有哪几个要点呢？</p>
<ol>
<li><p>图不用很细（比如加工比较复杂我们可以简单写**加工），但是要能看到全貌，具体的每个模块如果需要展开的，那么在对应的详细设计中体现即可，在这里我们关注的是整体</p>
</li>
<li><p>接口如有归属不同的应用要标明</p>
</li>
<li><p>数据存储介质不同要标明</p>
</li>
<li><p>数据流转的箭头要清晰明确</p>
</li>
<li><p>数据加工计算的输入和输出要体现，同时要体现加工的运行环境（比如到底是odps计算还是内存计算，内存计算的话是在那个应用）</p>
</li>
</ol>
<p>下面的图可供参考<br><img src="https://s2.loli.net/2022/06/25/amvlx5qMDS3coVU.jpg" alt="4d513d6abe5a254a0cded80189236b1.jpg">
﻿﻿</p>
<h2 id="3-3-模型设计"><a href="#3-3-模型设计" class="headerlink" title="3.3 模型设计"></a>3.3 模型设计</h2><p>讲到数据模型设计 那么E-R图是比不可少的 那么E-R图里应该是包含以下的信息的</p>
<ol>
<li><p>每个领域对象，如果要持久化，都有表来存储。我们设计完ER图的时候，应该根据这条原则做一番检查，避免漏掉一些表。在大型项目中，漏掉表是很常见的事情，应尽量避免。</p>
</li>
<li><p>领域对象之间的关系，如果要持久化，都要在表结构中体现。这种体现，可能是code字段，可能是外键，可能是中间表。我们设计完ER图的时候，也应该根据这条原则做一番检查，避免漏掉一些关系。在大型项目中，漏掉关系更是司空见惯，应尽量避免。</p>
</li>
<li><p>清晰定义的表名。设计ER图的时候，就要设计出清晰定义的表名。清晰定义的表名，可以帮助大家理解ER图，可以帮助大家映射回领域对象及其关系。在后续的设计和实施中，将沿用这个表名。</p>
</li>
<li><p>清晰定义的字段名、字段类型、字段长度和枚举值。很多同学容易忽略这点，他们往往清晰定义了表名，却没有重视表的字段。认真去做的时候，会发现，这里面有很多工作。例如，字段名是否合适，用什么类型好，字段长度多少合适，是否有枚举值等等，都需要一一斟酌。如果这点做好了，在实施的时候，可以避免很多麻烦，甚至避免返工。</p>
</li>
</ol>
<h2 id="3-4-对外依赖提前确认"><a href="#3-4-对外依赖提前确认" class="headerlink" title="3.4 对外依赖提前确认"></a>3.4 对外依赖提前确认</h2><p>技术方案1：需要依赖缓存、分布式调度中间件，消费外部的消息，但是没有把对应的中间件使用方式，数据格式给贴出来</p>
<p>技术方案2：需要依赖缓存、分布式调度中间件，消费外部的消息，将缓存接入的方法&amp;对应的缓存key-value设计写清楚、将分布式调度中间件接入所需要准备的依赖项梳理好、将外销消息对应的topic和数据格式列清楚</p>
<p>两个方案对比好坏其实很明显。如果一开始我们在技术方案里面将外部依赖确定好，那么我们在开发的时候就一马平川，反之如果外部依赖都不确定的情况下就进入到开发，那么返工的概率将大大增加从而降低我们的工作效率</p>
<p>那么对外的依赖有哪些以及我们要确认的都是些什么呢？下面列举了一些我们常见的一些依赖</p>
<ul>
<li><p>a.外部hsf依赖——需要确认对应hsf接口的类、方法、version，以及二方包（也可使用泛化调用）</p>
</li>
<li><p>b.外部消息依赖——需要确认消息的topic、数据格式</p>
</li>
<li><p>c.分布式调度、缓存等中间件——当前应用是否接入过改中间件，未接入需要去到官网确认接入文档，接入的话需要确认是否可以复用接入逻辑</p>
</li>
</ul>
<p>﻿</p>
<h2 id="3-5-内部前后模块依赖-amp-层次结构"><a href="#3-5-内部前后模块依赖-amp-层次结构" class="headerlink" title="3.5 内部前后模块依赖&amp;层次结构"></a>3.5 内部前后模块依赖&amp;层次结构</h2><p>首先模块依赖层次从高到底分为</p>
<ul>
<li><p>a.领域依赖（如交易依赖商品）</p>
</li>
<li><p>b.应用依赖（如cntcp应用依赖cngfc应用）</p>
</li>
<li><p>c.接口依赖（如滚存看板查询接口依赖于锁接口&amp;渠道集接口）</p>
</li>
</ul>
<p>我们举接口依赖的例子来看：一共三个接口分别是滚存看板查询接口、锁接口、渠道集接口 滚存看板查询接口依赖于锁接口和渠道集接口<br>技术方案1-目录层次： 滚存看板查询接口、锁接口、渠道集接口<br>技术方案2-目录层次： 锁接口、渠道集接口、滚存看板查询接口<br>很明显，技术方案2是更加合理的，A依赖于B那么B应该先做<br>我们在写技术方案的时候要考虑什么应该在前什么应该在后而不是想一步写一步，要有一个清晰、有序的结构，而不是别人看起来是杂乱无章的。</p>
<h2 id="3-6-一个模块里面应该有啥"><a href="#3-6-一个模块里面应该有啥" class="headerlink" title="3.6 一个模块里面应该有啥"></a>3.6 一个模块里面应该有啥</h2><p>下面列出一个技术方案的模块里面应该要写哪些东西，供参考</p>
<h3 id="3-6-1-具体的接口定义"><a href="#3-6-1-具体的接口定义" class="headerlink" title="3.6.1 具体的接口定义"></a>3.6.1 具体的接口定义</h3><p>要求：实现一个飞机运力合同查询接口，入参为运力大区<br>技术方案1：<br>入参：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;area&quot;: &quot;南美&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>﻿<br>出参:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;date&quot;: &quot;***&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>﻿<br>技术方案2：<br>方法名：CapacityService.queryPlan</p>
<p>入参：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;cnArea&quot;: &quot;南美&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出参:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;date&quot;: &quot;***&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>技术方案2是更好的，为什么？测试、前端 、后续要接手该接口的人都能够一下子找到你的接口并清楚的知道他的输入输出是什么，并且1和2的入参一个area一个cnArea，那么到底那个更对呢？这里由于系统中在用的都是cnArea，固沿用cnArea是对的（一致性减小沟通成本）。</p>
<p>这里总结对接口定义有几点要求：</p>
<ol>
<li>完整的类和方法名</li>
<li>入参字段如果系统中已有那便沿用，如果没有那么英文的描述需要准确（可同产品业务商榷）</li>
<li>出参字段要求同入参</li>
</ol>
<p>﻿</p>
<h3 id="3-6-2-详细的时序图"><a href="#3-6-2-详细的时序图" class="headerlink" title="3.6.2 详细的时序图"></a>3.6.2 详细的时序图</h3><ul>
<li><p>要求：实现一个学生信息查询接口</p>
</li>
<li><p>技术方案1：写出查询结果中执行的相关步骤。</p>
<ul>
<li>step1. 入参校验</li>
<li>step2. 查询A表</li>
<li>step3. 对A标返回结果做校验</li>
<li>step4. 查询B表<br>······</li>
</ul>
</li>
<li><p>技术方案2：在1的基础上使用时序图表达出来</p>
</li>
</ul>
<p>推荐使用技术方案2，好处是尽管内容相同但是时序图能够更直观的看到层次、数据流转等信息</p>
<p>﻿<br>除了以上比较基础的2点我觉得的还有一些要点<br>数据加工的详细图（如有）——同样推荐用图的形式可以更直观<br>消息设计（如有），明确消息生产方、消费方，tps、数据结构<br>自测用例（推荐），比较重要的功能点构造一些自测用例<br>······</p>
<h2 id="3-7-技术选型分析"><a href="#3-7-技术选型分析" class="headerlink" title="3.7 技术选型分析"></a>3.7 技术选型分析</h2><ul>
<li>要求：实现一个定时任务，定期将过期的数据删除</li>
<li>技术方案1：使用spring自带的定时器进行数据清除</li>
<li>技术方案2：使用分布式调度中间件（如schedulerx）进行定时过期数据清楚</li>
</ul>
<p>咋一看好像都能实现，那么我们仔细对比两个实现方式之后我认为大部分人还是会选择技术方案2，为什么？下面列出一些在选择技术方案时考虑的点</p>
<table>
<thead>
<tr>
<th></th>
<th>目标是否可达成</th>
<th>实现难度</th>
<th>可维护性</th>
<th>可扩展性</th>
</tr>
</thead>
<tbody><tr>
<td>技术方案1-spring定时器</td>
<td>是</td>
<td>易</td>
<td>易</td>
<td>低</td>
</tr>
<tr>
<td>技术方案2-分布式调度中间件</td>
<td>是</td>
<td>易</td>
<td>中</td>
<td>高</td>
</tr>
</tbody></table>
<p>﻿</p>
<h2 id="3-8-安全生产"><a href="#3-8-安全生产" class="headerlink" title="3.8 安全生产"></a>3.8 安全生产</h2><p>安全生产包括几个部分，包括且不限于下面几个部分</p>
<ul>
<li>a. 监控</li>
<li>b. 对账</li>
<li>c. 灰度方案</li>
<li>d. 数据隔离</li>
<li>e. 兼容性评估</li>
<li>f. 发布流程</li>
</ul>
<p>我们举一个例子。</p>
<p>需求：在消费者收货成功时触发对商家的结算<br>技术方案1：<strong><strong><strong>，写了一堆如何如何触发结算，如何如何更好的支持后续的可扩展性<br>技术方案2：</strong></strong></strong>，写的方案可扩展性没有技术方案1高，但是做好了未触发结算的监控、触发结算之后的对账并设计好了对应的报表防止出现资损</p>
<p>﻿<br>其实这也是我们在技术方案中可能会忽略的，埋头于代码结构如何如何的好，但是有些东西其实是要比单纯的代码更重要的，就比如风险控制，完备的监控、不可缺少的对账是保障公司资金安全更是保障我们自己绩效的工具【狗头】（此处应有表情）</p>
<p>那么对于监控、对账的具体要求是什么呢？笔者认为</p>
<p>监控：</p>
<ul>
<li>a.监控目标——写清楚监控的是什么内容</li>
<li>b.监控点——如通过打印日志监控，那么日志打印在哪个类的哪个方法</li>
<li>c.监控触发——是通过sunfire采集触发还是其它，如果是sunfire采集最好能把监控项地址贴出来</li>
<li>d.监控订阅人——监控告警需要的订阅人</li>
<li>e.监控触发后的解决方法——如果发生异常改如何解决？如手工触发结算</li>
</ul>
<p>﻿<br>对账：</p>
<ul>
<li>a.对账目标——写清楚对账是为什么</li>
<li>b.对账方式——写清楚是怎么对账的（如通过odps天级定时任务，履行单上的关务资源code和日志表中关务cp回传报文的关务资源code相对比要一致，不一致的形成某个数据集，通过锦衣卫-资损风险平台配置）</li>
<li>c.对账告警订阅人</li>
<li>d.对账异常之后的解决办法</li>
</ul>
<p>﻿<br>还有其它几个部分</p>
<ol>
<li>灰度方案，包括且不限于</li>
</ol>
<ul>
<li>a.多方前置准备</li>
<li>b.灰度切流开关设计</li>
<li>c.灰度切流节奏</li>
<li>d.异常应对</li>
</ul>
<ol start="2">
<li>向前兼容性，包括且不限于</li>
</ol>
<ul>
<li>a.接口的向前兼容-尤其是对外的接口</li>
<li>b.数据结构的向前兼容-如不能随意改变字段的存储类型和格式</li>
</ul>
<ol start="3">
<li><p>环境隔离-如有租户隔离&amp;预发线上隔离的情况需要考虑数据</p>
</li>
<li><p>发布流程，包括且不限于</p>
</li>
</ol>
<ul>
<li>a.发布计划</li>
<li>b.检查项列表</li>
<li>c.发布流量监控</li>
</ul>
<p><img src="https://s2.loli.net/2022/06/25/i3qRYab8dQy5VFl.jpg" alt="带土.jpeg"></p>
]]></content>
      <categories>
        <category>architecture</category>
      </categories>
      <tags>
        <tag>architecture</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈架构</title>
    <url>/2022/02/05/architecture/what_is_architecture/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2022/02/05/eUDdT19AyOtoVPL.jpg" alt="fcb226b79e150279769d6becdf281c7.jpg"></p>
<h3 id="什么是架构"><a href="#什么是架构" class="headerlink" title="什么是架构"></a>什么是架构</h3><h4 id="架构的定义"><a href="#架构的定义" class="headerlink" title="架构的定义"></a>架构的定义</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>架构(Architecture)&#x3D;体系结构(Structure)+理念(Strategy)+模式(Patterns)</p>
<h5 id="架构方法论中的架构分类定义"><a href="#架构方法论中的架构分类定义" class="headerlink" title="架构方法论中的架构分类定义"></a>架构方法论中的架构分类定义</h5><h6 id="企业架构与软件架构"><a href="#企业架构与软件架构" class="headerlink" title="企业架构与软件架构"></a>企业架构与软件架构</h6><ul>
<li>企业架构的构成TOGAF&#x2F;PEAF</li>
<li>我们常说的软件架构更多是信息系统架构与技术架构</li>
<li>而我们常常关注的反而是业务架构（或者说信息系统中的应用架构）<span id="more"></span>
<h6 id="软件架构分类"><a href="#软件架构分类" class="headerlink" title="软件架构分类"></a>软件架构分类</h6></li>
<li>我们常说的信息系统架构是会分为应用架构、数据架构、基础架构</li>
<li>常见的架构结构：分布式<h6 id="技术架构分类"><a href="#技术架构分类" class="headerlink" title="技术架构分类"></a>技术架构分类</h6></li>
<li>常见的架构驱动设计类型：SOA&#x2F;EDA&#x2F;MDA</li>
</ul>
<h4 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h4><h5 id="体系结构的组成"><a href="#体系结构的组成" class="headerlink" title="体系结构的组成"></a>体系结构的组成</h5><h6 id="体系结构的构成"><a href="#体系结构的构成" class="headerlink" title="体系结构的构成"></a>体系结构的构成</h6><ul>
<li>框架(Framework)：体系结构的约束定义</li>
<li>组件(Component)：结构体的构成元素</li>
<li>连接器(Connector)：组件间的关系</li>
<li>任务流(Flow)：描述组件间如何利用连接器进行协作</li>
<li>视图(View)：理解或表达展现体系结构的图形</li>
</ul>
<h6 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h6><p>一种具象化的结构，描述体系结构与外部的交互关系，限制约束组件和连接器的设计</p>
<h4 id="架构理念"><a href="#架构理念" class="headerlink" title="架构理念"></a>架构理念</h4><h5 id="什么是架构理念"><a href="#什么是架构理念" class="headerlink" title="什么是架构理念"></a>什么是架构理念</h5><ul>
<li>采用什么样的架构方法和架构演进方法去解决当下或未来的问题</li>
<li>问题识别、架构目标、架构的特征分析、架构的演进迭代</li>
</ul>
<h5 id="架构理念的思维"><a href="#架构理念的思维" class="headerlink" title="架构理念的思维"></a>架构理念的思维</h5><ul>
<li>体系化：结构性、目的性</li>
<li>抽象化：问题的抽象、场景的抽象、体系结构的抽象</li>
</ul>
<h5 id="演进化思维"><a href="#演进化思维" class="headerlink" title="演进化思维"></a>演进化思维</h5><ul>
<li>架构没有绝对的好坏，只有对问题的可适性、尤其是对环境的可适，对未来问题的可适</li>
<li>所以一个好的架构理念是必须有演进化思维，也就是架构有演进路径</li>
</ul>
<h5 id="历史与知识"><a href="#历史与知识" class="headerlink" title="历史与知识"></a>历史与知识</h5><p>历史总是惊人的相似，架构没有新知识</p>
<h5 id="经典的互联网分布式架构理念-BASE"><a href="#经典的互联网分布式架构理念-BASE" class="headerlink" title="经典的互联网分布式架构理念-BASE"></a>经典的互联网分布式架构理念-BASE</h5><p>Basic Available &#x2F; Soft state &#x2F; Eventually consisten</p>
<h5 id="理念背后的问题与思考"><a href="#理念背后的问题与思考" class="headerlink" title="理念背后的问题与思考"></a>理念背后的问题与思考</h5><ul>
<li>分布式下的CAP问题与解决成本</li>
<li>确定性的范围</li>
</ul>
<h4 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h4><h5 id="软件架构的复用是最高级别的复用"><a href="#软件架构的复用是最高级别的复用" class="headerlink" title="软件架构的复用是最高级别的复用"></a>软件架构的复用是最高级别的复用</h5><ul>
<li>从复用形式：代码复用-&gt; 程序体(API)复用-&gt; 设计模式复用-&gt; 架构复用</li>
<li>从结构范围：方法(API)复用-&gt;结构(类)复用-&gt;模块复用-&gt;系统复用</li>
</ul>
<h5 id="架构设计模式的构成"><a href="#架构设计模式的构成" class="headerlink" title="架构设计模式的构成"></a>架构设计模式的构成</h5><ul>
<li>架构设计模式实际上是一系列程序设计模式的场景化应用</li>
<li>上下文Context &#x2F; 问题Problem &#x2F; 约束Forces &#x2F;</li>
<li>解决方法Solution &#x2F; 结构Structure &#x2F; 角色与职责P&amp;R</li>
</ul>
<h5 id="架构模式的核心"><a href="#架构模式的核心" class="headerlink" title="架构模式的核心"></a>架构模式的核心</h5><ul>
<li>架构理念：对问题的认知、对环境的认知、对目的的理解</li>
<li>架构方法：对方法论的掌握、工具的掌握、结构化表达</li>
</ul>
<h3 id="软件技术架构介绍"><a href="#软件技术架构介绍" class="headerlink" title="软件技术架构介绍"></a>软件技术架构介绍</h3><p><img src="https://s2.loli.net/2022/02/05/Gaz7yPOVYRTJL4I.png" alt="二十年来分布式架构模式演进1.png"><br><img src="https://s2.loli.net/2022/02/05/iqkrvAIS2glZB9p.png" alt="二十年来分布式架构模式演进2.png"></p>
<h4 id="分布式技术架构中面临的常见问题"><a href="#分布式技术架构中面临的常见问题" class="headerlink" title="分布式技术架构中面临的常见问题"></a>分布式技术架构中面临的常见问题</h4><h5 id="分布式节点间数据通信问题"><a href="#分布式节点间数据通信问题" class="headerlink" title="分布式节点间数据通信问题"></a>分布式节点间数据通信问题</h5><ul>
<li>网络质量、IO吞吐、通信状态<h5 id="多节点-Node-协同计算效率问题"><a href="#多节点-Node-协同计算效率问题" class="headerlink" title="多节点(Node)协同计算效率问题"></a>多节点(Node)协同计算效率问题</h5></li>
<li>节点故障容错、计算协同(分布&#x2F;对等&#x2F;并行&#x2F;时序)<h5 id="CAP的平衡"><a href="#CAP的平衡" class="headerlink" title="CAP的平衡"></a>CAP的平衡</h5></li>
<li>Consistency 一致性、Availability 可用性、Partition Tolerance 分区容错</li>
</ul>
<h4 id="互联网常见的架构模式"><a href="#互联网常见的架构模式" class="headerlink" title="互联网常见的架构模式"></a>互联网常见的架构模式</h4><h5 id="架构结构与特点"><a href="#架构结构与特点" class="headerlink" title="架构结构与特点"></a>架构结构与特点</h5><ul>
<li>节点构成一致，节点间相对隔离无通信</li>
<li>由统一的控制器进行负载分片，Controller简单高效</li>
<li>负载不一定是流量，也可以是业务等任何用于节点隔离的因子</li>
<li>2结构增加共享节点用于共享数据，可以实现负载在节点间的迁移<h5 id="形式与场景"><a href="#形式与场景" class="headerlink" title="形式与场景"></a>形式与场景</h5></li>
<li>1最为常见普遍的流量分片与负载均衡、业务分组</li>
<li>1节点如果过重，就往往是我们说的中心架构</li>
<li>2经常用于Failover，比如云主机、状态迁移</li>
<li>2模式中如果Controller弱化，其实就是企业层级数据分块</li>
</ul>
<p><img src="https://s2.loli.net/2022/02/05/MU3JBhN6wd1jiPg.png" alt="架构结构.png"></p>
<h4 id="常见分布式架构-主备模式"><a href="#常见分布式架构-主备模式" class="headerlink" title="常见分布式架构-主备模式"></a>常见分布式架构-主备模式</h4><h5 id="架构结构与特点-1"><a href="#架构结构与特点-1" class="headerlink" title="架构结构与特点"></a>架构结构与特点</h5><ul>
<li>由Master-Slave主从结构，且只有一个主节点</li>
<li>主节点提供全面服务•在变形情况下，备份节点可提供部分服务</li>
<li>2模式可动态任一节点可提供全面服务，数据副本是瓶颈<h5 id="形式与场景-1"><a href="#形式与场景-1" class="headerlink" title="形式与场景"></a>形式与场景</h5></li>
<li>1常见为数据库</li>
<li>2为分布式数据，比如ZK</li>
</ul>
<p><img src="https://s2.loli.net/2022/02/05/7VzBKxSA64lUcM3.png" alt="常见分布式架构-主备模式.png"></p>
<h4 id="常见分布式架构-对等模式"><a href="#常见分布式架构-对等模式" class="headerlink" title="常见分布式架构-对等模式"></a>常见分布式架构-对等模式</h4><h5 id="架构结构与特点-2"><a href="#架构结构与特点-2" class="headerlink" title="架构结构与特点"></a>架构结构与特点</h5><ul>
<li>对等节点，任一节点均可对外服务</li>
<li>节点间可相互通信，数据实时多副本同步策略</li>
<li>基于网络拓扑的节点管理及维护</li>
<li>模式增加管理节点，降低网络拓扑维护成本<h5 id="形式与场景-2"><a href="#形式与场景-2" class="headerlink" title="形式与场景"></a>形式与场景</h5></li>
<li>1常见为DFS，也包括区块链分布式数据</li>
<li>2类似Hadoop，阿里单元化站点结构</li>
<li>2 在WAN层面其实就是网格计算的缩影</li>
</ul>
<p><img src="https://s2.loli.net/2022/02/05/BEJcp1yKHbdOrl3.png" alt="常见分布式架构-对等模式.png"></p>
<h4 id="流行技术架构"><a href="#流行技术架构" class="headerlink" title="流行技术架构"></a>流行技术架构</h4><h5 id="互联网常见系统架构抽象说明"><a href="#互联网常见系统架构抽象说明" class="headerlink" title="互联网常见系统架构抽象说明"></a>互联网常见系统架构抽象说明</h5><p><img src="https://s2.loli.net/2022/02/05/ycpqzB4KFT1H6Cr.png" alt="image.png"><br>常见微服务架构前端流量入口采用负载分片模式</p>
<p>应用层常见是采取一级网络(通过配置推送的软负载)或者二级网络(通过应用网关负载隔离)模式。阿里是使用前者，百度、新浪使用后者，主要取决于微服务的展现形式(RPCorRest-API)，差异是是否需要一个专职配置中心</p>
<p>为保证请求无状态地实现迁移，所以使用共享数据节点(存储各种形式的临时或中间数据)的形式实现。数据节点往往采用分片的主备模式</p>
<h4 id="面向服务的架构SOA"><a href="#面向服务的架构SOA" class="headerlink" title="面向服务的架构SOA"></a>面向服务的架构SOA</h4><h5 id="核心理念"><a href="#核心理念" class="headerlink" title="核心理念"></a>核心理念</h5><ul>
<li>复用集成现有已经存在的应用基础能力ApplicationInfrastructure</li>
<li>可描述且编排的业务流程BusinessProcess•可组织的有机业务OrganicBusiness<h5 id="SOA的核心构成"><a href="#SOA的核心构成" class="headerlink" title="SOA的核心构成"></a>SOA的核心构成</h5></li>
<li>服务基础设施ServiceInfrastructure，比如Web服务（WSDL)</li>
<li>标准化服务协议：比如SOAP&#x2F;UDDI•服务集成：ServiceBus比如ESB</li>
<li>服务编排：比如BPMN&#x2F;BPEL</li>
<li>服务质量：QoS、SLA</li>
<li>服务治理：<h5 id="SOA与Web服务"><a href="#SOA与Web服务" class="headerlink" title="SOA与Web服务"></a>SOA与Web服务</h5></li>
<li>SOA是一种架构设计思想和设计理念，Web服务只是实现工具</li>
</ul>
<h4 id="事件驱动架构EDA"><a href="#事件驱动架构EDA" class="headerlink" title="事件驱动架构EDA"></a>事件驱动架构EDA</h4><h5 id="核心理念-1"><a href="#核心理念-1" class="headerlink" title="核心理念"></a>核心理念</h5><ul>
<li>以生产-消费为基础的异步通信构建组件间松耦合关系的架构模式</li>
<li>改变以往面向过程的API轮询请求<h5 id="EDA与消息机制的差异"><a href="#EDA与消息机制的差异" class="headerlink" title="EDA与消息机制的差异"></a>EDA与消息机制的差异</h5></li>
<li>带有语义性的事件定义</li>
<li>有确定性的事件产生、有规则性的事件路由、有响应的事件消费及回调</li>
<li>消息系统是实现EDA的常见基础设施，但不是唯一<h5 id="EDA的适用性"><a href="#EDA的适用性" class="headerlink" title="EDA的适用性"></a>EDA的适用性</h5></li>
<li>基于异步松耦合，不适用高响应</li>
<li>避免跨平台&#x2F;语言复杂异构环境</li>
<li>事件的路由需要清晰明确</li>
<li>EDA与SOA的结合</li>
</ul>
<h4 id="模型驱动架构MDA"><a href="#模型驱动架构MDA" class="headerlink" title="模型驱动架构MDA"></a>模型驱动架构MDA</h4><h5 id="核心理念-2"><a href="#核心理念-2" class="headerlink" title="核心理念"></a>核心理念</h5><ul>
<li>以生产-消费为基础的异步通信构建组件间松耦合关系的架构模式</li>
<li>改变以往面向过程的API轮询请求<h5 id="EDA与消息机制的差异-1"><a href="#EDA与消息机制的差异-1" class="headerlink" title="EDA与消息机制的差异"></a>EDA与消息机制的差异</h5></li>
<li>带有语义性的事件定义</li>
<li>有确定性的事件产生、有规则性的事件路由、有响应的事件消费及回调</li>
<li>消息系统是实现EDA的常见基础设施，但不是唯一<h5 id="EDA的适用性-1"><a href="#EDA的适用性-1" class="headerlink" title="EDA的适用性"></a>EDA的适用性</h5></li>
<li>基于异步松耦合，不适用高响应</li>
<li>避免跨平台&#x2F;语言复杂异构环境</li>
<li>事件的路由需要清晰明确</li>
<li>EDA与SOA的结合</li>
</ul>
<h4 id="模型驱动架构MDA-1"><a href="#模型驱动架构MDA-1" class="headerlink" title="模型驱动架构MDA"></a>模型驱动架构MDA</h4><h5 id="基于面向对象技术的架构设计理念"><a href="#基于面向对象技术的架构设计理念" class="headerlink" title="基于面向对象技术的架构设计理念"></a>基于面向对象技术的架构设计理念</h5><ul>
<li>2002年由OMG推出诞生</li>
<li>UML–模型设计工具</li>
<li>MOF–元数据对象机制，定义元数据接口与模型</li>
<li>CWM–公共仓库元数据模型，处理对象转换<h5 id="MDA的主要过程"><a href="#MDA的主要过程" class="headerlink" title="MDA的主要过程"></a>MDA的主要过程</h5></li>
<li>CIM（Computation Independent Model）-聚焦于系统环境及需求，但不涉及系统内部的结构与运作细节。</li>
<li>PIM（Platform Independent Model）-聚焦于系统内部细节，但不涉及实现系统得具体平台。</li>
<li>PSM（Platform Specific Model）-聚焦于系统落实于特定具体平台的细节<br><img src="https://s2.loli.net/2022/02/05/93ZRQUwEcgYJt2z.png" alt="模型驱动架构MDA.png"></li>
</ul>
<h4 id="J2EE核心设计模式"><a href="#J2EE核心设计模式" class="headerlink" title="J2EE核心设计模式"></a>J2EE核心设计模式</h4><h5 id="诞生于2003年的核心模式"><a href="#诞生于2003年的核心模式" class="headerlink" title="诞生于2003年的核心模式"></a>诞生于2003年的核心模式</h5><ul>
<li>最早诞生于99年的SunPetstore</li>
<li>2003年推出第一版•2007年推出第二版<h5 id="核心理念与策略"><a href="#核心理念与策略" class="headerlink" title="核心理念与策略"></a>核心理念与策略</h5></li>
<li>基于MVC的展现与处理逻辑分离</li>
<li>分层模式</li>
<li>基于网络的数据处理优化</li>
<li>面向服务</li>
</ul>
<p><img src="https://s2.loli.net/2022/02/05/hS37Tdpr59AvIKl.png" alt="image.png"></p>
<h4 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h4><h5 id="微服务是否是一种架构"><a href="#微服务是否是一种架构" class="headerlink" title="微服务是否是一种架构"></a>微服务是否是一种架构</h5><p><img src="https://s2.loli.net/2022/02/05/CWQYpgwXKGU4cde.png" alt="微服务.png"></p>
<h5 id="微服务的改进思考"><a href="#微服务的改进思考" class="headerlink" title="微服务的改进思考"></a>微服务的改进思考</h5><p><img src="https://s2.loli.net/2022/02/05/6sdmbEchXkU2BLI.png" alt="image.png"></p>
<h3 id="如何成为优秀架构师"><a href="#如何成为优秀架构师" class="headerlink" title="如何成为优秀架构师"></a>如何成为优秀架构师</h3><h4 id="清晰的架构理念"><a href="#清晰的架构理念" class="headerlink" title="清晰的架构理念"></a>清晰的架构理念</h4><h5 id="在架构设计之初一定要有鲜明的架构理念"><a href="#在架构设计之初一定要有鲜明的架构理念" class="headerlink" title="在架构设计之初一定要有鲜明的架构理念"></a>在架构设计之初一定要有鲜明的架构理念</h5><ul>
<li>架构理念没有对与错，它只反映我们对环境上下文、问题、约束的认知<h5 id="体系化思考"><a href="#体系化思考" class="headerlink" title="体系化思考"></a>体系化思考</h5></li>
<li>结构性</li>
<li>目的性<h5 id="演进化思维-1"><a href="#演进化思维-1" class="headerlink" title="演进化思维"></a>演进化思维</h5></li>
<li>架构没有绝对的好坏，只有对问题的可适性、尤其是对环境的可适，对未来问题的可适</li>
<li>所以一个好的架构理念是必须有演进化思维，也就是架构有演进路径<h5 id="历史与知识-1"><a href="#历史与知识-1" class="headerlink" title="历史与知识"></a>历史与知识</h5></li>
<li>历史总是惊人的相似，架构没有新知识</li>
</ul>
<h4 id="方法论和应用"><a href="#方法论和应用" class="headerlink" title="方法论和应用"></a>方法论和应用</h4><h5 id="学习了解架构方法论"><a href="#学习了解架构方法论" class="headerlink" title="学习了解架构方法论"></a>学习了解架构方法论</h5><ul>
<li>学习TOGAF中的信息系统架构、技术架构章节</li>
<li>了解PEAF架构方法构成<h5 id="文档的结构化与标准化"><a href="#文档的结构化与标准化" class="headerlink" title="文档的结构化与标准化"></a>文档的结构化与标准化</h5></li>
<li>别把业务架构、系统架构、技术架构混淆在一起</li>
<li>明确架构理念的文档</li>
<li>架构视图文档：视图反映受众、视角；是表达架构设计的重要构成，给谁看，看什么<h5 id="架构的一致性匹配与持续治理"><a href="#架构的一致性匹配与持续治理" class="headerlink" title="架构的一致性匹配与持续治理"></a>架构的一致性匹配与持续治理</h5></li>
<li>系统架构与业务架构的一致性匹配</li>
<li>架构设计与架构表达的一致性</li>
<li>系统实现与架构设计的一致性</li>
<li>持续的架构治理及优化</li>
</ul>
<h4 id="模式借鉴"><a href="#模式借鉴" class="headerlink" title="模式借鉴"></a>模式借鉴</h4><h5 id="常见的误区"><a href="#常见的误区" class="headerlink" title="常见的误区"></a>常见的误区</h5><ul>
<li>不动脑筋的分层模式</li>
<li>职责链(ResponsibilityChain)与管道(Pipeline)的滥用</li>
<li>SOA、MDA的混杂滥用</li>
<li>微服务的滥用<h5 id="学习了解架构模式"><a href="#学习了解架构模式" class="headerlink" title="学习了解架构模式"></a>学习了解架构模式</h5></li>
<li>业界已经有很多成熟的模式，比如PEAF中就定义了15种</li>
<li>学习模式切忌照猫画虎，要真正理解模式的结构和适用性<br>应用与反思</li>
<li>跳出框框，多设计</li>
<li>多问问自己，假设是否存在，应用是否合理</li>
</ul>
<h4 id="架构设计工具"><a href="#架构设计工具" class="headerlink" title="架构设计工具"></a>架构设计工具</h4><h5 id="关于架构设计的错误以为"><a href="#关于架构设计的错误以为" class="headerlink" title="关于架构设计的错误以为"></a>关于架构设计的错误以为</h5><ul>
<li>架构设计≠PPT图•架构设计图≠PPT“砖块图”</li>
<li>软件架构的构成：组件图、组件协作图、视图、能力特征说明<h5 id="学会最常用的设计工具-UML"><a href="#学会最常用的设计工具-UML" class="headerlink" title="学会最常用的设计工具-UML"></a>学会最常用的设计工具-UML</h5></li>
<li>结构设计：实体图•协作设计：CRC图（类、职责、协作）、通信模式（状态图)<h5 id="其他设计工具"><a href="#其他设计工具" class="headerlink" title="其他设计工具"></a>其他设计工具</h5></li>
<li>分层结构图：PPT分层L0-&gt;L2设计，抽象到具象</li>
<li>流程图：PPT&#x2F;Visio</li>
</ul>
<h4 id="一些好书"><a href="#一些好书" class="headerlink" title="一些好书"></a>一些好书</h4><ul>
<li>面向模式的软件架构：5卷</li>
<li>企业应用架构模式</li>
<li>企业集成模式设计.构建及部署消息传递解决方案</li>
<li>软件架构：架构模式特征及实践指南</li>
<li>面向SOA的事件驱动架构设计与实现</li>
<li>SOA原理·方法·实践</li>
<li>J2EE核心模式(J2EECorePatterns</li>
</ul>
<p><img src="https://s2.loli.net/2022/02/05/5nqPEvTmx43DACf.jpg" alt="c992a5265037459df5f89ec98c7651e.jpg"><br> 如果你觉得文章有用可以给博主打赏一瓶肥宅快乐水并添加微信:wzq657 获取以下图书的电子版:</p>
<ul>
<li>面向模式的软件架构(卷4)-分布式计算的模式语言</li>
<li>面向模式的软件架构(卷5)-模式与模式语言</li>
<li>面向模式的软件体系结构(卷1)：模式系统</li>
<li>面向模式的软件体系结构(卷2)：用于并发与网络化对象的模式</li>
<li>面向模式的软件体系结构(卷3)</li>
<li>企业集成模式：设计、构建及部署消息传递解决方案</li>
<li>企业应用架构模式中文版</li>
</ul>
<p><img src="https://s2.loli.net/2022/02/05/C5HPYJmIit2qnGX.jpg" alt="3c973a36379404eba87bc15f64815f5.jpg"></p>
]]></content>
      <categories>
        <category>architecture</category>
      </categories>
      <tags>
        <tag>architecture</tag>
      </tags>
  </entry>
  <entry>
    <title>system_detail_design</title>
    <url>/2021/03/12/develop_minds/system_detail_design/</url>
    <content><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>﻿
﻿</p>
<h2 id="1-1-术语"><a href="#1-1-术语" class="headerlink" title="1.1 术语"></a>1.1 术语</h2><p>﻿
﻿</p>
<h2 id="1-2-需求背景"><a href="#1-2-需求背景" class="headerlink" title="1.2 需求背景"></a>1.2 需求背景</h2><p>﻿
﻿</p>
<h2 id="1-3-目标"><a href="#1-3-目标" class="headerlink" title="1.3 目标"></a>1.3 目标</h2><p>﻿<br>﻿<span id="more"></span></p>
<h1 id="2-系统业务分析"><a href="#2-系统业务分析" class="headerlink" title="2. 系统业务分析"></a>2. 系统业务分析</h1><p>﻿
﻿</p>
<h2 id="2-1-业务主流程"><a href="#2-1-业务主流程" class="headerlink" title="2.1 业务主流程"></a>2.1 业务主流程</h2><p>﻿
﻿</p>
<h2 id="2-2-总体功能用例图"><a href="#2-2-总体功能用例图" class="headerlink" title="2.2 总体功能用例图"></a>2.2 总体功能用例图</h2><p>﻿
﻿</p>
<h1 id="3-模块详细设计"><a href="#3-模块详细设计" class="headerlink" title="3. 模块详细设计"></a>3. 模块详细设计</h1><p>﻿
﻿</p>
<h2 id="3-1-模块一"><a href="#3-1-模块一" class="headerlink" title="3.1 模块一"></a>3.1 模块一</h2><p>﻿
﻿</p>
<h3 id="3-1-1-操作界面"><a href="#3-1-1-操作界面" class="headerlink" title="3.1.1 操作界面"></a>3.1.1 操作界面</h3><p>﻿
﻿</p>
<h3 id="3-1-2-用例图及描述"><a href="#3-1-2-用例图及描述" class="headerlink" title="3.1.2 用例图及描述"></a>3.1.2 用例图及描述</h3><p>﻿
﻿</p>
<h3 id="3-1-3-流程图或者时序图"><a href="#3-1-3-流程图或者时序图" class="headerlink" title="3.1.3 流程图或者时序图"></a>3.1.3 流程图或者时序图</h3><p>﻿
﻿</p>
<h3 id="3-1-4-类图"><a href="#3-1-4-类图" class="headerlink" title="3.1.4 类图"></a>3.1.4 类图</h3><p>﻿
﻿</p>
<h3 id="3-1-5-实现方案描述"><a href="#3-1-5-实现方案描述" class="headerlink" title="3.1.5 实现方案描述"></a>3.1.5 实现方案描述</h3><p>﻿
﻿</p>
<h3 id="3-1-6-涉及的表及存储结构"><a href="#3-1-6-涉及的表及存储结构" class="headerlink" title="3.1.6 涉及的表及存储结构"></a>3.1.6 涉及的表及存储结构</h3><p>﻿
﻿</p>
<h3 id="3-1-7-性能分析"><a href="#3-1-7-性能分析" class="headerlink" title="3.1.7 性能分析"></a>3.1.7 性能分析</h3><p>﻿
﻿</p>
<h3 id="3-1-8-测试分析及测试用例"><a href="#3-1-8-测试分析及测试用例" class="headerlink" title="3.1.8 测试分析及测试用例"></a>3.1.8 测试分析及测试用例</h3><p>﻿
﻿</p>
<h1 id="4-数据库设计"><a href="#4-数据库设计" class="headerlink" title="4. 数据库设计"></a>4. 数据库设计</h1><p>﻿
﻿</p>
<h1 id="5-现有系统影响分析"><a href="#5-现有系统影响分析" class="headerlink" title="5. 现有系统影响分析"></a>5. 现有系统影响分析</h1><p>﻿<br>﻿<br><em>【可选，描述本次功能之外可能会有影响的功能点。这里是测试的一个关注点】</em>
﻿
﻿</p>
<h1 id="6-系统间关系和影响"><a href="#6-系统间关系和影响" class="headerlink" title="6. 系统间关系和影响"></a>6. 系统间关系和影响</h1><p>﻿<br>﻿<br><em>【可选】</em>
﻿
﻿</p>
<h2 id="6-1-公司对外部服务接口变更影响分析"><a href="#6-1-公司对外部服务接口变更影响分析" class="headerlink" title="6.1 公司对外部服务接口变更影响分析"></a>6.1 公司对外部服务接口变更影响分析</h2><p>﻿<br>﻿<br><em>【可以从以下方面进行分析：<br>公司对外提供的接口有没有变化，是否影响原来的客户？是否遵守原来的契约？这一点非常重要！<br>是否需要发布新的官方接口文档，规范，或SDK，Demo<br>外部接口新增加的内容如果被原有不需要的客户使用是否会有风险？<br>公司对外提供的接口将来可以撤销吗，有没有生命周期结束的时候？<br>项目的改造对原有接口的安全性有没有新的要求？<br>等等<br>】</em>
﻿
﻿</p>
<h2 id="6-2-系统之间服务变化影响分析"><a href="#6-2-系统之间服务变化影响分析" class="headerlink" title="6.2 系统之间服务变化影响分析"></a>6.2 系统之间服务变化影响分析</h2><p>﻿<br>﻿<br><em>【可以从以下方面进行分析：<br>接口变更向前兼容吗？<br>服务提供的数据向前兼容吗？<br>变更的服务的稳定性有何要求？<br>】</em>
﻿
﻿</p>
<h2 id="6-3-系统之间依赖变化影响分析"><a href="#6-3-系统之间依赖变化影响分析" class="headerlink" title="6.3 系统之间依赖变化影响分析"></a>6.3 系统之间依赖变化影响分析</h2><p>﻿<br>﻿<br><em>【描述完成本系统要实现的功能时，它需要哪些外部系统提供的服务。<br>本系统整个系统会产生哪些影响。从业务访问量，事务量，数据库资源消耗，网络资源消耗等多个方面进行考虑。<br>描述本系统提供的那些服务正在被外部系统使用？此次是否会涉及到服务接口、服务规则的升级？外部系统如何适应这些变化？外部系统如何升级？，<br>描述本系统即将提供那些服务供外部系统使用？这些服务的完整性如何保证。<br>可以从以下方面进行分析：<br>服务之间的依赖有变化吗？是否合理<br>ESB的消息依赖是否有变化，是否合理？<br>ESB消息的处理是否能正确支持重试，是否合理？<br>可确保ESB的处理是否能正确支持重试，是否合理？<br>系统release的Jar包依赖是否有变化，是否合理？<br>依赖第三方jar包是否有重大变化，是否安全?<br>】</em>
﻿
﻿</p>
<h2 id="6-4-间接影响的系统"><a href="#6-4-间接影响的系统" class="headerlink" title="6.4 间接影响的系统"></a>6.4 间接影响的系统</h2><p>﻿<br>﻿<br><em>【本项目所影响的系统有没有发现间接被影响的系统？可能是支付宝的其它系统，也可能是合作伙伴，淘宝，阿里软件等兄弟公司的系统】</em>
﻿
﻿</p>
<h2 id="6-5-各产品线特有影响分析"><a href="#6-5-各产品线特有影响分析" class="headerlink" title="6.5 各产品线特有影响分析"></a>6.5 各产品线特有影响分析</h2><p>﻿<br>﻿<br><em>【各个产品线或各个系统的相关人员可以整理各自的影响CheckList，加入到系分模板中，要求系分一定要做出检查，例如：<br>项目是否影响发送到积分营销系统的数据<br>项目是否影响发送到收费系统的数据<br>项目是否影响账务日切<br>项目是否影响给用户的邮件<br>等等<br>】</em>
﻿
﻿</p>
<h1 id="7-运维分析"><a href="#7-运维分析" class="headerlink" title="7. 运维分析"></a>7. 运维分析</h1><p>﻿<br>﻿<br><em>【可选】</em>
﻿
﻿</p>
<h2 id="7-1-数据库影响分析"><a href="#7-1-数据库影响分析" class="headerlink" title="7.1 数据库影响分析"></a>7.1 数据库影响分析</h2><p>﻿<br>﻿<br><em>【至少可以从以下方面进行分析，并通知dba：<br>新增表或库的数据量和io，事务数评估<br>原有表的数据量或io，事务数变化评估，有时候一个很不起眼的修改，甚至是页面上一个链接位置的调整都有可能导致最终某个表io，事务数的很大变化，不要忽视这一块，我们的数据库快受不了了。建议一个大表的io或数据量，事务数变化可能到达20%以上一定要事先告知dba并达成一致同意。<br>有没有影响历史数据迁移，有没有新的历史数据迁移计划<br>有没有导数据的计划<br>有没有初始化数据的计划<br>有没有上线前数据订正的计划<br>有没有停机维护的计划<br>】</em>
﻿
﻿</p>
<h2 id="7-2-网络硬件等影响分析"><a href="#7-2-网络硬件等影响分析" class="headerlink" title="7.2 网络硬件等影响分析"></a>7.2 网络硬件等影响分析</h2><p>﻿<br>﻿<br><em>【至少可以从以下方面分析：<br>是否需要新的硬件投资，请和运维达成一致<br>是否需要新的运维配置新的域名，共享目录，端口，ftp服务等设置<br>是否对现有机房内网网络流量造成很大变化<br>是否对机房对外网网络流量造成很大变化<br>是否会对网络连接session数造成很大变化<br>是否需要防火墙策略等新的运维安全控制策略<br>是否需要新的jboss, jdk ,apache等支撑环境变化<br>是否对负载均衡有新的要求<br>是否对存储有新的要求，占用存储是否会有很大的变化<br>等等<br>】</em>
﻿
﻿</p>
<h2 id="7-3-发布期间影响分析"><a href="#7-3-发布期间影响分析" class="headerlink" title="7.3 发布期间影响分析"></a>7.3 发布期间影响分析</h2><p>﻿<br>﻿<br><em>【至少可以从以下方面分析：<br>系统发布期间服务是否正常可用，<br>系统发布期间对用户有没有影响，<br>系统发布期间新老系统共存产生的数据有没有影响<br>各个系统发布顺序有没有要求<br>系统发布期间的兼容性是否建议专门测试<br>】</em>
﻿
﻿</p>
<h2 id="7-4-系统监控"><a href="#7-4-系统监控" class="headerlink" title="7.4 系统监控"></a>7.4 系统监控</h2><p>﻿<br>﻿<br><em>【至少可以从以下方面分析：<br>系统发布和运行期间是否要对什么特殊有系统日志做监控<br>系统发布和运行期间是否要对原有业务做监控，以便知道影响<br>有没有制定新的一些重要的监控指标<br>系统是否在特定情况下需要一些报警，请和运维协商，运维需要特殊的处理吗<br>系统有没有考虑以后方便的扩充监控<br>监控发现严重问题是否有方法来得及挽回损失<br>】</em>
﻿
﻿</p>
<h2 id="7-5-业务监控"><a href="#7-5-业务监控" class="headerlink" title="7.5 业务监控"></a>7.5 业务监控</h2><p>﻿<br>﻿<br><em>【至少可以从以下方面分析：<br>系统发布和运行期，是否需要对业务数据做监控<br>系统发布和运行期，是否需要对原有业务的数据做监控, 以便知道影响<br>有没有制定新的一些重要的监控指标<br>有没有影响支付宝大盘监控<br>】</em>
﻿
﻿</p>
<h2 id="7-6-系统日志"><a href="#7-6-系统日志" class="headerlink" title="7.6 系统日志"></a>7.6 系统日志</h2><p>﻿<br>﻿<br><em>应用日志保证遵循《支付宝标准应用日志规范》，满足故障处理以及监控数据收集的需求。<br>如果有新增日志或已有日志的存储计划需要变更，请参考《日志存储规范》进行日志存储计划制定和日志名设定，详见<span class="exturl" data-url="aHR0cDovL3d3dy5hbGlzb3VwLm5ldC8=">http://www.alisoup.net/<i class="fa fa-external-link-alt"></i></span>日志存储规范。<br>列出需要变更的日志名：<br>例如：cif-service.log<br>【其他方面可以从以下方面分析：<br>是否有新的需要长期归档的日志，请遵守命名规范<br>日志的量有没有明显变化<br>那些业务需要从日志中进行分析，以方便进行监控或排错，是否需要考虑<br>作为外部交互凭据的日志是否有归档，并和其它日志分开<br>公共的性能，摘要，错误日志是否有重大变化和影响<br>】</em>
﻿
﻿</p>
<h2 id="7-7-灾备要求"><a href="#7-7-灾备要求" class="headerlink" title="7.7 灾备要求"></a>7.7 灾备要求</h2><p>﻿<br>﻿<br><em>【至少可以从以下方面分析：<br>系统是否支持在灾难时在灾备机房运行，有没有影响，是否需要特殊配置<br>平时在灾备机房是否需要跑定时任务<br>系统有没有对灾备远程日志产生影响，是否需要新的灾备远程日志<br>灾难发生时，如果数据有部分丢失，可能会造成多大的损失，有没有补救措施，有没有措施可以减少损失和防止损失的扩大<br>系统和公司外部交互是否在灾备机房记录凭证<br>系统内部重要业务凭证或流水日志是否在灾备机房记录<br>】</em>
﻿
﻿</p>
<h1 id="8-非功能性分析"><a href="#8-非功能性分析" class="headerlink" title="8. 非功能性分析"></a>8. 非功能性分析</h1><p>﻿<br>﻿<br><em>【可选】</em>
﻿
﻿</p>
<h2 id="8-1-业务平衡检查分析"><a href="#8-1-业务平衡检查分析" class="headerlink" title="8.1 业务平衡检查分析"></a>8.1 业务平衡检查分析</h2><p>﻿<br>﻿<br><em>【至少可以从以下方面分析：<br>系统内部业务数据之间是否可以有合适的平衡检查机制<br>系统内外部凭证之间时候可以有合适的平衡检查机制<br>如果系统出现不平衡的数据，是否有方法可以检查可能的原因，有没有办法恢复<br>】</em>
﻿
﻿</p>
<h2 id="8-2-出错数据订正分析"><a href="#8-2-出错数据订正分析" class="headerlink" title="8.2 出错数据订正分析"></a>8.2 出错数据订正分析</h2><p>﻿<br>﻿<br><em>【有时候会出现数据错了之后无法评估错误面，无法获得正确数据进行订正的情况，<br>本项目有没有考虑相关问题，至少可以从以下方面分析：<br>关键业务数据如果出错有没有办法根据日志或外部凭证评估影响<br>关键业务数据如果出错有没有办法根据日志或外部凭证获取要订正的数据<br>关键业务数据如果出错数据订正是否可以马上进行还是要等数据库不繁忙或等数据仓库能够提供支持的时候才可以进行<br>】</em>
﻿
﻿</p>
<h2 id="8-3-性能分析"><a href="#8-3-性能分析" class="headerlink" title="8.3 性能分析"></a>8.3 性能分析</h2><p>﻿<br>﻿<br><em>【从业务的角度分析对性能的需求<br>         对事务的响应时间（平均、最长）<br>         吞吐量（例如每秒处理的事务数）<br>         容量（例如业务所能容纳的客户或事务数）<br>         资源利用：雇员数量、系统的存储容量等。<br>性能及容量必须符合《支付宝应用上线规范v1.0》标准。<br>[在性能分析的时候，通常关注业务链路的起点、连接点、受限制的资源点；此时要考虑单个请求的性能要求，要考虑群体情况下（并发情况下）的性能要求（在某一单个性能指标下的容量问题），要考虑该业务所占据整个系统业务容量的最大百分比。<br>在这个地方，我们最好指出那些点是影响系统性能的，原因是什么，场景是使那么？<br>大部分系统性能都是从使用者体验角度来衡量的。<br>】</em>
﻿
﻿</p>
<h3 id="8-3-1-响应的要求"><a href="#8-3-1-响应的要求" class="headerlink" title="8.3.1 响应的要求"></a>8.3.1 响应的要求</h3><p>﻿<br>﻿<br><em>【有没有具体的指标或要求？<br>有没有可能影响现有系统?<br>】<br>【避免使用统一的指标要求所有业务，可能各个系统use case，或各个业务有不同的性能要求，应该要分别描述。<br>】</em>
﻿
﻿</p>
<h3 id="8-3-2-业务吞吐量"><a href="#8-3-2-业务吞吐量" class="headerlink" title="8.3.2 业务吞吐量"></a>8.3.2 业务吞吐量</h3><p>﻿<br>﻿<br><em>【有没有具体的指标或要求？<br>有没有可能影响现有系统?<br>】<br>【避免使用统一的指标要求所有业务，可能各个系统use case，或各个业务有不同的性能要求，应该要分别描述。<br>】</em>
﻿
﻿</p>
<h2 id="8-4-并发访问控制分析"><a href="#8-4-并发访问控制分析" class="headerlink" title="8.4 并发访问控制分析"></a>8.4 并发访问控制分析</h2><p>﻿<br>﻿<br><em>【至少可以从以下方面分析：<br>有没有资源需要并发访问控制？<br>有没有资源在并发控制出错的情况下会造成损失？<br>并发访问控制会不会造成性能瓶颈<br>】</em>
﻿
﻿</p>
<h2 id="8-5-可测性分析"><a href="#8-5-可测性分析" class="headerlink" title="8.5 可测性分析"></a>8.5 可测性分析</h2><p>﻿<br>﻿<br><em>【至少可以从以下方面分析：<br>系统依赖的外部环境是否可以测试，是否需要开发专门的mock系统<br>系统依赖的时间因素是否可以测试，是否需要开发专门的配合工具进行测试<br>系统依赖的时间，环境，权限等因素是否可以预发布确认，是否需要特别的准备才可以预发布确认。<br>系统依赖的特殊因素如果不能很好的测试或预发布确认，是否需要试运行策略？<br>】</em>
﻿
﻿</p>
<h2 id="8-6-强壮性分析"><a href="#8-6-强壮性分析" class="headerlink" title="8.6 强壮性分析"></a>8.6 强壮性分析</h2><p>﻿<br>﻿<br><em>【此处应说明对组织可靠性的需求（从业务主角的角度来看）。建议如下：<br>         精确度 – 指出输出中所需的精密度（分辨率）和精确度（按照某一已知的标准）。<br>         用户量的变化对系统带来的影响<br>】</em>
﻿
﻿</p>
<h2 id="8-7-系统容错分析"><a href="#8-7-系统容错分析" class="headerlink" title="8.7 系统容错分析"></a>8.7 系统容错分析</h2><p>﻿<br>﻿<br><em>可以从以下方面进行分析：<br>一、 系统所依赖的外部系统发生一些错误的时候，系统有没有相应的容错机制<br>例如，cif的cache不能使用的时候，cif能否正常运行，<br>收费不能使用的时候，交易能否继续进行<br>外部传入错误的数据的时候业务收到什么影响，<br>二、 系统所依赖的硬件网络等基础设施发生故障，系统有没有相应的容错机制<br>由于所选择的通信，存储等方面的不可确定的因素，以及在某一个临界点处导致的质变，需要我们在此处指出可能存在的风险以及解决方案。<br>通信层面常出故障：带宽太小，例如拨号系统。此处需要考虑传输的数据质量（大小问题）。<br>防火墙的限制，某些防火墙可能会过滤一些信息，导致数据不完整。<br>文件系统：文件系统损坏。<br>文件系统容量。<br>文件系统每个目录所能容纳的目录、文件数量的限制。<br>文件系统同时打开的句柄数的限制，间接影响并发行。<br>文件自身的损坏。<br>】</em>
﻿
﻿</p>
<h2 id="8-8-可用性要求分析"><a href="#8-8-可用性要求分析" class="headerlink" title="8.8 可用性要求分析"></a>8.8 可用性要求分析</h2><p>﻿<br>﻿<br><em>可用性 – 指出可用时间百分比 ( xx.xx%)、预期的使用小时数等。<br>【有没有指标可以分析可用性】</em>
﻿
﻿</p>
<h1 id="9-技术风险评估"><a href="#9-技术风险评估" class="headerlink" title="9. 技术风险评估"></a>9. 技术风险评估</h1><p>﻿<br>﻿<br><em>【必选】</em>
﻿
﻿</p>
<h2 id="9-1-资损风险评估"><a href="#9-1-资损风险评估" class="headerlink" title="9.1 资损风险评估"></a>9.1 资损风险评估</h2><p>﻿<br>﻿<br><em>【可以从以下方面进行分析：<br>是否有金额处理的节点，包括前端和后端<br>是否有存在配置引起的资损风险<br>是否有外部异常引起的资损风险<br>是否有资金核对机制<br>】</em>
﻿
﻿</p>
<h2 id="9-2-安全风险评估"><a href="#9-2-安全风险评估" class="headerlink" title="9.2 安全风险评估"></a>9.2 安全风险评估</h2><p>﻿<br>﻿<br><em>【可以从以下方面进行分析：<br>是否有合理的内部工作流程和权限保证公司内部业务操作<br>是否有机制保证客户敏感隐私数据不被内部泄漏：例如DBA不能看到明文的支付密码，信用卡信息等<br>是否有合理的设计保证内部关键操作不被误解和误操作<br>是否有合理的措施保证内部关键操作可以审计和监控，至少有日志<br>业务数据的机密性，关键业务数据、敏感业务数据，在WEB展示，传输过程中涉及到隐私和机密性，需要找出来，采取对应的措施予以解决<br>】</em>
﻿
﻿</p>
<h2 id="9-3-稳定性风险评估"><a href="#9-3-稳定性风险评估" class="headerlink" title="9.3 稳定性风险评估"></a>9.3 稳定性风险评估</h2><p>﻿<br>﻿<br><em>【可以从以下方面进行分析：<br>是否有中间件异常引起的风险<br>是否有外部依赖系统异常的引起风险<br>是否有DB异常引起的风险<br>】</em>
﻿
﻿</p>
<h2 id="9-4-应急方案设计"><a href="#9-4-应急方案设计" class="headerlink" title="9.4 应急方案设计"></a>9.4 应急方案设计</h2><p>﻿<br>﻿<br><em>【可以从以下方面进行分析：<br>是否有业务熔断开关<br>是否有细粒度的业务管控开关，防止风险蔓延<br>是否有异常的快速检测机制<br>】</em></p>
]]></content>
      <categories>
        <category>develop_minds</category>
      </categories>
      <tags>
        <tag>system_detail_design</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK5.6.11_install</title>
    <url>/2018/09/28/elasticsearch/ELK5.6.11_install/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>kibana</tag>
        <tag>logstash</tag>
      </tags>
  </entry>
  <entry>
    <title>elasticsearch_center</title>
    <url>/2019/07/16/elasticsearch/elasticsearch_center/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>  公司内部要对搜索中心进行改造，降低运维成本，leader让我负责整块的设计和编码以及前端展示，整个开发历时30个工作日，完成第一期，现在把一些当中的点做一次share，各位看官轻喷。</p>
<span id="more"></span>

<h4 id="现有系统的状态"><a href="#现有系统的状态" class="headerlink" title="现有系统的状态"></a>现有系统的状态</h4><p>  所在团队做的是跨境电商的服务，海量的商品存在mysql集群当中，当商品上架的时刻，需要将mysql的数据同步到elasticsearch集群当中，目的是为了给用户提供快速的搜索服务，同步的最小单元是表，即将一张表同步到es集群，老的系统的做法是当随着业务的增长，表结构会变化，或者增加，修改表等等一些DDL操作，之前的做法是每当这些变化发生的时候，需要在搜索中心的工程当中编写正对于变化的表的同步代码，适配mysql的变化，比如新增加了一张表，需要对这张表的数据同步到es，就需要写一个正对于此表的同步任务，修改表也是如此，需要制定开发周期，排工作量，测试计划等等。</p>
<h5 id="之前的架构设计"><a href="#之前的架构设计" class="headerlink" title="之前的架构设计"></a>之前的架构设计</h5><p>  针对于每一个mysql数据库实例都对接一个<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvY2FuYWw=">canal<i class="fa fa-external-link-alt"></i></span>服务,canal监听mysql的binlog日志，然后将日志push到mq（canal支持kafka和rocketmq）里边，然后我们的app就是mq的消费者，消费mq的消息，消费的过程就是从mq的broker执行poll，拉取消息，然后将消息解析，得到消息里边的业务id，通过业务id去真实的mysql数据查询数据（重新查询一次mysql，这么做的原因是保证数据的强一致性），然后将数据刷新到es集群，完成消息的消费。<br>  <img src="/old_structure.png" alt="old_structure.png"></p>
<h4 id="现有系统存在的问题"><a href="#现有系统存在的问题" class="headerlink" title="现有系统存在的问题"></a>现有系统存在的问题</h4><ul>
<li>新增表需要进行针对性编码</li>
<li>修改表需要进行针对性编码</li>
<li>新增加数据库需要进行针对性编码</li>
<li>索引的版本管理混乱<ul>
<li>需要手动掉es的http api切换别名(开发人员在使用es的搜索api查询的时候都是使用的别名，一个别名只能同时指向一个索引，如果发生索引升级，需要指向新的索引版本，别名的存在就是为了做无缝切换)<br><img src="/remappinh_reindex.png" alt="remappinh_reindex.png"></li>
</ul>
</li>
<li>数据类型映射管理刀工火种，人工做jdbc到es的数据类型映射太繁琐，还容易出错。<br>  <img src="/dataTypeMapping.png" alt="dataTypeMapping.png"></li>
</ul>
<h4 id="现有轮子考察"><a href="#现有轮子考察" class="headerlink" title="现有轮子考察"></a>现有轮子考察</h4><ul>
<li><p>Elasticsearch-jdbc</p>
<ul>
<li>Not support Elasticsearch 5.0</li>
<li>Not support delete and unfriendly incremental update</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pwcmFudGUvZWxhc3RpY3NlYXJjaC1qZGJjL2lzc3Vlcy85MTU=">https://github.com/jprante/elasticsearch-jdbc/issues/915<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li><p>logstash-jdbc</p>
<ul>
<li>Create new config need restart server</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xvZ3N0YXNoLXBsdWdpbnMvbG9nc3Rhc2gtaW5wdXQtamRiYy5naXQ=">https://github.com/logstash-plugins/logstash-input-jdbc.git<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li><p>elasticsearch-river-mysq</p>
<ul>
<li>Stop maintain</li>
</ul>
</li>
<li><p>go-mysql-elasticsearch</p>
<ul>
<li>Unstable</li>
<li>Can not alter table format at runtime</li>
<li>Can not change too many rows at same time in one SQL</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NpZGRvbnRhbmcvZ28tbXlzcWwtZWxhc3RpY3NlYXJjaA==">https://github.com/siddontang/go-mysql-elasticsearch<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>现有轮子都存在各种各样的问题，阿里的dataX对增量是同步不太友好，而且对es的一些特性支持不友好,比如parent-child关系映射直接不支持。</p>
</li>
</ul>
<h4 id="新改造支持的特性"><a href="#新改造支持的特性" class="headerlink" title="新改造支持的特性"></a>新改造支持的特性</h4><ul>
<li>动态创建主题(mq topic)<ul>
<li>前提是预先创建canal实例</li>
</ul>
</li>
<li>动态创建数据库</li>
<li>动态创建表</li>
<li>支持es的<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9ndWlkZS9jbi9lbGFzdGljc2VhcmNoL2d1aWRlL2N1cnJlbnQvcGFyZW50LWNoaWxkLmh0bWw=">Parent-child<i class="fa fa-external-link-alt"></i></span> 关系</li>
<li>支持es映射的递归嵌套(支持nest嵌套)</li>
<li>同步异常，支持断点续传</li>
<li>表的一对多，一对一关联</li>
<li>索引的区域更新</li>
<li>索引版本管理</li>
<li>日常数据增量校验，保证每天的数据一致性（避免各类bug导致数据不一致，一个数据一致性保险检查程序）</li>
<li>在大表的情况，分布式创建索引</li>
<li>元数据类型的业务数据，当元数据修改的时候，需要将其关联的业务索引更新，这里支持延迟任务调度，并且是分布式的方式。</li>
<li>Ik的动态词库</li>
</ul>
<h3 id="功能演示"><a href="#功能演示" class="headerlink" title="功能演示"></a>功能演示</h3><ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly8xMTU2NzIxODc0LmdpdGh1Yi5pby8yMDE4LzA5LzI4L0VMSy1FbGFzdGljU2VhcmNoLUxvZ3N0YXNoLUtpYmFuYSVFNiU5MCVBRCVFNSVCQiVCQSVFNSVBRSU5RSVFNiU5NyVCNiVFNiU5NyVBNSVFNSVCRiU5NyVFNSU4OCU4NiVFNiU5RSU5MCVFNSVCOSVCMyVFNSU4RiVCMC8=">es集群搭建<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2N0cmlwY29ycC9hcG9sbG8=">apollo配置中心部署<i class="fa fa-external-link-alt"></i></span>此处不在熬述，参考官方和之前的博客。</p>
</li>
<li><p>数据库脚本配置请使用工程里边的init.sql执行初始化.</p>
</li>
<li><p>项目分为三个工程：</p>
<ul>
<li>tdl-mysql-elasticsearch 核心引擎配合apollo</li>
<li>tdl-mysql-elasticsearch-api api层，为前端提供接口，配合apollo</li>
<li>tdl-mysql-elasticsearch-web vue前端展示工程</li>
</ul>
</li>
<li><p>topic</p>
<ul>
<li>topic 列表<br><img src="/topic-list.png" alt="topic-list.png"></li>
<li>topic 新增或者修改<br><img src="/topic-insert-edit.png" alt="topic-insert-edit.png"></li>
</ul>
</li>
<li><p>数据库操作</p>
<ul>
<li>数据库列表<br>  <img src="/database-list.png" alt="database-list.png"></li>
<li>数据库新增和修改<br>  <img src="/database-insert-edit.png" alt="database-insert-edit.png"></li>
</ul>
</li>
<li><p>表</p>
<ul>
<li><p>表的列表<br><img src="/table-list.png" alt="table-list.png"><br>一张表对应es里边的一个索引;<br>如果是parent-child关系，是多张表映射到一个索引上，每一张表代表一个类型;</p>
</li>
<li><p>表新增修改<br><img src="/table-insert.png" alt="table-insert.png"><br>IndexName：表对应的索引名称<br>IndexType：索引的type，一个索引有多个type<br>IndexAlias：索引的别名，线上都是用的别名，如果索引发生了升级，只需要将别名指向新的索引版本即可，完成无缝切换<br>DailyCheckColumn：日常检查的字段，一般是修改时间字段，用来对数据做校验，同步的时候也会用到这个字段，用时间戳做增量同步<br>BucketColumn: 分布式创建索引或者分布式延迟刷新元数据的时候根据这个值对表进行分桶，一般是表的创建时间<br>ParentIndexType：父子关系的时候，当前是child，ParentIndexType指向的是parent的index type，父子关系中父是一个type，child是一个type，2个type必须在同一个索引里边。<br>ParentIndexColumnName：子表中父表的pid字段名称。<br>ToCopy：参考es官网解释：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9ndWlkZS9lbi9lbGFzdGljc2VhcmNoL3JlZmVyZW5jZS9jdXJyZW50L2NvcHktdG8uaHRtbA==">https://www.elastic.co/guide/en/elasticsearch/reference/current/copy-to.html<i class="fa fa-external-link-alt"></i></span><br>DelayEffect: 是否延迟刷新，当一张表设置了这个属性为true，那么这张表的binlog在消费的时候，不会刷新到索引，而且保存在mysql数据库里边，这些快照数据等待调度任务去消费，刷新到索引里边去，因此是延迟的方式，而且支持分布式的方式，被设置为true的表会在【delay】菜单展示，后续会对delay菜单做介绍。<br>Add One Column操作：添加一列<br>Auto Gen Column: 根据左侧填写的表名，自动拉取所有的列</p>
</li>
<li><p>表字段添加<br><img src="/table-column-insert.png" alt="table-column-insert.png"><br>ColumnName：字段名称<br>ColumnType：字段的数据类型<br>EsDataType：es的数据类型<br>Analyzer：分析器（参考es官方doc：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9ndWlkZS9lbi9lbGFzdGljc2VhcmNoL3JlZmVyZW5jZS9jdXJyZW50L3NlYXJjaC1hbmFseXplci5odG1sJUVGJUJDJTg5">https://www.elastic.co/guide/en/elasticsearch/reference/current/search-analyzer.html）<i class="fa fa-external-link-alt"></i></span><br>CopyTo：参考官方doc：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9ndWlkZS9lbi9lbGFzdGljc2VhcmNoL3JlZmVyZW5jZS9jdXJyZW50L2NvcHktdG8uaHRtbA==">https://www.elastic.co/guide/en/elasticsearch/reference/current/copy-to.html<i class="fa fa-external-link-alt"></i></span><br>ExtendName：扩展对象名称，通过【AddRelation】按钮添加扩展对象的时候此名称可以被覆盖<br>Keyword：参考官方doc：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9ndWlkZS9lbi9lbGFzdGljc2VhcmNoL3JlZmVyZW5jZS9jdXJyZW50L2tleXdvcmQuaHRtbA==">https://www.elastic.co/guide/en/elasticsearch/reference/current/keyword.html<i class="fa fa-external-link-alt"></i></span><br>IsKey：标识当前字段是主键<br>ExtendIsNest：扩展对象是否是嵌套的，可以被字段关系覆盖，参考官方doc：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9ndWlkZS9lbi9lbGFzdGljc2VhcmNoL3JlZmVyZW5jZS9jdXJyZW50L3F1ZXJ5LWRzbC1uZXN0ZWQtcXVlcnkuaHRtbA==">https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-nested-query.html<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>字段关联(支持多级嵌套)<br><img src="/table-column-relation.png" alt="table-column-relation.png"><br>SearchColumnName：当前要关联的字段名称。<br>ExtendName：关联的对象在当前表里边的扩展名称，此处可以覆盖字段上的  ExtendName<br>RelationTableName：关联的表<br>RelationTableColumns：关联的表要加载它的那些字段<br>RelationTableColumn：当前SearchColumnName和RelationTableName的RelationTableColumn发生关联，一般是id之类的。<br>ExtendIsNest：是否是嵌套的，此处可以覆盖字段的ExtendIsNest<br>freeSql: 关联子表附带的查询条件，比如 delete&#x3D;0 and status &#x3D; 1<br>Distinct: 对sql的查询结果进行mysql的distinct关键字去重<br>refreshParent: 当子表数据发生变化，而且子表在索引里边是nest的内嵌的方式，那么子表的数据变化会触发所在文档的更新<br>AreaUpdate:当子表数据发生变化，而且子表在索引里边是nest的内嵌的方式，那么子表的数据变化会触发所在文档的更新，更新方式采用区域更新的方式，和refreshParent的差别是少了很多无关的数据的查询，区域更新采用es的脚本更新文档的方式进行的</p>
</li>
<li><p>表的状态和操作<br><img src="/table-list-operation.png" alt="table-list-operation.png"><br>另外表的状态在history和avaiable状态的时候会有deleteAll操作权限，deleteAll会把抽象和es当中的索引全部删除，危险操作；<br>表的抽象创建完毕之后状态是unavailable状态，表在创建新的索引之后，首先是changing状态，标识正在创建新的索引版本，版本会自动加一，上一个版本的索引会置为history，新的索引的状态是available状态，标识正在同步mysql。<br>Reset：状态置为可用、版本号清空、索引任务删除、当前版本索引删除，如果当前索引正在创建将会被强制终止，主要作用是用于创建异常的人工恢复。<br>AddDelayEffect: 当前表的变化不会立刻刷新到索引文档里边去，而是由调度任务去完成，一般元数据的表，并且这种元数据经常发生改变。</p>
</li>
<li><p>分布式治理<br><img src="/distribute.png" alt="distribute.png"><br>refresh: 刷新列表<br>Rebalance: 重新执行负载均衡</p>
</li>
<li><p>延时刷新</p>
<ul>
<li>打标了延迟处理的表：<br><img src="/delay-list.png" alt="delay-list.png"></li>
<li>元数据影响的顶层表的关系维护<br><img src="/delay-top-view.png" alt="delay-top-view.png"></li>
<li>添加的顶层表top黏连关系<br><img src="/delay-top-view.png" alt="delay-top-view.png"></li>
<li>查询和管理快照列表<br><img src="/snapshot_list.png" alt="snapshot_list.png"></li>
</ul>
</li>
<li><p>动态词库<br>  <img src="/dynamic_words.png" alt="dynamic_words.png"><br>  词库状态分为初始化和发布完毕2种，只有发布完毕的才会进入es的动态词库。<br>  词库分为扩展词库和停用词词库。<br>  一个单词没有发布之前可以修改，发布完毕之后不可以修改，只能删除。<br>  初始化和发布完成的都可以删除。<br>  es对Ik的动态词库配置参考：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21lZGNsL2VsYXN0aWNzZWFyY2gtYW5hbHlzaXMtaWs=">https://github.com/medcl/elasticsearch-analysis-ik<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
</li>
</ul>
<h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><h4 id="整体架构图"><a href="#整体架构图" class="headerlink" title="整体架构图"></a>整体架构图</h4><p>  <img src="/new_structure.png" alt="new_structure.png"><br>  每个节点都有一个searchContext，首先解释下searchContext，searchContext是这个上下文，里边存储了当前可以同步的主题，数据库，表，以及正在changing的tableId，还有同步线程的引用等等，ListenTopicTask会每隔三分钟刷新一次上下文；<br>  整个轮子有2条主线，以searchContext为中心，searchContext下面是索引创建流程，上面是消息监听流程（索引已经创建完毕，mysql数据变化监听，然后将变化推送到es集群）；<br>  索引创建流程将索引创建完毕之后，会更新上下文，然后消息监听流程会使用更新之后的上下文。</p>
<h4 id="索引创建流程"><a href="#索引创建流程" class="headerlink" title="索引创建流程"></a>索引创建流程</h4><p>  索引创建流程就是在页面发起【createIndex】操作，后端会进行5个步骤的操作：</p>
<ul>
<li><p>创建索引请求的发起，这个过程会做一些表和字段的校验，以及一些判重操作，比如当前表已经同步过，或者正在同步，又或者在同步任务比价多，同步任务被放到任务队列里边也是会被发现的，这些数据是不允许往下执行的。</p>
</li>
<li><p>一个创建索引的请求就是对一张表的数据到es的全量同步，table_id是当前要同步表的id，这张表首先会通过create_time分为多个桶，total_bucket_number是集群当中部署的app数量，mod_number是某个节点的顺序号(mod_number &lt;&#x3D; total_bucket_number),data_cursor是同步的游标，一般是表的id字段的值，job_type是任务的类型，创建索引是index类型，delay任务调度是job类型，params是任务的参数，比如在job类型，只同步某个业务id，可以放在这个参数里边，syn_cursor已经废弃，不再描述。集群当中存活的机器数n就是一张表生成的tnp_search_job的记录数。</p>
</li>
<li><p>分桶之后每台机器执行的sql会根据mod_number进行分区拉取数据:select * from table where  UNIX_TIMESTAMP(A.create_time) mod total_bucket_number  &#x3D; mod_number order by A.modify_time;A指的是业务表名称。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `tnp_search_job` (</span><br><span class="line">  `id` varchar(64) COLLATE utf8_bin NOT NULL,</span><br><span class="line">  `table_id` varchar(64) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;table的id&#x27;,</span><br><span class="line">  `status` varchar(45) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;同步状态&#x27;,</span><br><span class="line">  `syn_cursor` timestamp(6) NULL DEFAULT NULL COMMENT &#x27;按照时间同步时间游标&#x27;,</span><br><span class="line">  `total_bucket_number` int(11) DEFAULT NULL COMMENT &#x27;桶总数&#x27;,</span><br><span class="line">  `mod_number` int(11) DEFAULT NULL COMMENT &#x27;桶编号&#x27;,</span><br><span class="line">  `data_cursor` varchar(64) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;业务数据同步游标&#x27;,</span><br><span class="line">  `job_type` varchar(45) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;任务类型：index:索引创建任务/task:调度任务&#x27;,</span><br><span class="line">  `params` varchar(4096) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;任务参数&#x27;,</span><br><span class="line">  `create_time` datetime DEFAULT NULL,</span><br><span class="line">  `modify_time` datetime DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;记录表的同步状态和同步游标&#x27;;</span><br></pre></td></tr></table></figure></li>
<li><p>负载均衡过程：<br>发起负载均衡的节点执行负载均衡逻辑，每个节点都会把节点的抽象写到zookeeper里边，抽象对象如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class NodeJobEntity &#123;</span><br><span class="line"></span><br><span class="line">    public NodeJobEntity()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public NodeJobEntity(CloudStatusENUM cloudStatusENUM, NodeStatusENUM nodeStatusENUM, NodeJobTypeENUM nodeJobTypeENUM,</span><br><span class="line">                         List&lt;SearchJobBO&gt; indexJobs, String rebalanceSessionId) &#123;</span><br><span class="line">        this.cloudStatusENUM = cloudStatusENUM;</span><br><span class="line">        this.nodeStatusENUM = nodeStatusENUM;</span><br><span class="line">        this.nodeJobTypeENUM = nodeJobTypeENUM;</span><br><span class="line">        this.indexJobs = indexJobs;</span><br><span class="line">        this.rebalanceSessionId = rebalanceSessionId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NodeJobEntity(CloudStatusENUM cloudStatusENUM, NodeStatusENUM nodeStatusENUM, NodeJobTypeENUM nodeJobTypeENUM,</span><br><span class="line">                         List&lt;SearchJobBO&gt; indexJobs,  JobParam params, String rebalanceSessionId) &#123;</span><br><span class="line">        this.cloudStatusENUM = cloudStatusENUM;</span><br><span class="line">        this.nodeStatusENUM = nodeStatusENUM;</span><br><span class="line">        this.nodeJobTypeENUM = nodeJobTypeENUM;</span><br><span class="line">        this.indexJobs = indexJobs;</span><br><span class="line">        this.params = params;</span><br><span class="line">        this.rebalanceSessionId = rebalanceSessionId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 集群状态</span><br><span class="line">     REBALANCING(&quot;rebalancing&quot;),</span><br><span class="line">     NORMAL(&quot;normal&quot;);</span><br><span class="line">     */</span><br><span class="line">    private CloudStatusENUM cloudStatusENUM;</span><br><span class="line">    /**</span><br><span class="line">     * 节点状态</span><br><span class="line">      CLEAN(&quot;clean&quot;),</span><br><span class="line">      CLEAN_OK(&quot;clean_ok&quot;),</span><br><span class="line">      INIT(&quot;init&quot;),</span><br><span class="line">      FINISH(&quot;finish&quot;);</span><br><span class="line">     */</span><br><span class="line">    private NodeStatusENUM nodeStatusENUM;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 任务节点类型</span><br><span class="line">     INDEX(&quot;index&quot;),</span><br><span class="line">     JOB(&quot;job&quot;);</span><br><span class="line">     */</span><br><span class="line">    private NodeJobTypeENUM nodeJobTypeENUM;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 节点任务</span><br><span class="line">     */</span><br><span class="line">    private List&lt;SearchJobBO&gt; indexJobs;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 任务参数</span><br><span class="line">     */</span><br><span class="line">    private JobParam params;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 工作线程池存活的线程数和未完成的任务数=</span><br><span class="line">     * ThreadPoolManager.getHighFrequencyTaskPool().getQueue().size()  + ThreadPoolManager.getHighFrequencyTaskPool().getActiveCount()</span><br><span class="line">     */</span><br><span class="line">    private Integer aliveThreadMount = -1;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * rebalanceId 每次rebalance都会生成一个rebalanceSessionId，可以用来区分是否发生了新的rebalance。</span><br><span class="line">     */</span><br><span class="line">    private String rebalanceSessionId;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">SearchJobBO:</span><br><span class="line">@Data</span><br><span class="line">public class SearchJobBO &#123;</span><br><span class="line">    private String id;</span><br><span class="line"></span><br><span class="line">    private String tableId;</span><br><span class="line">    /**</span><br><span class="line">     * @see SearchJobStatusEnum</span><br><span class="line">      INIT(&quot;init&quot;,&quot;初始化&quot;),</span><br><span class="line">      RUNNING(&quot;running&quot;,&quot;运行中&quot;),</span><br><span class="line">      ERROR(&quot;error&quot;,&quot;同步异常&quot;),</span><br><span class="line">      DONE(&quot;done&quot;,&quot;完毕&quot;);</span><br><span class="line">     */</span><br><span class="line">    private String status;</span><br><span class="line"></span><br><span class="line">    private Timestamp synCursor;</span><br><span class="line"></span><br><span class="line">    private Integer totalBucketNumber;</span><br><span class="line"></span><br><span class="line">    private Integer modNumber;</span><br><span class="line"></span><br><span class="line">    private String dataCursor;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @see NodeJobTypeENUM</span><br><span class="line">     INDEX(&quot;index&quot;),</span><br><span class="line">     JOB(&quot;job&quot;);</span><br><span class="line">     */</span><br><span class="line">    private String jobType;</span><br><span class="line"></span><br><span class="line">    private String params;</span><br><span class="line"></span><br><span class="line">    private Date createTime;</span><br><span class="line"></span><br><span class="line">    private Date modifyTime;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 是否被负载均衡中断</span><br><span class="line">     */</span><br><span class="line">    private volatile Boolean breakByRebalance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>负载均衡的过程[创建索引任务和延迟刷新任务同样的流程]：</p>
<ul>
<li>首先会加分布式锁;</li>
<li>清除所有存活节点的任务数据，节点集群状态是REBALANCING，节点状态是CLEAN状态;<ul>
<li>对NodeJobEntity的indexJobs数组清空，nodeStatusENUM置为clean，将这个信息写到zk节点里边，节点通过zk数据变化事件得到变化的数据，检查本地线程池是否有存活的任务，如果有就等待，等待线程池执行完毕(同步阻塞等待)，如果线程池没有任务，那么将nodeStatusENUM置为cleanok，写到zk</li>
<li>负载均衡发起的节点阻塞检查所有节点是否清除完毕，如果完毕，继续下面的步骤；</li>
</ul>
</li>
<li>清空所有节点任务完毕，进入任务分配阶段;<ul>
<li>根据任务数量和节点数量平均分配任务，任务会写到NodeJobEntity的indexJobs数组，nodeStatusENUM为init，cloudStatusENUM为rebalancing，然后写入到zk。</li>
</ul>
</li>
<li>任务下发到各个节点完毕;<ul>
<li>节点接到下发的任务后本地执行异步同步任务。</li>
</ul>
</li>
<li>解锁</li>
</ul>
</li>
<li><p>节点异步执行同步任务[创建索引任务和延迟刷新任务同样的流程]<br>SynchronizeJobTask右侧的代码是SynchronizeJobTask的核心逻辑，在死循环当中，使用了CompletableFuture，而且是完全异步的，同步过程是异步，同步完毕（成功后者失败）之后也是异步的，一张表由于使用了CompletableFuture，就会对应使用2个线程分别去同步和处理同步结果。在supplyAsync当中做的工作有：</p>
<ul>
<li>将当前表的同步任务状态从init置为running状态</li>
<li>表的状态置为changing状态</li>
<li>记录开始日志<br>supplyAsync占用一个线程去处理任务。<br>thenAcceptAsync是对同步完毕之后的后置处理:</li>
<li>最后一个任务完成，并且不存在异常同步的任务，并且没有被负载均衡中断，并且是同步成功<ul>
<li>记录日志</li>
<li>表的同步任务状态置为完毕</li>
<li>将当前同步表的状态置为可用</li>
<li>将上一个版本的索引状态置为history</li>
<li>将索引别名指向新的索引版本</li>
<li>删除mysql中当前表的任务抽象: delete from tnp_search_job where table_id &#x3D; XXX and job_type&#x3D;’index’;</li>
<li>将在同步期间修改或者新增的数据（类似于jvm垃圾收集里边的浮动垃圾）刷新到新的索引里边，和这个步骤在图片中没有画出。</li>
</ul>
</li>
<li>最后一个任务完成，并且不存在异常同步的分桶，并且没有被负载均衡中断，并且是同步失败<ul>
<li>记录日志</li>
<li>删除mysql中当前表的任务抽象: delete from tnp_search_job where table_id &#x3D; XXX and job_type&#x3D;’index’;</li>
<li>将当前同步表的状态置为不可用</li>
<li>删除刚刚创建的索引版本映射</li>
<li>记录失败日志</li>
</ul>
</li>
<li>最后一个任务完毕，但是被负载均衡中断<ul>
<li>不做任何操作</li>
</ul>
</li>
<li>最后一个任务完毕，而且是异常中断退出任务，一般是同步出现了问题, 比如long转换为integer超界<ul>
<li>删除刚刚创建的索引版本</li>
<li>当前table状态回滚为不可用状态</li>
<li>如果同步失败直接删除表的同步任务数据，用户重新添加同步：delete from tnp_search_job where table_id &#x3D; XXX and job_type&#x3D;’index’;</li>
<li>记录失败日志</li>
</ul>
</li>
<li>非最后一个任务，并且不是重新负载中断而且同步成功<ul>
<li>更新job状态为done：update tnp_search_job set status &#x3D; ‘done’ where id&#x3D;XXX</li>
<li>记录成功日志</li>
</ul>
</li>
<li>非最后一个任务，并且不是重新负载中断而且同步失败<ul>
<li>更新job状态为done：update tnp_search_job set status &#x3D; ‘error’ where id&#x3D;XXX</li>
<li>记录失败日志</li>
</ul>
</li>
<li>非最后一个任务，被负载均衡中断<ul>
<li>不需要处理</li>
</ul>
</li>
<li>非最后一个任务，异常中断退出任务，一般是同步出现了问题, 比如long转换为integer超界<ul>
<li>更新job状态为done：update tnp_search_job set status &#x3D; ‘error’ where id&#x3D;XXX</li>
<li>记录失败日志</li>
</ul>
</li>
</ul>
</li>
<li><p>刷新数据到es集群<br>  当同步任务被执行的时候，内部就会将数据从mysql的一张表按照步长同步到es集群当中，主要是由SynchronizeFactory来做的，SynchronizeFactory是一个同步工厂的抽象，他的实现类是EsSynchronizeFactoryImpl，同步过程如下：</p>
<ul>
<li>获取jdbc驱动，jdbc驱动使用的c3p0数据库连接池，并且设置了不会让链接空闲失效，在SynchronizeFactory层面是模板模式。</li>
<li>组装存储到es的JSON对象，这个对象是按照建立的mapping格式组装的，我们设置的父子关系，嵌套等设置，这个JSON对象都要遵守。</li>
<li>检查索引和索引type，如果没有的话就会创建。</li>
<li>父子关系的检查，es当中规定parent type和child type必须在同一个es分片，否则就会产生查询混乱，当我们修改了一个child的pid的时候，这个时候pid对应的parent可能不和child在同一个分片，这个时候我们要将child删除，重新插入child，确保child和parent在同一个分片，<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9ndWlkZS9jbi9lbGFzdGljc2VhcmNoL2d1aWRlL2N1cnJlbnQvaW5kZXhpbmctcGFyZW50LWNoaWxkLmh0bWw=">parent-child扩展阅读<i class="fa fa-external-link-alt"></i></span></li>
<li>调用es的java api刷新数据到es集群。</li>
</ul>
</li>
</ul>
<h4 id="消息监听流程"><a href="#消息监听流程" class="headerlink" title="消息监听流程"></a>消息监听流程</h4><p>  当一个索引创建成功处于available状态的时候，就会被消息监听流程使用，当mysql产生binlog，会被canal收到，然后canal将binlog推送到mq里边，然后我们的应用就是mq的消费者，我们的消费者是可以在界面上配置的，配置完毕之后就会在程序里边创建一个消费者实例，进入到监听，监听到消息之后消费的流程如下：</p>
<ul>
<li>拿到应用的上下文</li>
<li>解析消息</li>
<li>数据库和消息匹配检查</li>
<li>table和消息匹配检查</li>
<li>过滤不感兴趣的操作，只对插入，修改，删除感兴趣</li>
<li>获取jdbc驱动，jdbc驱动使用的c3p0数据库连接池，并且设置了不会让链接空闲失效，在SynchronizeFactory层面是模板模式。</li>
<li>组装存储到es的JSON对象，这个对象是按照建立的mapping格式组装的，我们设置的父子关系，嵌套等设置，这个JSON对象都要遵守。</li>
<li>检查索引和索引type，如果没有的话就会创建。</li>
<li>父子关系的检查，es当中规定parent type和child type必须在同一个es分片，否则就会产生查询混乱，当我们修改了一个child的pid的时候，这个时候pid对应的parent可能不和child在同一个分片，这个时候我们要将child删除，重新插入child，确保child和parent在同一个分片，<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9ndWlkZS9jbi9lbGFzdGljc2VhcmNoL2d1aWRlL2N1cnJlbnQvaW5kZXhpbmctcGFyZW50LWNoaWxkLmh0bWw=">parent-child扩展阅读<i class="fa fa-external-link-alt"></i></span></li>
<li>调用es的java api刷新数据到es集群(支持批量刷入)。</li>
</ul>
<h4 id="Delay延迟刷新"><a href="#Delay延迟刷新" class="headerlink" title="Delay延迟刷新"></a>Delay延迟刷新</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>  在构建索引的时候，有些表属于元数据，或者一张表的变动涉及到大量表的同步，导致同步阻塞，这种问题导致了binlog消息的阻塞，影响后续业务的进行。</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>  设置某些表的修改在索引生效可以是延迟的，即，当天做了修改，第二天才会生效。<br>  在表tnp_search_table里边增加字段：is_delay_effect,意思是是否延迟生效;</p>
<p>  如果某个表被设置了延迟生效，那么当这个表的数据发生变化的时候，不会执行回溯过程，比如标签表是一个被商品表引用的元数据表，如果一个标签被成千上万个商品打标，那么如果标签的元数据发生变化，那么这些成天上万的商品数据的索引中的标签信息需要被更新，而更新是比较缓慢的，是一个大数据量的更新，耗时比较长，因此，如果在标签表上设置了is_delay_effect&#x3D;yes，那么这个回溯会在当天晚上被调度任务执行，第二天生效。</p>
<h5 id="记录案发现场"><a href="#记录案发现场" class="headerlink" title="记录案发现场"></a>记录案发现场</h5><p>  如果某个表设置了is_delay_effect&#x3D;yes那么需要立刻记录案发现场到数据库。</p>
<p>  案发现场格式(tnp_change_snapshot)：<br>  id,      dataBase_id,table_id,table_name,operation_type,   changeDatas, status<br>  唯一序列，数据库id   ，表id    ,表名      ,操作类型(修改&#x2F;删除),当前变化的数据,状态</p>
<p>  修改和新增<br>  修改和新增都会有幂等，后边的更新覆盖前边的更新，减少无谓的消耗;<br>  只记录【id,dataBase_id,table_id,table_name,operation_type,status】<br>  删除<br>  记录【id,dataBase_id,table_id,table_name,operation_type,changeDatas,status】</p>
<h5 id="zk树形结构"><a href="#zk树形结构" class="headerlink" title="zk树形结构"></a>zk树形结构</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/search-center/[PERSISTENT]</span><br><span class="line">- nodes[PERSISTENT]</span><br><span class="line"> - node1[EPHEMERAL]</span><br><span class="line"> - node2[EPHEMERAL]</span><br><span class="line"> - node3[EPHEMERAL]</span><br><span class="line">   &#123;NodeId:&quot;&quot;,CloudStatus:&quot;REBALANCING/NORMAL&quot;,NodeStatus:&quot;CLEAN/CLEAN_OK/INIT/FINISH&quot;,SessionId:&quot;&quot;, jobType:&quot;index/job&quot;,</span><br><span class="line">     jobs:[&#123;id:&quot;&quot;,tableId:&quot;&quot;,status:&quot;&quot;,synCursor:&quot;&quot;,totalBucketNumber:&quot;&quot;,modNumber:&quot;&quot;,dataCursor:&quot;&quot;&#125;]</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="分片策略"><a href="#分片策略" class="headerlink" title="分片策略"></a>分片策略</h5><p> <img src="/delay.png" alt="delay.png"></p>
<h6 id="方案一【基于抽象】"><a href="#方案一【基于抽象】" class="headerlink" title="方案一【基于抽象】"></a>方案一【基于抽象】</h6><p>  首先根据我们保存的表关系的抽象模型，找到标签表关联了那张业务表，比如标签通过标签关系表关联了product表，那么我们的调度任务就要把整个product表所有数据刷新一遍，造成没有受到标签影响的product也刷新了，资源浪费，但是对已有程序复用性高。</p>
<h6 id="方案二【基于数据】"><a href="#方案二【基于数据】" class="headerlink" title="方案二【基于数据】"></a>方案二【基于数据】</h6><p>  从元数据的表开始往上回溯，一直到product表，中间要经过中间表的层层递归往上找到 product，优点是只更新元数据相关联的product，缺点是如果一个标签影响了10万product的数据，那个这个十万数据的刷新数据集不能拆分为桶，因为这个是一个单机多层递归而且是分页的过程，做分布式分桶很复杂，即，不能使用分布式的方式拆分压力。对已有程序复用性高。</p>
<h6 id="方案三【混合】"><a href="#方案三【混合】" class="headerlink" title="方案三【混合】"></a>方案三【混合】</h6><p>  新建表：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `tnp_search_change_snapshot` (</span><br><span class="line">  `id` varchar(64) COLLATE utf8_bin NOT NULL,</span><br><span class="line">  `database_id` varchar(64) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;数据库id&#x27;,</span><br><span class="line">  `table_id` varchar(64) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;表id&#x27;,</span><br><span class="line">  `c_table_name` varchar(45) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;表名称&#x27;,</span><br><span class="line">  `operation_type` varchar(45) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;操作类型(update/delete)&#x27;,</span><br><span class="line">  `business_id` varchar(64) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;业务id&#x27;,</span><br><span class="line">  `change_datas` varchar(4096) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;发生变化的数据，用于删除额情况&#x27;,</span><br><span class="line">  `c_status` varchar(45) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;状态：init,running,error,done&#x27;,</span><br><span class="line">  `attach_date` date DEFAULT NULL COMMENT &#x27;数据进入搜索系统的时间&#x27;,</span><br><span class="line">  `create_time` datetime DEFAULT NULL,</span><br><span class="line">  `modify_time` datetime DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `unit_index` (`database_id`,`table_id`,`operation_type`,`business_id`,`c_status`,`attach_date`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;案发现场快照表&#x27;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `tnp_search_relation_top` (</span><br><span class="line">`id` varchar(64) COLLATE utf8_bin NOT NULL,</span><br><span class="line">`table_id` varchar(64) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27; 当前表id&#x27;,</span><br><span class="line">`relation_data_base_id` varchar(64) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;关联数据库id&#x27;,</span><br><span class="line">`relation_table_id` varchar(64) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;关联表id&#x27;,</span><br><span class="line">`relation_table_column_id` varchar(45) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;关联表的字段id&#x27;,</span><br><span class="line">`level_sql` varchar(2048) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;当前层级的sql&#x27;,</span><br><span class="line">`level_sql_output_business_column` varchar(64) COLLATE utf8_bin DEFAULT NULL COMMENT &#x27;level_sql输出的业务id&#x27;,</span><br><span class="line">`level_sql_output_target_column` varchar(64) COLLATE utf8_bin DEFAULT NULL,</span><br><span class="line">`create_time` datetime DEFAULT NULL,</span><br><span class="line">`modify_time` datetime DEFAULT NULL,</span><br><span class="line">PRIMARY KEY (`id`),</span><br><span class="line">UNIQUE KEY `rt_unit_index` (`table_id`,`relation_table_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;表关联的顶层表的关系&#x27;</span><br></pre></td></tr></table></figure><br>  A-(DB1-从快照表收集数据)-程序固定写死-调度任务发起的节点执行:<br>  select database_id,table_id,business_id from tnp_search_change_snapshot where status&#x3D;”init”<br>  B-(DB2-中间数据-分桶-分页)-tnp_search_relation_top.level_sql字段-桶节点执行:<br>  select lr.target_id,lr.target_type,label.label_name from tnp_label label right join tnp_label_relation lr on label.id&#x3D;lr.label_id<br>  where lr.label_id in (A.business_id) and UNIX_TIMESTAMP(lr.create_time) mod 6 &#x3D; 1 limit 1,20<br>  C-(DB3-业务数据刷新)-桶节点执行:<br>  select * from tnp_product【tnp_search_relation_top.relation_table_id】 where id in (B.target_id) limit 1,20<br>  程序复用性低，编写新的逻辑。</p>
<p>  风险：<br>  1、只能支持跨2个业务数据库（支持同一个数据库水平拆分）。</p>
<h4 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h4><ul>
<li>调度任务扫描tnp_change_snapshot，得到调度列表。将每一个调度抽象为线程可运行的实体;</li>
<li>获取当前集群可用机器数量（zk临时节点数量）;</li>
<li>调度和rebalance是互斥的2个任务;<ul>
<li>如果当前集群正在REBALANCING，job类型是index，那么snapshopJobs无法执行，线程等待重试，重试次数是有限制的;</li>
<li>如果当前集群正在REBALANCING，job类型是调度(job)，那么index重负载无法执行，线程等待重试，重试次数是有限制的;</li>
</ul>
</li>
<li>开始执行调度任务，设置当前任务的db状态是running，如果任务中断（断电），那么重启之后会重新拉起running的任务;</li>
<li>当一个任务执行完毕之后，线程会删除这个任务的DB和zk里边的数据;</li>
<li>到目前为止系统有2种调度：<ul>
<li>复盘调度：当天发生变化的数据，晚上重新覆盖一次;</li>
<li>数据延迟生效调度：针对于引起蝴蝶效应的数据进行生效;</li>
</ul>
</li>
</ul>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p>  <img src="/SearchCenterCLassDiagram.jpg" alt="SearchCenterCLassDiagram.jpg"></p>
<h4 id="启动流程图"><a href="#启动流程图" class="headerlink" title="启动流程图"></a>启动流程图</h4><p>  <img src="/boot-sequence.png" alt="boot-sequence.png"></p>
<h4 id="索引创建流程图"><a href="#索引创建流程图" class="headerlink" title="索引创建流程图"></a>索引创建流程图</h4><p>  <img src="/SerarchCenterJobSequenceDiagram.jpg" alt="SerarchCenterJobSequenceDiagram.jpg"></p>
<h4 id="消息消费流程图"><a href="#消息消费流程图" class="headerlink" title="消息消费流程图"></a>消息消费流程图</h4><p>  <img src="/SerarchCenterConsumerSequenceDiagram.jpg" alt="SerarchCenterConsumerSequenceDiagram.jpg"></p>
<h4 id="DDL-SQL"><a href="#DDL-SQL" class="headerlink" title="DDL-SQL"></a>DDL-SQL</h4><p>  <a href="sql/tnp_search_tnp_kafka_offset.sql">tnp_search_tnp_kafka_offset.sql</a><br>  <a href="sql/tnp_search_tnp_search_change_snapshot.sql">tnp_search_tnp_search_change_snapshot.sql</a><br>  <a href="sql/tnp_search_tnp_search_column.sql">tnp_search_tnp_search_column.sql</a><br>  <a href="sql/tnp_search_tnp_search_column_table.sql">tnp_search_tnp_search_column_table.sql</a><br>  <a href="sql/tnp_search_tnp_search_database.sql">tnp_search_tnp_search_database.sql</a><br>  <a href="sql/tnp_search_tnp_search_dynamic_word.sql">tnp_search_tnp_search_dynamic_word.sql</a><br>  <a href="sql/tnp_search_tnp_search_job.sql">tnp_search_tnp_search_job.sql</a><br>  <a href="sql/tnp_search_tnp_search_relation_top.sql">tnp_search_tnp_search_relation_top.sql</a><br>  <a href="sql/tnp_search_tnp_search_table.sql">tnp_search_tnp_search_table.sql</a><br>  <a href="sql/tnp_search_tnp_search_table_syns_log.sql">tnp_search_tnp_search_table_syns_log.sql</a><br>  <a href="sql/tnp_search_tnp_search_topic.sql">tnp_search_tnp_search_topic.sql</a></p>
<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>  代码正在脱敏。。。。稍后即来。。。。</p>
]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>第1个ARM裸板程序及引申</title>
    <url>/2023/05/01/embed/diyigearmluobanchengxu/</url>
    <content><![CDATA[<h1 id="硬件知识-LED原理图-辅线"><a href="#硬件知识-LED原理图-辅线" class="headerlink" title="硬件知识_LED原理图(辅线)"></a>硬件知识_LED原理图(辅线)</h1><p>怎样点亮一个LED？</p>
<ol>
<li>看原理图，确定控制LED的引脚，</li>
<li>看主芯片手册，确定如何设置&#x2F;控制引脚</li>
<li>写程序<br><img src="https://s2.loli.net/2023/11/12/YITWXSRGCQB8em9.png" alt="image.png"><span id="more"></span></li>
</ol>
<h2 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h2><p>led的电阻很小，接通电源以后，其本身的电流很大，会被烧毁<br><img src="https://s2.loli.net/2023/05/01/TMUk48wPXho9KWE.png" alt="image.png"><br>因此在他之前加了一个电阻：<br><img src="https://s2.loli.net/2023/05/01/gkCuEthS3zjFmX1.png" alt="image.png"></p>
<p>这里的开关使我们手动的，在芯片里边都是引脚，引脚可以输出一个电压值<br><img src="https://s2.loli.net/2023/05/01/PVkBqd91YbR8zUX.png" alt="image.png"><br>还可以<br><img src="https://s2.loli.net/2023/05/01/bBUsd51ZpfOxciu.png" alt="image.png"></p>
<p>有些芯片的引脚驱动不足，电压很低，不能驱动LED，这个时候需要三极管<br><img src="https://s2.loli.net/2023/05/01/mHWpOifNJRslraG.png" alt="image.png"><br><img src="https://s2.loli.net/2023/05/01/f3QMhN9qomtFWBg.png" alt="image.png"></p>
<h2 id="硬件知识"><a href="#硬件知识" class="headerlink" title="硬件知识"></a>硬件知识</h2><p>打开s3c2440的芯片手册，搜索LED<br><img src="https://s2.loli.net/2023/05/01/KmMtz96dpRVCBwF.png" alt="image.png"><br>这个LED接了一个3.3V的电源，然后接到芯片的nLED_1，当nLED_1输出高电平的时候，LED熄灭，当nLED_1输出低电平的时候，n指的是低电平有效。<br>我们在s3c2440手册里边找到nLED_1连接的脚本是EINT4&#x2F;GPT4<br><img src="https://s2.loli.net/2023/05/01/gQR2Vx6OYCcDtjJ.png" alt="image.png"></p>
<p>我们打开s3c2440找到gpt4的使用，芯片里边有A-J组引脚，gpt4在Port F(GPF)这一组里边<br><img src="https://s2.loli.net/2023/05/01/V6tceIa2QZNYdGE.png" alt="image.png"><br>现在的问题是怎么把GPT4的引脚设置为输出低电平？</p>
<ol>
<li>GPT4配置为输出引脚，注意每个引脚都可以配置为输出引脚还是输入引脚<br><img src="https://s2.loli.net/2023/05/01/V6tceIa2QZNYdGE.png" alt="image.png"><br>GPT4可以设置输入，也可以设置输出，也可以设置中断功能。<br><img src="https://s2.loli.net/2023/05/01/wHu3a9y4tqZSknX.png" alt="image.png"></li>
</ol>
<h1 id="编程设置它的状态"><a href="#编程设置它的状态" class="headerlink" title="编程设置它的状态"></a>编程设置它的状态</h1><p>这个是GPFCON和GPFDAT寄存器的地址：<br><img src="https://s2.loli.net/2023/05/01/Hq2pimJxKaRrwDv.png" alt="image.png"><br>设置GPFCON的[9:8]为0b01，那么GPF4设置为输出引脚,即把0x100写入GPFCON，就是写到地址0x56000050.<br>下面是GPFDATA寄存器的设置说明<br><img src="https://s2.loli.net/2023/05/01/G4q2T3K6aUlXE1A.png" alt="image.png"><br>GPFDATA的意思是设置对应引脚编号的位置为对应引脚输出的值。<br>比如是GPF4：<br>LED熄灭：那么就设置GPFDATA的第4位为1，即为输出高电平，把0x10写到地址0x56000054上；<br>LED点亮：设置GPFDATA的第4位为0，即为输出低电平，把0写到地址0x56000054上；</p>
<p>接下来就是写代码去配置，在写代码配置之前，需要先来了解下s3c2440框架和启动过程<br><img src="https://s2.loli.net/2023/05/01/H5GrkCWlLD2Qw7T.png" alt="image.png"><br>启动过程如下：</p>
<ol>
<li><p>nor启动：nor flash基地址为0，片内RAM地址为0x4000,0000<br>cpu读出nor上第一个指令（前4字节），执行。<br>cpu继续读出其他指令执行。</p>
</li>
<li><p>nand启动：片内4Kram基地址为0，nor flash不可访问，2440硬件把nand前4K内容复制到片内RAM，然后cpu从0地址取出第一条指令执行。</p>
</li>
</ol>
<p>另外，cpu操作寄存器的形式如下：<br><img src="https://s3.bmp.ovh/imgs/2023/05/27/6c3d971cd12ba611.png"></p>
<ol start="4">
<li><p>操作寄存器的几个汇编指令<br>4.1 LDR 指令<br>读内存，LDR R0,[R1] ,假设R1的值是x，读取地址x上的数据（4字节），保存到R0中。<br>4.2 STR指令<br>写内存指令，STR R0,[R1]<br>假设R1的值是x，把R0的值写到地址X（4字节）<br>4.3 B指令<br>跳转<br>4.4 MOV指令<br>MOV R0,R1 把R1的值赋值给R0，R0&#x3D;R1；<br>MOV R0,#0x100，R0&#x3D;0x100;<br>4.5 LDR R0,&#x3D;0x12345678:R0&#x3D;0x12345678<br>这是一条伪指令，它会被拆分为几条真正的RAM指令<br>如果我们用MOV R0,0x12345678，这样是错误的，不能正确执行，因为一条ARM指令长度是32位，除了数据意外，还需要表示指令本身以及其他变量。<br><img src="https://s3.bmp.ovh/imgs/2023/05/27/88729adcce5541c4.png"><br>所以引入伪指令 LDR R0,&#x3D;0x12345678<br>4.6 加减法<br>add r0,r1,#4:r0&#x3D;r1+4 ;<br>sub r0,r1,#4:r0&#x3D;r1-4;<br>sub r0,r1,r2:r0&#x3D;r1-r2;<br>4.7 bl指令<br>branch and link</p>
</li>
<li><p>编写程序<br>我们写的第一个程序是汇编程序，不会上来就写c语言main函数。<br>新建文件led_on.S</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 点亮LED1: gpf4</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">/* 配置GPF4为输出引脚</span><br><span class="line"> * 把0x100写到地址0x56000050</span><br><span class="line"> */</span><br><span class="line">	ldr r1, =0x56000050</span><br><span class="line">	ldr r0, =0x100	/* mov r0, #0x100 */</span><br><span class="line">	str r0, [r1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 设置GPF4输出高电平</span><br><span class="line"> * 把0写到地址0x56000054</span><br><span class="line"> */</span><br><span class="line">	ldr r1, =0x56000054</span><br><span class="line">	ldr r0, =0	/* mov r0, #0 */</span><br><span class="line">	str r0, [r1]</span><br><span class="line"></span><br><span class="line">	/* 死循环 */</span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>
<p>将此文件放在linux系统编译：<br>5.1.  预编译<br> arm-linux-gcc -c -o led_on.o led_on.S<br>5.2. 连接<br>arm-linux-ld -Ttext 0 led_on.o -o led_on.elf<br>5.3. 得到bin文件<br>arm-linux-objcopy -o binary -S led_on.elf led_on.bin<br>这些命令写的时候容易出错，可以放在一个文件里边。<br>文件名为Makefile</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">all:</span><br><span class="line">	arm-linux-gcc -c -o led_on.o led_on.S</span><br><span class="line">	arm-linux-ld -Ttext 0 led_on.o -o led_on.elf</span><br><span class="line">	arm-linux-objcopy -O binary -S led_on.elf led_on.bin</span><br><span class="line">	arm-linux-objdump -D led_on.elf &gt; led_on.dis</span><br><span class="line">clean:</span><br><span class="line">	rm *.bin *.o *.elf</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>5.4. 然后使用make clean来清除，使用make命令来编译</p>
<h1 id="烧写"><a href="#烧写" class="headerlink" title="烧写"></a>烧写</h1><p>将在linux下编译好的并文件copy到windows平台下<br>硬件接好烧写器<br>烧写命令:<br>oflash led_on.bin<br><img src="https://s3.bmp.ovh/imgs/2023/05/27/535c9277e2ab23f9.png"><br>一次输入0、1、0、0、0<br>接下来把烧写排线拔掉，关电，设置为nand启动，上电。<br>效果就是有一个灯亮了。</p>
<h1 id="汇编与机器码"><a href="#汇编与机器码" class="headerlink" title="汇编与机器码"></a>汇编与机器码</h1><p>上边的makefile文件有一条	arm-linux-objdump -D led_on.elf &gt; led_on.dis 这条命令是反汇编指令，会得到一个 led_on.dis文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">led_on.elf:     file format elf32-littlearm</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000000 &lt;_start&gt;:</span><br><span class="line">   0:	e59f1014 	ldr	r1, [pc, #20]	; 1c &lt;.text+0x1c&gt;</span><br><span class="line">   4:	e3a00c01 	mov	r0, #256	; 0x100</span><br><span class="line">   8:	e5810000 	str	r0, [r1]</span><br><span class="line">   c:	e59f100c 	ldr	r1, [pc, #12]	; 20 &lt;.text+0x20&gt;</span><br><span class="line">  10:	e3a00000 	mov	r0, #0	; 0x0</span><br><span class="line">  14:	e5810000 	str	r0, [r1]</span><br><span class="line"></span><br><span class="line">00000018 &lt;halt&gt;:</span><br><span class="line">  18:	eafffffe 	b	18 &lt;halt&gt;</span><br><span class="line">  1c:	56000050 	undefined</span><br><span class="line">  20:	56000054 	undefined</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上边我们提到cpu可以直接访问的寄存器从R0到R15，pc是什么，pc是一个别名，有一张如下的映射表：</p>
<p>User 模式  SVC 模式   IRQ 模式   FIQ 模式  APCS</p>
<p>R0 ——- R0 ——- R0 ——- R0        a1<br>R1 ——- R1 ——- R1 ——- R1        a2<br>R2 ——- R2 ——- R2 ——- R2        a3<br>R3 ——- R3 ——- R3 ——- R3        a4<br>R4 ——- R4 ——- R4 ——- R4        v1<br>R5 ——- R5 ——- R5 ——- R5        v2<br>R6 ——- R6 ——- R6 ——- R6        v3<br>R7 ——- R7 ——- R7 ——- R7        v4<br>R8 ——- R8 ——- R8         R8_fiq    v5<br>R9 ——- R9 ——- R9         R9_fiq    v6<br>R10 —— R10 —— R10        R10_fiq   sl<br>R11 —— R11 —— R11        R11_fiq   fp<br>R12 —— R12 —— R12        R12_fiq   ip<br>R13        R13_svc    R13_irq    R13_fiq   sp<br>R14        R14_svc    R14_irq    R14_fiq   lr<br>————- R15 &#x2F; PC ————-       pc<br>上边的汇编指令执行的时候哦，会是如下的方式：<br><img src="https://s3.bmp.ovh/imgs/2023/05/27/15efca16247ab67c.png"></p>
<h1 id="字节序和位操作"><a href="#字节序和位操作" class="headerlink" title="字节序和位操作"></a>字节序和位操作</h1><p><img src="https://s2.loli.net/2023/11/12/rkCfSFTe5vRscgV.jpg" alt="编程知识_节序_位操作.jpg"></p>
<h1 id="C语言点亮LED"><a href="#C语言点亮LED" class="headerlink" title="C语言点亮LED"></a>C语言点亮LED</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int *pGPFCON = (unsigned int *)0x56000050;</span><br><span class="line">	unsigned int *pGPFDAT = (unsigned int *)0x56000054;</span><br><span class="line"></span><br><span class="line">	/* 配置GPF4为输出引脚 */</span><br><span class="line">	*pGPFCON = 0x100;</span><br><span class="line"></span><br><span class="line">	/* 设置GPF4输出0 */</span><br><span class="line">	*pGPFDAT = 0;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建一个Start.S文件，用于为C语言文件设置内存，调用main函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">	/* 设置内存: sp 栈 */</span><br><span class="line">	ldr sp, =4096  /* nand启动 */</span><br><span class="line">//	ldr sp, =0x40000000+4096  /* nor启动 */</span><br><span class="line"></span><br><span class="line">	/* 调用main */</span><br><span class="line">	bl main</span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>

<p>C语言视角内存操作：<br><img src="https://s2.loli.net/2023/11/12/azStEmYAbQKjl3f.jpg" alt="编写C程序控制LED.jpg"></p>
<h1 id="解析C程序的内部机制"><a href="#解析C程序的内部机制" class="headerlink" title="解析C程序的内部机制"></a>解析C程序的内部机制</h1><p>上面点亮LED的代码，反编译为汇编指令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">led.elf:     file format elf32-littlearm</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000000 &lt;_start&gt;:</span><br><span class="line">   0:	e3a0da01 	mov	sp, #4096	; 0x1000</span><br><span class="line">   4:	eb000000 	bl	c &lt;main&gt;</span><br><span class="line"></span><br><span class="line">00000008 &lt;halt&gt;:</span><br><span class="line">   8:	eafffffe 	b	8 &lt;halt&gt;</span><br><span class="line"></span><br><span class="line">0000000c &lt;main&gt;:</span><br><span class="line">   c:	e1a0c00d 	mov	ip, sp</span><br><span class="line">  10:	e92dd800 	stmdb	sp!, &#123;fp, ip, lr, pc&#125;</span><br><span class="line">  14:	e24cb004 	sub	fp, ip, #4	; 0x4</span><br><span class="line">  18:	e24dd008 	sub	sp, sp, #8	; 0x8</span><br><span class="line">  1c:	e3a03456 	mov	r3, #1442840576	; 0x56000000</span><br><span class="line">  20:	e2833050 	add	r3, r3, #80	; 0x50</span><br><span class="line">  24:	e50b3010 	str	r3, [fp, #-16]</span><br><span class="line">  28:	e3a03456 	mov	r3, #1442840576	; 0x56000000</span><br><span class="line">  2c:	e2833054 	add	r3, r3, #84	; 0x54</span><br><span class="line">  30:	e50b3014 	str	r3, [fp, #-20]</span><br><span class="line">  34:	e51b2010 	ldr	r2, [fp, #-16]</span><br><span class="line">  38:	e3a03c01 	mov	r3, #256	; 0x100</span><br><span class="line">  3c:	e5823000 	str	r3, [r2]</span><br><span class="line">  40:	e51b2014 	ldr	r2, [fp, #-20]</span><br><span class="line">  44:	e3a03000 	mov	r3, #0	; 0x0</span><br><span class="line">  48:	e5823000 	str	r3, [r2]</span><br><span class="line">  4c:	e3a03000 	mov	r3, #0	; 0x0</span><br><span class="line">  50:	e1a00003 	mov	r0, r3</span><br><span class="line">  54:	e24bd00c 	sub	sp, fp, #12	; 0xc</span><br><span class="line">  58:	e89da800 	ldmia	sp, &#123;fp, sp, pc&#125;</span><br><span class="line">Disassembly of section .comment:</span><br><span class="line"></span><br><span class="line">00000000 &lt;.comment&gt;:</span><br><span class="line">   0:	43434700 	cmpmi	r3, #0	; 0x0</span><br><span class="line">   4:	4728203a 	undefined</span><br><span class="line">   8:	2029554e 	eorcs	r5, r9, lr, asr #10</span><br><span class="line">   c:	2e342e33 	mrccs	14, 1, r2, cr4, cr3, &#123;1&#125;</span><br><span class="line">  10:	Address 0x10 is out of bounds.</span><br></pre></td></tr></table></figure>
<p>在讲解这段指令之前，需要先解释下里边的一些陌生指令：<br>stmdb和ldmia指令。<br><img src="https://s2.loli.net/2023/11/19/Bs1eIUb5qH9ayEL.png" alt="image.png"></p>
<p>下面对这段指令进行解析:<br><img src="https://s2.loli.net/2023/11/12/U4LcDuHOaCokinr.jpg" alt="解析C程序的内部机制.jpg"></p>
<h1 id="给C程序传递参数"><a href="#给C程序传递参数" class="headerlink" title="给C程序传递参数"></a>给C程序传递参数</h1><p>修改Start.S文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">	/* 设置内存: sp 栈 */</span><br><span class="line">	ldr sp, =4096  /* nand启动 */</span><br><span class="line">//	ldr sp, =0x40000000+4096  /* nor启动 */</span><br><span class="line"></span><br><span class="line">	mov r0, #4</span><br><span class="line">	bl led_on</span><br><span class="line"></span><br><span class="line">	ldr r0, =100000</span><br><span class="line">	bl delay</span><br><span class="line"></span><br><span class="line">	mov r0, #5</span><br><span class="line">	bl led_on</span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>修改ldc.c文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void delay(volatile int d)</span><br><span class="line">&#123;</span><br><span class="line">	while (d--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int led_on(int which)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned int *pGPFCON = (unsigned int *)0x56000050;</span><br><span class="line">	unsigned int *pGPFDAT = (unsigned int *)0x56000054;</span><br><span class="line"></span><br><span class="line">	if (which == 4)</span><br><span class="line">	&#123;</span><br><span class="line">		/* 配置GPF4为输出引脚 */</span><br><span class="line">		*pGPFCON = 0x100;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (which == 5)</span><br><span class="line">	&#123;</span><br><span class="line">		/* 配置GPF5为输出引脚 */</span><br><span class="line">		*pGPFCON = 0x400;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 设置GPF4/5输出0 */</span><br><span class="line">	*pGPFDAT = 0;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序先让第一个灯亮，然后等了一段时间(delay函数)，又让第二个灯亮，参数传递使用了r0寄存器，那么调用者和被调用者之前都是使用那些寄存器呢，下面是一套使用标准：<br><img src="https://s2.loli.net/2023/11/19/Qfd6RgjpSiBbqEh.png" alt="image.png"></p>
<h1 id="关闭看门狗"><a href="#关闭看门狗" class="headerlink" title="关闭看门狗"></a>关闭看门狗</h1><p>以上程序在运行的时候，2个灯被依次点亮，然后又会往复循环点亮，这是因为系统有保护机制，防止程序卡死，不能使用，会重新复位系统，内置了看门狗机制，我们可以关闭看门狗：<br>Start.S修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">  /* 关闭看门狗 */</span><br><span class="line">  ldr r0, =0x53000000</span><br><span class="line">  ldr r1, =0</span><br><span class="line">  str r1, [r0]</span><br><span class="line"></span><br><span class="line">	/* 设置内存: sp 栈 */</span><br><span class="line">	ldr sp, =4096  /* nand启动 */</span><br><span class="line">//	ldr sp, =0x40000000+4096  /* nor启动 */</span><br><span class="line"></span><br><span class="line">	mov r0, #4</span><br><span class="line">	bl led_on</span><br><span class="line"></span><br><span class="line">	ldr r0, =100000</span><br><span class="line">	bl delay</span><br><span class="line"></span><br><span class="line">	mov r0, #5</span><br><span class="line">	bl led_on</span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>

<h1 id="程序兼容nor启动和nand启动"><a href="#程序兼容nor启动和nand启动" class="headerlink" title="程序兼容nor启动和nand启动"></a>程序兼容nor启动和nand启动</h1><p>修改Start.S</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">	/* 关闭看门狗 */</span><br><span class="line">	ldr r0, =0x53000000</span><br><span class="line">	ldr r1, =0</span><br><span class="line">	str r1, [r0]</span><br><span class="line"></span><br><span class="line">	/* 设置内存: sp 栈 */</span><br><span class="line">	/* 分辨是nor/nand启动</span><br><span class="line">	 * 写0到0地址, 再读出来</span><br><span class="line">	 * 如果得到0, 表示0地址上的内容被修改了, 它对应ram, 这就是nand启动</span><br><span class="line">	 * 否则就是nor启动</span><br><span class="line">	 */</span><br><span class="line">	mov r1, #0</span><br><span class="line">	ldr r0, [r1] /* 读出原来的值备份 */</span><br><span class="line">	str r1, [r1] /* 0-&gt;[0] */</span><br><span class="line">	ldr r2, [r1] /* r2=[0] */</span><br><span class="line">	cmp r1, r2   /* r1==r2? 如果相等表示是NAND启动 */</span><br><span class="line">	ldr sp, =0x40000000+4096 /* 先假设是nor启动 */</span><br><span class="line">	moveq sp, #4096  /* nand启动 */</span><br><span class="line">	streq r0, [r1]   /* 恢复原来的值 */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	bl main</span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>修改led.c文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &quot;s3c2440_soc.h&quot;</span><br><span class="line"></span><br><span class="line">void delay(volatile int d)</span><br><span class="line">&#123;</span><br><span class="line">	while (d--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int val = 0;  /* val: 0b000, 0b111 */</span><br><span class="line">	int tmp;</span><br><span class="line"></span><br><span class="line">	/* 设置GPFCON让GPF4/5/6配置为输出引脚 */</span><br><span class="line">	GPFCON &amp;= ~((3&lt;&lt;8) | (3&lt;&lt;10) | (3&lt;&lt;12));</span><br><span class="line">	GPFCON |=  ((1&lt;&lt;8) | (1&lt;&lt;10) | (1&lt;&lt;12));</span><br><span class="line"></span><br><span class="line">	/* 循环点亮 */</span><br><span class="line">	while (1)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp = ~val;</span><br><span class="line">		tmp &amp;= 7;</span><br><span class="line">		GPFDAT &amp;= ~(7&lt;&lt;4);</span><br><span class="line">		GPFDAT |= (tmp&lt;&lt;4);</span><br><span class="line">		delay(100000);</span><br><span class="line">		val++;</span><br><span class="line">		if (val == 8)</span><br><span class="line">			val =0;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上2个文件兼容nor和nand启动。</p>
<h1 id="按钮控制led点亮"><a href="#按钮控制led点亮" class="headerlink" title="按钮控制led点亮"></a>按钮控制led点亮</h1><p><img src="https://s2.loli.net/2023/11/19/BfnTmzg1GlW3j2c.png" alt="image.png"><br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>EINT0控制LED_1，EINT2控制LED_2，EINT11控制LED_4。查看原理图<br><img src="https://s2.loli.net/2023/11/19/Zvu4QGN2dimYbg1.png" alt="image.png"><br>寻找他们对应的引脚：<br><img src="https://s2.loli.net/2023/11/19/cCRre7P5ptQwE1T.png" alt="image.png"><br><img src="https://s2.loli.net/2023/11/19/SrUzhMkGpNlt7CT.png" alt="image.png"><br>按键和引脚的对应关系:EINT0:GPF0,EINT2:GPF2,EINT11:GPG3;<br>想找到GPFCON的2个引脚配置：<br>GPFCON引脚的地址是：0x56000050<br><img src="https://s2.loli.net/2023/11/19/AYKRnj7pq8skNxB.png" alt="image.png"><br>GPGCON引脚配置：<br>GPGCON引脚的地址是：0x56000060<br><img src="https://s2.loli.net/2023/11/19/c9ybNWzfK8GJskm.png" alt="image.png"><br>GPFDATA和GPGDATA的地址分别是：0x56000054、0x56000064，这些都可以通过S3C2440芯片手册找到。<br>还有一个问题是，怎么判断按键是被按下或者松开？看下原理图：<br><img src="https://s2.loli.net/2023/11/19/5UwPS8ib1pcsnhf.png" alt="image.png"><br>这样，只要我们的程序只要检测到引脚GPF0是高电平意味着开关没有被按下，如果是低电平，意味着开关被按下。<br>然后就是确认3盏灯的控制引脚：<br><img src="https://s2.loli.net/2023/11/19/kSNCWVE8YcpK7a9.png" alt="image.png"><br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p>EINT0控制LED_1，EINT2控制LED_2，EINT11控制LED_4。查看原理图</p>
<p><img src="https://s2.loli.net/2023/11/19/Zvu4QGN2dimYbg1.png" alt="image.png"></p>
<p>寻找他们对应的引脚：</p>
<p><img src="https://s2.loli.net/2023/11/19/cCRre7P5ptQwE1T.png" alt="image.png"></p>
<p><img src="https://s2.loli.net/2023/11/19/SrUzhMkGpNlt7CT.png" alt="image.png"></p>
<p>按键和引脚的对应关系:EINT0:GPF0,EINT2:GPF2,EINT11:GPG3;<br>想找到GPFCON的2个引脚配置：<br>GPFCON引脚的地址是：0x56000050</p>
<p><img src="https://s2.loli.net/2023/11/19/AYKRnj7pq8skNxB.png" alt="image.png"></p>
<p>GPGCON引脚配置：<br>GPGCON引脚的地址是：0x56000060</p>
<p><img src="https://s2.loli.net/2023/11/19/c9ybNWzfK8GJskm.png" alt="image.png"></p>
<p>GPFDATA和GPGDATA的地址分别是：0x56000054、0x56000064，这些都可以通过S3C2440芯片手册找到。<br>还有一个问题是，怎么判断按键是被按下或者松开？看下原理图：</p>
<p><img src="https://s2.loli.net/2023/11/19/5UwPS8ib1pcsnhf.png" alt="image.png"></p>
<p>这样，只要我们的程序只要检测到引脚GPF0是高电平意味着开关没有被按下，如果是低电平，意味着开关被按下。<br>然后就是确认3盏灯的控制引脚：</p>
<p><img src="https://s2.loli.net/2023/11/19/kSNCWVE8YcpK7a9.png" alt="image.png"></p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>db05d90729ee645598105d778a95820856c0bfea<br>分别是GPF4，GPF5，GPF6.<br>接下里就可以把led.c程序写出来：</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;s3c2440_soc.h&quot;</span><br><span class="line"></span><br><span class="line">void delay(volatile int d)</span><br><span class="line">&#123;</span><br><span class="line">	while (d--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int val1, val2;</span><br><span class="line"></span><br><span class="line">	/* 设置GPFCON让GPF4/5/6配置为输出引脚 */</span><br><span class="line">	GPFCON &amp;= ~((3&lt;&lt;8) | (3&lt;&lt;10) | (3&lt;&lt;12));</span><br><span class="line">	GPFCON |=  ((1&lt;&lt;8) | (1&lt;&lt;10) | (1&lt;&lt;12));</span><br><span class="line"></span><br><span class="line">	/* 配置3个按键引脚为输入引脚:</span><br><span class="line">	 * GPF0(S2),GPF2(S3),GPG3(S4)</span><br><span class="line">	 */</span><br><span class="line">	GPFCON &amp;= ~((3&lt;&lt;0) | (3&lt;&lt;4));  /* gpf0,2 */</span><br><span class="line">	GPGCON &amp;= ~((3&lt;&lt;6));  /* gpg3 */</span><br><span class="line"></span><br><span class="line">	/* 循环点亮 */</span><br><span class="line">	while (1)</span><br><span class="line">	&#123;</span><br><span class="line">		val1 = GPFDAT;</span><br><span class="line">		val2 = GPGDAT;</span><br><span class="line"></span><br><span class="line">		if (val1 &amp; (1&lt;&lt;0)) /* s2 --&gt; gpf6 */</span><br><span class="line">		&#123;</span><br><span class="line">			/* 松开 */</span><br><span class="line">			GPFDAT |= (1&lt;&lt;6);</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			/* 按下 */</span><br><span class="line">			GPFDAT &amp;= ~(1&lt;&lt;6);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (val1 &amp; (1&lt;&lt;2)) /* s3 --&gt; gpf5 */</span><br><span class="line">		&#123;</span><br><span class="line">			/* 松开 */</span><br><span class="line">			GPFDAT |= (1&lt;&lt;5);</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			/* 按下 */</span><br><span class="line">			GPFDAT &amp;= ~(1&lt;&lt;5);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (val2 &amp; (1&lt;&lt;3)) /* s4 --&gt; gpf4 */</span><br><span class="line">		&#123;</span><br><span class="line">			/* 松开 */</span><br><span class="line">			GPFDAT |= (1&lt;&lt;4);</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			/* 按下 */</span><br><span class="line">			GPFDAT &amp;= ~(1&lt;&lt;4);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>如果你觉得我的文章有用，可以打赏我一杯雀巢咖啡<br><img src="https://i.postimg.cc/8Pmvqq4J/b1c4562d7729c208aef2f861473f309.jpg" alt="image.jpg"></p>
]]></content>
      <categories>
        <category>embed</category>
      </categories>
      <tags>
        <tag>embed</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc编译器和makeFile详解</title>
    <url>/2023/11/19/embed/gcc_makeFile/</url>
    <content><![CDATA[<h1 id="gcc常用选项"><a href="#gcc常用选项" class="headerlink" title="gcc常用选项"></a>gcc常用选项</h1><ul>
<li>x86平台<ul>
<li>windos应用程序:建立工程-编辑-编译(vc6.0)-运行</li>
<li>ubuntu应用程序:编辑-编译(gcc)-运行</li>
</ul>
</li>
<li>arm裸机：编辑-编译(arm-linux-gcc)-烧写-运行<ul>
<li>hello.c —预处理—&gt; hello.i —编译—&gt; hello.s —汇编—&gt; hello.o —连接—&gt; hello</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h1 id="gcc常用编译选项"><a href="#gcc常用编译选项" class="headerlink" title="gcc常用编译选项"></a>gcc常用编译选项</h1><p>gcc和arm-linux-gcc的常用选项</p>
<h3 id="gcc的使用方法："><a href="#gcc的使用方法：" class="headerlink" title="gcc的使用方法："></a>gcc的使用方法：</h3><p>gcc  [选项]   文件名</p>
<p>gcc常用选项：<br>  -v：查看gcc编译器的版本，显示gcc执行时的详细过程<br>  -o <file>                Place the output into <file><br>                           指定输出文件名为file，这个名称不能跟源文件名同名<br>  -E                       Preprocess only; do not compile, assemble or link<br>                           只预处理，不会编译、汇编、链接<br>  -S                       Compile only; do not assemble or link<br>                           只编译，不会汇编、链接<br>  -c                       Compile and assemble, but do not link<br>                           编译和汇编，不会链接<br>&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>gcc  -v：查看gcc编译器的版本</p>
<h4 id="方式1："><a href="#方式1：" class="headerlink" title="方式1："></a>方式1：</h4><p>gcc hello.c  输出一个a.out，然后.&#x2F;a.out来执行该应用程序。</p>
<p>gcc -o hello hello.c  输出hello，然后.&#x2F;hello来执行该应用程序。</p>
<h4 id="方式2："><a href="#方式2：" class="headerlink" title="方式2："></a>方式2：</h4><p>gcc -E -o hello.i hello.c<br>gcc -S -o hello.s hello.i<br>gcc -c -o hello.o hello.s<br>gcc -o hello hello.o</p>
<p>.o:object file(OBJ文件)<br>小结：<br>1）输入文件的后缀名和选项共同决定gcc到底执行那些操作。<br>2）在编译过程中，除非使用了-E、-S、-c选项(或者编译出错阻止了完整的编译过程)<br>   否则最后的步骤都是链接。</p>
<h4 id="方式3："><a href="#方式3：" class="headerlink" title="方式3："></a>方式3：</h4><p>gcc -c -o hello.o hello.c<br>gcc -o hello hello.o</p>
<p>gcc会对.c文件默认进行预处理操作，-c再来指明了编译、汇编，从而得到.o文件<br>再通过gcc -o hello hello.o将.o文件进行链接，得到可执行应用程序。</p>
<p>链接就是将汇编生成的OBJ文件、系统库的OBJ文件、库文件链接起来，<br>最终生成可以在特定平台运行的可执行程序。</p>
<p>crt1.o、crti.o、crtbegin.o、crtend.o、crtn.o是gcc加入的系统标准启动文件，<br>对于一般应用程序，这些启动是必需的。</p>
<p>-lc：链接libc库文件，其中libc库文件中就实现了printf等函数。</p>
<p>gcc -v -nostdlib -o hello hello.o会提示因为没有链接系统标准启动文件和标准库文件，而链接失败。<br>这个-nostdlib选项常用于裸机&#x2F;bootloader、linux内核等程序，因为它们不需要启动文件、标准库文件。</p>
<p>一般应用程序才需要系统标准启动文件和标准库文件。<br>裸机&#x2F;bootloader、linux内核等程序不需要启动文件、标准库文件。</p>
<p>动态链接使用动态链接库进行链接，生成的程序在执行的时候需要加载所需的动态库才能运行。<br>动态链接生成的程序体积较小，但是必须依赖所需的动态库，否则无法执行。</p>
<p>静态链接使用静态库进行链接，生成的程序包含程序运行所需要的全部库，可以直接运行，<br>不过静态链接生成的程序体积较大。</p>
<p>gcc -c -o hello.o hello.c<br>gcc -o hello_shared  hello.o<br>gcc -static -o hello_static hello.o</p>
<h1 id="makeFile"><a href="#makeFile" class="headerlink" title="makeFile"></a>makeFile</h1><h2 id="Makefile的引入及规则"><a href="#Makefile的引入及规则" class="headerlink" title="Makefile的引入及规则"></a>Makefile的引入及规则</h2><p>使用keil, mdk, avr等工具开发程序时点点鼠标就可以编译了，<br>它的内部机制是什么？它怎么组织管理程序？怎么决定编译哪一个文件？</p>
<p>gcc -o test a.c b.c<br>&#x2F;&#x2F; 简单,<br>&#x2F;&#x2F; 但是会对所有文件都处理一次,<br>&#x2F;&#x2F; 文件多时如果只修改其中一个文件会导致效率低</p>
<p>Makefile的核心—规则 :</p>
<p>目标 : 依赖1 依赖2 …<br>[TAB]命令</p>
<p>当”目标文件”不存在,<br>或<br>某个依赖文件比目标文件”新”,<br>则: 执行”命令”</p>
<h1 id="C语言复习"><a href="#C语言复习" class="headerlink" title="C语言复习"></a>C语言复习</h1><h2 id="Makefile的语法"><a href="#Makefile的语法" class="headerlink" title="Makefile的语法"></a>Makefile的语法</h2><p>a. 通配符: %.o<br>   $@ 表示目标<br>   $&lt; 表示第1个依赖文件<br>   $^ 表示所有依赖文件</p>
<p>b. 假想目标: .PHONY</p>
<p>c. 即时变量、延时变量, export<br>简单变量(即时变量) :<br>A :&#x3D; xxx   # A的值即刻确定，在定义时即确定<br>B &#x3D; xxx    # B的值使用到时才确定</p>
<p>:&#x3D;   # 即时变量<br>&#x3D;    # 延时变量<br>?&#x3D;   # 延时变量, 如果是第1次定义才起效, 如果在前面该变量已定义则忽略这句<br>+&#x3D;   # 附加, 它是即时变量还是延时变量取决于前面的定义</p>
<p>参考文档:<br>a. 百度搜 “gnu make 于凤昌”<br>b. 官方文档: <span class="exturl" data-url="aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL21ha2UvbWFudWFsLw==">http://www.gnu.org/software/make/manual/<i class="fa fa-external-link-alt"></i></span></p>
<p>如果想深入, 可以学习这视频:<br>第3期视频项目1, 第1课第4节_数码相框_编写通用的Makefile_P</p>
<h2 id="Makefile函数"><a href="#Makefile函数" class="headerlink" title="Makefile函数"></a>Makefile函数</h2><p>a. $(foreach var,list,text)<br>b. $(filter pattern…,text)      # 在text中取出符合patten格式的值<br>   $(filter-out pattern…,text)  # 在text中取出不符合patten格式的值</p>
<p>c. $(wildcard pattern)            # pattern定义了文件名的格式,<br>                                  # wildcard取出其中存在的文件<br>d. $(patsubst pattern,replacement,$(var))  # 从列表中取出每一个值<br>                                           # 如果符合pattern<br>                                           # 则替换为replacement</p>
<h2 id="Makefile实例"><a href="#Makefile实例" class="headerlink" title="Makefile实例"></a>Makefile实例</h2><p>a. 改进: 支持头文件依赖<br><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXExNDUyMDA4L2FydGljbGUvZGV0YWlscy81MDg1NTgxMA==">http://blog.csdn.net/qq1452008/article/details/50855810<i class="fa fa-external-link-alt"></i></span></p>
<p>gcc -M c.c &#x2F;&#x2F; 打印出依赖</p>
<p>gcc -M -MF c.d c.c  &#x2F;&#x2F; 把依赖写入文件c.d</p>
<p>gcc -c -o c.o c.c -MD -MF c.d  &#x2F;&#x2F; 编译c.o, 把依赖写入文件c.d</p>
<p>b. 添加CFLAGS<br>c. 分析裸板Makefile</p>
]]></content>
      <categories>
        <category>embed</category>
      </categories>
      <tags>
        <tag>embed</tag>
      </tags>
  </entry>
  <entry>
    <title>开发板熟悉与体验(jz2440)</title>
    <url>/2023/04/24/embed/kaifabanshuxihetiyan/</url>
    <content><![CDATA[<h1 id="选择什么开发板"><a href="#选择什么开发板" class="headerlink" title="选择什么开发板"></a>选择什么开发板</h1><p>我们学习单片机的目的是什么，是为了后期学习linux系统驱动做铺垫。<br>它的层级结构是这样的：<br>单片机-&gt;bootloader-&gt;linux系统&#x2F;驱动-&gt;app<br>                                      :纯c&#x2F;c++无界面<br>                                      :qt&#x2F;android</p>
<p>在单片机-&gt;bootloader-&gt;linux系统&#x2F;驱动-&gt;app-&gt;qt这个学习路线上我们可以使用同一套开发板。<br>怎么选择开发板？答案是资料丰富<br><img src="https://s2.loli.net/2023/11/12/XI9cFBofaCWkiH8.png" alt="image.png"></p>
<span id="more"></span>
<p>他们百度搜索结果条数</p>
<ul>
<li><p>三星系列的</p>
</li>
<li><p>s3c2440     92万</p>
</li>
<li><p>s3c6410     43万</p>
</li>
<li><p>s5pv210     22万</p>
</li>
<li><p>exynos4412  14万</p>
</li>
<li><p>ti</p>
</li>
<li><p>AM437x       4.5万</p>
</li>
<li><p>AM335x       164万 营销好 用户多，工控芯片</p>
</li>
<li><p>freescale</p>
<ul>
<li>I.MX6       21万</li>
</ul>
</li>
<li><p>全志，瑞芯微  资料不开放<br>从教程丰富程度，我们选择s3c2440</p>
<h2 id="错误观点"><a href="#错误观点" class="headerlink" title="错误观点"></a>错误观点</h2><p>有人说s3c2440过时了，他的cpu还是arm9，性能差，过时了，但是他的知识没有过时。<br><img src="https://s2.loli.net/2023/05/01/BGu1cCqo2LsmU3y.png" alt="image.png"><br>我们在操作硬件的时候，不是操作的cpu，不接触cpu的指令，而是操作内存和寄存器，以及硬件的口径。<br>只有在中断的时候，才和cpu有点关系，但是不同的cpu之间关系比较小，没啥成本，并且我们以后再学习linux内核的时候，linux已经帮我们做好了封装和处理，根本不需要我们关心。</p>
</li>
</ul>
<p>驱动&#x3D;软件框架+硬件操作</p>
<p>软件框架都是一样的，所有内核都是linux内核，硬件操作，只要在s3c2440掌握了i2c，spi的原理，其他的硬件开发板都是一样的。</p>
<h1 id="使用什么开发工具"><a href="#使用什么开发工具" class="headerlink" title="使用什么开发工具"></a>使用什么开发工具</h1><p>ads,keil,mdk<br>只要写一个main函数，所有细节都封装了，谁来调main，c写的main函数代码生成代码怎么放在内存里边，这些工具都帮你做了，但是这些工具封装了太多的细节，不适合初学者，初学者应该学习细节，扎实基础，因此不会使用这些开发工具。<br>基于arm+linux裸机学习我们可以学习更多知识。<br>学习了s3c2440+linux裸机开发+arm芯片，回过头来再去学习STM32就是几分钟搞定的事情。<br>这样我们就能无缝进入后续的学习bootloader、linux驱动。</p>
<h1 id="开发板介绍"><a href="#开发板介绍" class="headerlink" title="开发板介绍"></a>开发板介绍</h1><p>s3c2440开发板，实际上他的性能并不是很强，但是他的资料非常的丰富<br><img src="https://s2.loli.net/2023/05/01/YzpM71Xv3flhreC.png" alt="20210906021414799.png"><br><img src="https://s2.loli.net/2023/05/01/4XcUry2pGwILqWY.png" alt="20210906021415633.png"></p>
<h1 id="开发板接口介绍与串口连接"><a href="#开发板接口介绍与串口连接" class="headerlink" title="开发板接口介绍与串口连接"></a>开发板接口介绍与串口连接</h1><h2 id="怎么使用这个开发板，它里边有如下几个核心接口"><a href="#怎么使用这个开发板，它里边有如下几个核心接口" class="headerlink" title="怎么使用这个开发板，它里边有如下几个核心接口"></a>怎么使用这个开发板，它里边有如下几个核心接口</h2><p><img src="https://s2.loli.net/2023/05/01/UBo9PQyFuNbHh1X.png" alt="image.png"></p>
<ul>
<li>接通电源</li>
<li>按下开关</li>
<li>使用串口(usb串口)观察信息<ul>
<li>连接以后windows会自动安装驱动(如果没法自动安装，可以下载PL2303_Prolific_DriverInstaller_v1.7.0.exe或者驱动精灵暗转)</li>
<li>然后我们需要在pc安装一个mobaxterm软件，用来连接串口，这样开发板通过串口返回的信息我们可以在这个软件里边看到，也可以用这个软件通过串口发送命令给开发板</li>
</ul>
</li>
<li>使用jtag口（usb烧写器）烧写程序</li>
<li>如果板上程序支持usb下载，板子的bus接口连接pc的usb接口<ul>
<li>烧写软件：oflash.ext</li>
<li>硬件:op&#x2F;eop、 easy open jtag</li>
<li>驱动<ul>
<li>eop连接到pc</li>
<li>安装eop驱动</li>
<li>暗转app</li>
<li>开发板通过排线连接到eop，eop通过usb线连接到pc</li>
<li>执行oflash.exe xxx.bin</li>
<li>断开开发板和eop，断开eop和pc的连线</li>
<li>设置从nor或者nand启动</li>
<li>重新上电</li>
</ul>
</li>
</ul>
</li>
<li>启动选择开关：从nor启动，还是从nand启动</li>
</ul>
<p>mobaxterm设置串口的时候，注意下波特率和不选中限流：<br><img src="https://s2.loli.net/2023/05/01/KaMgHwTV1Fb6tJv.png" alt="image.png"></p>
<h1 id="使用eop烧写裸板程序"><a href="#使用eop烧写裸板程序" class="headerlink" title="使用eop烧写裸板程序"></a>使用eop烧写裸板程序</h1><h2 id="eop烧写"><a href="#eop烧写" class="headerlink" title="eop烧写"></a>eop烧写</h2><p> 将eop连接到pc，然后安装驱动(下载驱动程序OpenOCD with GUI setup.exe)，开发板通过排线连接到eop，eop通过usb线连接到pc 这三个步骤做完。<br> oflash.exe烧写的bin文件，可以是u-boot.bin，它可以选择烧写到nor或者nand上，烧写到0地址。<br> 也可以直接烧写我么自己写的程序，比如led.bin。烧写到nand上去，烧写到0地址。</p>
<ol>
<li><p>命令模式下，切换到要烧写的文件所在的目录里，执行oflash xx.bin<br><img src="https://s2.loli.net/2023/05/01/1Z6qYdcQ8eHUC4A.png" alt="image.png"></p>
</li>
<li><p>烧写到nand flash（2次确认）<br><img src="https://s2.loli.net/2023/05/01/Zbvy9qhVoYw36cT.png" alt="image.png"></p>
</li>
<li><p>烧写到0地址<br><img src="https://s2.loli.net/2023/05/01/jDoGpTqfAK4Qy5H.png" alt="image.png"></p>
</li>
<li><p>将开发板的启动开关设置为nand启动</p>
</li>
<li><p>将jtag线拔掉，拔掉的原因是jtag上有复位引脚，不然无法启动</p>
</li>
<li><p>按下电源开关关闭开发板，然后重新上电，启动开发板，就会看到烧写的程序运行，如果是led的程序，开发板的灯就会闪烁</p>
</li>
</ol>
<p>如果是烧写uboot，在启动以后我们可以通过mobaxterm连接到串口，在uboot等待3秒之内，在mobaxterm的串口命令窗口按下空格键，就会进入uboot 的菜单<br><img src="https://s2.loli.net/2023/05/01/DYPBrMJLq8m4uG5.png" alt="image.png"><br>空格以后：<br><img src="https://s2.loli.net/2023/05/01/nghrGv7b1RkWEUF.png" alt="image.png"><br>【本节结束】</p>
<p><img src="https://s2.loli.net/2023/11/12/F7zHMlmXtxbu81j.png" alt="image.png"></p>
<p>如果你觉得我的文章有用，可以打赏我一杯雀巢咖啡<br><img src="https://i.postimg.cc/8Pmvqq4J/b1c4562d7729c208aef2f861473f309.jpg" alt="image.jpg"></p>
]]></content>
      <categories>
        <category>embed</category>
      </categories>
      <tags>
        <tag>embed</tag>
      </tags>
  </entry>
  <entry>
    <title>2020回顾和总结</title>
    <url>/2021/02/24/life/2020%E5%9B%9E%E9%A1%BE%E5%92%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>今天是2021.02.24,鄙人从工作了将近2年的连连支付离职了。<br>其实要不要离开纠结了一段时间，因为在连连能做很多有意思的技术问题，虽然业务很很多，但是你总能在一家成长当中的企业当学到一些成长期必然遇到的技术问题，在阿里，腾讯，美团之类的成熟it企业，动辄就是一个大的概念滚出来的一套架构，整个集团统一技术规范和规约，以及中间件规范，业务团队其实重点还是在业务实现上面。而我呢，又是对技术狂人派的，自然喜欢技术氛围好的团队，但是现实催人往前走，我去了某宝。</p>
<span id="more"></span>
<p><img src="https://i.loli.net/2021/02/24/UjhgrHAM8K2dwV9.png" alt="company-card.png"></p>
<h3 id="老团队的收获-对功能的高度抽象能力"><a href="#老团队的收获-对功能的高度抽象能力" class="headerlink" title="老团队的收获:对功能的高度抽象能力"></a>老团队的收获:对功能的高度抽象能力</h3><p>在刚进入跨境物流这个业务的时候，我认为我将要做的技术工作是大坨的业务实现代码，但是后来被安排了做搜索中心的建设，需求很简单：</p>
<ul>
<li><p>当前业务数据库的数据有复杂搜索的需求。</p>
</li>
<li><p>多个业务数据库跨库联合搜索，sql很显然无法满足复杂的关联搜索逻辑的实现。</p>
</li>
<li><p>对业务数据库的数据实时同步到es或者redis或者其他不同于rdbms的异构系统。</p>
</li>
<li><p>es上的索引版本的无缝切换和升级。</p>
<p>这些逻辑有一部分是需求侧的要求，有60%是我自己添加的，其实当时看到这个需求，我第一反应就是要做一个中间件系统，所以考虑了很多需求侧没有看到的问题，于是干脆就往更高的层次抽象了一下。</p>
</li>
</ul>
<p>最终的产品就是 <a href="https://ceaser.wang/2019/07/16/elasticsearch/elasticsearch_center/">elasticsearch_center</a> 。<br>通过这个系统让我对软件开发产生了新的认识，首先你如果要想让自己有成长，就要善于在实际的工作当中去想办法实践和创新，我们学了很多框架和知识，但是不能去使用，那就等于没学，公司不会逼你去使用某一个轮子，但是你对这个轮子有兴趣，就要懂得去思考在实际开发当中的实践，你首先要不害怕去用这个东西，而不是想着赶紧把业务实现然后去摸鱼，事业上的成长要自己逼自己，本来工作的我们在大企业就是一个工具人，但这不是我们选择放弃的借口。</p>
<h3 id="裁员-裁员"><a href="#裁员-裁员" class="headerlink" title="裁员+裁员"></a>裁员+裁员</h3><p>  后来团队由于在市场上一直打不开缺口，无法盈利，最后裁员了,时间是在2020.06月份，走了很多兄弟和姐们，我也在当时很焦虑，当时也刚刚交了房子的首付，焦虑是肯定的，我不想走，最后留下了，<br>主要是领导尊重每个人的选择，没有强制让谁离开，但是留下的名额也是有限的，走了的那帮人我其实挺怀念的，没有不散的宴席，每个人都在为自己的生活焦虑、选择、放弃、冲锋。一波裁员之后，团队摸鱼了3个月，摸索出了新的模式，但是最后无奈坚持了一段时间，又裁员了一波也就是2020.12月份左右，因为开发太多了，这波裁员是集团内转岗，我去了一个核心创业团队国际钱包，经过了一波三折，身心疲惫，也到了2020年的年底，最后决定离开了，2021年年假回来提了离职，很不舍，让我成长了很多，很多。</p>
<h3 id="新团队的收获"><a href="#新团队的收获" class="headerlink" title="新团队的收获"></a>新团队的收获</h3><p>  在钱包的这段时间做了2件对我来说比较有成长的事情<br>    - 集团starter框架<br>    - 分库分表shardingsphere封装的starter<br>  后续章节我会对这两个部分展开详细介绍。</p>
<h3 id="团队合作"><a href="#团队合作" class="headerlink" title="团队合作"></a>团队合作</h3><p>  首先是团队开发流程的一个规范：<br>  <img src="https://i.loli.net/2021/02/25/tPEDWed8TbopY5x.png" alt="微信图片_20210225170244.png"><br>  FRD、项目评估、交互&amp;视觉、技术方案、接口评审、研发计划评审、功能开发、接口联调、代码评审、测试用例评审、冒烟测试、测试、上线计划、UAT、上线。这是一个项目的生命周期，经典的模式，这部分后续单独章节介绍；<br>  后来接触到连连集团中间团队的leader，和他讨论了很多团队管理方面的事情，我汇聚成2本书：<span class="exturl" data-url="aHR0cHM6Ly93ZXJlYWQucXEuY29tL3dlYi9hcHByZWFkZXIvODI4MzJjZjA4MTFlM2EzMDVnMDEwMGFha2NmYzMyZGEwMTBjZmNkMjA4NDk1NDg4P3d0aGVtZT13aGl0ZSZ3ZnJvbT1hcHAmd3ZpZD04ODA1MjgzJnNjZW5lPWJvdHRvbVNoZWV0U2hhcmU=">敏捷软件开发:原则、模式与实践<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclQjIlQkUlRTclOUIlOEElRTUlQkMlODAlRTUlOEYlOTElRTUlQUUlOUUlRTYlODglOTglRUYlQkMlOUElRTclOTQlQTglRTclOUMlOEIlRTYlOUQlQkYlRTclQUUlQTElRTclOTAlODYlRTUlQTQlQTclRTUlOUUlOEIlRTklQTElQjklRTclOUIlQUUvMTgxNDMyOT9mcj1hbGFkZGlu">精益开发实战:用看板管理大型项目<i class="fa fa-external-link-alt"></i></span> 希望2021年我能读完吧。</p>
<h3 id="博客未来的一段时间的输出内容"><a href="#博客未来的一段时间的输出内容" class="headerlink" title="博客未来的一段时间的输出内容"></a>博客未来的一段时间的输出内容</h3><ul>
<li>在连连的一些收获细化输出</li>
<li>在阿里的一些收获也将会持续输出</li>
<li>二龙湖科技拼图的技术成果分享</li>
</ul>
<h3 id="落居杭城"><a href="#落居杭城" class="headerlink" title="落居杭城"></a>落居杭城</h3><p>  在2019年年底的时候，我的一个同事(局座)在中招星未来首付了一套90平米的房子，他是刚需，拉我去和他一块看房，当时看了中招星未来，还有南湖明月等楼盘，这个时候我也萌生了购置一套的想法，<br>杭州是需要摇号的，我和<span class="exturl" data-url="aHR0cHM6Ly9pbmNvZGVyLm9yZy9hYm91dC8=">Jerry xu<i class="fa fa-external-link-alt"></i></span> 先后看了佳兆业云峰、大溪谷、南湖明月、上塘九里，其实看得不多，最后入坑上塘九里，第一预算紧张综合性价比选这个、第二交通规划有上涨空间，第三未开发区域有升值空间。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  整体上自我感觉是满意的，未来规划在餐饮互联网以及自动化工厂方面做一些事情，这也是一个未来年的规划吧。<br>今年做了很多事情都是为了生活和生存，但是做的这些都是为了一个大拼图做铺垫—-自主创业。我们二龙湖科技目前一只在积累技术方面的知识，做一些整体面的规划，每个人所在的公司和所做的工作，都是这个拼图的一个块，总有一天这些块会拼在一起成为我们想要的样子，这也是我们的梦想。</p>
<p><img src="https://i.loli.net/2021/02/25/Xs7kMrD82AqHZzc.png" alt="做人如果没有梦想和咸鱼有什么区别.png"></p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>2020</tag>
      </tags>
  </entry>
  <entry>
    <title>2022 year-end review</title>
    <url>/2022/12/30/life/2022_end_review/</url>
    <content><![CDATA[<p>说来惭愧，博客一年没怎么更新了，说什么理由都是借口，哈哈哈，其实在Java领域玩了这么多年，对于技术细节探索和新技术兴趣，没有刚开始进入这个领域热情高涨了，转而对技术架构设计产生了极大的热情，<br>但是技术架构探索和积累是完全通过理论加实践实际操作搅拌出来了，第二个是在做嵌入式相关的学习，目前还没有输出像样子的东西，不好意思写博客，今年的复盘如下：<br><img src="https://s3.bmp.ovh/imgs/2023/01/02/096480c43775a0d3.png"></p>
<span id="more"></span>
<p>我的2022：<br>一月：做核酸<br>二月：做核酸<br>三月：做核酸<br>四月：做核酸<br>五月：做核酸<br>六月：做核酸<br>七月：做核酸<br>八月：做核酸<br>九月：做核酸<br>十月：做核酸<br>十一月：做核酸<br>十二月：阳了</p>
<p>各位看官是不是深有感触。好在我的免疫系统过于变态，至今未阳，以至于我感觉和在坐的各位感觉格格不入，真是给村里的“羊”队生产总值拖后腿了。</p>
<p>谈下一个话题。<br>数一下今年认真提高的几个点</p>
<h1 id="政治"><a href="#政治" class="headerlink" title="政治"></a>政治</h1><p>今天斗胆谈一下政治</p>
<p>福报厂的公司文化价值观，除了第一条客户第一，其他的价值观都是政治，都是为了控制人的；<br>它甚至玷污了第一条，让很多人错误的认为客户第一也是bullshit。<br>这个世界上有些规则都是相通的，在混沌之中建立秩序，分为对事物的治理和对人的治理，对事物的治理方法论有很多，<br>但是对人的治理只有一种——–政治。<br>在中国很多人都受到过教育，教育的目的除了让人有更多的选择，另外一点是学会辨别，分别什么是对的，什么是错的，<br>有一部分人会分辨，但是迫于政治和群体惯性意志，现实的引力太强，根本无法支棱和去改变，因为代价是被踢出这个大家公认、合理的、<br>被约束的、每个人利益都可以最大化的怪圈。<br>于是，社会上出现了一种理论—–适者生存，鄙人将这种理论成为“社会达尔文理论”，如果在人类社会(注意是人类社会，不是人类生物圈)，<br>如果有人认同这个理论，那么鄙人认为他就是个没有思考的主流病毒价值观传递网络的一环而已，以前的教育白上了，没有分辨能力。<br>你有读过《物种起源》去认同，我不会骂你，但是没有读过，认同这样的理论属实草帅和愚昧。<br>达尔文的适者生存只适合于生物圈的生物特性演化，是带着自然的残酷和时间维度上物理上的适用，充满了野蛮淘汰，竞争上位，<br>而人类社会如果加载了这些血淋淋的东西，文明将不会是文明，文明的组成是意志、精神、秩序上的有机统一和一致，存在着善良、<br>人道、约束、合作。使用社达，就是给达尔文戴无辜的帽子，不分析原因就去社达，过于草率。<br>但是这些和福报厂价值观有吊毛关系呢？<br>其中一个关系就是在公司文化价值观体系下，衍生的政治本质约束下，存在着底层韭菜的竞争，但是如果用“社达”去解释和合理化这个体系，<br>这就略显愚昧，在这个政治体系下，也不是没有选择，选择无非就是朝着事情的2个极端发展，要么躺平、沉默，这是一种反抗，要么适应、内化，<br>这是一种成长，这2种选择都没有对错之分，底层都有一套无法用主流价值观解释的原因，另外在不同的环境，就会衍生不同环境的人和秩序，<br>在一套环境的成长和对抗，不代表在另一种环境的成长和对抗，我们还是要相信相对主义，这并非自我合理化，而是一种世界上无限的无法确定的可能性，要去客观针对。<br>政治这个东西，一家公司如果想要建立一套公司文化和价值观，让生意长久兴隆下去，教科书式的教材就是国家的政党体系，你只需要用正确的价值观和大众公认的正确的方向，<br>以此作为作用范围内所有人潜在承认的价值体系即可，比如社会主义核心价值观24字，形而上学复制一下作为企业的价值观就可以建立资本体系政治基座。<br>政治是为了秩序、统一、约束、控制，但是会一定程度的失去创造力和自由，这就像有创造力和崇尚自由的人都润出去了，润出去的人都是知识分子、资本家，<br>他们分别带走了知识和财富，一个组织失去了知识和财富，剩下就只能是愚昧和贫穷，一个愚昧和贫穷的组织需要什么，它需要一个皇上。<br>然后底层干活的逐渐失声，因为组织关闭了声音的接收。这是一种副作用，只要企业使用了政治，企业也会有副作用，人才流失，组织臃肿，次之声誉扫地，股市熊熊烈火。<br>另外，谈一下PUA，首先是PUA的鉴别不是通过推理和百度搜索一下得出来的，这属于很肤浅的PUA，高级的食材都是经过时间的淬炼，你的教育积累决定了你能不能分辨，或者它有没有掺水，大部分PUA都是拿着锤子找钉子，预先设定，惯性操作，政治和集权约束的副作用而已。<br>有人很喜欢用认知解释事情，那认知是不是也存在选择呢，我相信人都有自由意志，《西部世界》这种反自由意志的case只是妄自菲薄，<br>每个人都有认知选择的自由意志。<br>另外一个维度，认知的高低，高认知的获取通过成长，内化获取，低认知的保持，躺平就行，这也是一个选择，所有选择都没有对错，他的底层都有一套更加抽象、宏观，<br>脱离环境之外的原因他是相对的。错的是定义它的对错这个行为。<br>现实社畜很多人都常常思考人生和生命的意义所在，诺贝尔文学奖获得者加缪的存在主义给出了很不错的答案，给出了三个解决无意义人生内耗的三个方向:对抗、激情、自由。<br>在这里要指出的是，很多时候我们对抗或者内化的都不是具体的人，而是人性的网络构建的群体意识，你只需要做的仅仅是做出选择，而不要去定义它的是否存在性和对错。</p>
<h1 id="说服之术"><a href="#说服之术" class="headerlink" title="说服之术"></a>说服之术</h1><p>你在和后端同事在某个设计上产生了分歧，你和前端妹子在甩锅这个逻辑是前端吃还是后端包掉，你和你的领导在某个设计上那个方案更优秀焦灼不下，你总是想让对方按照你的思路去落地，你认为你的设计方案是天衣无缝、高效、优雅的，你觉得你是C位，甚至在无法说服对方的时候，情绪失控，大喊：这个就这样搞！按照我说的做，你那个不行，太XXXX了。</p>
<p>基于以上case，有时候让我们很是不爽，你的强迫症促使你必须打败和说服对方，让对方说：大佬英明。。。。</p>
<p>那么怎么说服同事，说服领导，说服前端妹 子&#x2F;后端大佬，说服产品呢？<br>我们先分析一下分歧的本质，对于解决同一个问题，你和对方持有各自的意见，各自坚持的原因有如下几个：性能、工作量、合理性。<br>举例说明下，现在有一个系统，每次有新的需求过来都需要开发、测试、前端介入开发，但是每次开发都是同质性很强的代码，于是为了提效，架构师进行了一次架构重建，想减少开发的工作量，同时也减少系统交付时间，快速满足业务诉求，一举两得的事情，业务和开发都从中受益，能够从以前15天交付通过架构重构以后能达到5天交付，经过架构师设计以后，将系统里边的同质化的东西全部抽象后，进行了可视化配置，包括数据接口和依赖于数据接口的页面都是可以配置的，配置的工作由开发同学执行，这一步在整个需求交付里边属于配置阶段，开发同学配置完毕以后，配置了很多组件，这些组件是组成业务推进页面的积木，然后就是产品同学接入，产品同学拿到这些积木以后，往一个空白页面拖拉积木，构建一个有实际业务语义的页面或者业务流程动线，然后发布上线给到用户使用，这些积木的构建都是在本次架构调整当中需要前后端实现，这是一套配置系统，只要实现这一次，后续就不用在写代码了，只需要开发同学配置积木就行，但是在开发阶段，这套配置系统在前端表现的很复杂，前端同学觉得复杂度太高了，而且需要开发很长的时间，而且开发同学说他们的开发人力资源不够，另外还说道，这个配置系统投入和产出比太小了，意思是我投入了这么大的力气，开发了一套复杂庞大的前端页面，得到的收益是很小的，因为页面是给开发同学使用的，可以做的简陋一点，开发同学能看懂就行，就不是给产品或者用户使用的，没必要把页面做的如此复杂，在这这套系统仅仅一个业务在使用，业务上没有大规模推广的计划和相同性，既然使用场景很少又是开发人员使用，更不应该投入进入，这件事情不应该去做，这是前端给到第一个核心的反驳支撑点，而且前端给出了一个折中的方案，就是在原来的前端页面设计做下修改，一部分简单的页面数据交互由前端实现，剩下的大部分复杂的交互，做成json配置的形式，因为这些复杂的页面交互部分也是对json数据进行搬运，为了减少复杂度，直接在页面让开发同学输入json数据完成积木的配置阶段。</p>
<p>前端带着这个折中的方案来找后端的开发和开发leader开撕，那么我们首先要知道前端的诉求，他们的诉求第一是页面复杂度太高，第二是他们的资源有限，第三是投入产出比太低。<br>分别对应我说的工作量、合理性2个本质。</p>
<p>这个前端的诉求过来以后，大部分人都会觉得前端想逃避问题，想出了这个说法来规避进入复杂页面的编写，他们觉得，这个复杂的页面第一期上了以后，后边还会进行迭代，前端会频繁进入这个复杂系统的开发，是一个泥潭，无法挣脱，不仅做了没有好的绩效提升，而且这么复杂很容易出问题，还会把其他重要的事情挤占了资源，得不偿失，这个是前端拒绝做这个事情背后真实的原因。</p>
<p>接下来是后端架构思考回路：<br>针对前段给到的折中方案，简单的页面前段可以开发，但是复杂的部分前段不会开发页面支撑数据操作，由开发人员配置json的形式达到最终的配置目标，首先思考前段的方案是否和我们架构重构的目标冲突，我们的架构重构是为了提高需求交付效率，解放开发人员的生产力，如果使用前段方案一般是页面交互一般是json配置，其实对我们架构重构的目标没有很大的影响，只不过增加了开发人员<br>去理解json配置结构的成本，其实使用页面去组织这个json也是由理解成本的，只不过小一点，那么后端是坚持呢，还是同意前端的建议，其实是应该同意前端的建议的，因为他说的既没有和架构设计目标冲突，也没有影响产品最终目标，它是合理，这里有一个重点就是合理性是不是和目的冲突，你虽然说的很合理，但是和初始目标冲突那么合理性本身就不具有合理性的约束。<br>其次，如果工作量和合理性冲突怎么办，首先最先想到的是不能降低合理性达到减少工作量的目的，这是掩耳盗铃，一个事情不合理，后期工作量肯定是指数增长的。如果我们把开发的诉求告诉业务方，这个需求我们资源不足，为了满足能让你们跑通业务，我们砍掉一块能力，或者你们决定砍掉那一块，这些迂回战术都是可以，但是就是不能答应既要也要的情况，当你无法说服别人以及你自己的时候，就不应该坚持了，除非你能找到强有力站得住脚的理由，而且是合理的，当你开始接受别人的建议的时候，其实也是一种吸收，让自己的思路更加包容，包容的越多，你对各种各样问题域的解题思路就会越多，越准确，这就是从实践中积累经验的一个方法。</p>
<p>因为我们得出一个结论：</p>
<ul>
<li>不要闭门造车，和别人讨论，要么你打败了别人对你思路的怀疑，要么别人把你的设计思路干死，前者说明你确实是对的，后者我们要懂得包容，在合理，不冲突的前提下尝试吸收别人的思路，从另一个维度看自己是赢家。</li>
<li>说服别人，不是用强制的语言和手段达成的，而是用做成这个事情更加合理，更加高效为意愿，论证了对方是和意愿冲突的。</li>
</ul>
<h1 id="对抗软件复杂度的战争"><a href="#对抗软件复杂度的战争" class="headerlink" title="对抗软件复杂度的战争"></a>对抗软件复杂度的战争</h1><p>上边说的这个场景，出现了复杂的问题域，我们每天都在面对这个复杂度的战争。</p>
<h2 id="一、何为研发效能？"><a href="#一、何为研发效能？" class="headerlink" title="一、何为研发效能？"></a>一、何为研发效能？</h2><p>当我们谈研发效能的时候，我们在谈些什么？这个议题被抛出来，有人讨论，是因为存在问题，问题就在于实际的研发效率，已经远低于预期了。企业初创的时候，一个想法从形成到上线，一个人花两个小时就完成了，而当企业发展到数千人的时候，类似事情的执行，往往需要多个团队，花费好几周才能完成。这便造成了鲜明的对比，而这一对比产生的印象，对于没有深入理解软件工程的人来说，显得难以理解，可又往往无计可施。</p>
<p>前文我既用了“效能”一词，也用了“效率”一词。这是为了做严谨的区分，效能往往是用来衡量产品的经济绩效，而效率仅仅是指提升业务响应能力，提高吞吐，降低成本。</p>
<p>本世纪 10 年代，早期的互联网从业者开发简易网站的时候，只需要学会使用 Linux、Apache、MySql、PHP（Perl）即可，这套技术有一个好记的名字：LAMP。可今天，在一个大型互联网公司工作的开发者，需要理解的技术栈上升了一个数量级，例如分布式系统、微服务、Web 开发框架、DevOps 流水线、容器等云原生技术等等。如果仅仅是这些复杂度还好说，毕竟都是行业标准的技术，以开发者的学习能力，很快就能掌握。令人生畏的复杂度在于，大型互联网公司都有一套或者多套软件系统，这些软件系统的规模往往都在百万行以上，质量有好有坏（坏者居多），而开发者必须基于这些系统开展工作。这个时候必须承担非常高的认知负荷，而修改软件的时候也会面临破坏原有功能的巨大风险，而风险的增高就必然导致速度的降低。</p>
<p>因此研发效率的大幅降低，其中一个核心因素就是软件复杂度的指数上升。</p>
<h2 id="二、本质复杂度和偶然复杂度"><a href="#二、本质复杂度和偶然复杂度" class="headerlink" title="二、本质复杂度和偶然复杂度"></a>二、本质复杂度和偶然复杂度</h2><p>Fred Brooks 在经典著作《人月神话》的「没有银弹」一文中对于软件复杂度有着精彩的论述，他将软件复杂度分为本质复杂度（Essential Complexity）和偶然复杂度（Accidental Complexity）。这里的本质和偶然两个词来源于亚里士多德的《形而上学》，在亚里士多德看来，本质属性是一个物体必然拥有的属性，偶然属性是一个物体可以拥有的属性（也可以不拥有）。例如，一个电商软件必然会包含交易、商品等业务复杂度，因此我们称它们为本质复杂度；而同一个电商软件，可以是基于容器技术实现（也可以不是），可以是基于 Java 编写的（也可以不是），因此我们称由于容器技术或者Java 技术而引入的复杂度，为偶然复杂度。</p>
<p>Fred Brooks 所描述的软件本质复杂度，指的就是来自问题域本身的复杂度，除非缩小问题域的范围，否则是无法消除本质复杂度的。而偶然复杂度是由于解决方案带来的，例如选择了 Java，选择了容器，选择了中台等等。</p>
<p>此外，我们可以从所谓问题空间（Problem Space）和方案空间（Solution Space）来理解这两个复杂度，问题空间就是现实的初始状态和期望状态，以及一系列约束规则（我们常常称之为业务），方案空间就是工程师设计实现的，一系列从初始状态达到期望状态的步骤。缺乏经验的工程师往往在还没理解清楚问题的情况下就急于写代码，这便是缺乏对于问题空间和方案空间的理解，而近年来领域驱动设计为那么多工程师所推崇，其核心原因就是它指导了大家去重视问题空间，去直面本质复杂度。Eric Evans 在 2003 年的著作《Domain Driven Design》，其副标题是 “Tackling Complexity in the Heart of Software”，我想这也不是偶然。</p>
<p>《人月神话》写于 1975 年，距今已经有 47 年了，Brooks 认为软件的本质复杂度是无法得到本质上的降低的，同时认为随着高级编程语言的演进，开发环境的发展演进，偶然复杂度会得到本质的降低。他的论断前半部分对了，然而后半部分是错了，我们今天的确有更高级的编程语言，功能更丰富的框架，能力更强大的 IDE，但是大家逐渐发现学习这些工具已经成为了一个不小的负担。</p>
<h2 id="三、复杂度的爆炸"><a href="#三、复杂度的爆炸" class="headerlink" title="三、复杂度的爆炸"></a>三、复杂度的爆炸</h2><p>今天的软件已经从深入到人类生活的方方面面。稍有规模的互联网软件，都服务着数百万、千万级的用户。阿里巴巴的双11在2020年的峰值实现了每秒58.3万笔的交易；Netflix 在2021年Q4拥有了2.2亿的订阅用户；而 TikTok 在2021年9月宣布月活数量超过10亿。这些惊人的商业成功背后，都少不了复杂的软件系统。而所有这些复杂软件系统，都不得不面对巨大的 Scalability 的挑战，服务一个人的系统，和服务一亿人的系统，其复杂度有着天壤之别。</p>
<p>本质复杂度是一个方面，毕竟更多用户意味着更多的功能特性，但我们无法忽略这里的偶然复杂度，其中最典型的就是分布式系统引入的偶然复杂度。为了能够支撑如此大规模的用户量，系统需要能够管理数万机器（调度系统），需要能否管理好用户的流量（负载均衡系统），需要能够管理好不同计算单元之间的通讯（服务发现，RPC，消息系统），需要能够保持服务的稳定性（高可用体系）。这里的每一个主题都能延展开用几本书来描述，而开发者只有在初步掌握了这些知识后，才能够设计实现足够 Scalable 的系统，服务好大规模的用户。</p>
<p>相比于分布式系统引入的复杂度，团队的扩张更易带来偶然复杂度的急剧增长。成功产品的软件研发团队动辄数百人，有些已经达到了一两千人的规模。如果企业没有严格清晰的人才招聘标准，人员入职后没有严格的技术规范培训，当所有人以不同的风格，不同的长短期目标往代码仓库中提交代码的时候，软件的复杂度就会急剧上升。</p>
<p>团队的扩张还会带来另外一个问题，在大规模的团队中，关键干系人的目标事实上是影响软件复杂度的关键因素。我亲眼见过许多案例，其方案空间中明明放着简单的方案，但因为这个原因，当事人不得不选择复杂的方案，例如：</p>
<ul>
<li>原本方案只需要直接改动系统 A，但由于负责系统 A 的团队并没有解决该问题的动力，其他人不得不绕道去修改系统 B，C，D 来解决该问题。</li>
<li>原本方案只需要直接改动系统 A，但迫于系统 B 负责人或者上司的压力，方案不得不演进成同时改 A，B，甚至引入 C。<br>更有甚者，为了各种各样的原因，提出一些完全假设出来的问题（即，事实上并不存在的本质复杂度），然后拿着软件系统一阵无谓折腾。最后个人或者某个团队的目标实现了，但软件没有提供任何增量的价值，而复杂度却不会因此而停止增长。</li>
</ul>
<h2 id="四、错误的应对方式"><a href="#四、错误的应对方式" class="headerlink" title="四、错误的应对方式"></a>四、错误的应对方式</h2><p>面对效率地不断下降，研发团队的管理者必须做点什么。不幸的是，很多管理者并不明白效率的降低是由软件复杂度的上升造成的，更没有冷静地去思考复杂度蔓延直至爆炸的根因是什么，于是我们看到许多管理者其肤浅的应对方式收效甚微，甚至起到了反作用。</p>
<p>最常见的错误方式是设置一个不可更改的 Deadline，用来倒逼研发团队交付功能。但无数经验告诉我们，软件研发就是在质量、范围和时间这个三角中求取权衡。研发团队短期可以通过加班，牺牲假期等手段来争取一些时间（长期加班实际有百害无一利），但如果这个时间限制过于苛刻，那必然就要牺牲需求范围和软件质量。当需求范围不可缩减的时候，唯一可以被牺牲的就只有质量了，这实际就意味着在很短的时间内往系统中倾泻大量的偶然复杂度。</p>
<p>另一种做法是用“更先进”的技术去替换现有系统的技术，例如用 Java 的微服务体系技术去替换 PHP + Golang 体系的技术；或者用支撑过成功商业产品的中台类技术去替换原来的微服务体系技术；或者简单到用云产品去替换自建的开源服务。这些做法背后的基本逻辑是，“更先进”的技术在成功的商业场景中被验证过，因此可以被直接拿来解决现有的问题。</p>
<p>但在现实情况下，决策者往往忽略了当前的问题是否是“更先进”的技术可以解决的问题。如果现有的系统服务的用户在迅速增长，Scalablity 面临了严重的困境，那么这个答案是肯定的；如果现有的系统的稳定性堪忧，经常不可用且严重影响了用户体验，那么这个答案是肯定的。但是，如果现有的软件系统面临着研发效率下降问题，那么“更先进”的技术不仅帮不了什么忙，还会因为新老技术的切换给系统增加偶然复杂度。</p>
<h2 id="宏观解决之道"><a href="#宏观解决之道" class="headerlink" title="宏观解决之道"></a>宏观解决之道</h2><p>我先简单介绍一下 Wardley Map。<br><img src="https://s3.bmp.ovh/imgs/2022/12/30/3cac140b895200e1.png"><br>Wardley Map 是一个帮助分析技术战略的工具，它以地图的方式展现，地图中的每个组件可以被理解成一个软件模块，纵坐标是价值方向，越往上越靠近用户价值，横坐标是进化方向，越往右越靠近成熟商业产品。</p>
<p>例如上图中，Compute 是计算资源，在今天有许多成熟的云计算公司提供，但它离图中上下文业务的用户价值非常远。Virtual Fitting（虚拟试衣）则离用户价值非常靠近，因为它可以让用户更有信心自己是否购买了合适的衣服，但是这个技术显然还谈不上是成熟产品，只是自己研发的模块，远没有达到开放商业化的阶段。</p>
<p>设计研发一套用来支撑百万、千万级用户的分布式系统，是非常有挑战的事情，而且会给系统引入大量的复杂度，管理好这些复杂度本身则又是一项巨大的挑战。幸运的是，今天的云厂商，包括阿里巴巴，亚马逊，谷歌和微软等，在这方面都具有丰富的经验，并且已经通过多年的积累，把这些经验通过商业产品提供给市场。</p>
<p>从 Wardley Map 的方式去分析，我们就会发现，几乎所有的业务，其左上角（贴近直接用户价值，不成熟）都必须是要自己研发和承担复杂度的，而只要做好正确的软件架构，那么就能把右下角的部分（远离直接用户价值，有现成商业产品）提取出来，直接购买。所以在今天，一个合格的架构师，除非自己是云厂商，否则绝对不应该自己去投入研发数据库、调度系统、消息队列、分布式缓存等软件。通过购买的方式，研发团队完全不用承担这些复杂度，也能轻松地支撑好用户规模的增长。</p>
<h2 id="微观层面的复杂度控制"><a href="#微观层面的复杂度控制" class="headerlink" title="微观层面的复杂度控制"></a>微观层面的复杂度控制</h2><p>这一块属于编程细节范围，简答就3句话概括：</p>
<ul>
<li>It works</li>
<li>It is easy to understand</li>
<li>It is safe to change</li>
</ul>
<h2 id="系统架构对复杂度的影响"><a href="#系统架构对复杂度的影响" class="headerlink" title="系统架构对复杂度的影响"></a>系统架构对复杂度的影响</h2><p>在面对需求的时候，缺乏经验的工程师会直接想着在自己熟悉的模块中直接解决，而经验丰富的工程师会先思考一下系统上下文。在《Design Docs at Google》这篇优秀的技术文档写作指导中，就重点提到了，设计文档应当写清楚系统上下文图（sysmte-context-diagram），这背后的原因是什么呢？<br>我近期对一个遗留系统做了一个依赖链路的梳理分析，这个系统是负责生产环境中各类资源的管理的，包括资源的规格，版本，依赖关系等等，梳理完成后，整体的结构吓了我一跳，这个图大致是这样的：<br><img src="https://img-blog.csdnimg.cn/img_convert/18ddb4520201cd9acba001dbde442c47.png"></p>
<p>图中蓝色的部分是控制和执行的子系统（System X，Y，Z），例如控制容器的调度，控制镜像变更的执行等等，是比较清晰的。但是其余部分就不是这样了（A1, A2, A3, C1, C2, S, E），它们都是在管理一个资源的运行态版本，包括镜像的版本，容器的规格，是否有 GPU，容器的数量，关联的网络资源等等，但却演进出了七个子系统，这实际上是非常高的偶然复杂度。当一个领域的概念被分散到这么多子系统之后，就会产生一系列问题：</p>
<ul>
<li>不同子系统对于同一个概念有不同的名称，交互的时候会涉及各种翻译。</li>
<li>不同子系统承担了同一个实体的部分概念，导致修改的时候需要大范围一起修改，且容易出错。</li>
<li>更高的运维成本。</li>
</ul>
<p>仔细去分析这一复杂度形成的因素，我发现这既不是技术战略的问题，也不是微观层面工程师生产低质量代码导致，而是有其他更深层次的问题。其中的最核心的因素是，这些子系统在不同时期是归属于不同的团队的，有的甚至是不同部门的，具体来说，当各个部门各个团队目标不一致的时候，而这个系统又不幸地被拆到各个团队，那么就不会有人会对系统整体的复杂度控制负责。当有的团队在负责把这套系统商业化对外输出，有的团队在负责把这套系统从虚拟机模式演进到容器模式，有的团队在负责资源的成本控制，有的团队在思考全局高可用架构，而没有一个全局的架构师从整体控制概念，控制边界的时候，系统就自然而然地腐化成这样的一个状态了。</p>
<p>当一个问题域没有系统架构，或者其系统架构是错误的时候，你就会发现不同的人在发明不同的语言，这就好比相隔几十公里的两个村子，常常对同一个概念有不同的用词或者发音。日常生活中语言的不精确不是问题，因为日常的沟通是充满上下文的（表情，气氛，环境等），但在计算机的世界，语言的不精确就意味着需要写代码翻译，一旦翻译错误软件就会执行出错。这也就是为什么领域驱动设计那么强调统一语言，强调限定上下文。但领域驱动设计是方法论，而知道方法并不能取代系统架构角色的缺位。</p>
<p>这个复杂系统是康威定律的绝佳例证，康威定律说：“任何系统设计的系统，其系统结构会复制组织的沟通结构。”这句话其实还是有些抽象的，更具体的一些阐述是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“康威定律 … 是一个合理的社会学观察。… 除非模块 A 和模块 B 的设计及实现者能有效沟通，否则这两个软件模块是无法正确对接的。因此软件系统的接口结构，就必然会和生产软件系统的社会结构及组织相对应。”</span><br></pre></td></tr></table></figure>

<p>康威定律所揭示的事实，就是软件架构在很大程度上是由组织的结构和协作模式决定的，这实际上已经不再是一个软件技术问题了，而是一个组织管理问题。因此，解决系统架构层面的软件复杂度问题，就必须面对组织管理的挑战。关键问题域是否有唯一的负责人？当不同的团队在同一个问题域重复建设系统的时候，如何整合团队？当已有团队为了自己的生存，不断夸大其负责系统的重要性和特殊性，如何识别这种问题？组织如何给予大家充分的安全感，让工程师愿意为了架构的合理性，放弃自己辛苦耕作的系统模块？</p>
<p>讨论管理工作似乎已经超出了这篇论述软件复杂度的文章的范畴，但很多工程师或者隐隐感觉，或者思来想去最终领悟，这是我们的软件系统或优雅健壮或千疮百孔的根本因素。</p>
<h1 id="架构设计的原则"><a href="#架构设计的原则" class="headerlink" title="架构设计的原则"></a>架构设计的原则</h1><p>上面介绍了软件复杂度，介于宏观的技术战略和微观的工程师文化之间，存在着一块重要的决策区域，也对软件复杂度有着关键的影响，我称之为系统架构。<br>介绍几个软件架构设计时可以遵循的原则：<br>软件设计原则是设计模式的基石。目的只有一个，降低对象之间的耦合，增加程序的可复用性、可扩展性、可维护性。<br><img src="https://s3.bmp.ovh/imgs/2022/12/30/3fb375c6ac27d1e7.png"></p>
<h2 id="开闭原则-OCP"><a href="#开闭原则-OCP" class="headerlink" title="开闭原则 OCP"></a>开闭原则 OCP</h2><p>定义：软件实体对扩展开放，对修改关闭。</p>
<ul>
<li>对扩展开发，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。</li>
<li>对修改关闭，意味着类一旦设计完成，就可以独立的工作，而不要对其进行任何的修改。</li>
</ul>
<p>在面向对象设计中，我们通常通过继承和多态来实现OCP，即封装不变部分。<br>比如需求要实现2种状态的业务。</p>
<ul>
<li>如果用if else来判断，那么后面加第三种状态，就还需要在此接口上增加else逻辑，不符合开闭原则。</li>
<li>用策略类实现，则定义策略接口，策略A和策略B为具体实现类，分别对应两种状态。假如下一次需求要实现第三种状态，那么直接定义一个StrategyC实现类就可满足。原有代码不变，符合开闭原则。<br><img src="https://s3.bmp.ovh/imgs/2022/12/30/99c4273a7cef25f3.png"></li>
</ul>
<h2 id="里氏替换原则-LSP"><a href="#里氏替换原则-LSP" class="headerlink" title="里氏替换原则 LSP"></a>里氏替换原则 LSP</h2><p>定义：程序中的父类型都可以正确的被子类型替换。</p>
<p>程序中的对象可以在不改变程序正确性的前提下被它的子类所替换，即子类可以替换任何基类能够出现的地方，并且经过替换后，代码还能正确工作。</p>
<p>根据LSP的定义，如果在程序中出现使用instanceof、强制类型转换或者函数覆盖，很可能意味着是对LSP的破坏。</p>
<p>假设定义一个抽象禽类，有一个飞翔方法fly(), 我们就可以自由的继承禽类衍生出各种鸟儿，并调用其飞翔方法。如果鸵鸟加入禽类行列，继承禽类，但不会飞，那么飞翔方法fly()就显得多余。而且在所有禽类出现的地方，无法用鸵鸟替换（此时不满足正确业务逻辑）。违反了里氏替换原则。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/30/916302e2c0390d68.png"></p>
<p>经过反思，是设计问题，禽类和飞翔无必然联系，所以禽类不应该定义飞翔方法fly()，把禽类飞翔方法fly()抽离出去单独定义飞翔接口Flyable。<br>对于有飞翔能力的鸟儿继承禽类并实现飞翔接口。鸵鸟继承禽类，但不实现飞翔接口，是否是鸟儿取决于是否继承自禽类，能不能飞取决于是否实现飞翔接口。所有禽类出现的地方都可以用子类进行替换，所有飞翔接口出现的地方都可以被其替换为实现。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/30/334829f57aa7bb23.png"></p>
<h2 id="依赖倒置原则-DIP"><a href="#依赖倒置原则-DIP" class="headerlink" title="依赖倒置原则 DIP"></a>依赖倒置原则 DIP</h2><p>定义：模块之间交互应该依赖抽象，而非实现。</p>
<p>DIP要求高层模块不应该依赖于底层模块，二者都应该依赖于抽象。抽象不应该依赖细节，细节应该依赖抽象。</p>
<p>比如某个人喂养小动物，如果依赖了具体的实现，则每新增一个动物，需要在Person内加一个对应的方法。违背了开闭原则，也不符合依赖倒置原则。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/30/d4c9dd2def7ff34f.png"></p>
<p>重新修改后，如下。新增一个Birds抽象类，具体的动物继承自父类Birds,Person中的方法参数依赖于抽象，而不是具体的实现。符合依赖倒置原则。<br><img src="https://s3.bmp.ovh/imgs/2022/12/30/43daef95d433ca4c.png"></p>
<h2 id="单一职责原则-SRP"><a href="#单一职责原则-SRP" class="headerlink" title="单一职责原则 SRP"></a>单一职责原则 SRP</h2><p>定义：对任何类的修改只能有一个原因。换句话说，一个类只应该负责一项职责。</p>
<p>SRP要求每个软件模块职责要单一，衡量标准是模块是否只有一个被修改的原因。职责越单一，被修改的原因就越少，模块的内聚性就越高，被复用的可能性就越大，也更容易被理解。</p>
<p>举例员工类 Employee，开发工作变了，需要修改Employee类，测试工作变了需要修改Employee类，不符合单一职责原则，类的复杂性也高。</p>
<ul>
<li>职责多，引起此类变化的原因也多。后续变更的风险就大。</li>
<li>后续需求变更，会造成职责的混乱，类结构的不稳定。</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/30/0687d48c54dd2c6e.png"></p>
<p>改造后，类的职责单一。开发者的职责就是“写代码”，那么对其进行的修改只有与“写代码”相关的一个原因(画类图也是为了指导代码落地)，这样才能确保类职责的单一性原则。</p>
<p>同时，类与类之间虽有着明确的职责划分，但又一起合作完成任务，它们保持着一种“对立且统一”的辩证关系。</p>
<ul>
<li>以责任链模式为例，每个处理者类职责清晰，只处理与自己职责相关的业务。</li>
<li>以员工类为例，拆分后，各个员工完成相应的职责，共同保障项目上线。</li>
</ul>
<p>这种清晰的职责范围划分就是单一职责原则的最佳实践。符合单一职责原则的设计能使类具备高内聚性，让单个模块变得简单易懂，如此才能增强代码的可读性和可复用性。并提高系统的易维护性和易测试性。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/30/9c0fe213f179f6e1.png"><br>上面的例子是类职责单一，那么微服务划分也同理，采用单一职责原则，每个服务负责一块业务。同一类业务的变更落在单个服务内变更。</p>
<h2 id="接口隔离原则-ISP"><a href="#接口隔离原则-ISP" class="headerlink" title="接口隔离原则 ISP"></a>接口隔离原则 ISP</h2><p>定义：客户端对类的依赖基于最小接口，而不依赖不需要的接口。</p>
<p>接口隔离原则认为不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口要好。做接口拆分时，也要尽量满足单一职责原则。将外部依赖减到最少，降低模块间的耦合。</p>
<p>比如类A只需要使用方法1、方法3，类B只需要使用方法2、方法4，但在源代码层次上与所有方法形成依赖关系。这种依赖意味着我们对接口I的方法2修改，即使不会影响A所依赖的方法1、方法3的功能，也会导致它需要重新部署和编译。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/30/9e192cd95fbf4b9c.png"></p>
<p>改造后，类A不需要用到方法2、方法4，就可以选择不依赖它们。代码更加清晰，接口职责更加明确。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/30/99f8960236504a4a.png"></p>
<h2 id="迪米特法则-LOD"><a href="#迪米特法则-LOD" class="headerlink" title="迪米特法则 LOD"></a>迪米特法则 LOD</h2><p>定义：一个类对于其它类知道的越少越好。<br>迪米特法则也被称为最少知识原则，它提出一个模块对其他模块应该知之甚少，或者说模块之间应该彼此保持陌生，甚至意识不到对方的存在，以此最小化、简单化模块间的通信，并达到松耦合的目的。</p>
<p>反之，模块之间若存在过多的关联，那么一个很小的变动则可能会引发蝴蝶效应般的连锁反应，最终会波及大范围的系统变动。我们说，缺乏良好封装性的系统模块是违反迪米特法则的，牵一发动全身的设计使系统的扩展与维护变的举步维艰。</p>
<p>门面模式和中介者模式是迪米特法则极好的范例。 Tomcat中 RequestFacade类就使用了外观模式。RequestFacade是对Request类封装，屏蔽内部属性和方法，避免暴露。<br><img src="https://s3.bmp.ovh/imgs/2022/12/30/af13e033f068ffd4.png"></p>
<h2 id="合成复用原则-CRP"><a href="#合成复用原则-CRP" class="headerlink" title="合成复用原则 CRP"></a>合成复用原则 CRP</h2><p>定义：优先使用合成&#x2F;聚合，而不是类继承。</p>
<p>比如对象的继承关系是在编译时就定义好了，所以无法在运行时改变从父类继承的实现。子类的实现与它的父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。当你需要复用子类时，如果继承下来的实现不适合解决新的问题，则父类必须重写或被其它更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。</p>
<p>合成（组合）和聚合都是关联的特殊种类。</p>
<ul>
<li>聚合表示一种弱的拥有关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；</li>
<li>合成则是一种强大的“拥有”关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。</li>
</ul>
<p>合成&#x2F;聚合复用原则好处：优先使用对象的合成&#x2F;聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模。</p>
<p>举例：手机软件划分可分为QQ、微信等，按品牌划分可分为华为、小米等。如果同时考虑这两种分类，其组合就很多。往下继续扩展软件、手机品牌，都会新增许多子类。违背了开闭原则，也限制了复用性。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/30/9c0cc486fab39f80.png"><br>用聚合关系实现的类图：后面新增软件，手机品牌类不用变更代码。继承的层次也少了。<br><img src="https://s3.bmp.ovh/imgs/2022/12/30/8696182ed2db909b.png"></p>
<h1 id="常用的几种架构设计"><a href="#常用的几种架构设计" class="headerlink" title="常用的几种架构设计"></a>常用的几种架构设计</h1><h2 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h2><p>分层架构是指基于具体的业务模型按照功能模块将代码进行分层组织。每一层代表了一组相关功能的集合。具体分为几层没有明确的规则，通常可以分为3-4层或者更多。在分层架构中，依赖关系是由上往下，上层依赖于下层，不能反向依赖。越往下的层次越通用，偏向于基础能力。越往上层次越动态，偏向于业务。<br><img src="https://s3.bmp.ovh/imgs/2022/12/31/54322a8b2fd91c3d.png"></p>
<p>分层架构设计按照依赖规则的严格程度分为严格型分层架构和松散型分层架构。严格型分层架构要求每一层只能访问其直接依赖的层，不能访问其间接依赖的层。松散型分层架构允许每一层访问位于其下方的任意一层。严格型分层架构使得各个层之间的耦合度降到最低，但是灵活性不足，当上层需要访问下面间接层的能力时必须从上往下层层穿透。松散型分层架构在保证依赖规则的前提下提供了足够的灵活性，所以大部分分层架构都是松散型的。</p>
<p>分层架构设计简洁易懂。对抽象事物按照基础特征进行分类，符合我们的思维习惯，易于理解。分层架构设计保证每一层内部有较好的内聚性，减少了层与层之间的耦合度，易于基础能力的沉淀和复用，也易于控制变更带来的风险。﻿</p>
<p>另外一方面，分层架构设计虽然定义了多个层，但是层与层之间的边界并不是特别清晰。对于新增的模块有可能难以确定应该放在哪一层。或者随着业务逻辑的变化，未来可能需要调整模块所属的层次。分层架构中，上层模块对下层模块有直接的依赖，下层模块的实现直接向上层模块暴露。在修改或者替换下层模块时需要修改上层模块，对上层业务的影响较大。业务实现与基础能力没有完全解耦合。</p>
<h2 id="六边形架构"><a href="#六边形架构" class="headerlink" title="六边形架构"></a>六边形架构</h2><p>又称为端口-适配器架构。为了解决具体实现依赖于基础能力的问题，采用依赖倒置设计方法将工程分为内部和外部。内部是具体的业务逻辑，外部是依赖的基础能力。内部业务逻辑不再直接依赖于外部基础能力，而是都依赖于其抽象定义。使用依赖注入的方式将外部实现传入内部业务逻辑中。内部和外部使用接口进行交互，内部业务逻辑访问基础能力时直接调用其抽象接口即可。<br><img src="https://s3.bmp.ovh/imgs/2022/12/31/0371b8c0e3feb24e.png"><br>六边形架构解决了业务逻辑直接依赖外部模块的问题，它们都依赖于抽象，不依赖于直接的实现和细节。它们直接通过定义好的接口进行交互。因为业务逻辑和外部模块没有直接的依赖关系，在修改和替换外部模块时只需要按照接口定义实现功能，不需要改动业务逻辑。</p>
<h2 id="洋葱圈架构（整洁架构）"><a href="#洋葱圈架构（整洁架构）" class="headerlink" title="洋葱圈架构（整洁架构）"></a>洋葱圈架构（整洁架构）</h2><p>洋葱圈架构又称为整洁架构，结合了分层架构、六边形架构和领域驱动设计特点的架构设计方法。洋葱圈架构是对六边形架构的进一步扩展，依赖关系依然是外部依赖内部。参考领域驱动设计，将依赖层次划分为3-4层甚至更多。从内向外依次为：领域模型、业务逻辑、领域服务、基础能力、外部模块等。</p>
<p>洋葱圈架构具有六边形架构的优点，采用依赖倒置的原则使内部业务模型不再直接依赖于外部基础能力。外部模块的变动和替换不影响内部业务逻辑。采用领域驱动设计的方法划分实体和模型，利于业务规则的抽象和业务模型的建立，对未来业务迭代的支持较好。洋葱圈架构使业务实体、业务模型和业务实现处在里层，保证了业务模型和实现的稳定，避免受到外部模块变动的影响。</p>
<p>例如，使三方SDK或者数据库系统属于最外层，使用依赖注入的方法将它们的实现传入内部逻辑。当替换三方SDK或者数据库系统时，按照接口定义实现具体细节即可。不需要对内部逻辑进行改动。</p>
<h2 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h2><p>领域驱动设计简称为DDD（Domain-Driven Design）。准确来说它不是一个架构设计方法，而是一种以业务分析和划分来驱动系统架构设计的软件开发方法。它强调识别业务的核心问题域来确定问题边界，同时将问题域进行分解降低分析的复杂度。DDD强调通过关注业务核心提升业务价值。<br>下图是我总结的DDD的架构的全貌介绍：<br><img src="https://s3.bmp.ovh/imgs/2022/12/31/41fff245c10d414a.png"><br>下面是DDD的一些核心概念，我们做一些简单的介绍。</p>
<ol>
<li><p>领域：有确定的范围和边界的业务问题域。实际上是我们要解决什么业务问题的抽象描述。比如提供给用户当前位置、目的地位置且提供到达信息是高德地图的问题域。</p>
</li>
<li><p>子域：将大的问题域根据业务规则的不同拆分成的小问题域。比如高德地图的问题域太大了，难以解决。我们可以将问题域拆分成定位、POI搜索、路线规划等子问题域。</p>
</li>
<li><p>界限上下文：领域之间的抽象边界。封装了领域内的概念、规则和模型。</p>
</li>
<li><p>实体：具有唯一标识的、存在生命周期的对象。比如展示给用户可见的POI气泡是一个实体，它有状态和确定的生命周期。</p>
</li>
<li><p>值对象：没有唯一标识和生命周期的对象，依附于实体而存在。比如POI信息是值对象，本身没有状态，只能依附于POI气泡这个实体而存在。</p>
</li>
<li><p>聚合：领域内一组实体、值对象的集合。封装了集合与外界的交互</p>
</li>
</ol>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/31/729d2f1b2c2abd52.png"></p>
<p>使用DDD对业务问题进行分析和拆解后，可以采用任何一种架构设计方法，无论是分层架构、六边形架构或者整洁架构等。但是DDD要求架构设计从实际的业务场景出发，理解业务的核心问题。架构需要明确概念、规则的设计，并且保证业务模型的稳定性。使用分层架构展现DDD的领域设计方法，将工程分为4层：基础设施层、领域层、应用层和用户接口层。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/31/3f95da9b7f2ab078.png"></p>
<h1 id="工业4-0"><a href="#工业4-0" class="headerlink" title="工业4.0"></a>工业4.0</h1><p>我们用大量的篇幅说了软件开发的复杂度，架构设计规范，几种常见的架构方式，我认为这些是在架构领域一些本质和核心的知识，虽然比较抽象，但是一个架构师毕生可能都在这些理念当中游走，<br>这是我们首先要认知的东西，思想上认同这些核心，然后在实践当中努力思考做的系统是否对齐了这些理念，还可以对别人的系统进行思考，然后总结，只有在不断的思考、好奇、总结当中才能打破自己的边界，知识边界、认知边界。</p>
<p>前几天看到吾辈楷模野生钢铁侠从菊场离职了，我就知道他待不长，他只有离职了才是原来的钢铁侠，这类人的抱负和理想我是最了解不过的了，因为我看到了自己的影子。<br><img src="https://s3.bmp.ovh/imgs/2022/12/31/ba7c9dd66f1ffd32.png"></p>
<p>在企业级系统领域开发了这么多年，从毕业到现在，一直没有停过，确切的说从大二就开始java开发这条不归路，别人开黑，我在学习java，别人上自习，我他妈也在学习，别人放寒假暑假了，我还是在学习java，不断的coding，去厂子打塑料件，和老刘我们他娘的还在coding java，工作了以后，在济南华为，在杭州连连，在蚂蚁集团，还在这片江湖上燃烧着火之意志，从之前的各种眼花缭乱的技术框架学习，到现在专研架构，回想这一路，真是刺激，一个技术人员能为此疯狂七八年，那真的是渗透到了骨子里，大学里边的老刘、草莓、君才他们也是这样从高校阶段自学开始的，不知道他们现在是否还有这个技术热情，老刘应该还有，这货打了火之意志的思想钢印，草莓、君才难说了，生活和现实让很多东西很难坚持，梦想成了饭后唠嗑的笑话，剩下的都是随风飞舞的无奈。</p>
<p>我觉得32岁开始，男人的人生道路会出现一个分水岭，要么曲线开始爬升，要么曲线开始缓缓下降，埃隆马斯克30岁拥有了PayPal，32岁合并了ebay。<br>这个时间点一直在暗示我，是时候转移赛道了，为了第二次火之意志的燃烧，flight for freedom!</p>
<p>在吾辈楷模稚晖君的引领下，我开始计划长久的攻城策略，开始打持久战，嵌入式Linux开发是我的技术生涯里边一直想要补充的一个版块，没有这个版块是不完美，是残疾的技术栈，它不符合火之意志的指导方针，不认同三个代表，没有落实科学发展观，也不符合中国梦的蓝图。</p>
<p>我做了一个思维导图，我在做这个导图的时候，回想起来当初在暑假学习各类java框架的时候的感觉很相似，同样充满了未知、东西太多、看不懂，这种感觉就像你有一桶汽油，但是一直没有遇到明火，但是在不经意的写作当中擦出了静电。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/31/100658b25bef720c.png"></p>
<p>我目前还在电路设计能力-数字电路设计-接口设计里边攻城拔寨，接口设计这部分已经快学完了，剩下的就是不断的coding强化。<br>配套的军火如下：<br><img src="https://s3.bmp.ovh/imgs/2022/12/31/d4779323e23e65ef.png"><br>另外配套如下教学：<br><img src="https://s3.bmp.ovh/imgs/2022/12/31/dcbc8eb59bc89661.png"></p>
<h1 id="运动挑战"><a href="#运动挑战" class="headerlink" title="运动挑战"></a>运动挑战</h1><p>总体来说</p>
<ul>
<li>一次开年开局跑，2022图形<br><img src="https://s3.bmp.ovh/imgs/2022/12/31/2b1b9a61ed2215d3.jpg"></li>
<li>参加了一次半程马拉松<br><img src="https://s3.bmp.ovh/imgs/2023/01/02/79c55bb220092f33.png"><br><img src="https://s3.bmp.ovh/imgs/2023/01/02/d2cc5b46da9ba6bc.png"></li>
<li>越野-野玫瑰路线<br><img src="https://s3.bmp.ovh/imgs/2022/12/31/7f80012bc4599ba1.jpg"></li>
<li>越野-圣诞树路线<br><img src="https://s3.bmp.ovh/imgs/2022/12/31/8e509bfff173110a.png"></li>
<li>越野-爱情鸟路线<br><img src="https://s3.bmp.ovh/imgs/2022/12/31/9700179d95f867bd.jpg"></li>
<li>骑行-千岛湖27km<br><img src="https://s3.bmp.ovh/imgs/2022/12/31/7db576a4fceb5e0c.png"></li>
<li>夜爬-怡情<br><img src="https://s3.bmp.ovh/imgs/2023/01/02/6c230439a541aa7b.png"></li>
<li>越野-标毅路线<br><img src="https://s3.bmp.ovh/imgs/2023/01/02/0ddd4eb5549b37c5.png"></li>
</ul>
<p>没有达到我心中的的要求，按照计划是每个月一次越野，由于各种乱七八糟的事情，没有实现目标。</p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ol>
<li><p>不要尝试去改变别人，这是失败的开始，一个人在你面前能说这样的话，做这样的事情，并不是偶然的，他的经历、他见过人、听见的事、走过路，童年晚上放学一次仰望星空都会作为构建一个人认知的组成部分，你去改变他&#x2F;她，就是等同于改变ta的历史，我的一个发小今年来杭州找我玩，喝了一顿酒，借着酒劲，他说出了她婚后很多不堪，说到他和他老婆之间很多争吵，家里一片狼藉，后来了解到，他老婆不满意他的很多行为，一直在逼我的这个发小去改变，我的这个发小在逼迫之下一个月没有回家，我听到这里，就知道，他老婆的原因最大，因为她无法改变一个活了将近30多年的人的习惯和认知，出现裂缝是必然的，后来去劝他回家，最近他确实回家了，惊奇的是他老婆反应过来这个事情了，承认逼迫一个人按照自己喜欢的风格去生活是自私的，古人云：君子和而不同，小人同而不和。他老婆也是做了一次君子。</p>
</li>
<li><p>认识自己，向内求，强势文化的人和弱势文化的人本质区别是强势文化的人向内求，同时遵循了第一条，不去改变别人，这个在生活、工作、感情当中都可以流通，尤其是在感情里边，把自己的事情做好，就是维持稳定的第一要素，对方不管做什么事情，好事坏事，统统和你没关系，是对方的认知促使ta做了这件事，火影忍者里边的宇智波鼬说过：【每个人都依靠自己的知识和认识，却又被之所束缚，还将这些称之为现实。但知识和认识是非常暧昧的东西，那个现实也许只不过是镜中花水中月】。 ​​​只有现实才能改变一个人的认知，认识自己就是把蛋糕做大，对于工作上来说，也是如此，你是一个leader，你给下级说了很多道理，做事情的方法论，但是实际上整个团队交付的产品还是有各类失误造成的瑕疵，为什么？道理是非常抽象的东西，你作为leader你经历过，你说的每一句话都是有实际的case作为背书的，而你的下级认为这就是一句普通的大道理，甚至他们会认为这是PUA，内心还会骂娘：去你骂了隔壁的吧！你算老几，和我谈人生。。。正确的做法是让下级去经历，让他们去犯错，从实际当中总结经验教训，建立自己的认知和知识体系，这才是正确的提拔栽培之道。</p>
</li>
<li><p>养成思考问题的习惯，我们工作和生活每天都在进行，每天来来回回就是那么点儿事，坏事常见，好事少有，你和我差不多，我和他也挺像，为了眼前和手上的烂事糟心着，没什么意思你知道吧，也没有多难过，就是觉得没意思，一点意思都没有。 ​​  ​很多人都会有这样的感受，行尸走肉一般，时间久了终会成为一座山，把你压垮，比如平时上班写完增删改查的代码就开始摸鱼，突然有一天裁员了，技术积累和架构设计积累都没沉淀，草草走人，因此日常工作需要思考，也就是卷，互联网的江湖如逆水行舟，不进则退，这是客观规律，不以人的意志为转移，你选择上进就要去思考，你选择摆烂就会被时代的洪流冲走，而冲走的到了下游都是枯枝烂叶，一步退，步步退，消极的溪水汇聚到了一起，终会影响到你的人生的各个方面：婚姻生活稳定性、工作可被替代性、个人健康，悲剧的人生都是从小的负向沉淀汇聚为江河湖泊成了悲剧。所以这条在很多择偶市场上也会出现，要求上进心，有自己喜欢的爱好或者事业等等，男女通用，这种正向积极的生活态度，标记着配偶将来会有好的资源，利于繁殖和基因传递。天下事，一切都在理性系统的支配之下。</p>
</li>
</ol>
<h1 id="谈一下哲学"><a href="#谈一下哲学" class="headerlink" title="谈一下哲学"></a>谈一下哲学</h1><p>最近看了一下西方的哲学历史，对个人主义，自由主义有了一些个人的认识，仅仅作为娱乐，胡说八道，哈哈哈。</p>
<h2 id="个人主义与现代文明"><a href="#个人主义与现代文明" class="headerlink" title="个人主义与现代文明"></a>个人主义与现代文明</h2><p>为什么东方人习惯于将自身置身于一个集体中思考问题呢？<br>为什么一代一代的人为了家庭和孩子牺牲了自己的全部， 但却每一代都过不好自己的一生？<br>当年，进几十年有了明显的改变，我们东方的宗族观念逐渐崩塌。丁克，独身，离婚越来越多。<br>人们逐渐抛弃了集体的观念，我们不会再为了集体放弃自己的生活，这一些改变都是因为我们思考世界的方式改变了。<br>东方的集体主义逐渐被西方的个人主义取代，可以毫不夸张的说因为西方个人主义的产生，我们才出现了现代文明。<br>不管是个体自由，市场自由，还是现代的民主政治自由，都依托与个人主义的观念之上，但是，个人主义在东方又面临着诸多的误解，<br>很多人对个人主义的理解就是自私，自利，一切以个人为中心，这些乱七八糟莫名其妙的解读让个人主义在东方长期成为一个贬义。<br>这造成了一种大撕裂，虽然人民早已经用个人主义的方式在思考问题，但是对个人主义却充满了偏见和误解。<br>首先需要明确的是个人主义是文明发展过程中的一个bug，因为不仅仅是东方，全世界都活在集体主义或者集体主义的变种里。<br>唯独欧洲诞生了个人主义，在个人主义诞生之前，人类社会从来都是少数人统治绝大数人，绝大多数人都是任人摆布的工具人，在集体主义中人没有自我，<br>也没有自我意识，他们心中只有家庭、集体宗族、民族、国家等概念，个体从来不重要，这导致了人们思想和创造力的匮乏，因为人不是主主体，而是集体视角下的<br>一个客体。<br><img src="https://s3.bmp.ovh/imgs/2023/01/02/87f53127dcef11ae.png"><br>因为个人主义的发展非常复杂，他贯穿了整个西方思想史我们今天试着做一个极简的推到。<br>第一个阶段，古希腊的个人主义的萌芽，古希腊的普罗泰格拉提出：人是万物的尺度，整个观念奠定了个人主义的萌芽。<br>普罗泰格拉强调以人的个体感受去获得知识，以欲望和私利作为道德的目标，这是我们现在已知的，最早的个人主义。<br>第二个阶段，希腊化时代个人主义崛起， 亚历山大征服欧洲后希腊消亡，欧洲进入到希腊化时代，希腊化时代欧洲烽烟四起，战火蔓延，<br>人们关注城邦的公共精神逐渐退出舞台，因为外部世界不受控，人的精神世界被迫向内挤压，退缩到内心世界，个人主义在这个阶段积累了强劲的势能。<br>第三个阶段，亚多斯学派提出自然平等的观念，斯多亚学派是西方第一个阐述了人人生儿平等，权利是天赋的一个学派，这个观念到现代一直都是西方的核心观念，因为这种理论<br>斯多亚学派的信仰者囊括了从罗马皇帝到奴隶的各种阶层，斯多亚学派是西方人人平等的启蒙思潮之一，比如斯多亚学派的塞内加说：对人类而言，人是神圣的。<br>这种把个体推崇到神圣的地步，无疑是个人主义崛起的重要源头。<br>第四个阶段，文艺复兴和宗教改革的直接作用，我们知道文艺复兴的核心是人权向神权发起挑战，在中世纪的神权时代，人是神的客体，人怎么想不重要，神怎么想才重要。<br>而在文艺复兴人从客体成为主体，世界、万物、甚至神都成为客体，文艺复兴催生了人的觉醒，普通人开始思索和挖掘自我的内心世界，人类的内在力量得以慢慢释放。</p>
<p>其实在这四个阶段之外，还有一个最重要的推动作用，  那就是基督教，基督教对个人主义的推动来源于两次改革：<br>第一次，是以赛亚对犹太教的改革，犹太教先知以赛亚完成了对犹太教对祭司阶层的变革，让人与神点对点沟通，他删除了祭司阶层。<br>作为西伯来的先知，以赛亚认为如果一个宗教有祭司的产生，那么祭司阶层必然会成为特权阶层，它会垄断人与神之间的交流，同时，如果有祭司阶层就会有腐败产生，<br>于是以赛亚打破了犹太教的祭司阶层，对早期的犹太教的发展起到了至关重要的作用，他把人们对神的信仰带入到人们的内心，对个人主义的发展起到了决定性的作用。<br>第二次是马丁路德的宗教改革，宗教改革对个人主义推动至关重要，因为宗教改革为人们重塑了一种观念，在宗教改革之前，祭司阶层，即罗马教廷掌握了信仰的评估体系。<br>人们和神的沟通由这祭司这个中介完成，而宗教改革从理论层面，自一次删除了祭司阶层，同时基督教认为神创造了人，并且赋予了每个人灵魂，这种观念给了西方人存在的意义。<br>以及它作为人的基本权利，在浩渺的人生荒原上，每个人都是孤独的行者，他们只能沟通唯一的存在那就是神，在这种渺小的个体和全能的神之间的对立中，个体对自我的思索慢慢浮出水面。<br>所以我们可以知道，欧洲的哲学思想传承和基督教精神共同塑造了个人主义，个人主义的产生从根源上改变了人的主体性，让人对自我和世界都有了一次全新的思考，正是因为这些改变欧洲开始<br>焕发了巨大的活力和创造力。他成为人类现代文明的一种基石。</p>
<h2 id="自由主义为何让世界分裂成一万个平行宇宙"><a href="#自由主义为何让世界分裂成一万个平行宇宙" class="headerlink" title="自由主义为何让世界分裂成一万个平行宇宙"></a>自由主义为何让世界分裂成一万个平行宇宙</h2><p>自由主义作为西方哲学的重要概念，自由主义到底是如何产生的，古典自由主义和新自由主义的区别又是什么？<br>我们先看2个命题：<br>命题一,世界是由水组成的—泰勒斯<br>命题二，幸福就是在城邦和人坐地起扛—-苏格拉底<br>你不用判断这2个命题的对错，你需要判断的是这两个命题有什么本质的不同，有网友立刻会想到，这2个命题的本质区别是命题一是实时判断，命题二是价值判断。<br>西方文化之所以衍生出事实判断和价值判断2种命题范畴并且形成了学生必须掌握的一种逻辑思维训练工具，和自由主义的诞生有着莫大的关联。<br>在自由主义诞生之前的古典时代，就是古希腊时代，人们认为追问幸福是什么，和追问世界是由什么构成的一样他们都有着明确的答案，希腊人认为什么是幸福，什么是自由，什么是勇气，什么是爱，这些问题和宇宙中有多少颗星星，太阳的表面温度有多高一样，他是一种客观存在的实体，有标准答案。<br>这就是说在古典时代，人们认为价值观和自然客体一样，存在着唯一答案，只是因为我们的智慧不够，暂时还没有找到这种答案的本质，因为古典时代把价值观当成实体，所以在中世纪及中世纪后期的宗教改革中，因为价值观的分裂人们开始岗捍卫自己的价值观，而展开了漫长的斗争，宗教战争彼此起伏，人们生活在动荡，困苦和信仰危机中，人们的价值观经历了巨大的碰撞，对抗和融合。于是欧洲人开始反思，我们内心追寻的价值真的是一种实体吗？他有标准答案吗？天主教和新教的分歧真的不能调和吗？基督教世界和伊斯兰世界有达成共识的可能吗？在这种反思下，自由主义在欧洲诞生了。<br><img src="https://s3.bmp.ovh/imgs/2023/01/02/687047b3ce0b1812.png"><br>所谓自由主义就是提倡文化的多元，价值的多元，尊重不同思想，不同信仰人的内心秩序，把所有的美好、幸福、审美价值偏好等等全部交给个人去选择，自由主义实现了一个伟大的转向，他把公共权利赶出了人们的内心，从此公共权利只关心秩序和安全，他不在涉足人们的内心自由主义的起源还有另外一个观点，他们认为自由主义的诞生和西方个人主义的诞生同时发生，他们都起源于亚里斯多德逝世到斯多亚学派崛起这段时间，这段时间是希腊化时代。<br>随着亚历山大的征服，欧洲战火蔓延，人们从关心城邦政治退缩到关心自己的内心世界，于是个人主义诞生，自由主义也在个人主义的基础上开始诞生。</p>
<p>自由主义的诞生无疑是人类文明的一个伟大时刻，从此人类文明产生了一个划时代的转向，人们知道人们内心的认知不是一种实体，不同的人不需要遵守一套共同的价值观，人们把内心的价值从科学和政治哲学抽离出来，科学和政治哲学负责外向探索自然的本质和秩序，而另一条是通往人们内心的探索，关于幸福，关于爱情，关于美，关于自由等等，这条路催生了自由主义和个人主义。</p>
<p>无论是源于宗教改革，还是起源于希腊化时代自由主义的诞生都是人类文明慢慢长夜的第二个火炬，而且可能是最亮的那只火炬，在自由主义诞生之前没有一种文明一种宗教，会把价值层的认知和对自然客体的认知区分开来，大多数文明不能容忍不同的意见，不同的价值观，他们认为价值观就是一种实体，有标准答案，不符合标准答案就是一种异端邪说，还是烧了比较安全，因为这种认知大多数文明不允许不同的价值观存在，世界出现了诡异的沉默的大一统。<br><img src="https://s3.bmp.ovh/imgs/2023/01/02/01d97961407f3806.png"></p>
<p>这种向内和向外的分离，心灵和物质的分离，和笛卡尔的身心二元论、康德物自体现象二元论都有着密切的思想的关联，在笛卡尔后的400年中，人类的外向探索可以说是硕果累累，它产生了辉煌的现代科技，并且征服了星辰大海，现在美帝的马斯克要殖民火星，这是一种伟大的外拓的胜利，然后人类向内的探索不但毫无建树，甚至可以说越来越举步维艰，因为自由主义对不同的价值观的的尊重世界产生了越来越多的对抗，纷争，矛盾，猜忌和战争，时至今日，宗教战争的阴霾依然笼罩着全人类，不同的意识形态的斗争依然如火如荼，人们越来越陷入自我的价值观，而不想再去听他人的解释，所谓的信息茧房正在形成，价值观成为一道永恒的高墙，让无数人身体近在咫尺，而心灵却万里千年，自由主义提倡个人自由个性解放，他主张个体的意志和精神，这种自我意志的张扬和西方的后现代文明融为一体，西方那些颓废的嬉皮士堕落的朋克青年，似乎都成为了自由主义的反面典型。<br>在自由主义之下，因为价值观的相近形成了社群主义，但不同的社群主义又因为价值观的分裂而产生了更加尖锐的对抗，于是无数的粉丝团，后援团饭圈女孩开始了远征，她们以键盘为武器，以文字为炮火，开始了互联网的世界大战，世界不是在分裂成2个，而是被分裂成无数个平行宇宙，人们渴望的统一的价值观再也没有出现过。</p>
<p>是自由主义错了吗？自由主义的多元价值观导致现代人们逐渐被原子化，而原子化又是现代性中人们普遍孤独的深层原因，自由主义导致了人与人之间形成了永恒的心灵孤岛，这到底是文明的进度还是倒退？</p>
<h2 id="个人主义是否导致婚姻制度的消亡？"><a href="#个人主义是否导致婚姻制度的消亡？" class="headerlink" title="个人主义是否导致婚姻制度的消亡？"></a>个人主义是否导致婚姻制度的消亡？</h2><p>让人十分恼火的是明星的离婚事件总是霸占着自媒体的头条，看别人的离婚吃瓜群众自己能兴奋半个月，好像这里边有自己什么事，但确定的是不管是大数据统计还是我们的现实观感，不管是东方的还是西方的，全世界的离婚率都在逐年上升，如果一个现象跨越了中西方文化 的差异，它一定有自己内在的逻辑，那么离婚率全世界逐年走高的原因到底是什么呢？<br>我们需要向回顾人类的婚姻制度是如何产生的，首先是生育困境，因为直立行走导致了女性骨盆变窄，骨盆变窄导致了生育困难，生育困难导致了女性需要找一个人来做分工协作，于是女性必须拉个男人组建家庭，以帮助自己度过漫长的生育和哺乳期，所以女性的生育困难是婚姻制度产生的第一个源头。<br>其次是私有制，在私有制之前，婚姻是没有的，大家是出于一棒子敲晕扛回去山洞的群婚状态，当私有制出现后，男性首先要考虑是财产的传承问题，自己的财产到底传给谁呢？传给隔壁老王，有点亏，传给伴侣，伴侣带着你的财产可能还是找了隔壁的老王，怎么算老王都是永远最大的赢家，最佳的方案当然是创给自己的孩子，毕竟这娃还有你的基因，但是传给孩子最大的问题是如何确定孩子的身份，和女性娃永远是自己的娃不同，男性的永恒焦虑是那个从小养到大的娃，不一定是自己的娃，所以男性看到隔壁老王总是血压飙升，这不是你的问题，这是基因带来的永恒焦虑。<br>于是子嗣的血缘就显得非常重要，男性必须垄断性伴侣与实现血缘的确定性，于是婚姻产生了，可以看出女性的生育困境和男性血缘伦理的要求，共同导致了婚姻的出现，不管是东方还是西方，婚姻都是一种自发秩序，它的本质是血缘传承，是分工协作，是资源整合，是宗族联姻，是政治博弈，</p>
<p>唯独无关爱情。</p>
<p>世俗的婚姻千篇一律，崇高的爱情万里挑一，婚姻乏善可陈，爱情却十足珍贵，比如一篇孔雀东南飞之所以被传颂至今，正是因为婚姻中爱情的稀缺性，婚姻只会涉及资源的整合，比如在欧洲国王的子嗣婚配对象不可能是平民百姓，如果贵族奔着爱情寻找婚姻，会付出惨痛的代价，比如权游中罗伯去了平民女子，最终导致了血色婚礼的发生，这在欧洲历史上都有原型，而现代社会使用爱情取代了前文明社会中以资源整合为基础的婚姻，为什么会出现这种变化呢？这一切都是因为个人主义的产生。</p>
<p>罗素认为人主义可以追溯到古希腊的犬儒学派和斯多亚学派，在希腊消亡以后的希腊化时代，希腊人被迫从公共生活退缩到内心，他们不再关注城邦，而是在自己的心灵中独善其身，个人主义从此诞生，后来文艺复兴和宗教改革也促进了个人主义的发展，人们从神权中走出，开始认识到自我的意义和价值，认识到个体才是万物的尺度。</p>
<p>个人主义和其他思想最大的不同是人们到底是用什么标准评价和思考这个世界，在这个人主义之前，个体的价值由社会和他人赋予，比如社会评价你是一个怎样的儿子、丈夫和父亲，你有没有做到忠孝两全，你有没有做到义薄云天，个体的所有价值都掌握在他人手中，但是当个人主义出现，个体的价值不再仅仅由社会赋予，而是由他个体内心的感受决定，这种价值的内心化，评判的个体化，导致了欧洲文明的大转向，集体主义、宗族主义被抛弃，人们把所有的判断交给个体交给内心，我的内心即为整个世界。</p>
<p>这里插一句题外话，个人主义的诞生非常重要，他是西方出现文明大升级的关键因素。<br><img src="https://s3.bmp.ovh/imgs/2023/01/02/0420acd49a0db15d.png"><br>因为除了欧洲之外，全世界绝大多数文明，都是集体主义的变种，只有在西方诞生了个人主义，因为个人主义一切从自己出发，它导致了婚姻制度的根本性改变，那些传统婚姻基于分工协作、传宗接代、宗族联姻都不在重要，“我喜欢”才是最重要的。</p>
<p>那么以爱情为基石的婚姻，为什么有可能瓦解婚姻制度呢？</p>
<p>首先，，恩格斯在《家庭、私有制和国家的起源》中指出，如果以爱情为基础的婚姻是合乎道德的，那么只有继续保持爱情的婚姻才会继续合乎道德，恩格式的这句话无疑洞悉了现代婚姻的本质，<br>当爱情不在的时候，以爱情为基础的婚姻也就不可能存在了，其次，爱情的流变性导致失望情绪的蔓延，因为爱情是一种玄学，不但科学解决不了，哲学也无能为力，爱情不但玄之又玄，而且极易流变，当昨天的梦中女神，成为今天的枕边悍妇，当曾经的大长腿欧巴成为渣男，爱情就消失了，而这种爱情的消失，导致人们普遍流露出失望的情绪，如果一个人能凭借着爱情组建婚姻，那么ta很大程度也会走向失望，那些能够白头到老的更多是处于一种相对封闭的环境中，他们的价值观改变不大，如果是2个人的价值观不断流变，那么大概率的结果就是分道扬镳。同时在爱情为基础的婚姻观下，婚姻成为人们实现自我的一种途径，他们认为婚姻应该是玩乐，而不是任务，婚姻应该是让人兴奋的，而不是让人厌倦的，婚姻应该是充满了激情的，而不是充满亲情的，当然们在婚姻生活中感受不到这种情绪后，分道扬镳就会自然产生。所以因为个人主义的崛起，人们对婚姻观念发生了翻天覆地的改变，他最终导致了越来越多的离婚发生。</p>
<p>至于个人主义会不会颠覆传统的婚姻制度，以上是我个人的推论，不代表个人对婚姻爱情的看法，仅仅是逻辑推理过程，实际情况需要实事求是。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/12/30/fb9eddf1a2111791.jpg" alt="image.jpg"></p>
<p>如果你觉得我的文章有用，可以打赏我一杯雀巢咖啡</p>
<p><img src="https://i.postimg.cc/8Pmvqq4J/b1c4562d7729c208aef2f861473f309.jpg" alt="image.jpg"></p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>2022</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能相关学习资料汇总</title>
    <url>/2023/12/25/life/aigc/</url>
    <content><![CDATA[<p>本文旨在整理一份可供参考和学习的专业ChatGPT相关资料，包括ChatGPT相关论文、Github项目、以及当前市场上出现的ChatGPT相关产品等。</p>
<p>本文将持续不断更新，只涵盖最专业的内容。</p>
<span id="more"></span>
<h2 id="大模型学习课程或教程"><a href="#大模型学习课程或教程" class="headerlink" title="大模型学习课程或教程"></a><strong>大模型学习课程或教程</strong></h2><p>| <strong>名称</strong> | <strong>介绍</strong> | <strong>课程或教程地址</strong> | <strong>发布或发表时间</strong> |</p>
<p>| — | — | — | — |</p>
<p>| The Transformer Family Version 2.0 | 大模型家族详细介绍 | <span class="exturl" data-url="aHR0cHM6Ly9saWxpYW53ZW5nLmdpdGh1Yi5pby9wb3N0cy8yMDIzLTAxLTI3LXRoZS10cmFuc2Zvcm1lci1mYW1pbHktdjIv">The Transformer Family Version 2.0 &amp;#124; Lil’Log (lilianweng.github.io)<i class="fa fa-external-link-alt"></i></span> | 2023-01-27 |</p>
<p>| TensorFlow学习教程 | Google官方TensorFlow学习教程，可以直接通过Google colab实验室运行教程中的代码 | <span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvdHV0b3JpYWxzL3F1aWNrc3RhcnQvYmVnaW5uZXI/aGw9emgtY24=">初学者的 TensorFlow 2.0 教程  &amp;#124;  TensorFlow Core<i class="fa fa-external-link-alt"></i></span> | 2022-09-21 |</p>
<p>| 斯坦福大模型课程CS324 | CS324提供了关于大型语言模型建模、理论、伦理和系统方面的基础知识，并且提供了亲自体验构建大模型的机会。 | <span class="exturl" data-url="aHR0cHM6Ly9zdGFuZm9yZC1jczMyNC5naXRodWIuaW8vd2ludGVyMjAyMi8=">Home &amp;#124; CS324 (stanford-cs324.github.io)<i class="fa fa-external-link-alt"></i></span> | 2021-12-24 |</p>
<p>| 伯克利STAT 157深度学习课程 | 这个课程提供了深度学习的实用介绍，包括理论动机以及如何在实践中实现。 | <span class="exturl" data-url="aHR0cDovL2NvdXJzZXMuZDJsLmFpL2JlcmtlbGV5LXN0YXQtMTU3L3N5bGxhYnVzLmh0bWw=">Syllabus — STAT 157, Spring 19 documentation (d2l.ai)<i class="fa fa-external-link-alt"></i></span> | 2019-02 |</p>
<p>| The Illustrated Transformer | “Transformer”概念通俗易懂介绍 | <span class="exturl" data-url="aHR0cHM6Ly9qYWxhbW1hci5naXRodWIuaW8vaWxsdXN0cmF0ZWQtdHJhbnNmb3JtZXIv">The Illustrated Transformer – Jay Alammar – Visualizing machine learning one concept at a time. (jalammar.github.io)<i class="fa fa-external-link-alt"></i></span> | 2018-06-27 |</p>
<h2 id="大模型项目"><a href="#大模型项目" class="headerlink" title="大模型项目"></a><strong>大模型项目</strong></h2><p>| <strong>模型名称</strong> | <strong>介绍</strong> | <strong>介绍地址</strong> | <strong>发布时间</strong> |</p>
<p>| — | — | — | — |</p>
<p>| Vicuna-13B | 一个开源的聊天机器人，通过在从ShareGPT收集的用户共享对话上进行LLaMA微调来训练。使用GPT-4作为评判标准的初步评估显示，Vicuna-13B在超过90％<em>的情况下实现了OpenAI ChatGPT和Google Bard的质量，并且在超过90％</em> 的情况下优于其他模型（如LLaMA和Stanford Alpaca）。训练Vicuna-13B的成本约为300美元。训练和服务<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xtLXN5cy9GYXN0Q2hhdA==">代码<i class="fa fa-external-link-alt"></i></span>以及在线演示可供非商业用途公开使用。 | <span class="exturl" data-url="aHR0cHM6Ly92aWN1bmEubG1zeXMub3JnLw==">Vicuna: An Open-Source Chatbot Impressing GPT-4 with 90%* ChatGPT Quality &amp;#124; by the Team with members from UC Berkeley, CMU, Stanford, and UC San Diego (lmsys.org)<i class="fa fa-external-link-alt"></i></span> | 2023-03-19 |</p>
<p>| LangChain | 一个用于开发由语言模型驱动的应用程序的框架 | <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmxhbmdjaGFpbi5jb20vZG9jcw==">https://docs.langchain.com/docs<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h3Y2hhc2UxNy9sYW5nY2hhaW4=">https://github.com/hwchase17/langchain<i class="fa fa-external-link-alt"></i></span> | 2023-03-24 |</p>
<p>| LMFlow | 一个可扩展、方便、高效的工具箱，用于微调大型机器学习模型，旨在用户友好、快速可靠，并且对整个社区开放。 | <span class="exturl" data-url="aHR0cHM6Ly9sbWZsb3cuY29tLw==">https://lmflow.com/<i class="fa fa-external-link-alt"></i></span> | 2023-03-27 |</p>
<p>| Chatbot Arena | 一个基于大型语言模型（LLMs）的基准平台，在发布博客文章中，给出了一个基于Elo评分系统的排行榜 | <span class="exturl" data-url="aHR0cHM6Ly9sbXN5cy5vcmcvYmxvZy8yMDIzLTA1LTAzLWFyZW5hLw==">https://lmsys.org/blog/2023-05-03-arena/<i class="fa fa-external-link-alt"></i></span> | 2023-05-03 |</p>
<p>| ImageBind | 第一个能够同时绑定六种模态数据的AI模型，无需明确监督。通过识别这些模态之间的关系——图像和视频、音频、文本、深度、热量和惯性测量单元（IMUs）——这一突破有助于推进人工智能，使机器能够更好地分析许多不同形式的信息。 | <span class="exturl" data-url="aHR0cHM6Ly9pbWFnZWJpbmQubWV0YWRlbW9sYWIuY29tLw==">https://imagebind.metademolab.com/<i class="fa fa-external-link-alt"></i></span> | 2023-05-09 |</p>
<h2 id="ChatGPT相关大模型论文合集"><a href="#ChatGPT相关大模型论文合集" class="headerlink" title="ChatGPT相关大模型论文合集"></a>ChatGPT相关大模型论文合集</h2><p>| <strong>论文分类</strong> | <strong>名称</strong> | <strong>论文链接</strong> | <strong>发表时间</strong></p>
<p><strong>【时间为预印网站最新时间】</strong> |</p>
<p>| — | — | — | — |</p>
<p>| Transformer | Transformer 论文 | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzE3MDYuMDM3NjI=">Attention Is All You Need<i class="fa fa-external-link-alt"></i></span> | 2017-12-05 |</p>
<p>|  | Transformer 模型介绍和分类 | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIzMDIuMDc3MzA=">Transformer models: an introduction and catalog<i class="fa fa-external-link-alt"></i></span> | 2023-02-16 |</p>
<p>| OpenAI | DALL E 论文 | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIxMDIuMTIwOTI=">Zero-Shot Text-to-Image Generation<i class="fa fa-external-link-alt"></i></span> | 2021-02-26 |</p>
<p>|  | DALL E 2论文 | <span class="exturl" data-url="aHR0cHM6Ly9jZG4ub3BlbmFpLmNvbS9wYXBlcnMvZGFsbC1lLTIucGRm">Hierarchical Text-Conditional Image Generation with CLIP Latents<i class="fa fa-external-link-alt"></i></span> | 2022-04-12 |</p>
<p>|  | Codex 论文 | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIxMDcuMDMzNzQ=">Evaluating Large Language Models Trained on Code<i class="fa fa-external-link-alt"></i></span> | 2021-07-14 |</p>
<p>|  | GPT-1 | <span class="exturl" data-url="aHR0cHM6Ly9jZG4ub3BlbmFpLmNvbS9yZXNlYXJjaC1jb3ZlcnMvbGFuZ3VhZ2UtdW5zdXBlcnZpc2VkL2xhbmd1YWdlX3VuZGVyc3RhbmRpbmdfcGFwZXIucGRm">Improving Language Understanding by Generative Pre-Training<i class="fa fa-external-link-alt"></i></span> | 2018-06 |</p>
<p>|  | GPT-2 | <span class="exturl" data-url="aHR0cHM6Ly9jZG4ub3BlbmFpLmNvbS9iZXR0ZXItbGFuZ3VhZ2UtbW9kZWxzL2xhbmd1YWdlX21vZGVsc19hcmVfdW5zdXBlcnZpc2VkX211bHRpdGFza19sZWFybmVycy5wZGY=">Language Models are Unsupervised Multitask Learners<i class="fa fa-external-link-alt"></i></span> | 2019-02 |</p>
<p>|  | GPT-3 | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzIwMDUuMTQxNjU=">Language Models are Few-Shot Learners<i class="fa fa-external-link-alt"></i></span> | 2020-07-22 |</p>
<p>|  | InstructGPT | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIyMDMuMDIxNTUucGRm">Training language models to follow instructions with human feedback<i class="fa fa-external-link-alt"></i></span> | 2022-03-04 |</p>
<p>|  | GPT-4 | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIzMDMuMDg3NzQ=">GPT-4 Technical Report<i class="fa fa-external-link-alt"></i></span> | 2023-03-27 |</p>
<p>|  | GPT对美国劳动力市场影响研究论文 | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzIzMDMuMTAxMzA=">[2303.10130] GPTs are GPTs: An Early Look at the Labor Market Impact Potential of Large Language Models (arxiv.org)<i class="fa fa-external-link-alt"></i></span> | 2023-03-23 |</p>
<p>|  | 语言模型可以解释语言模型中的神经元 | <span class="exturl" data-url="aHR0cHM6Ly9vcGVuYWlwdWJsaWMuYmxvYi5jb3JlLndpbmRvd3MubmV0L25ldXJvbi1leHBsYWluZXIvcGFwZXIvaW5kZXguaHRtbA==">Language models can explain neurons in language models (windows.net)<i class="fa fa-external-link-alt"></i></span> | 2023-05-09 |</p>
<p>| 开源GPT替代模型 | BLOOM：1760亿参数的仅解码器Transformer语言模型 | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIyMTEuMDUxMDA=">BLOOM: A 176B-Parameter Open-Access Multilingual Language Model<i class="fa fa-external-link-alt"></i></span> | 2023-03-13 |</p>
<p>|  | 开放预训练Transformer语言模型 | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIyMDUuMDEwNjg=">OPT: Open Pre-trained Transformer Language Models<i class="fa fa-external-link-alt"></i></span> | 2022-06-21 |</p>
<p>| Chain of Thought | Chain of Thought论文 | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIyMDEuMTE5MDM=">Chain-of-Thought Prompting Elicits Reasoning in Large Language Models<i class="fa fa-external-link-alt"></i></span> | 2023-01-10 |</p>
<p>|  | 语言模型中的多模态思维链推理 | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIzMDIuMDA5MjM=">Multimodal Chain-of-Thought Reasoning in Language Models<i class="fa fa-external-link-alt"></i></span> | 2023-02-16 |</p>
<p>| ViLT | ViLT论文 | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIxMDIuMDMzMzQ=">ViLT: Vision-and-Language Transformer Without Convolution or Region Supervision<i class="fa fa-external-link-alt"></i></span> | 2021-06-10 |</p>
<p>| HELM | HELM全面语言模型评测论文 | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIyMTEuMDkxMTA=">Holistic Evaluation of Language Models<i class="fa fa-external-link-alt"></i></span> | 2022-11-16 |</p>
<p>| GPT模型分析 | 复旦大学GPT模型对比分析 | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIzMDMuMTA0MjA=">A Comprehensive Capability Analysis of GPT-3 and GPT-3.5 Series Models<i class="fa fa-external-link-alt"></i></span> | 2023-03-18 |</p>
<p>|  | 微软研究院GPT-4早期实验 | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIzMDMuMTI3MTI=">Sparks of Artificial General Intelligence: Early experiments with GPT-4<i class="fa fa-external-link-alt"></i></span> | 2023-03-27 |</p>
<p>|  | AIGC完整调查，ChatGPT从GPT-4到GPT-5是你所需要的全部吗？ | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIzMDMuMTE3MTc=">A Complete Survey on Generative AI (AIGC): Is ChatGPT from GPT-4 to GPT-5 All You Need?<i class="fa fa-external-link-alt"></i></span> | 2023-03-21 |</p>
<p>| Anthropic | Anthropic LLM论文 | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIyMDQuMDU4NjI=">Training a Helpful and Harmless Assistant with Reinforcement Learning from Human Feedback<i class="fa fa-external-link-alt"></i></span> | 2022-04-12 |</p>
<p>| LaMda | LaMda模型论文 | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzIyMDEuMDgyMzk=">LaMDA: Language Models for Dialog Applications<i class="fa fa-external-link-alt"></i></span> | 2022-02-10 |</p>
<p>| GLM | GLM论文 | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIxMDMuMTAzNjA=">GLM: General Language Model Pretraining with Autoregressive Blank Infilling<i class="fa fa-external-link-alt"></i></span> | 2022-03-17 |</p>
<p>|  | GLM-130B | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIyMTAuMDI0MTQ=">GLM-130B: An Open Bilingual Pre-trained Model<i class="fa fa-external-link-alt"></i></span> | 2022-10-05 |</p>
<p>| Toolformer | Toolformer模型论文 | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIzMDIuMDQ3NjE=">Toolformer: Language Models Can Teach Themselves to Use Tools<i class="fa fa-external-link-alt"></i></span> | 2023-02-09 |</p>
<p>| GPT-4应用分析 | GPT-4在医学挑战问题上的能力 | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIzMDMuMTMzNzU=">Capabilities of GPT-4 on Medical Challenge Problems<i class="fa fa-external-link-alt"></i></span> | 2023-03-20 |</p>
<p>|  | 人工缪斯：生成式人工智能聊天机器人已经达到了与人类相当的创造力水平 | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIzMDMuMTIwMDM=">Artificial muses: Generative Artificial Intelligence Chatbots Have Risen to Human-Level Creativity<i class="fa fa-external-link-alt"></i></span> | 2023-03-21 |</p>
<p>|  | 心灵与机器相遇：揭开GPT-4的认知心理学 | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIzMDMuMTE0MzY=">Mind meets machine: Unravelling GPT-4’s cognitive psychology<i class="fa fa-external-link-alt"></i></span> | 2023-03-20 |</p>
<p>| CodeGeeX | CodeGeeX，一个具有130亿参数的多语言代码生成模型。截至2022年6月，CodeGeeX已经在23种编程语言的8500亿个标记上进行了预训练。广泛的实验表明，在HumanEval-X上，CodeGeeX在代码生成和翻译任务方面都优于规模相似的多语言代码模型。 | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIzMDMuMTc1Njg=">CodeGeeX: A Pre-Trained Model for Code Generation with Multilingual Evaluations on HumanEval-X<i class="fa fa-external-link-alt"></i></span> | 2023-03-30 |</p>
<p>| BloombergGPT | 基于广泛的金融数据进行训练的500亿参数语言模型，拥有一个3630亿令牌数据集，基于彭博社广泛的数据来源，可能是迄今为止最大规模的特定领域数据集，并增加了来自通用目标数据集的3450亿令牌。通过标准LLM基准测试、开放式金融基准测试以及一套最能反映彭博社预期使用方式的内部基准测试验证了BloombergGPT。通过混合数据集训练得到了一个性能优异且不损失通用LLM基准表现水平但在金融任务上超越现有模型很多倍的模型。 | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIzMDMuMTc1NjQ=">BloombergGPT: A Large Language Model for Finance<i class="fa fa-external-link-alt"></i></span> | 2023-03-30 |</p>
<p>| HuggingGPT | HuggingGPT是一个协作系统，由LLM作为控制器和许多专家模型作为协作执行者（来自HuggingFace Hub）组成。系统工作流程包括四个阶段：</p>
<ol>
<li></li>
</ol>
<p>任务规划：使用ChatGPT分析用户请求以理解其意图，并将其分解为可能可解决的任务。</p>
<ol start="2">
<li></li>
</ol>
<p>模型选择：为了解决计划中的任务，ChatGPT基于它们的描述选择托管在Hugging Face上的专家模型。</p>
<ol start="3">
<li></li>
</ol>
<p>任务执行：调用并执行每个选定的模型，并将结果返回给ChatGPT。</p>
<ol start="4">
<li></li>
</ol>
<p>响应生成：最后，使用ChatGPT集成所有模型的预测，并生成响应。 | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIzMDMuMTc1ODAucGRm">HuggingGPT: Solving AI Tasks with ChatGPT and its Friends in Hugging Face<i class="fa fa-external-link-alt"></i></span> | 2023-04-01 |</p>
<p>| ImageBind | 一种学习跨越六种不同模态的联合嵌入的方法——图像、文本、音频、深度、热和IMU数据。ImageBind可以利用最近大规模视觉语言模型，并通过使用它们与图像自然匹配来扩展其零样本能力到新的模态上。 | <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIzMDUuMDU2NjU=">https://arxiv.org/pdf/2305.05665<i class="fa fa-external-link-alt"></i></span> | 2023-05-09 |</p>
<h2 id="OpenAI参考资料集锦"><a href="#OpenAI参考资料集锦" class="headerlink" title="OpenAI参考资料集锦"></a>OpenAI参考资料集锦</h2><p>| <strong>功能</strong> | <strong>地址</strong> |</p>
<p>| — | — |</p>
<p>| OpenAI 官方Prompt调试 | <span class="exturl" data-url="aHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL3BsYXlncm91bmQ/bW9kZT1jaGF0">https://platform.openai.com/playground?mode=chat<i class="fa fa-external-link-alt"></i></span> |</p>
<p>| OpenAI 官方文档 | <span class="exturl" data-url="aHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvaW50cm9kdWN0aW9u">https://platform.openai.com/docs/introduction<i class="fa fa-external-link-alt"></i></span> |</p>
<p>| OpenAI API文档 | <span class="exturl" data-url="aHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvYXBpLXJlZmVyZW5jZQ==">https://platform.openai.com/docs/api-reference<i class="fa fa-external-link-alt"></i></span> |</p>
<p>| OpenAI 官方Prompts示例 | <span class="exturl" data-url="aHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2V4YW1wbGVz">https://platform.openai.com/examples<i class="fa fa-external-link-alt"></i></span> |</p>
<p>| OpenAI 官方论文合集 | <span class="exturl" data-url="aHR0cHM6Ly9vcGVuYWkuY29tL3Jlc2VhcmNo">https://openai.com/research<i class="fa fa-external-link-alt"></i></span> |</p>
<p>| OpenAI 产品介绍 | <span class="exturl" data-url="aHR0cHM6Ly9vcGVuYWkuY29tL3Byb2R1Y3Q=">https://openai.com/product<i class="fa fa-external-link-alt"></i></span> |</p>
<p>| OpenAI 模型使用价格说明 | <span class="exturl" data-url="aHR0cHM6Ly9vcGVuYWkuY29tL3ByaWNpbmc=">https://openai.com/pricing<i class="fa fa-external-link-alt"></i></span> |</p>
<p>| OpenAI 插件API说明 | <span class="exturl" data-url="aHR0cHM6Ly9wbGF0Zm9ybS5vcGVuYWkuY29tL2RvY3MvcGx1Z2lucy9pbnRyb2R1Y3Rpb24=">https://platform.openai.com/docs/plugins/introduction<i class="fa fa-external-link-alt"></i></span> |</p>
<h2 id="ChatGPT相关Github项目"><a href="#ChatGPT相关Github项目" class="headerlink" title="ChatGPT相关Github项目"></a>ChatGPT相关Github项目</h2><h3 id="类ChatGPT模型相关Github项目"><a href="#类ChatGPT模型相关Github项目" class="headerlink" title="类ChatGPT模型相关Github项目"></a>类ChatGPT模型相关Github项目</h3><p>| <strong>模型名称</strong> | <strong>简介</strong> | <strong>项目地址</strong> | <strong>发布时间</strong> |</p>
<p>| — | — | — | — |</p>
<p>| GLM | 清华知识工程和数据挖掘组开源的一个通用语言模型，使用自回归填空目标进行预训练，并可以在各种自然语言理解和生成任务上进行微调。 | <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1RIVURNL0dMTQ==">https://github.com/THUDM/GLM<i class="fa fa-external-link-alt"></i></span> | 2022-03-17 |</p>
<p>| GLM-130B | 清华知识工程和数据挖掘组开源的一个开放的双语（英文和中文）双向稠密模型，具有1300亿个参数，使用通用语言模型（GLM）算法进行预训练。 | <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1RIVURNL0dMTS0xMzBC">https://github.com/THUDM/GLM-130B<i class="fa fa-external-link-alt"></i></span> | 2022-10-05 |</p>
<p>| ChatGLM-6B | 清华知识工程和数据挖掘组开源的、支持中英双语的对话语言模型，基于 General Language Model (GLM) 架构，具有 62 亿参数。结合模型量化技术，用户可以在消费级的显卡上进行本地部署（INT4 量化级别下最低只需 6GB 显存）。 | <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1RIVURNL0NoYXRHTE0tNkI=">https://github.com/THUDM/ChatGLM-6B<i class="fa fa-external-link-alt"></i></span> | 2023-03 |</p>
<p>| LLaMA | Facebook开源的用于加载LLaMA（arXiv）模型并运行推理的代码。 | <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rcmVzZWFyY2gvbGxhbWE=">https://github.com/facebookresearch/llama<i class="fa fa-external-link-alt"></i></span> | 2023-02 |</p>
<p>| Alpaca | 斯坦福开源的Alpaca 7B模型，一个在52K个指令跟随演示中从LLaMA 7B模型微调而来的模型。在对单轮指令跟随的初步评估中，Alpaca表现出与OpenAI的text-davinci-003相似的定性特征，同时其体积小、易于复制且成本低廉。 | <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RhdHN1LWxhYi9zdGFuZm9yZF9hbHBhY2E=">https://github.com/tatsu-lab/stanford_alpaca<i class="fa fa-external-link-alt"></i></span> | 2023-03-13 |</p>
<p>| OpenAI Evals | OpenAI开源的ChatGPT相关模型的评测工具 | <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9ldmFscw==">https://github.com/openai/evals<i class="fa fa-external-link-alt"></i></span> | 2023-03 |</p>
<p>| Visual ChatGPT | 微软开源的视觉ChatGPT，连接了ChatGPT和一系列视觉基础模型，使得在聊天过程中可以发送和接收图片。 | <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC92aXN1YWwtY2hhdGdwdA==">GitHub - microsoft&#x2F;visual-chatgpt: Official repo for the paper: Visual ChatGPT: Talking, Drawing and Editing with Visual Foundation Models<i class="fa fa-external-link-alt"></i></span> | 2023-03-08 |</p>
<p>| Dolly | Databricks的Dolly是一个大型语言模型，它在Databricks机器学习平台上进行了训练。研究表明，当这个两年前的开源模型（GPT-J）仅经过30分钟的精细调整，并针对50,000条记录（斯坦福Alpaca）进行专注语料库训练时，其展现出惊人高质量的指令跟随行为，而这种行为并不是基于该模型构建的基础模型所具有的特征。我们认为这一发现非常重要，因为它证明了创造强大人工智能技术的能力比以前意识到的要容易得多。 | <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RhdGFicmlja3NsYWJzL2RvbGx5">https://github.com/databrickslabs/dolly<i class="fa fa-external-link-alt"></i></span> | 2023-03-24 |</p>
<p>| gpt4all | gpt4all：一个聊天机器人，它是在包括代码、故事和对话等大量干净的助手数据集上进行训练的。 | <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25vbWljLWFpL2dwdDRhbGw=">https://github.com/nomic-ai/gpt4all<i class="fa fa-external-link-alt"></i></span> | 2023-03 |</p>
<p>| CodeGeeX | CodeGeeX是一个具有130亿参数的多编程语言代码生成预训练模型。CodeGeeX采用华为MindSpore框架实现，在鹏城实验室“鹏城云脑II”中的192个节点（共1536个国产昇腾910 AI处理器）上训练而成。截至2022年6月22日，CodeGeeX历时两个月在20多种编程语言的代码语料库（&gt;8500亿Token）上预训练得到。CodeGeeX有以下特点：</p>
<p>●</p>
<p>高精度代码生成：支持生成Python、C++、Java、JavaScript和Go等多种主流编程语言的代码，在HumanEval-X代码生成任务上取得47%~60%求解率，较其他开源基线模型有更佳的平均性能。</p>
<p>●</p>
<p>跨语言代码翻译：支持代码片段在不同编程语言间进行自动翻译转换，翻译结果正确率高，在HumanEval-X代码翻译任务上超越了其它基线模型。</p>
<p>●</p>
<p>自动编程插件：CodeGeeX插件现已上架VSCode插件市场（完全免费），用户可以通过其强大的少样本生成能力，自定义代码生成风格和能力，更好辅助代码编写。</p>
<p>●</p>
<p>模型跨平台开源: 所有代码和模型权重开源开放，用作研究用途。CodeGeeX同时支持昇腾和英伟达平台，可在单张昇腾910或英伟达V100&#x2F;A100上实现推理。 | <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1RIVURNL0NvZGVHZWVY">https://github.com/THUDM/CodeGeeX<i class="fa fa-external-link-alt"></i></span> | 2023-03-30 |</p>
<p>| LMFlow | 一个可扩展、方便和高效的工具箱，用于微调大型机器学习模型，旨在用户友好、快速可靠，并且对整个社区开放。 | <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL09wdGltYWxTY2FsZS9MTUZsb3c=">https://github.com/OptimalScale/LMFlow<i class="fa fa-external-link-alt"></i></span> | 2023-04-02 |</p>
<p>| DeepSpeed-Chat | DeepSpeed Chat: 一键式RLHF训练，可以让类ChatGPT千亿大模型提速省钱15倍 | <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9EZWVwU3BlZWQvdHJlZS9tYXN0ZXIvYmxvZ3MvZGVlcHNwZWVkLWNoYXQvY2hpbmVzZQ==">https://github.com/microsoft/DeepSpeed/tree/master/blogs/deepspeed-chat/chinese<i class="fa fa-external-link-alt"></i></span> | 2023-04-12 |</p>
<p>| AutoGPT | Auto-GPT是一个实验性的开源应用程序，展示了GPT-4语言模型的能力。这个程序由GPT-4驱动，将LLM“思想”链接在一起，以自主地实现您设定的任何目标。作为GPT-4完全自主运行的首批示例之一，Auto-GPT推动了人工智能可能性的界限。 | <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1RvcmFudHVsaW5vL0F1dG8tR1BU">https://github.com/Torantulino/Auto-GPT<i class="fa fa-external-link-alt"></i></span> | 2023-04-12 |</p>
<p>| MiniGPT-4 | MiniGPT-4：使用先进的大型语言模型增强视觉语言理解 | <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Zpc2lvbi1DQUlSL01pbmlHUFQtNA==">https://github.com/Vision-CAIR/MiniGPT-4<i class="fa fa-external-link-alt"></i></span> | 2023-04-17 |</p>
<p>| StableLM | Stability AI发布了一个新的开源语言模型——StableLM。该模型的Alpha版本可用于30亿和70亿个参数，随后还将推出150亿到650亿个参数的模型。 | <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1N0YWJpbGl0eS1BSS9TdGFibGVMTQ==">https://github.com/Stability-AI/StableLM<i class="fa fa-external-link-alt"></i></span> | 2023-04-19 |</p>
<p>| ImageBind | ImageBind学习了六种不同模态的联合嵌入——图像、文本、音频、深度、热成像和IMU数据。它使得新颖的应用程序“开箱即用”，包括跨模态检索，使用算术组合模态，跨模态检测和生成等。 | <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rcmVzZWFyY2gvSW1hZ2VCaW5k">https://github.com/facebookresearch/ImageBind<i class="fa fa-external-link-alt"></i></span> | 2023-05-09 |</p>
<h3 id="ChatGPT产品相关Github项目"><a href="#ChatGPT产品相关Github项目" class="headerlink" title="ChatGPT产品相关Github项目"></a>ChatGPT产品相关Github项目</h3><p>| <strong>产品名称</strong> | <strong>简介</strong> | <strong>项目地址</strong> |</p>
<p>| — | — | — |</p>
<p>| OpenAI-translator | 基于 ChatGPT API 的划词翻译浏览器插件和跨平台桌面端应用 | <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lldG9uZS9vcGVuYWktdHJhbnNsYXRvcg==">https://github.com/yetone/openai-translator<i class="fa fa-external-link-alt"></i></span> |</p>
<p>| sql-translator | 一款基于人工智能的可以将自然语言转换为SQL的开源项目。 | <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dob2lza2F0cmluL3NxbC10cmFuc2xhdG9y">https://github.com/whoiskatrin/sql-translator<i class="fa fa-external-link-alt"></i></span> |</p>
<p>| ChatGPT | 一款封装了ChatGPT网页的桌面版ChatGPT应用。 | <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xlbmN4L0NoYXRHUFQ=">https://github.com/lencx/ChatGPT<i class="fa fa-external-link-alt"></i></span> |</p>
<p>| Chatgpt-web | 一款基于Express 和 Vue3 搭建的 ChatGPT 演示网页，可自定义配置OpenAI的API-key来搭建自己的私人ChatGPT。 | <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NoYW56aGFveXUvY2hhdGdwdC13ZWI=">https://github.com/Chanzhaoyu/chatgpt-web<i class="fa fa-external-link-alt"></i></span> |</p>
<p>| Chatbox | 跨平台桌面应用程序，用于ChatGPT API（OpenAI API），同时也是一个Prompts调试和管理工具。 | <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Jpbi1IdWFuZy9jaGF0Ym94">GitHub - Bin-Huang&#x2F;chatbox: A cross-platform desktop application for ChatGPT API (OpenAI API), also a prompt debugging and management tool.<i class="fa fa-external-link-alt"></i></span> |</p>
<h2 id="ChatGPT相关投研报告"><a href="#ChatGPT相关投研报告" class="headerlink" title="ChatGPT相关投研报告"></a>ChatGPT相关投研报告</h2><p>| <strong>机构名称</strong> | <strong>报告题目</strong> | <strong>报告地址</strong> | <strong>发表时间</strong> |</p>
<p>| — | — | — | — |</p>
<p>| 国泰君安 | ChatGPT研究框架 | <span class="exturl" data-url="aHR0cDovL3d3dy5ldmluY2hpbmEuY29tL3VwbG9hZGZpbGUvZmlsZS8yMDIzMDMxNS8yMDIzMDMxNTA5NDAyNDA3NTM5LnBkZg==">http://www.evinchina.com/uploadfile/file/20230315/2023031509402407539.pdf<i class="fa fa-external-link-alt"></i></span> | 2023-03-15 |</p>
<p>| 华福证券 | AIGC&amp;ChatGPT发展报告 | <span class="exturl" data-url="aHR0cHM6Ly9maWxlLmRpZ2l0YWxpbmcuY29tL2VJbWcvdWltYWdlcy8yMDIzMDMxNS8xNjc4ODUwODkxMzg0MjIxLnBkZg==">https://file.digitaling.com/eImg/uimages/20230315/1678850891384221.pdf<i class="fa fa-external-link-alt"></i></span> | 2023-03-15 |</p>
<p>| 民生证券 | ChatGPT在金融应用前景 | <span class="exturl" data-url="aHR0cHM6Ly9wZGYuZGZjZncuY29tL3BkZi9IM19BUDIwMjMwMjE0MTU4MzEzMDkxMl8xLnBkZj8xNjc2MzgwOTYxMDAwLnBkZg==">https://pdf.dfcfw.com/pdf/H3_AP202302141583130912_1.pdf?1676380961000.pdf<i class="fa fa-external-link-alt"></i></span> | 2023-02-14 |</p>
<p>| 民生证券 | ChatGPT 系列报告：为人形机器人注入“灵魂 | <span class="exturl" data-url="aHR0cHM6Ly9maWxlLml5YW5iYW8uY29tL3BkZi84YmE2ZC1hZTAwNzk5Zi01OGE3LTRlZDEtOWFlYi1kOTk2ZjliMTI5YzIucGRm">https://file.iyanbao.com/pdf/8ba6d-ae00799f-58a7-4ed1-9aeb-d996f9b129c2.pdf<i class="fa fa-external-link-alt"></i></span> | 2023-02-14 |</p>
<p>| 德邦证券 | ChatGPT 热度加速 AI 算力投资，光通信产业链或将持续受益 | <span class="exturl" data-url="aHR0cHM6Ly9wZGYuZGZjZncuY29tL3BkZi9IM19BUDIwMjMwMjEwMTU4Mjk5MjE2M18xLnBkZj8xNjc2MDI1ODIyMDAwLnBkZg==">https://pdf.dfcfw.com/pdf/H3_AP202302101582992163_1.pdf?1676025822000.pdf<i class="fa fa-external-link-alt"></i></span> | 2023-02-10 |</p>
<p>| 招银国际 | ChatGPT 跨行业专题报告 | <span class="exturl" data-url="aHR0cDovL3BnLmpyai5jb20uY24vYWNjL1Jlcy9DTl9SRVMvSU5EVVMvMjAyMy8yLzEwL2VjNzEyYWZhLTg5N2ItNGQ3MS05ZjFiLTAyNGIzMjk3ZDRlYS5wZGY=">http://pg.jrj.com.cn/acc/Res/CN_RES&#x2F;INDUS&#x2F;2023&#x2F;2&#x2F;10&#x2F;ec712afa-897b-4d71-9f1b-024b3297d4ea.pdf<i class="fa fa-external-link-alt"></i></span> | 2023-02-10 |</p>
<p>| 银河证券 | ChatGPT 开启 AI 新纪元，AIGC 投资框架梳理 | <span class="exturl" data-url="aHR0cDovL3BnLmpyai5jb20uY24vYWNjL1Jlcy9DTl9SRVMvSU5EVVMvMjAyMy8yLzE3L2YwOWFkYzcxLTkzNmMtNDAyOS1hOGI3LWUyOTAyZGZiYjZlNy5wZGY=">http://pg.jrj.com.cn/acc/Res/CN_RES&#x2F;INDUS&#x2F;2023&#x2F;2&#x2F;17&#x2F;f09adc71-936c-4029-a8b7-e2902dfbb6e7.pdf<i class="fa fa-external-link-alt"></i></span> | 2023-02-17 |</p>
<p>| 浦银国际 | 序幕揭开：ChatGPT 将 AIGC 推向“平民化”时代 | <span class="exturl" data-url="aHR0cDovL3d3dy5zcGRiaS5jb20vZ2V0ZmlsZS9pbmRleC9hY3Rpb24vaW1hZ2VzL25hbWUvNjNlY2JhOTFjMjQ4Zi5wZGY=">http://www.spdbi.com/getfile/index/action/images/name/63ecba91c248f.pdf<i class="fa fa-external-link-alt"></i></span> | 2023-02-14 |</p>
<p>| 长城证券 | ChatGPT 概念发酵，建议关注泛 AI产业链 | <span class="exturl" data-url="aHR0cDovL3d3dy5jZ3dzLmNvbS9jY3pxL2dnZHQvY2N5ai8yMDIzMDIvUDAyMDIzMDIyMjMwODUyNjc3MDE1Ni5wZGY=">http://www.cgws.com/cczq/ggdt/ccyj/202302/P020230222308526770156.pdf<i class="fa fa-external-link-alt"></i></span> | 2023-02-22 |</p>
<p>| 华龙证券 | 当下最成功的 C 端人工智能应用——ChatGTP点评报告 | <span class="exturl" data-url="aHR0cDovL3d3dy5obHpxZ3MuY29tL3VwbG9hZC8yMDIzMDIyMS8yMDIzMDIyMTE2NzY5NjkwNjAzMzAucGRm">http://www.hlzqgs.com/upload/20230221/202302211676969060330.pdf<i class="fa fa-external-link-alt"></i></span> | 2023-02-21 |</p>
<p>| 偉祿亞太證券 | 人工智能:AIGC、ChatGPT | <span class="exturl" data-url="aHR0cHM6Ly93d3cucmVhbG9yZGFwc2VjLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAyMy8wMi8lRTclQTAlOTQlRTclQTklQjYlRTUlQTAlQjElRTUlOTElOEEtQ2hhdEdQVC0lRTQlQkElQkElRTUlQjclQTUlRTYlOTklQkElRTYlODUlQTctU0MucGRm">https://www.realordapsec.com/wp-content/uploads/2023/02/%E7%A0%94%E7%A9%B6%E5%A0%B1%E5%91%8A-ChatGPT-%E4%BA%BA%E5%B7%A5%E6%99%BA%E6%85%A7-SC.pdf<i class="fa fa-external-link-alt"></i></span> | 2023-02-17 |</p>
<h2 id="ChatGPT相关产品"><a href="#ChatGPT相关产品" class="headerlink" title="ChatGPT相关产品"></a>ChatGPT相关产品</h2><h3 id="类ChatGPT产品"><a href="#类ChatGPT产品" class="headerlink" title="类ChatGPT产品"></a>类ChatGPT产品</h3><p>| <strong>产品名称</strong> | <strong>产品介绍</strong> | <strong>官网地址</strong> |</p>
<p>| — | — | — |</p>
<p>| 文心一言 | 百度发布的一款类似于ChatGPT的产品。 | <span class="exturl" data-url="aHR0cHM6Ly95aXlhbi5iYWlkdS5jb20vd2VsY29tZQ==">https://yiyan.baidu.com/welcome<i class="fa fa-external-link-alt"></i></span> |</p>
<p>| New Bing | 微软发布的基于GPT-4的类似于ChatGPT的产品。 | <span class="exturl" data-url="aHR0cHM6Ly93d3cuYmluZy5jb20vbmV3">https://www.bing.com/new<i class="fa fa-external-link-alt"></i></span> |</p>
<p>| 通义千问 | 达摩院发布的一款大语言模型产品 | <span class="exturl" data-url="aHR0cHM6Ly90b25neWkuYWxpeXVuLmNvbS8=">https://tongyi.aliyun.com/<i class="fa fa-external-link-alt"></i></span> |</p>
<p>| open-assistant | 开放助手（简称OA）是一个基于聊天的开源助手。该项目的愿景是创建一个可以在单个高端消费级GPU上运行的大型语言模型。通过一些修改，Open Assistant也应该能够轻松地与其他第三方应用程序进行接口，并从数据库和互联网中检索信息。 | <span class="exturl" data-url="aHR0cHM6Ly9vcGVuLWFzc2lzdGFudC5pby8=">https://open-assistant.io/<i class="fa fa-external-link-alt"></i></span> |</p>
<h3 id="ChatGPT非官方产品"><a href="#ChatGPT非官方产品" class="headerlink" title="ChatGPT非官方产品"></a>ChatGPT非官方产品</h3><p>| <strong>产品名称</strong> | <strong>产品介绍</strong> | <strong>官网地址</strong> |</p>
<p>| — | — | — |</p>
<p>| Poe | 一款集成了ChatGPT、GPT-4、Claude、Claude+、Sage、Dragonfly的聊天机器人hub | <span class="exturl" data-url="aHR0cHM6Ly9wb2UuY29tLw==">https://poe.com/<i class="fa fa-external-link-alt"></i></span> |</p>
<h3 id="类ChatGPT-AI工具"><a href="#类ChatGPT-AI工具" class="headerlink" title="类ChatGPT AI工具"></a>类ChatGPT AI工具</h3><p>| <strong>产品工具名称</strong> | <strong>介绍</strong> | <strong>官网地址</strong> |</p>
<p>| — | — | — |</p>
<p>| BloopAI | 一款使用GPT-4和语义代码搜索来理解代码库的AI软件 | <span class="exturl" data-url="aHR0cHM6Ly9ibG9vcC5haS8=">https://bloop.ai/<i class="fa fa-external-link-alt"></i></span> |</p>
<p>| Cursor | 一款基于GPT-4开发的进行辅助编程的软件。 | <span class="exturl" data-url="aHR0cHM6Ly93d3cuY3Vyc29yLnNvLw==">Cursor &amp;#124; Build Fast<i class="fa fa-external-link-alt"></i></span> |</p>
<p>| OpenL | 一款基于OpenAI的翻译工具网站。支持15种常见语言，另外还提供了writer功能，可修正语法和润色文章。免费用户有20个额度 | <span class="exturl" data-url="aHR0cHM6Ly9vcGVubC5pby8=">https://openl.io<i class="fa fa-external-link-alt"></i></span> |</p>
<p>| Browse AI | 一款预构建的网络爬虫机器人，可以在2分钟内构建机器人，无需写代码，帮你爬取需要的任何资源。 | <span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJvd3NlLmFpLw==">https://www.browse.ai/<i class="fa fa-external-link-alt"></i></span> |</p>
<p>| Hypotenuse AI | 一款基于AI的写作助手。 | <span class="exturl" data-url="aHR0cHM6Ly93d3cuaHlwb3RlbnVzZS5haS8=">https://www.hypotenuse.ai/<i class="fa fa-external-link-alt"></i></span> |</p>
<p>| There’s an ai for that | 一个收集了能完成很多任务的AI工具集合网站。 | <span class="exturl" data-url="aHR0cHM6Ly90aGVyZXNhbmFpZm9ydGhhdC5jb20v">https://theresanaiforthat.com/<i class="fa fa-external-link-alt"></i></span> |</p>
<p>| Durable AI Website Builder | 基于AI在30秒内构建一个网站。 | <span class="exturl" data-url="aHR0cHM6Ly9kdXJhYmxlLmNvL2FpLXdlYnNpdGUtYnVpbGRlcg==">https://durable.co/ai-website-builder<i class="fa fa-external-link-alt"></i></span> |</p>
<p>| Delv AI | 一款基于GPT-3的可以帮助从任何文本中进行总结的工具。 | <span class="exturl" data-url="aHR0cHM6Ly93d3cuZGVsdi5haS8=">https://www.delv.ai/<i class="fa fa-external-link-alt"></i></span> |</p>
<p>| Perplexity AI | 一款旨在于替代Google的人工智能搜索引擎。 | <span class="exturl" data-url="aHR0cHM6Ly93d3cucGVycGxleGl0eS5haS8=">https://www.perplexity.ai/<i class="fa fa-external-link-alt"></i></span> |</p>
<p>| ChatPDF | ChatPDF是与任何PDF快速、简便地聊天的方式，免费且无需登录。 | <span class="exturl" data-url="aHR0cHM6Ly93d3cuY2hhdHBkZi5jb20v">https://www.chatpdf.com/<i class="fa fa-external-link-alt"></i></span> |</p>
<p>| ChatExcel | 通过文字聊天实现Excel的交互控制的AI辅助工具 | <span class="exturl" data-url="aHR0cHM6Ly9jaGF0ZXhjZWwuY29tLw==">https://chatexcel.com/<i class="fa fa-external-link-alt"></i></span> |</p>
<p>| ChatDoc | 一个基于ChatGPT的文件阅读助手，可以快速从PDF中提取、定位和总结信息。 | <span class="exturl" data-url="aHR0cHM6Ly9jaGF0ZG9jLmNvbS8=">ChatDOC - Chat with your documents<i class="fa fa-external-link-alt"></i></span> |</p>
<p>| Humata | 一个基于ChatGPT的文件理解助手 | <span class="exturl" data-url="aHR0cHM6Ly93d3cuaHVtYXRhLmFpLw==">https://www.humata.ai/<i class="fa fa-external-link-alt"></i></span> |</p>
<p>| LLamaChat | LlamaChat允许您与在Mac本地运行的LLaMa、Alpaca和GPT4All模型进行聊天。可直接下载LLama、Alpaca和GPT4All模型后直接进行使用。 | <span class="exturl" data-url="aHR0cHM6Ly9sbGFtYWNoYXQuYXBwLw==">https://llamachat.app/<i class="fa fa-external-link-alt"></i></span> |</p>
<h3 id="多模态产品"><a href="#多模态产品" class="headerlink" title="多模态产品"></a><strong>多模态产品</strong></h3><p>| <strong>产品名称</strong> | <strong>介绍</strong> | <strong>官网地址</strong> |</p>
<p>| — | — | — |</p>
<p>| Midjourney | AI绘画创作工具 | <span class="exturl" data-url="aHR0cHM6Ly93d3cubWlkam91cm5leS5jb20v">https://www.midjourney.com/<i class="fa fa-external-link-alt"></i></span> |</p>
<p>| Stable Diffusion | 一种潜在的文本到图像扩散模型，能够生成逼真的照片，只需输入任何文本即可。它培养了自主创作的自由，产生了令人惊叹的图像，并使数十亿人能够在几秒钟内创造出令人惊叹的艺术作品。 | <span class="exturl" data-url="aHR0cHM6Ly9zdGFibGVkaWZmdXNpb253ZWIuY29tLw==">https://stablediffusionweb.com/<i class="fa fa-external-link-alt"></i></span> |</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>2023</tag>
      </tags>
  </entry>
  <entry>
    <title>在人间做韭菜的那些年(1)--韭菜集团</title>
    <url>/2021/03/13/life/leeklife_0/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码不正确，请重新输入！" data-whm="文章不能被校验, 不过您还是能看看解密后的内容！">
  <script id="hbeData" type="hbeData" data-hmacdigest="9cf8ad653582b4b46de48776bcc6f0bc056d62533f6bfaaf72fee8db3d5ea645">90b802059200f1da98db072b6ecfd077beb0c3f5110a5ecfa2a9ca59ea61c29c4a589c088cb0070de74cea56e51254a52d88489390ff4f7b601f4caa51c18ccd428625b568942d41cbcb61781a091668fd163b7b5cfc4cb1fdcb1ebe1d70409514bd9039ba9381262329a49633a898726c3a605b30a92415b7111abfc45b4232da7c25289e7a602d5f12d03e6ad63c13f9c2b2a6cca0e7de74f9c419d9db1489b373d0dba0902f58c793a4726bc1510f85d3af1c2f774f71d6e17613558c6868d858c04e7c2788c70987bc1937c9f1b26a6ad0a35911fc4e575a7a9b9574a1888301682f985fbf0c24ae6ccf05183262d941d8736a8d77532640a3cd5fcad5806467bf5c4294dc5b869f7887e43a2e813e66870458c909d976db8a7549920cf28b0c274728db392020643dfe5041d200da2766f9383128731c4f4be443652210b4d17b8e05559db9227ac343ec6f3fc641ad0f8ed1b494556fbb64ff1d879fe470204ab7b22742efd02628e927d1a9e827bf9f0864f303f1d2cc2eeba1762a845aef1aaa4c1bf4e1931348fd482caa79756e694d774fd5adc238dda8bc172b2403227372534f4315081ddd1add3c930b166aa9352f5f808f795643635a0d0ee7102dfef9f82591149700105a9d02dd6fb4973361de6bfe8a633c8823395877a41afe283950c1434e08d7989a8cf1a13c53f23e2be214d258fa77e2f6c0b58542ca7ab4e4df53c8cea4dcdf1f52248490bad3073afa7387796e88cf2ff0668018cc507d40c98455a7b7a91284df2159e338882cf7ad69fec27ad24812171b10f5066f67c341a7d6978bf89359d1fefaaa6bc05ec36b7e2a93c4d9e49b7c25ef8c0eeaa3b206cc02b16ea68726c2c24347e91f2cf432d52fdee58ab01adfeb63a6ecf7089f45899ae94664ff9da807346653c298daa13fa2770a5dfb412892349a0cb083173af27d29d59692f45c8343c77bd3033265de8543fe6c24dee2e5373539433e12e56e9fc8f742c0903c166d78c1dd8235cbe18d697a865cbefbeaa1d457d49b52d3161c13bf87520a1beaac209520a128312d95d87858116f5ac2502afbf09529d3b842f8097f43f4b8743ee03be5c8be04f53789dc5ccb63442a269df753c7b3d4dd5a13d4065c7373b42973e640dabccc8bcb0a6fbd6bf26969096d091a0a4fc2a88df8b23a95cb4c9687f42cf4ef3dc85637bd0d721999f5d498b9077a6d243917c001f06111709b2df3ddb96a4f097d62dd95889b0edd8b24a3a6b9a750e09cd3d420df8ef31a07060fa383ca676894231f8148f2643b8544a7ae78b181798b070d04e15f508fe621d8ae1189a8386cbd96512ebba5a52841de5881be49f8a527d7e3942297d2353464ce66a58d4decb5af457287d0cc992810727ab7fee5e6b56207fd86f8fc62bcca8f7f6f58101f51af7fcc8c8dad3bfa5d0625094d7127b285cf6e5ee33a160b53b8bcceab11f155edcfd29ce7119713cf1e8009ff3350a2a43ad219fb04886ba093a59aefb7b16b77ec9bd73a19503e936066a0fe6e5419a3f434f1fde3e845540f89bda85ffb00664048036924f72b610d80bb3591aa6360c26d1da138e6852bb370914809626fcb7ff00ead2c83062fc401a2875ea175c5b313f5d7e7e906547f7a8f8e0754779ddc55b24a8c2c784302367f8e6554565d6b4f75b263d3252dfdc825ed85571e2761411ba7ef7febb20bd9978d4aaf5d0b7b27ef78acd193bc38fabdabcd5e65c28834c04768658ba193b7cc70c33943f0884b37883e47aae5d5fa13897a1bd8ac5475b08bcc708a5c80e30bc73526bb6614ebef9cf71105fb995656abc883790ebcb3656d5a40e43ca6e93f6c4bdf9326714bcc2b02de5044ab047a646eba1d82e5a2368e41cfed04986fa8805ac8a7f51684288ec76b8f202b68e506d87821c515a06686b0f2ebbd7e46ca187b5a8ca0d2bd757d180e4914b595fe019bc0678c1414548ceff356c7cec1cdfc5f78d7dfd0d7a1781ac2ffaf541ddf191cd2eef2a2722a704643f895a55bf5d9b5d8532378abefde66a9199f7b465b6e015c998cfc1e734e0f445ed2f477b3f47558e7a6609f60878540cd18ece01ff124047052f707a872a4edaece05bda9be0a3993fd20c12040a49df95f402223be5ecdafd752465ebcc38c8d765dabd45e104a3395c05e65570eaba8b76efe614ed247ef1a74ef61f6d7de325230b503a152d5d7e6796f2370b825df51ef340aae47b9e8058deb648d7fd7d02f8080e09e53ead40b324e7c70a93c5e82fcf419986e979f7fca3629858c24f46fec06b766c673d9fa0c513ff33709f88aa8f819de53c7269ed085ee9e79b1401c6a6d920362ca817f46386d241527a50c2c30da3e7669e67c8af4e791b6d44b75de390f4507901f853e949cf413ae4c3a6ce1c6011d93e8b29dbc16df31559b1c4d863d32a7dab8cb354a910af738078403fb119adcc2c147e73cf951d213019f4b7b394d542378998b21a78695e4197190124bc81f0410ef43a3c9c7b54e5a5c993f1640b5b0f5cdea6137fa0aed553f5b558f9e846665158fbe6bf4b6b2dce94f4440c6b17d13e7e82cfb27270c83c2e21b59539a02c4fffb7be47cb0c01beb6471ad647d07f98b00806106db1fd6ce8e16927c99431253c09fa61cfb497b57df7eaa3b780e07d9f4446b4f7defb0122b0ffb44290efff6e87ac65612af465939964c4181a1394acda8397cbc57f9141b451af5e2cd1b69890a2614dc42bf9303a05ef017fa5e3da0619d894f302a0448141f84a5b2007bb13e9dbacca4fb24ac9750798162eb6b6c4bc2bfa8196aed4726da899466ff6bbe347d6ca9060d1f99d353b8cd37799f8cd84dac01eba7b8e1377dffb669129957045216533ca728fd7f6ede7bd9e1df50bcea3e792490d4349da9797f0eb9643727f89e4725e10309a53ef2db1e48e35cfa342c838b966a6695181c3db90570f5b74d4d6190471215c6357a1a704f7e05a09410247cb4c6973d85688d0fc02f8aec45386de7749b514ce94d466218daedaa3519f8cf601f1fd3d7b01643885e2485578a8ad0f5874ff42294502b624ffe58f25d92ce7768e523ab0d6903c06116d962766d95005daa0dc445a0c080f00c2fafd16b4f73c42790b985bbbdc0255839f27733e75bb599b5431e53805a11efbd3297511b0f891ff44edcba48492c53a8e337202919a1fa6c8745d5639d5b08d895cebfc8e988fc8633393386e24d667eaa2aff993fb69073c449f2e06792f93407273cd332cd83f26cca726641ab51527c00c76e44bcedede0248e16e97fde2e9e1113e56e9fd0e387ebab78381349e5195f408e4d440893cc05b626aa5507fe9490d8d5a4aed3fe2cc663521f60ba8615c1a1da3767720c20f021c15d902c2086294f4cd26e163a76e39bf835679f256c1f8bf5b10a0f531dac53b599df5630cce388cc7ad46d6fbe81c680ee322c8a9a4b02b44dbba977af461f2a2549287cf246f0a3c5bae04d9708331c911a104c4bb9805056c121ee9076786ada6643d760275abbf95e030707164cedd0d11d9d65b9ffe7851baaa9a706a8c997af78baec0e045e7f804d05e2edcd519ade08cd97fc4de1aec4f09d67b6c7217dacdfed5b5cdc1876657d427ef9af9d4816f82c36c2e951d6236bf2c6d71735caab6a225cef4d74373a164f1e6b33bb5677296f2691d0d9c94ccf60cd53b21a35687eb3dda4b383543c1123b4649fb0695567d3e227ae63a81d621bde46f80a26db55d734ed9096934357e4f0b9098151b4ea98ef4575f7e4fae3380f1eeb785d36ad1254eff190b2713a20e41232fde516d68e26d885ab070b70f93defeba43d9c8ca7344ab6d68faa0acd3d3bff07b9d8cac6460fe6a2bfb9490d6f9f62dec792c799a4b4245aa66574edd527c329f5589bc84173d26ba3c71b800e2ae46b66099c40d266f2ee7d46b3446dd72599c71e00cc38628a5824c3ed54a9b9f3ff2be533a74ef2b6a0b5aee27c5b89b294fc3de9a7db8e04a0f61def973d970992bce990186e0a8eff147e33dac8ad3fb65e7815374d2311a8ed4152596b551a7a566e32bf376b9bcaf37365d0bf6de5b9d8bbf68cc87922378fac5037034b3c8eda60e365e47a3c1a46812a8bf6c33afdb368d4c670f76aae47944a851748f6fd7b72b6c141b5fc89afbff1466be88f658dd25a79639eaa0b779daf0165611df8c0e88abbff7fd7e94e4a8b8fa6d9698b5e53865a677cc859089d0589b43a5fb2bb675491527aeeada5db96ceec9e5f518a706926c9f0b30f46370397d6702d06e032d4db7a76a6349dfe5ad61eb38aff6820ef28bc9512bca74c83104e563357174bc8d3defb673650b7e70e66bb661a5a26136ed4ce936dcc6af93d65363c7cc2e66732a1eb958bf3e61762c4e301cf70d925ac7266afac2422f760a1fc8fe497437e18d7f26641b0cbf09d001294cacc7c16650b9ebd913ae91025c1a8ce78883e48e6de11a51dcbf0e70701a5e566feb722fde773dbe10cc71dca36441b1092243afb60f9e71753533cca379c89e57f533b416f147e4d2944857a4bd00b57dec522bb77c1ce806bb7deaad66bf435acbbf1a38141ae47b831f1d8b79e84299e86c6f876eedc76fea69b645c94ff856f3cb8b199280f7c649bea847a9cfb5776396a77159026dfea51a23c54ddf7759d229bef7b2bb791d144a5c96b3cb2d3491981abff4131425c9db093bf3126477cb4424b6cc7d7a5ecc02d8bad8cb1071fbc46e9ccdb05a852ab071e0dfbcfc5d7656bb15f8b683605d26135bdd8e92b1cf140c02df2d40e5abf649dc3715820b4855bebbb3e803b0073d0365452285b892d73f101df079bc97b724f6160d8b6764f09ee5930e378c270b1c831f617ee1995067cd01ccc74cbf03b5ef2d5933b8d062185234e4be2ddee32c37e5fa4dc56cb62eb10e5030cbad3d147808660515c669171720bc80ab9e8307065551e3e4b4beac35b69a0b77600f6a9fe77d5eab92cdcb984bb06fac162f0c68453b6bf15d47833c1a3f0c0b3d903e98a4e1b2bafc363acc1e51d1d5e2cf72411141e7c8b6b1b25b72296c1cb3c2dfbf34074a118bca37876d3784b103d130f14e707e480851e72e76cb76af71ee7fffa28f6e8d8239043db6f841650f4cbe042dd62d5db81534ed11b846d13ea7acdb8b10ed26a923ddfe9e4a74b653c2a2b6e01b763885a56c9f99b999201f5e712967cc630507a3154125e43d9cee1a00205d86f76937dda95e2a3aa9fae8e7d54ce3a0174e03111d8331f032b02c8badbc68c1e75a8fdb43a13ac90b014e77f9ffbd99fe134a2fae49f86e3f22fc751a946eea09955695eb37fca53d4acf7f1e6f311847bd1afed8236d83d7e662d7447e3b3df8cefbc44a711875b15972a0ea9ca651a33953b2fa84b74d992d6dab2a215a0fa53f264cc6440bc6b99aade95c9cd90b217ee1647540d6ac2f5b8afeea9a003ad43b6756b2b75fd512f3b43aac642f46bcaafd1424b8364d4cc4b8f87ed0cc2a0a2a853e4a4f77c8290e179233a92d389a043d8219aa54866a428b0a82b71ecb0ed8e5ce73c5837860645c42e432d6939e73ed0ecc3f2670c9bc717c0169d9a191def0bd0659b2f4929de56a835594567e9b299c91c11ab4dc6fac1294b9d69e3bfdcdef8c736c7b710561a35736a122d4fbb6e288d5498dd876eb387c30596d0fe415467014d75646b61f15f5654e6e28d60ada7fce5720f8ab50d88737ea0a5fba4c1ff786daefb1720e149719da21587e60da093405eaca4fbb6980d5119cc4918a144544d98b5096aea04c5b9b05cc6a885c701372913cbef0a4515f7293fc0f892ca79fed6ae197a6ba88c29a535cc25bf0ecc19904dea26142628d30953e3f4696108840b5d530a56d20594ecca99000a3cac7cb98a1e3adfcb5b0e7ae0ef19d76a70a2d8dee13e2a25be7167326fa1a66dffcdf727d3ea5871e72a8a97d2a956ab14e1a74b588f021b014c36e5b9809c9430c6b4df90286545fd59e38d0cafe73669face6722d80304a17d86c6ecea18e4d9e52d83e5b12cd7794b23fac15d2aa5031d440f4f90a5800de8ebb0a793aa47a4caa2a0661fe4ebb7911680fdd5563c9b6a60e60e04f6a22d3b23f4ef2c24f7039b1eca8d6079973b5e9c67da2b8c4e682bed27c3e6bfeedfc3e2315561dd9e4d03a047ecb43254e136ae5fc3abfc28200328372dc58a154912c7a65258ca76c7c15f010352414ae14e8b2c18eb8910310a12d3d39f5c661589748b38935adcfec036de3874f2baf283c145192ac3ece32db5df878adb13fdf7e0b2c3e114bb18cb3f2aca01363f5a5d2acdbd20aaba5cb5d9771934051357c4393728a2fe6f7d07f5f34de89231a6ceeaed003e735e301b72d42026d401e9e8f82a053f5b9a2c7c2cb38ff524d55c74ca65413c952270893e8597cc3238c3d48c8d8c6ba96237798de62c69b52a260f1dc2868d2e39205bf846f43609998f192956d2890e8bb2907f1e8bc6a0ce5d57e911cb53c4c9e2ea99d90f8f8fa30459cc81fa99e092f2e44ec0387754c9d0c51fb2d8e0b74915df2a23a8312aa467ac81f464b137dfc96538820a4182f62ce6f6fada2c44aa239a0df06f04c5992fb8cba8516300079ce8acbadf7d4ee81384e49d7e232362e05249491314bf2e6d6cf4c6d68a97239a418bc1250841810fed582e4d73e6533468d384bf0ffca13f47dfeecf6984480fc845e1360ff717657446b03b3dc5d80b01b7fdf12adc5c2cc60bb3f0631d3d2fb77a53b7f96bbb9d0e01d895479d90a4fd252ff77dfcb3f5e61959af24bbc9518924ec2734761c34a37a3f885caab7d77c625061df4c76cd7c5fba2c7d444e02e349c07d5407dd9b0fecbf61630ae9e962280ac814686ae4e337cc44f920e7112e7d25c5b85642f074b7f1d977c2ffcb4baf64b6f26eef34ebd13dde6b5657fba7591bdd1ffe132e016620594d6b288c5b1e5bed62f46f00723c5aefaa97b7b1d4106b76e174ee67df5eda2ca35531163df12c6df6730000994ec6fe1f156aa09f40f1d2e08e45515be9ec2c04edcf8eb46c220e7d0914668aaa721b2e578fad9c5dcd69351dc6448b4fa9986ff4f78ac0cce1220deaef79fabc44d1c20a802dea9d17a28a788cdbab6314ab0253b894d1cb9e5df8b51aea90abbd80feb52747df64b72cbe393161f50eb29fa020774c1b601fade5966aa4e6503c8923e74d0c20f404e0b2467d17d40327aaeb42776fbc762dafe1c6b64c29fa55d6f63e257680c442dabc953d5dbe0cad2bdf640cb6228857890b550c6e6cafbf9602e3f41746f1238cf50db3830f9c31c43e80fa722d07677cf4cbee3d4982729200673b598205d75b92e5c1cd511dd0a99bbbc1a665c7048656ac39b40f778db597a4f53c236b6ecde76c5af97c473a82d5b45a70d1c8fe5dd90e4aa1f72e28e55f4cdfa2a8361a65ffa42776b401fcfea2b47fb9aa2ee12b20b7d85c3058d8c90347bf4c40caada11d0b92cb0dbd2f927344c0747828be6068c9b5133f8e0555638e6e0cededfdb871dfc399aba2805634e16698efde887901d3d061758d2a18c78f2fa7b6c1fb48f96c79b5399fe365103471d6c3f963f585b1824c2ae158fc8bf45da3b225b1707e72e3e884f4c4c54b793787fdfbdb7c40cfee5f0ce6378e9a97ce2299c9cac3a6eae8e50e0ef58c56630505c8056a463628344b739c6b8c66a9cd8129039d4f1262827114061bab9fcc397a71fc3e6255e7a0b4f4ff3af77bc1686f39f30bb41f44ba50ba8fd759d478e35bf5bf9682e7b6c2db4337afa595d8a4fb2e2a469166eb1f5555c07372720123afcf87b201842c0b0e65a359b25c097854c3f0e0d6f3f6ed5017f2bb253cff31784f312f418019948a8e0892d0a108b599abdbacc224170a10efea025aa82a6cf1927644d7d4daf0bf0873051e0368ee7b12d8f3924c309fdee39587baf97dc48d0ed0e143f4f21a5735e3cdfd4670d33971c9c8076312f6c18466192b85737e25ba5394fbe2871c09b391bae07ae510e63f160c1abe0190580d4326ab4bcb5ffda39637f8f7a4a047c8e9bc715ff4341e01cf59d6d8bffee656adf5dfbef71373dc2fe6996c9ecd72b4f0723937e2de63284caec5053f7d7c22e0a74b316bbd3710176c9a8e7c1cb9329ca5ed1a031b3a46d706b8f9490c8b7f6065e146e91a25d2bb835d20be39adc065339159c413a4b92047eae6529af6826569b0ec2ec546b8caeb6bb2693efea15f46b65098e9ae75ca7ae9d5c9b96bc61db24f950c05b99882d2539d9856ffbf66632a01393f783fa9f04e37681c3ac77e01ec5bf535a081c6d204a8358c848d1b29889146e81544f0f1853130b758f412649374e24f9387f7bbd93c8e9a25b058af5b96a33a659acc591b150a4d0a7edf9c2973a0ab8a2283948d49bce450e4daf435aeef4845dc17c97959d7608e2d02bca93507202b186c4d8b6685b636fa0fa982428d9febbe8eb6387969c6b10fa2b68d2a0eb7e975a035ce39b67005319dbc52c87e11157f41c3969eb921308d829be91bca6653be4c0acbfda5132f75ae9a65b5422969cebd03a27f2db4fcedbbe4453a9c7341d8e29513328524d3c4b759bf0d294eb1d2197dc6032ab5299dbd48c54a1cad4ce3a6b1f3d2ee4f1e21afbdf211e3751a7f6b333ced41e191d97e2d2e43ddbf81568d9b330a3a2bb4511e7d825a1f8b8a887b412cd7c02518a106efa8b073b7deb9df8516f9b742c2be51869ce147c9612d1dd2f98ca8cdf812a90de56de3aad227c51a1c20dd01ef3944a3a7c8fce771203510b95f694088d5f04bde25e3aa6c1de3ea5a48daae959925428e0ed13fc7f59e541adbfecef429b48b5cee07e0e2a3adf906c08a7ffb3e8c599c571e94d49b05d95190c151ec6886f888789b441565660cac6665af8b9ca22281311151728154c006faa9a267c83ac1daa53460f15f66d74b1f49b292972471d5a1b5268fe1971690510a3454b4517e765bdd91719be04c03efae50043ba75e46aaedcf6d071dd6073e4c5b6e3c09f0761cd8b6b27462779a0a1963eee005f5c37f196663140511e34569ed967412fa7c2da4991ca95dfc90cf4773e6f6060594e3de2183812e0930895c53dc484e6a4750a76ff388e9451c247e4a17ef23e0a6516eada019bf6d7ed616e28be250a7256541242782f357552a503eff3b113ec58fc233a28e5278b680451cc768aad7789f240cfe21606ffc6951eb21e0dcfa956e8d34b33344cf16a3635464efda3f04be3524932582433ba423483e74e6b18b7efc9d221be533e1e9e8c8c9425a46bf91d079442e92a536c157841de5e1d9c96ea624363598fb79587acd7e35801584c42c0859b848c69308589bc73890497ed46b32e565ca65340f98c06815a1e4d3160f95abd8fdbc6630679022aa17cba75463b02174d4deda22b54266bc76691b45d3a46369781ebc4a254ccc5de466d694e4db5e4689c0841b6307416b71cd448d46a1c8a3e4538d6bac75ba0f161c3d995be1ac21844c58515a10f5fecd1935c1703c99cd48251c4006fdd6e3f9dffd63213f7d88cbaa7bf2882516f67967d8999fe76815fad39f1bbd9394b6cc7fa9faf40abb163b0c1d09ec9e0dd19d5ad4ad6ace236a2d733d2eaf61b273313dc0d964e7b71e2fc9b6829a944c39a7b1b41d6392d70cecda56ef8afe27efd62a80612f02aff420054dbc81d1872cab528d4e398486b635df237eec6914783e6ee54b353c6a002d29f98f8b0e58aa62240b0250f0e51e8161fadd99bb4489263f708c8610775fa655bb8dc1c110f47bf0b4bd8a43b3c7b2a272c7fa854935a53aa57a4bf1508181970f3604128ea50db1c0e41ac2e83a34abec6ff45797d1e4948b6ab8294aab0e75a9c904f3a6cc42af01d2a360c95de7eb9df223db491ef7e841847e096dfbec37b3428e68d6f78ab2777e8b368bc1900e53af2fff2550650f358c0ad8e1e5a7508dbf4e0906d2f589101365801343d45190b926721229beda789c3573d17c0d94a0e65488dea91a7db0990a7eded83a96ada9dcb5743f101da5c7632b315a1dea98a1a473d20cfcce2bcd60f41e0b698d6e4c1d14f844f294efb8ce0db4e96c648420863bab95c2677d61c0f100788628cdf634e700d6e50d031334a058c7a2a2c2855d4473907ed82dae77180f9a281899fbed5cf4e8314042ab68cd5956faea3bf7f387ed2a4917e55049f07e7ab249446cdc5fc496c14aa70fefb20bdfc3c6843bb795638066e6f450c5af8bc6a776525b1fa6b7fd0e2d2e0b8080a923a1f963a9ed0741aac3e7c0b28e7b2e62400afcf44e7ac0ab0b94b5cf620db64b822ab1bf61db48158fe17d1f4809ee5ca68e65d371576df7f82245d663c8946f526b873bd570c3eabd69b8584f714fe8517262e41dfbdd759e39a28fa7ddd7a5d1742d172f0274971acb0c3708997c1416b923c83270d367fc4bb12f04171ee403d9868cc210a7897ed60d5dc09916b3b8f67e716ec2686f95122a9aa45b16b263b750503f76b4911e1a57794c385db5ac333af5903702935f11c9cfc367b544d839dba4a0e3c53b31395690b855a0ab403a0f367b70def5460f7ce58b9a7bc5c08bce32c1fb86ed40dc3429e4c1d3429d1eb5076ed4a4bf58c10bb96ce415bb40034d471224d88b75d342d9f370fc50bd991d7c2c6e8829bf757865d29db28c6db3a3fb08c4b26234a73d13c57326a3b05e541f58bd870527ab7541712fab685623a83091fbf90012597ce696f658177a61fdbe07b0107efd6b0a0400eeac8d75ee7c2757c0281de149e3ba80411d963e5ef075be2cc2473978170c8e0cc8e3e2e148437ac064334bd6c93076f697c4bf313cc527618362d23c36da79c2b9f129981db59d490f5851c99d2a876186bea2333a29615c2173baea87346255e8f135618603a23a8e6aeb4e160d4a3dff40365e74a774fce0d65ad29bbd4c7dcd8f018a7e889e9b7c35752ab51ce475e61f4af1c035ecfd7fe5e77e4daca1c6e179067096616681b30c3df77c8a16fa14da5c434bff3f9764f4883763e8053a5fbab658cb3dfac6584c6aecae62fb453d2a941be2bf3c555ccb5364830c179c6a149f2868b0bb0060ba8ccd361772bc5c592ed7d3e01281e2215d00a8423c25ac5a8c46918010c6a32601be0bc1b43b2bd5ea51817cffafcb31f2ce9ce07111055e7cf86bf32d1b0992b4249c22de64fc787db220efb9941bc83000b02e9be5496b39b78bc2a6adb494e371e7f020f5efe62b0ec500b051f6627b0615f08c76b3ed427384d6c157cac8f5d7a0c1f300c59f84aef5070dab55b77dcfc5dc97898c23d96407bdfd290f5eb540fe213890ae0c4c136628d3008c0afba7614d5060967a4a0137f5a018b2c24975e69d28e0c05d8d61be73a1e1b4cc3d55020d36cb34655e3dde91abd2953fdda6f59b568c0004076229046c3cb5a670beafc7a8b139cf87d6891ea8df97188a5cae31b4488fe06b7a92755037d00cee47ee4b8e1452571064278ee00998d7df57bbbb522c0390cb239a935bbc98f79765789474c7bcfc6d8f45bddf44a39f140bd31ad4144408093778af358a0e662a3b48fdce8c2a7dc92b1cdbcd4daec8162dd2292f4369f2a603a2485aaae77454d1b2ee8185e099a6863492a3c478ec5b9c7d42cf733ee1815dd10ccf71efa23e8b59304e8059e7b28654f2fee26aff45fbcff6404f3e3b3df2998421aab16ccb1f9e582d6934a61695d85ae0ecad6fee6a1bb3509ed26af85ec0b61a3786a63130017d195873adcf129e35c9f68047a9cdd603c5d8f44ae8138de1b917a1732b215be44341509bae4cb74fb6fd2bd744ab0199d6610dbadbd0da0378560d417482997a66f5d0bb43193aa78820ec27263b0efd67076c24a35fb1badd8449cc4cbcb13dde1503d2e1b3e66fc3a01011f5a6bd78fd030335daaaa054a262c323a4f6bbee8339ac6614e3c7a017b0d04f798964eaa8e86dc4567e19b8f956ddf1e578af0ace955da31d0301c887a70c12c1bd57966416d81846eb9b6bf1da588289b008278d5d2b4e0355f55ac9ec53115ebc138c70d5e92613511c09708b9bc6f41929457e8cb2bf8f41749072f2df242fe98e936456a88d681ee2fc654c3f6499dc0fa3a0e464b68540e05a3b8e509da3c7d80f3b706644210d627d8bb5341690904b1ded7134a977bd4bb877dc986e38e3c9b69bf98a2aa463287995b2e3e091d921fb0ef3751ec616be1e950954d20c166db657f1c9f6cc2e1f6ef17f8f3c67091007addd36413084be0da12553077ec879321af1eed790831c4e54608646dc461c6519468c75332e2ee7cc2ad600fa004d16756f956d7f27f9852bf946264a87df1cc4af68db58fb962f1f1e0cc42ebaf2103d4b193f84abb18d8ccac7663c65831b5151b10097a9d393637de1327743c8b4196207fbf01adbecb47f4c584b572f75f3c5ed671558d6fedccc47ccb25bfc4f42d1c607530f04e9416dc582202f562cec1a2529cd08823031ec9113283f872883711ee8860a3775631239f1aa64f8943a76c7e5b04e2056f466c320e4cf52123f68ad88ec48f1c85cee8257086779fe0646b8861833b3bca9e4cb616f178515f4b9b4f590fe657f4476597210902cb9b51f4d812125d25313fe375b0c46ea428ad8c10ff515a6e5db17ca47041e4d3f6b115a98082ae16f14cb9f7df4db00db67231a84ef8ed54ac174fe1067a3899d2da75b0971c955d2bdbabb3ef511c520f7cf7830e52cc9545b6bfb63c0da39b71e066fd715384a04c8b1349bc5efa88b48bdc1e24afba8db6fd9bc75971a02c0b645354f2be7502dbd67b06159d959a5a0015402cb35fd932e03c2d1fedc58f422911167a85c568706588df24b464c4171520cdd690e7ac4f664b8147cc9277cf7346451fae2d76422b35f489875483ea8a916d8f102c38ac037fb8f7e42c2dd144447c7dfaf8e2dd5308bbf61b0dc6ecde9ed990a29e98f67273c82365aabda4733792c6a1bca4eecba49f8b134e45e34e5980cfe62e0071826099066028a8885363625054a704baca934b1484844f9c819f4e48676fe62b1b25e80062a74a85e307955d5bdff983d906e178e9571fd6d9bade8cf3ae8603a1a0f9d98783ea874cf7ace62b5d06607d382d1e0c54b76c990958426034e6ef6e8d0baf25a08a74d71f8ba0fa8ca1f777386a35294215abd6942ff9178e6db10aba40a2df1f2b16b42824445f4d71fe9805d30b267a7cd0a2dcf9ba34a98417f03eb0e0208fc29c40fd1cd39b32f2ced09e5851492749c9371935b1fe595d95b259bc53c689f2f184b1451e71ef4c71a6f7f043e4d9452a8f40c2d59dcf1b93d90160cdc21733a91a493f718a6f09b078b26c2f4030b0c0e1943e147e1087e0a520c4403547a4a2ec775fad2ce5f483a06d0b24f274f3e14c6bd1a96e7c64b658b0a70c028d2e919ee1d7e1fb15513eb45a899888fb50d90d6459a517b22d483bef5defeaaba09eb31b1404055937e3c66285be45a907e39b62be9ce5278250fddc43fdfd0b8d68690b4de36f7932030cb135f950adc19bccb19a070f442bdd640ceae0f6f33e79d47d56ef879feced4138919e2a8a9e61f251f6025d60426148033715977cfc245765b9a519411ce84e3b7f1dd953ccb82252ce4ad97898daf61631df13e7ee6a639bc36cb5628614b007ea4c0644881ce78f9e3d0582c5ef052a0c35f784c696868594e103bdb019815388421760abe31f1057423a6e39afe960ccdd655801c33d039696d625a9a79da74991e5381d9d06721fb5b1e9d115e3af1ef55e030ea24128d8ecc9e08a04f8a7d56c57de36639f73d27d5c20a53dcfc4b5d786304e8435442ba14e60d42166aeb6350f0d3e9743dd2a62dbe23fcc631da6ef6576e77899d04d6de8e8abf7eacc242ea9ad3cdc7071fdd3987622e5bbd1ff9d84da3828ed0f6203b8ffa77a1394c9dd4e033f6b8d57924063ab6144b4da72ec2cbbff93a7de7d31e2bf14baeb4d9bb8332774aeab739ac13617a370a29996978f04744d636292579119dbefd121be9f10cda9cc8d72e6b1e74b8a1bfc81d80b61d0e814eff1b0fa503d5df385e1ae7d05957367678aeb28dc6599067c9ba26f7228047821660ff800c1a5998901b47247e085ba54da39e791a80892cd5bd805e9edca4f4bad7d0525a8c00b3691e8cf5aa2fbc12e4d9587bf9ab4f8631c9d1e2f28ef5cca12d736eb9841d27d45ac73aab428527f626fb7de7a98a89f079a7c683c22d03cd60794f4536c848cbec416e57056b3b4d0fbd80ae219b685a629963474eb8ba1f93893f74ddb589a0df85a28cdc584d2303b7fc357836ff68b67c281dd8f9dc5344ed2884a79678e6d25c15dbd88892dcf1709a8b0a33a978cabf037a6269e606f2ccb7521df2e1a5f393f050d2cbca38b5000366da6c8a05f67d5e89f1649e412b425f613b126c353d5fb85b51de99d5c8a42e530d8eb896d3fbb69059842bc42ad310cc6606ec5ada9e65713548993645ad7120f5704b61721df3605a05f5b479ea72ba7f6398956784c6a3130e3b72a7d1ad32c80f684b8e6ac9b6f2487f137b2d0742136f5db8c1f2c1efc35cb888740644e34ee16e9c7bc3f37f8f8125c3984c6e3c5b89aa2ff14fe34a09749e236577a7b28172e00aed7b5a37446f7628c14d7a224046f87b409f5bc3b7ec9546a5ceefc51a8dafbf8248f627196ce5773d780eb53415535dd7d6c088e73c92652ad9c6bb23387daccb5dcb2063ab0d84653112ee8cfb8acc5f5396d49e2004ce593c61bd4d3d1de7ce612b51a70962cd09239d93759dc884dc3db8d2e16fc96dd87b3d8dcbe4001c6369bc4de61219ec50c4f4c87b7992a95dc1685e6c8c0c86234583bfd87724db2f32986b9f434dbb273dce71b4f49e9594c0771e0e00a2551b37304791bf449110625127a261b326e55123139414000cc37eb69cb2d231eada48308c581c276f264822b892097ea6f81d71f347633d872cc87373400c1a140f976d76ee35ff48a2f8dd76eb118194fad2a9deeb6eb0b17b0f945be68d1d0c9841484fbb336d18ccec7333d3fc64d8fbf5a4f8bb62ca476516ee201e8a75da760912b2e66e5ebe210b3966e771529b08057183a1f6d381b406f38b261d14d3cc8663c94323429b184a70a4acf4ef36e5006963b10d1e9ab1a52edb46a5a58db8c23aa7d52331ae08ae5aac709673323b664f76e9a2f2d14a30b4fc9a97c2270e74d996c464c6b23b3f648ee287152f5d7f17a30256f51479a6c0d03f45209f36bcd011dcc4ba793c676f19b109ff8377c3c8d68b58ec4166055f60c5e050d35dbcea4e96e6fd649f6e2197f8b409af0fe0b7060ca6d8c8377f200bfa3e8fb30a42f77bacd0882dd180fd042dd834240af1d950b55b808439b992c6fc71feb631c0e6c6b773a1e70fc0397a852150b81403e1357a8d77c37aefe4e49e4d4deafe7e43d88e58b21d5132496c00cca0143e9cd156d0a993012f81d7069a267400e9368ed95474a1a68a6b8b0737190ded76e7c4b6e1073d851c38ec131e42ba6dc65806581b9650ab7107025e14412b2b9b2c94908281747f15547a2af4efe916a6153e38415f6fe37f9c20e8e23ec63098b7404b1ebd821dc69db4ad140a3b10bd6a013aa8f7b8decaf522cdfec5b1700d728137c3e55f35ec8c3ccede4c0f1a247288b949005d8e5b4a3b193b490fa472904c37ed73e366d25858a34fad12fe6ad17a4b0450558eba0fdf553ee893ac03b8f7fb3841bacffd659860ad83a3d40d41dbc7d45c54ad8c876f0ddeeec543526ca5129be9a525bfddc51547993333307c0420df9ac6ba11b076f3b377814f4b02fd9264bb53e51e5ee83d4416cfe0d3e8a6987ac9fa6fc5cea5584858e69c8df036c3d08d3f979459081ff2ae8053d007b7d6df4953faf925e2b2c9a68957510669d745043ebac22e41b4b4a037c12928eebb53d5167fee6d0bf52bc470e1cf50d4a19ab2ba109b06e982714f9946a5b42d19ab78656c431875a0d941da8c5562c4ac8ee56c42e26e622ad596336f2709a86ea854288f569c6df19956a0279d1c64c27c0c40c355826661f48f4e3b9eae9c92d23f77d5e29f3ca0e438afa25dbd82d5dbb38916a8fb70989ed2902e1b998fb53da3b4a1448ee8f3ce855280ad6c1ebcbc8178b9775aa17104f76715130487104744ca9c5d28c0418eb8f2c7a17d747fbadaf86db7f3f847ea9f87ea6d97f52ec0b4bb32b702698fbb2593749b3f8306dec1e83ce64790a06462596c741ccb80f289a15798993b783dd3f0f780369f5e46cf7df1b5a4c3c61ea4eb1e16d7924cc28e0d0c70e8affa724a7cc4d9ea034692f2c81b93e043f48f0855c51b5d5ac35c0e524098fff27dd9e38877b24b27310d6bc69d2e77eb9b589fbdd5cbb1da92e7b687b1a9ce52f472fb38d082629c5ba235d49fdde8facdcb67df7b79ea8475284e327f6eabfbfe8f451928e266f540e48b5bd59693fe9c8f4b0debb3785f197bd830ebdd79e047a90c0fac1e352306d6e7d13a80b4643a9747ebad23badb2bf6902c466540c7a04c7cc16a2a84f0e77a6b92f4a66a673fb85e79ff28d31594d11dd5b9690ca88ea345983b7d49ddbd111dead17421bc8d117a2ca353e319631b1f577b29e957d8fba753a1ff4f83ad572409985af512d44e076d1064d7ef6b051aca2acf40c1e5403e88bcebb2b771bf30be7e4ebe056e2fecae2cd0ee2a804b78fcecb2dde7776344b4f160b1ae4ee3deacb8053826a7f792485d6048bf706047a1bb9f859b379da9718e46d2b3364acb56f296ca06042c427318cf84d44b75c2835114712b284502754eb1e8bcccba18a79a1151c91fb6626d86a1a09ef8f2ba7b6384a8c7e01c4746e396a138087a4795400f85f56f96d7f01288ca5da072659fe665e8c18f02e0aede137487d0057552005fe2d0befe8fe63e0325d75fa011944372e7be0be857e6523fb450a48fa093c819bf9b76747e0e2e25334d515ba1058ebf83a63dd6955c1115cfa3e0f43cf29478a8ae7fccaa3d3a138666e0e95ea09ee1762bcbf2241e7386ac32e9daa156a44a13081eca829ad9a206b5cccb794f0455b8c74daead5ae6ac0dc47edd969c1ab4583b3496b6c3813c9775b3bc56afd26fccb527ad62adac9a57a263ae8aae04132db9f5476d69b4763bd53dc893c1aa09d8ad30ff4722959088d60cd15f2bafe7e4e56edf55c77128787886d3b1b2bc410cb85b3fa1617315325422a7157c8f0a769ccf96a729328ca852b8105426fb705fed013080c11a1909cd7805351362e605252f119bdd43a9c4cd517c82f713857686da5b06a68c6bf8d73be2a543e44720258651a36758cfe40ecd1d3a0cd1cf22d88507fec2d3888fa2585eef669e49165da207887fb3400bbebbeac50155499c7ed0402690ac3f067ff36cfafde949801fc59e3eb7cb7c52ab1e5553cff7d466b2105607144f406be03d2e311cb392ac6b485b3ce64c9033e6ccd9fc92217e43ebe34ded48b34f6638077945558dca4c52ead0feb71acaa20f5c441c80925c08d9c8d82daba9100f29eaf3827f6d96a26bb689ce22447f2d0eee6529eae0c01322c52aaf04cc987289b8de324355c1a086b5f276fdff713a734724d9231c8cbc0b583e8b3f139503dda599a0876dccc0cfe50024c3c86eb209880c2113ecff6b442d11840a3fe473ae6f65f1915c19e4632ec0bfff5b52d5ad62b6aa767895ccc2361c34cc93b4ba288d75ae84c2b97a879772bd532f8844eab4a68e5fe2e00c76d94721735e0ecad0cc0fe37736e411a12ff99012b41485e3702deb22922392f6c71fe6ca38ccc8995045e65583db106349eca1fb3f2bc4fec24fa004f652b42ec5cb2a13afa4d9894e8a1746c5a01f2707d60acb5de62fa3079ed9b6a297f847aa35c0e9654a90354a74f965124b0134dbcc8c99b03f6c1301a8bda369ea58ce4fce0ba90d1ddcad891f5ea3742dcd6e0c2c6cf794ef03fcacd7baded6992c26ea223a14c00e2db90e2a38a0e263ebf2d12bfd450756862873b2d4bb1d4e6f7ce944e91d598532cb54b5859d1cc7b4d9b9656d0c5e0b7756c284156c7a966bd8fc067b8888b738f613591fe2d609c79d82f14d825f7c8fbd787d42573f6459ba7bcc5e105125357574a838ea5c8974b41ffc914493a51ff060b73ace271dae4dab4bef28f964c2c4bae9e9db4b3f23baf11aa37e1f24257e961d62c3d50f7458601630ec1773a63f827b42a830793661c743c1005f0c1e49194507090bd9a918b2c4053695c30c59fd1c7761d7d6b8384b52c5614e3dad66104b2c7e6b9b41d35b1dbca5495de1d6052e8be20f835c5adecb342aa85e02c45961b601d9bc39bfa943c53b6512b322303c11427fb1763bc5d778da710b726bfefea05bd9f25bb93a36b815917bf866f7e1e0434c99e0db60a8e5eba651ff4908440d16cced6ed9b07eef849a5804c3e9b740ce5abc8dbd01ad9772f26c6111846e1c2af23705cb3eb92d80e874bee69fa978837922efef5243cf01b1c65f84dea9e57fc59d41b1c139dadb81f20b41662472416d3711af30ca345e06868d1e5f741ee03633de9151c654f34b0550c655d1b1db6f5ecd2b6cfbac4a82e4265d82b67888c87d588d5c015f7d524b5aac7c68f12d25b14b17fbbe9d425e0ea6cbe371bb2cdbb6f1b4e916b69c1957cab10f15acff5f7c722112dd5a5d41dd5a406ffbfa013f1364da03b3a21614f8b92fdb23b4ed7ebde49d268369270c0331cbadd7c880262b5e5d1eb0cb35a7bc9514ad0ba98b3471a50075bd5f1fef17f2c83695e17a25b77a686690f904de7fe06ed1a62ddd6f0c8d5070d7871eaac64a4ca72cb4c128bd8db38887d2a6be5a0075262336c1ea1ed9d84e0e21e4e4a847408466b184e6056e3a1ac7d632b6fbfb4762a2356deb0f2de3588229a4a0caaecb7a3a679ac8add01e5bfe009528ce37d0ed9495f5f53ef68a70944638969b6ca2d1497abf86acb1c259138bc747d949374eda5cf4c6c547a14fd97b80fb6760686fdf06dbcc270b9c409e987af09fc81078354c4700efe56cd00abbf9bb4a6bd64f94091b53c1a627e76edad3bd4a4e04357f39db045c87cd1008d4ea9b3f46a6261d211822f948d19f031bf8422ea259b0c0c45f8f9ebf782f3433eeff0f961232b03c1575c50ef6c0f7906899cd27256edf5beba7b3db16782e0568b66b8a3692a4d297e629f6eab467e95cb23f779c8e1c2042178052c573e54c9ddfec57d65f43da55a3d51c802daecd69e135f406882dbbecaf7228969a79ced019543558038f87d96601e89cc1bd301f114c077043c037a3448c675d6ba657a42980ac5e280b1bf7ced64b3307c990f7798b6efa454e9cb58913aacae5aac08839e903e550f59eba6b7d636bc01e50a552e6d204964b3fa4edb345c566acd2c6e584bed5285c0b1b29f416be78e144bb64b914e926dc3e03386ce0b2c77248de58c82d675b2d333c17e18ca86231f76dd11a3fd36b92e8e31d9f0d2e943b57f67d1e0eac0609ca2ecefedce1068fb8bc3b5761e350968d941c21872696e2171d9a8e1966175fdf3bb083caebf06fc9200898d4ec1427881a41dcd5d6b56c52e6a567876dc10cef734f33b02b32e243718116e886638de0f9e4c457ece9c7a47e22d669f2703aeab0c73d659f3e6697fb72262559be4a35b561d251ca4b18c0e1c2d0ddad3ecf9d6a63fcbcd04cb3574587c6a3464088849bc02e4a3f13459de82e5308c8495bb649b70a6eafc7efda82fc202eb9fcae0f2749afb679d30c9416cc227b0fd5b1f56853d24fb72f663f046e8134a2dcd38dc4c40167e054ca6fd0e0eb13de10c4f22a3f9d8446bf30173a70705e05f9948bb24aa6a4b367adc79a09145ee9890d78340ea2f2dd92c873742915d1e74ff1482a9cd27ef2f043753f0e0722e904e71e07ac65f57928702c5e2b0e5e00a7c55a35a9d4624cad94bbe5b68b527299e1cc5f03f4b92ec789d6a8f7d4fc4f7e44522bd8cb421e48ff9c04d3b4a35edb65541835623b2bef16c107f22c653dda63226d398f127b5addc430c5ba6e58da8d667b93474cff193591a685787bd66fece3b151b953b7ad890aa9a46d48b9910efc94a6deb827549de3753d261ca0953c56780fc42f7004d63265bc4572109872685997feee7b1d0f4e14fc3892e40a442e248865c0c77781d74c08a4252148e97eef3cdf6e8d82a716dda8f262954f3569817463933a954596b7eda9f4dca8df6d603c156d4b6769a62aeae5abdde820e73bdf0c452177652fcaec700fdcaa0f1d262c39a8dc419318af2cdec9fd38b09bd9d2186b2853aebd40e5f9a568ed0ace35b0a6be990f57da9fef51611a11699f336b1ea3bcc320ec24522cc1283aca8ba1593a7456402b7153bd289b1f4e0b9723416acfdaad428ee4e6269bafad0109adc9fc0204aa4f09f62acc4b582c774dc79372b2e81c9b994ff44c7e47263eedea4d1fb627efc3afabf6a10a216fe935d760f6c172dfe318ed64066113826a6fb3eb1a5e72e5255769c933473782ea182365a1ddbf1a9482b1c063e657f0894d35aa4d52fe7b0be603daf4c5ba38bececdc986b15c1cb5c02293d3c9bb6f51a43ad9a6da13d2409938ab3bbd1bfffbfd5741d6ebd175aab6ac2b64cc0de3ebec9a9fc4790617511d81a3599f3c306259fa060b0ab245cd2fdb4ad147f6e09ed956001f37a075c1ecbad087515485ce165437412d4001c17b745886702c93a150939cd1402bb9e757d53c56e40f950945e32b0e62ebb952f3f4cfd802e44064ded7031022fa9345546285c5cce88b35e62eccfdf532f4c073855ed1d1ec8f9f97accc7d98e4aeaa18bd874c76ac2f06c7c88c7dc4a403bfc5d4d6639d4ec96518e0d6a2628d2dd7e9a70ab368452f021b95221e4175b43324d3236c72019e0ebfdc74207fb77c389380604359b7b1b917fe485720a5a9960fe23a8ef39498b0a4dd772ee5b7d1c6feca48051352c5edb1e615537a8343436c7faacac7e11edca3f51c488a3e78fa8d7f10297845ad531cfa2772eeb79afd4a43b1240e700981fc16c711279329a47fb47d95df175fa2a43f6543569191ffd439fe37c6917f4a44db106654cc6781caeadaa68c4fd5d5fff3fbcee8e05f522620310d40911e5bc2291b07010a99706b50583058eb0ff15c7ea99fc0217d2bedee58c5f23e600ba414cf619bb848536715a47f341ee79ca08b9a8e42c6d5fc80e100740fcc93fe72c3b4f55ad5e1ac0407ac6c669fd168fbba00ac75beb9ecf18407e839ada44f0fc02a03da1619fac0cc041fe25667efbfe4eb5a1838a0091cf265484ea55078eb9b35e51ff053e608fb8acb80f218f3e2ae0b658fa6feb9be8695806c6e4aa32a8694938c088863b561704113230f7c78ab5eb9a8f5b59b010643c0284f0a92c145ec54de86c8ab47a1f8ba500662565ccf28e6a4b1096a1d93ebab75b1d8595cc17eb85990c0e6827f166dfc68eb73de0631688b03b307f8e762f06371268cff6a402d6d59266f07858f32ec1763ccdeac59b2cbb16617ac01e858c7b530e10b478c835d63815c0adbb99bb73b60e49a73b430e8761197a1c9c065a0bb69b05f054c6d9be6ac8bebd75dfe3b3e4bed9f1f900dc54e965c7d7755c5b2300f852a0599d6ffd28f8d1ddbd6e993fe0aca56b215cf90b017dbf4ec9b7cba91830bb3195a21c4709c70f2d73e2e3b35d3b5ba941eb6d85a4b955d3665fe8d5037a0024c62455faefa7b43ce07e753eb2ca88cdcd160334dccbce7e540ab51a7a38e096ff123495e3542b6f0ab020ba5b6b9f9fa6d370af17d3817311b243242f3084313116f3a940cb492307b64d9757af1c42f2c0a0c3b5c1548a1bb7aec79b8aa8cb6d9d165a7222935ae315425020b8eff6a9d72dc4656b43ca880fab85fb62a2f67d7d8eb36c05971e14d8c407ef2330760d322961a613ce14e9ffb7acfe5580c0f9400cf9aed2fd0edbd0316c5e9a95b2889829c63c5f609fe3e834047469f165b00434f44e86daf05055d36af3b481db17a</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">该文章已加密, 请输入密码查看。</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>leek</tag>
      </tags>
  </entry>
  <entry>
    <title>在人间做韭菜的那些年(2)--搬砖军规</title>
    <url>/2021/04/05/life/leeklife_1/</url>
    <content><![CDATA[<p>写了好几年代码，今天梳理和沉淀一些搬砖盖楼的方法论，时刻鞭策自己去遵守以及重温它们。</p>
<h3 id="编码军规"><a href="#编码军规" class="headerlink" title="编码军规"></a>编码军规</h3><ol>
<li>并发控制,默认使用悲观锁,一锁二判三更新,乐观引入须谨慎。</li>
<li>幂等拦截,幂等新老要兼容,字段约束需一致,异常场景防击穿。</li>
<li>状态推进,流转设计要完整,状态推进凭指令,业务态不可逆。</li>
<li>对象设置,成员变量慎赋值,引值引址需眼晰,对象比较用 equals。</li>
<li>数据库表,SQL必须带字段, where条件有索引,索引不含隐式转。</li>
<li>时间设置,关注时区和时,避兔设置当地值, string传值带时区。</li>
<li>异常防御,请求校验防慕改,异常 catch不能吞,线程对象清理好。</li>
<li>代码质量,CR单测集成测,结果断言边界值,金量回归不能少。<span id="more"></span>
<h3 id="中间件使用"><a href="#中间件使用" class="headerlink" title="中间件使用"></a>中间件使用</h3></li>
<li>消息使用, grouped要唯一,重复投递质关注,事务回查防悬挂,</li>
<li>缓存设计,缓存击穿要,过期设计去热点,存储容量需考虑。</li>
<li>事务处理,悬挂告警要及财,严禁造成空国滚,确保最终一致性。</li>
<li>调度任务,调度重要免,图取数据可配置,熔断能力需具备。</li>
<li>限流配置,增量覆盖要分清,删规则要小心,异常限流调算法。</li>
<li>druid使用,连接数量需评估,耗时上要警惕,FO机制来保障。</li>
</ol>
<h3 id="防御编程"><a href="#防御编程" class="headerlink" title="防御编程"></a>防御编程</h3><ul>
<li>强弱依赖合理<br>针对强依赖一般禁止高级别应用依赖低级别应用。<br>针对弱依赖系统,注意捕获调用异常,合理设置超时时间</li>
<li>业务环境隔离<br>为了避免业务之间产生能,必要的业务进行线程。<br>限流值连接池的基至进行存储的隔离。</li>
</ul>
<h3 id="资金安全"><a href="#资金安全" class="headerlink" title="资金安全"></a>资金安全</h3><ol>
<li>资金风险,证账实要对清楚,业务规则细分析,配置上下需一致。</li>
<li>金额计算,注意币种元和分,计算使用 Money类,外汇买卖方向对。</li>
<li>核对设计,过程终态均核对,包含金额状态码,中间帐户对余额。</li>
<li>资金应急,上报止血要及时,数据捞取要复核,应急调账需审批。</li>
</ol>
<h3 id="数据质量军规细则"><a href="#数据质量军规细则" class="headerlink" title="数据质量军规细则"></a>数据质量军规细则</h3><ol>
<li>业务保障,资损舆情录场景,时效保障用基线,上下协同保业务。</li>
<li>引擎变更,变更方案要评审,灰度测试融演练,巡检免疫要到位。</li>
<li>数据研发,研发规范须遵守,冒烟测试不可少,仿真灰度保稳定。</li>
<li>监控核对,任务监控要添加,内容核对要重视,及时降噪禁麻木。</li>
<li>风险治理,潜在风险配巡检,风险接收须治理,不治升级要限权。</li>
</ol>
<h3 id="生产变更"><a href="#生产变更" class="headerlink" title="生产变更"></a>生产变更</h3><ol>
<li>提前计划,下周变更本周理,重大高危需报备,沟通确认应有效</li>
<li>灰度分批,生产之前先灰度,分批操作控比例,关键业务须盯盘。</li>
<li>防御检测,变更前后配校验,监控巡检覆盖全,防御规则勤演练。</li>
<li>变更过程,恢复手段提前定,应急操作有人盯,出现问题变更停。</li>
</ol>
<h3 id="应象止血军规"><a href="#应象止血军规" class="headerlink" title="应象止血军规"></a>应象止血军规</h3><ol>
<li>应急值班,手机电脑随身带,电量网络要确保,暂时离开有备份。</li>
<li>应急响应,接到告警快响应,出现风脸速升级,预案执行要谨慎。</li>
<li>应急过程,恢复止血是第一,高危操作先灰度,谨慎小心防扩大。</li>
<li>应急手段,发现变更先回滚,容量不够降和限,容灾切换来兜底。</li>
<li>应急建设,实战攻防日常练,定位自愈助提升,历史故障取经验。</li>
</ol>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>leek</tag>
      </tags>
  </entry>
  <entry>
    <title>在人间做韭菜的那些年(4)--怎么管理聪明人&amp;送别孤尽</title>
    <url>/2021/05/30/life/leeklife_3/</url>
    <content><![CDATA[<h3 id="一个让人抵触但又有所收获的局"><a href="#一个让人抵触但又有所收获的局" class="headerlink" title="一个让人抵触但又有所收获的局"></a>一个让人抵触但又有所收获的局</h3><p>这周参加了一次“洗脑”式的培训，主要是价值观强化，整个集团组织过于庞大，在管理上要想实现高度的统一和控制，第一需要一套价值观时刻提醒每一颗韭菜，第二，这个价值观要和韭菜利益强相关–即纳入绩效系统，参加这个局，其实大部分的思想是过来接受集团的强制文化熏陶，5天当一个混子，摸摸鱼（实际上我也是这样度过的），但是中间有一些集团的老员工的分享风格让我认识到了一个点，这些合伙人现场给我们做分享，风格透露着很真实的言语和思想，比如内卷、996、蚂蚁ipo流产是不是说明蚂蚁不行了、工作和生活怎么平衡、女强人的想法、老板pua等这些问题都在会上直接抛给了这些在集团工作超过10年的老员工以及合伙人。<span id="more"></span> 他们的回答都很真实，内卷问题他们承认，集团现在很多团队都在做无效的做功，解决之道就是做自己，设法创新，跳出内卷圈子，996的出现主管的管理方式和员工的向上管理以及创新都不足，ipo失败是资本主义无序扩张的社会主义改造，蚂蚁属于科创板，如果蚂蚁上市科创板，那么蚂蚁的涨跌就是科创板的涨跌，对国家层面带来了不稳定性，最后又说到生活和工作的平衡，解决之道是往生活的银行里边存感情，等你需要在工作上义无反顾的时候，再把生活银行里边的储蓄拿出来做置换。</p>
<p>以上这些问题都被老员工和合伙人回答的非常真实，说出了人的内心的底层的想法，没有任何掩盖，会上听讲的虽然有做不同业务线的技术、pd、运营、财务、合规、管理等等的人才，都是聪明人，你不说真相大家也心知肚明，只有真相和真相相互碰撞才能和会上的这些人形成共鸣，在利益公平上产生共鸣，在家庭生活上产生共鸣，因为人追求的无非就是利益和感情，这2个是刚需，我在刚需上给你做了充分的解惑，韭菜就能大概率的在集团安安稳稳的搬砖，当然我这么说可能有点阴阳怪气，我的想法其实还是，你如果想在一个集体里边让自己成长，你必须得让集体有所成长才行，所以你就必须要让他们给你铺设这一套看似洗脑的价值观，需要向客观认同这一套价值体系，然后等你在这个集体呆了一段时间 有所成长了，你要懂得辨别哪些是需要自己吸收的，哪些是糟粕，深入浅出，深入和浅出都不容易做，深入的时候会做价值观产生抵触，浅出的时候由于被价值观打上了很深的烙印，要想出来，需要知道自己要什么，个人觉得，首先你离开了这亩韭菜田之后，你能知道哪些对你的成长产生了推动作用，那么即将对你产生推动(预测)，哪些阻碍你成长了，阻碍你成长的都要摒弃。</p>
<h3 id="优秀的维度"><a href="#优秀的维度" class="headerlink" title="优秀的维度"></a>优秀的维度</h3><p>我所在的小组，有刚毕业就进入ibm的年轻漂亮的美女、有哥伦比亚大学的硕士，年轻，高颜值的美女、工作上很抗压的运营、历经沧桑的在职场混迹多年的大哥、有家国情怀的人、有机车少女、有国企过来的优秀小伙等等，你进入这样的一个优秀的团队，刚开始你会发现你就是个弟弟，但是仔细分析一下你会发现，你有的他们没有，每个人都有自己的一个闪光点，而且他么也会羡慕你的这个闪光点。你上的大学 很牛逼，但是我做过牛逼的项目。你掌握的信息比较多，但是我在某个领域做得很深。你长得漂亮会说话，但是我带领过大的团队。这里的每个人都有自己的长处，我们要做的就是去向他们的闪光点学习即可。</p>
<h3 id="孤尽大佬的离开"><a href="#孤尽大佬的离开" class="headerlink" title="孤尽大佬的离开"></a>孤尽大佬的离开</h3><p><img src="https://i.loli.net/2021/05/30/BzcjaYCpJVIoe6H.png" alt="image.png"><br><img src="https://i.loli.net/2021/05/30/kPo2GpQbY5dUzBH.png" alt="image.png"></p>
<p>参加培训的空当，溜课去了孤尽的场子，送别了一下大佬，顺便大佬送了2本亲笔签名书，挺高兴，留个纪念。</p>
<h3 id="孤尽总结的学习方法论"><a href="#孤尽总结的学习方法论" class="headerlink" title="孤尽总结的学习方法论"></a>孤尽总结的学习方法论</h3><ol>
<li>如何学习</li>
</ol>
<ul>
<li>学习四部曲<ul>
<li>记忆：记忆是体力活，重复、重复、再重复。</li>
<li>理解：无论时隔多久，唤起的记忆深度是一致的，并且内化自己的认知。</li>
<li>表达：表达出来，别人理解了，既是理解的一个境界，也是表达的成功。</li>
<li>融会贯通：学以致用，实践是检验知识的唯一出路。</li>
</ul>
</li>
</ul>
<h4 id="如何记忆"><a href="#如何记忆" class="headerlink" title="如何记忆"></a>如何记忆</h4><p><img src="https://i.loli.net/2021/05/30/ZQM4cdqfy2Bg6nH.png" alt="image.png"><br>长波记忆包括:</p>
<ul>
<li>勾股定理</li>
<li>“欲穷千里目”的下一句</li>
<li>同桌的你是谁唱的</li>
</ul>
<p>长波记忆（磁盘）忘记信息并非没有存储，而是检索不到。<br>短驳波记忆（内存）忘记则没有持久化</p>
<ul>
<li>有场景的信息有利于记忆</li>
<li>有规律的信息有利于记忆</li>
<li>有分类的信息有利于记忆</li>
<li>有图像的信息有利于记忆</li>
</ul>
<p><img src="https://i.loli.net/2021/05/30/ofPp6ex8tZXs7vw.png" alt="image.png"></p>
<h4 id="XY问题"><a href="#XY问题" class="headerlink" title="XY问题"></a>XY问题</h4><p><img src="https://i.loli.net/2021/05/30/1zuDMqbGm9kQwpV.png" alt="image.png"><br><img src="https://i.loli.net/2021/05/30/ATe1gmpfhjEDLlx.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2021/05/30/zmTWa8QcqLYIrB4.png" alt="image.png"><br>对于XY问题的意思如下：<br>有人想解决问题X，他觉得Y可能是解决X问题的方法。<br>但是他不知道Y应该怎么做，于是他去问别人Y应该怎么做。</p>
<p>简而言之，没有去问怎么解决问题X，而是去问解决方案Y应该怎么实现和操作。<br>于是乎，一群人围着Y问题在求解。</p>
<p>在一个根本错误的方向上浪费大量的时间和精力，会导致：</p>
<ul>
<li>降低团队协作效率</li>
<li>产生预测外的风险</li>
<li>容易产生集体挫败感</li>
</ul>
<h5 id="XY问题的根源"><a href="#XY问题的根源" class="headerlink" title="XY问题的根源"></a>XY问题的根源</h5><ul>
<li>过度自信：希望大家兼听则明</li>
<li>知识广度：拓宽知识面</li>
<li>知识深度：深度挖掘某些好奇的点</li>
<li>干扰因素：以静制动</li>
<li>性格原因：简单、开放、透明</li>
</ul>
<h5 id="如何解决XY问题"><a href="#如何解决XY问题" class="headerlink" title="如何解决XY问题"></a>如何解决XY问题</h5><p>1)提问前，先想清楚你想解决的根本问题是什么<br>2)提问时，给别人说清楚问题的背景<br>3)提问后，再度清理一下思路<br>4)不要自作聪明，更不要过于执着自己的判断。<br>5)和别人明确一下自己的问题有没有问题。<br>6)主动和被问者一起探讨问题的解决方案。<br>7)在方案讨论过程中，尽量多地信息输入</p>
<h4 id="聊聊浮点数"><a href="#聊聊浮点数" class="headerlink" title="聊聊浮点数"></a>聊聊浮点数</h4><p><img src="https://i.loli.net/2021/05/30/cOfj4DkiesAb5IW.png" alt="image.png"><br><img src="https://i.loli.net/2021/05/30/IEq1RiV7uD8sStC.png" alt="image.png"><br><img src="https://i.loli.net/2021/05/30/Ug2KfRYqtcz3P9G.png" alt="image.png"><br><img src="https://i.loli.net/2021/05/30/OYHeuLiozUvq9IE.png" alt="image.png"><br><img src="https://i.loli.net/2021/05/30/Q46u8s17AWOtbSy.png" alt="image.png"><br><img src="https://i.loli.net/2021/05/30/TgLhePzdYV73s5J.png" alt="image.png"><br><img src="https://i.loli.net/2021/05/30/1pgiXaw4kedMz6x.png" alt="image.png"><br><img src="https://i.loli.net/2021/05/30/q9HpJAWOFRkdyvu.png" alt="image.png"></p>
<h5 id="背景-独占与共享"><a href="#背景-独占与共享" class="headerlink" title="背景-独占与共享"></a>背景-独占与共享</h5><p><img src="https://i.loli.net/2021/05/30/fjdSanTQLkEIWz6.png" alt="image.png"></p>
<h5 id="背景-并发与并行"><a href="#背景-并发与并行" class="headerlink" title="背景-并发与并行"></a>背景-并发与并行</h5><p><img src="https://i.loli.net/2021/05/30/fwDsJ1IPmrH39QW.png" alt="image.png"></p>
<h5 id="AQS-解决多线程访问共享资源问题的同步管理框架"><a href="#AQS-解决多线程访问共享资源问题的同步管理框架" class="headerlink" title="AQS-解决多线程访问共享资源问题的同步管理框架"></a>AQS-解决多线程访问共享资源问题的同步管理框架</h5><p><img src="https://i.loli.net/2021/05/30/MYeqF8k5oZxbiI6.png" alt="image.png"><br><img src="https://i.loli.net/2021/05/30/ozM2WHys6anQf8i.png" alt="image.png"><br><img src="https://i.loli.net/2021/05/30/VRdqy8sOQSZGt9e.png" alt="image.png"><br><img src="https://i.loli.net/2021/05/30/FjMtRK7Qmx9o3AC.png" alt="image.png"></p>
<h3 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h3><p>用哲科思维思考问题—《第一性原理》</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>leek</tag>
      </tags>
  </entry>
  <entry>
    <title>在人间做韭菜的那些年(3)--项目推进迭代流程</title>
    <url>/2021/04/24/life/leeklife_2/</url>
    <content><![CDATA[<h3 id="项目推进"><a href="#项目推进" class="headerlink" title="项目推进"></a>项目推进</h3><p>互联网做项目都是一把梭，在企业没有现有的项目管理系统的前提下，需要有一套行之有效的项目推进的步骤，以下是笔者认为还算ok的一套流程:<br><img src="https://i.loli.net/2021/04/24/MunjWY9IglcKHt8.png" alt="image.png"></p>
<span id="more"></span>

<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzExNTY3MjE4NzQvMTE1NjcyMTg3NC5naXRodWIuaW8vYmxvYi9kZXYvc291cmNlL19wb3N0cy9saWZlLyVFOSVBMSVCOSVFNyU5QiVBRSVFNiU4RSVBOCVFOCVCRiU5QiVFOCVCRiVBRCVFNCVCQiVBMyVFNiVCNSU4MSVFNyVBOCU4Qi54bHN4">项目推进迭代流程.xlsx<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="prd阶段"><a href="#prd阶段" class="headerlink" title="prd阶段"></a>prd阶段</h4><h5 id="基本输出"><a href="#基本输出" class="headerlink" title="基本输出"></a>基本输出</h5><p>这个阶段是pd同学在做头脑风暴，根据需求方需求和以及自己做的市场调研做出的产品设计的描述，会有业务架构图、数据流、资金流、数据流等一些信息，同时会有涉及到界面交互的信息描述。<br>这些设计都是根据需求来的，有的是现有需求，有的是未来的需求做提前的准备，也有解决历史问题等。<br>这个阶段pd同学会输出一份prd的设计文档，这个prd文档会到下一个步骤用。</p>
<h5 id="参与人"><a href="#参与人" class="headerlink" title="参与人"></a>参与人</h5><p>如果项目复杂，pd同学内部会有一个全体的评估，因为有些prd的设计是一个人做出来的，难免考虑的不是很全面，如果有设计不合理的地方，推进到下一个阶段会遭到技术同学的无情蹂躏。<br>如果项目牵涉到多个团队的情况，在产品设计层，主牵头的pd团队会召集其他团队的pd进行多次讨论敲定产品设计，主要是打通业务流程，划分每个团队的职责边界。<br>另外ui视觉交互会直接和pd讨论，让ui输出一份视觉交互稿，这个交互稿同样在下一个步骤使用。</p>
<h4 id="项目评估"><a href="#项目评估" class="headerlink" title="项目评估"></a>项目评估</h4><p>此阶段pd会发起邮件通知如下人员参加prd评审:</p>
<ul>
<li>pd<ul>
<li>牵头产品团队的pd</li>
<li>如果涉及到多个团队的pd会拉上其他团队的主要负责人。</li>
</ul>
</li>
<li>技术&#x2F;技术架构&#x2F;技术风控<ul>
<li>开发团队小组人员</li>
<li>架构师(涉及到主要架构调整的)</li>
<li>运维相关的风险控制相关人员，以及技术安全相关(可选)</li>
</ul>
</li>
<li>前端开发<ul>
<li>团队的前端开发</li>
</ul>
</li>
<li>测试<ul>
<li>相关业务团队的测试人员</li>
</ul>
</li>
<li>ui视觉交互<br>视觉交互人员</li>
<li>产品风控<ul>
<li>法务</li>
<li>合规</li>
<li>监管</li>
</ul>
</li>
<li>业务方<ul>
<li>实际提出需求的人员，比如运营人员、市场人员。</li>
</ul>
</li>
</ul>
<p>这个会议的主讲人pd同学为主，ui设计为辅的旋律，同时pd和技术在会议上会出现打架斗殴的现象，哈哈哈，如果技术和pd的方案出现冲突，双方会敲定都能接受的方式；<br>同时在达成一致的时候，ui交互稿也会做出调整；<br>其他角色会在宣讲过程中提出自己的意见和建议；<br>会议纪要一般是pd同学在做；</p>
<p>这个会议会存在pd设计被重新打回的情况，另外本次会议达成的一致，以及带会下去解决的问题，这些不一致需要敲定下一个时间去再去沟通达成一致，就是多次开会，不过下次会议只会拉上和冲突问题相关的人员，其他人员时间宝贵，不相关的就不会拉上。</p>
<p>如果项目很大，又很紧急，这个时候，技术可以提前做架构上的工作，以及可以做的提前要做的事情，但是不会出排期，以及具体分工。</p>
<h4 id="交互-amp-视觉"><a href="#交互-amp-视觉" class="headerlink" title="交互&amp;视觉"></a>交互&amp;视觉</h4><h5 id="参与人-1"><a href="#参与人-1" class="headerlink" title="参与人"></a>参与人</h5><ul>
<li>ui</li>
<li>技术</li>
<li>测试</li>
<li>前端<br>上一个阶段经过多次互相伤害，在业务流程match、技术同学实现得到认可，ui同学得到认可就会进入交互&amp;视觉阶段，根据上一个阶段的达成的一致，重新和技术以及质量同学走一遍。</li>
</ul>
<p>主旋律是ui同学携带ui设计稿，串通用户操作的行为，讲解一些交互细节。</p>
<h3 id="技术方案评审"><a href="#技术方案评审" class="headerlink" title="技术方案评审"></a>技术方案评审</h3><p>上一个阶段过了之后，技术同学会输出一份系统详细设计，然后拉一个会议进行一波评审。</p>
<h4 id="参与人-2"><a href="#参与人-2" class="headerlink" title="参与人"></a>参与人</h4><ul>
<li>后端开发</li>
<li>前端(非必须)</li>
<li>测试(非必须)</li>
</ul>
<p>这里边的测试人员会根据这个系分输出一份测试用例。<br>这里整理了一份系分设计的模板:<br><a href="https://ceaser.wang/2021/03/12/develop_minds/system_detail_design/">系分设计模板</a></p>
<p>涉及各个模块的类图、流程图、以及整体的架构设计、数据库设计，表的设计、各系统之间的关联和交互、风险控制等等。<br>这里说一下韭菜集团贯彻的三板斧：</p>
<ul>
<li>可监控<br>系统运行对技术参数和业务运行是否正常的数据可以有一个监控和观测的口子</li>
<li>可应急<br>如果线上系统发生了故障，比如机房故障、或者代码逻辑引发的bug、依赖的第三方系统服务不可用，都是不可以事先预测的，那么如果出现了这种问题，我们在架构上或者说是技术实现上要做防御性建设的处理。<br>机房挂掉(挖掘机技术哪家强，中国山东找蓝翔)可以使用多机房部署、异地多活等，代码逻辑出现问题导致的资金损失，要先止血，关键链路可以切断(实现的时候要做配置开关)处理、渠道路由切换、回滚等，第三方系统不可用，比如缓存系统不可用，可以使用降级方案。</li>
<li>可灰度<br>一个新功能上线默认认为是存在风险的，因此要先进行小范围的机器部署和发布或者进行路由配置，测试流量进入新迭代的逻辑或者机器。</li>
</ul>
<p>这三个发布前提是韭菜集团每个技术团队的必须要践行的，否则不能发布。</p>
<h3 id="接口评审"><a href="#接口评审" class="headerlink" title="接口评审"></a>接口评审</h3><p>  这个步骤理论上可以和技术方案评审 合并，也可以单独拿出来和前端同学评审</p>
<h4 id="参与人-3"><a href="#参与人-3" class="headerlink" title="参与人"></a>参与人</h4><ul>
<li>后端</li>
<li>前端(api)</li>
<li>其他依赖当前系统的对接人(rpc)</li>
</ul>
<p>主讲人是后端开发，对前端接口的形式和参数、返回值进行说明，收集接口使用人的建议。<br>每个公司都有自己的一套api mock系统，开源的有rap2.<br>参考:</p>
<h3 id="功能开发"><a href="#功能开发" class="headerlink" title="功能开发"></a>功能开发</h3><p>这个阶段是梭哈阶段，针对系分设计完成编码实现，编码阶段涉及的东西很多，这里抛一偏编码军规。<br>参考:<br><a href="https://ceaser.wang/2021/05/05/life/leeklife_1/">Api 文档管理系统 RAP2环境搭建</a></p>
<p>这里说一点我对开发层面的一些看法。<br>如果一个业务功能能通过pd设计的方式优雅解决掉，就最好不要通过技术手段去实现掉，设计大于实现，抽象大于编程，每一行代码都透露着线上问题的淫笑，选择大于努力。<br>敬畏每一行代码。<br><strong>salute！</strong><br>你懂我意思吗~</p>
<h3 id="接口联调"><a href="#接口联调" class="headerlink" title="接口联调"></a>接口联调</h3><p>这个阶段是各个后端服务能力的开发相互之间联合调试的阶段，发现存在的问题及时修复。<br>常用远程debug进行调试。<br>目前大部分的工程搭建都是spring boot，因为可以参考spring boot的远程调试：<br><a href="https://ceaser.wang/2019/06/08/spring_boot_and_cloud/spring_boot_cloud(3)JDWP%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E8%B0%83%E8%AF%95spring-boot-loader%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E5%8A%A0%E8%BD%BD%E5%85%A8%E6%B5%81%E7%A8%8B/">spring_boot_cloud(3)JDWP远程调试详解以及调试spring-boot-loader的启动与加载全流程</a></p>
<h3 id="代码评审-CR"><a href="#代码评审-CR" class="headerlink" title="代码评审(CR)"></a>代码评审(CR)</h3><p>技术人员的核心输出是code，良好的编码不仅能让系统稳定，还能提高系统的维护性以及扩展性，可读性也是要保证的。<br>优雅的编码就像写诗一样，不仅会喜欢上这个过程，还会让人无法自拔，提高技术热情。<br>设计模式能组织代码优雅编排，同时满足扩展性和可读性。</p>
<h4 id="参与人-4"><a href="#参与人-4" class="headerlink" title="参与人"></a>参与人</h4><ul>
<li>后端技术</li>
<li>测试同学<br>代码评审第一是为了发现当前编码存在的问题，第二是优雅编程。切记不要在CR的时候炫技装逼，有伤大雅，格局不够大。。。</li>
</ul>
<h3 id="测试用例评审"><a href="#测试用例评审" class="headerlink" title="测试用例评审"></a>测试用例评审</h3><p>CR之后，技术同学会发起提测，申请测试资源，测试人员在之前的系分产出了一份测试用例，技术同学提测后，会对整个测试用例进行评审，因为中间在编码阶段技术会可能发现一些坑，对现有逻辑改造等，这些需要告知到测试，让测试回归一下。<br>另外开发同学在邮件提测的时候要声明：</p>
<ul>
<li>提测的业务需求范围</li>
<li>提测的功能(可以部分功能提测)</li>
<li>对那些业务范围需要回归一下</li>
<li>后端代码分支、系分文档地址</li>
<li>前端代码分支</li>
<li>数据库坐标</li>
<li>提测建议</li>
</ul>
<h3 id="冒烟测试"><a href="#冒烟测试" class="headerlink" title="冒烟测试"></a>冒烟测试</h3><p>开发同学对自己开发的系统自己进行全局性的测试，测试粒度比较粗，主要功能是否实现，有无系统报错，数据是否正确等等。<br>这里尽量把问题都自我发现掉，最好不要让测试去发现，养成owner意识。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试阶段是质量同学的职责，根据之前评审的测试用例，对本次开发的需求范围进行测试，包括功能测试，压力测试等等。<br>测试同学测试验收完毕之后，会通知开发同学发布uat环境。<br>如果测试有问题，开发同学消灭bugs。</p>
<h3 id="UAT"><a href="#UAT" class="headerlink" title="UAT"></a>UAT</h3><p>UAT是最接近生产环境的一个环境，数据库都是线上的数据库，程序是本次需求的程序，有些问题由于业务丰富度以及数据的丰富程度，不会在开发和测试环境暴露出来，到了uat环境就会暴露出来。<br>uat环境测试同学验证完毕之后，会通知开发同学进入线上环境，如果有问题，通知开发同学消灭bugs。</p>
<h3 id="上线"><a href="#上线" class="headerlink" title="上线"></a>上线</h3><p>这个是我们最终要交付的环境，我们都要敬畏的系统，所有同学的一致目标环境。<br>uat环境在测试同学验证完毕之后，会给开发同学发起上线通知，开发同学将代码发布到线上机器。<br>发布完毕，测试同学会对正式环境进行一波验收和回归。<br>这里在测试的时候可以使用三板斧里边的灰度方式，减少测试数据影响范围。<br>没问题皆大欢喜，有问题解决bug，如果是阻塞问题要是用三板斧里边的应急策略。<br>正常上线完毕之后，要对系统的运行情况能监控，有的是技术上的监控，比如内存、cpu、磁盘、网络、io等进行监控，出现技术故障的时候可以提供参考。<br>第二种就是对业务进行监控，我们在实现业务的时候，比如交易笔数、访问量、退款笔数、这些数据都是业务数据，我们在编码的时候需要按照日志规范打印这些日志，监控系统根据日志模板抓取app的日志，抠出来里边的业务数据，<br>比如退款笔数1小时达到了1500笔，而1000属于每日平均水平，这个时候就会触发监控系统的报警。</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>leek</tag>
      </tags>
  </entry>
  <entry>
    <title>2023 year-end review</title>
    <url>/2023/12/30/life/2023_end_desc/</url>
    <content><![CDATA[<p>今年的几个关键词：思考力、AIGC、opneai、跨境电商、裁员、消费降级、俄乌战争、巴以冲突、全球经济低迷、甘肃地震。</p>
<h1 id="人工智能蓝海"><a href="#人工智能蓝海" class="headerlink" title="人工智能蓝海"></a>人工智能蓝海</h1><p>  今年是人工智能爆发的元年，从openai发布gpt3.0开始，直接点爆全球人工智能创业浪潮，每个人都带着一个信念：每一个行业都可以用大模型重新来一遍。<br>蚂蚁内网每天都有离职发帖的，一些人选择了下海从事人工智能创业下海，一部分去做跨境电商，剩下的无非就是3.25或者待够了，待够的这批人可能有一部分是接受不了组织的组织力。<br>初衷是以科技服务经济发展，为世界带来微小而美好的改变，但是绩效发展晋升导向，让”不务正业“随处可见，实际看到的很多客观事实是连自己的专业都没有做好，致使一部分理想主义者出去下海从事热点的人工智能创业又或者是逃离大厂。但是先不说当前阿里的问题，我认为99%的大厂人AI创业都会失败，为什么？<br><img src="https://s2.loli.net/2023/12/09/GNOJPR2cMnZAYiz.png" alt="image.png"></p>
<span id="more"></span>
<p>  背后其实是红利享受惯了养成的骨子里的傲慢。</p>
<ul>
<li>开放包容度缺乏，容不得与自己不同的事物。如处事方式、表达习惯等，动则采取对抗方式。所以大厂无意义的撕逼随处可见，动则剑拔弩张。<br>更莫名的是结果还被领导夸奖是工作要性强，心平气和沟通反而被认为工作积极性不强。</li>
<li>还有玻璃心，动则受害者思维。“多大点事嘛，你看不惯，你退出就行了啊”。好比到朋友家里作客，就因为主人家的招待你不满意，就想把人家家里砸了，那就有点骨子里的坏了。</li>
<li>另外就是自以为是。之前有参加过一个创业者线下沟通会，其中参会的有几个大厂人，一开口就是大而空、不接地气的宏大叙事，直接就被其它创业者怼了，在外面人家可不会惯着你。在大厂你可<br>以一天到晚做PPT，吹得天花乱坠，今年造一个轮子，明年换一个，反正公司有的是钱。还有即使这个产品没有价值，也没关系，因为毕竟通过卖公司的品牌，也是能找到愿者上钩的客户的。<br>  我想说的是，很多时候是时代的红利或者是公司的影响力，并不是你个人的能力有多强，离开平台你可能什么也不是。<br>  人工智能大模型这个赛道，的确会诞生一批新的公司和优秀的创业人，单纯卷技术赛道的大模型，这个需要交给国内资本大厂去做，小企业和个人没必要插手，因为目前处在不稳定阶段，大模型一天<br>一个变化，说实话，国内的大厂做出来的大模型都是垃圾！每一个能打的，openai开始做的时候，我们在玩共享单车，玩卖菜，单看北美资本市场，openai做了开头，但是未必一直会是大哥，谷歌更加有潜力，因为谷歌是很多ai科研论文的孵化器和发源地，ai之父就在谷歌，只不过现在离职的，谷歌的deep mind和谷歌大脑2个部门最近做出来的gemini就各种参数完爆gpt4.0，我个人战队谷歌这边。<br>  说回国内人工智能创业，通过上面的大模型技术领域的分析，技术还在变化阶段，面临着不稳定，和安全问题还没解决，那么我们国内的创业者都喜欢直来直去，就是搞钱，那么他们的赛道就不是技<br>术领域，而是aigc的上层应用领域寻找商机，也就是前文说的，每一个行业都可以用aigc重新来一遍。<br>  简单讲讲我对AI创业的理解：<br>  从大趋势判断，我认为这波AI浪潮是不亚于第四次工业革命级别的。顶级的公司赚技术的钱(客观讲蚂蚁也没怎么赚到技术的钱，大家在干卖流量和公司品牌的生意)，普通人赚信息差和执行力的钱，<br>因此看到了机会，是否躬身入局，还有是否够快就成为关键。<br>  从落地方向看，不外乎培训和开发。培训这块，圈子里目前已经有不少人赚到了500万以上，我相信AI培训未来会成为一个很大的赛道，因为AI能力是一种元能力，借助AI你的学习能力会大幅超越同<br>行。还有，未来随着大规模职业替代的发生，企业培训这块的潜力也特别大。而培训的核心在于获取流量的能力，并不是产品开发或交付，所以大家可以看到真正赚到大钱都是培训大V或有大量私域资源的人。<br>  定制化开发这块，多数其实还处于讲故事阶段。因为数据安全、合规性原因，加上GPT自身的特点，目前尚未看到实质性进展，我的判断是这块还得有个发展的过程。客观讲，要赚技术的钱并不容。<br>目前真正赚到钱的，不外乎几类。一是通过Al概念拉市值，如美亚柏科做了相关PR，市值直接翻倍，但其实也就是找了开源的大模型做了部署。目前我这边也在推荐自有大模型的定制服务。二是通过Al产品开发，获取大量的流量，如Al佛祖、AI算命等。三是做灰产的一帮人，很多人跑到东南亚去做开发。<br>  从落地场景看，真正能落地的还是得符合容错率高、通用性强的场景。毕竟GPT强的点就是“胡说八道”，那么数十个行业看下来，短期真正能产生价值的也就是营销(如短视频文案、朋友圈文案等)、<br>教育场景等。<br>  最后，我本人不会参与人工智能领域的创业，因为国内的创业都是在卷钱，卷上层应用，这个我没有兴趣，我对底层技术比较感兴趣，对技术力量有兴趣。</li>
</ul>
<h1 id="跨境电商"><a href="#跨境电商" class="headerlink" title="跨境电商"></a>跨境电商</h1><p>  在2019年底来疫情之前，跨境电商已经烧起来了，只不过被疫情压下去了，那个时候出现了连连的link+物流平台，还有四大快递:DHL、UPS、FEDEX、TNT等，知乎上、微信公众号都在写软文怎么月<br>赚70万，那个时候拼多多还没有temu，shine才刚刚展露头角，亚马逊和lanzanda已经在东南亚和全球有了牌子，跨境在那个时候，在人们的脑子里还是一个婴儿，会思考不会英语怎么做跨境，怎么找到外国客户，怎么选品，怎么了解不同国家文化的差异来上品，但是现在的temu已经成为了北美下载量第一的app，大家都在往里冲，有人欢喜有人忧，阿里的市值被拼多多超越，逼得马云在内网发帖鼓舞士气，temu之所以能够成为最近的赢家，赚到钱，是因为2个原因：第一是他的无货源模式，是一个首次打出来的商业模式，其二，拼多多靠的的是压寨商家的利润讨好消费者，获得了价格上的优势，说不好听多多就是在吸商家的血，喂给C端消费者哈哈哈。<br>  当前主要的跨境平台有temu、亚马逊、 AliExpress、eBay、Lazada、Shopee、阿里巴巴国际站、Shopify；这几家是占领市场的只要平台，我经过了一段时间的实际调研，结果如下：</p>
<ul>
<li>temu适合个人小微商户上车，不收服务费，他的注册不需要注册企业，只要个人身份证，当然平台也是支持企业用户的，temu开创了托管模式，商家把自己的货先在temu的卖家系统上架，，经过temu小二的审核和定价，审核通过后就可以把货物发到temu的国内仓库（广州、义乌、香港），快递费用商家和temu给自承担一半，到此商家的工作就完毕了，后边temu将国内仓库的货物经过船运或者空运送到世界各地的仓库，主要还是北美市场，当前现在已经有了韩国、日本、东南亚、欧洲市场，国外的用户通过temu的app购买商品，通过当地的物流系统送到客户手中，那么这里边的资金链条或者利润点是怎么运作的呢？首先是卖家有自己的供应链或者卖家自己生产货的不同，我们大部分人都是个人卖家，没有自己的工厂，那么都是有自己的供应链或者自己寻找货源，无非就是从1688选品，作为货源，比如一个篮球你从1688进货100个，由于是批发，每个篮球价格是10元，这是你的原价，然后你在temu卖家中心上架这个篮球产品，这个时候，你定价是15元一个，但是15元并不是你说了算了，是temu的小二会砍价的，他会给你砍到13元一个，你如果不认同他的这个价格，就无法上架，于是你的利润是13-10&#x3D;3元的利润，这个3元的篮球在北美或者欧洲上架，特姆会标价10美元，temu的利润是(10美元*人民币和美元汇率)-13元&#x3D;60多块人民币的利润。中间国外客户的物流、支付都不用商家参与，当然如果国外用户有退货，这个货物会首先退回temu的国外仓库，然后反运国内，或者temu将退货的商品不退回国内，直接在国外本地其他市场打折处理处理掉，然后将钱退回国内的商家，这就在国内衍生了另一个商业公司的池子，这帮公司从temu低价买入被退回的获取，然后在本地加价处理掉。整个链条闭环，也是商业模式的闭环。我买了几十块钱的temu运营相关的课程，看了一半多了，基本上了解了里边的模式，下一步会开始注册temu商家账号，进行实操，电商不管是国内还是国外玩的都是选品，temu的选品可以从temu的app里边观察商品品类空缺和一些商品的搜索关键词寻找商机，同时和其他跨境电商平台进行对比，就会找到市场上空缺但是有需求的商品，这类商品就是重点上架的类型，可以从1688和义乌小商品市场批发，想要盈利走的就是量，因为大的利润点都被temu赚去了，商家只能走量积累。</li>
<li>AliExpress是阿里的跨境平台，但是入住AliExpress是有们楷的，们楷就是必须是企业用户，需要有营业执照，因此需要注册公司，然后就是平台需要2万块钱的启动资金（服务费之类的），主要市场在东南亚、欧洲，这个没有精力和时间去深入了解，了解有限。</li>
<li>亚马逊不适合个人起步去操作，他是比较复杂的一个平台，需要认证学习它的规则，适合企业用户。</li>
<li>Shopify属于电商建站工具，如果你不想通过temu，或者其他已有的电商平台卖货，想搭建自己的域名的电商平台，Shopify提供了这样的建独立站的能力，现在独立站的典型代表就是shine，不过shine是自己开发的，将中国的货物买到国外，主要是服装品类，因为国外对中国的低价格，高品质的货物建立了很好的口碑，shine就是抓住了国外用户中国制造的民生发展出来的，扯远了，Shopify就是一个建站工具，这里在多说几句，Shopify的市场需求在海外，为什么这么说呢，在国内消费者为了安全起见，不会进入一个不熟悉的平台或者网站购物，因为担心商品品质和金融安全方面的问题，但是老外不是这么想的，老外很喜欢在独立站里边购物，因为独立站让老外觉得很独特的商品（独立站的商品都是垂直类的品类，会着重突出独特商品特点的修饰），然后还有一个就是，这些独立站接入了跨境支付系统paypal，接入的商家都要经过paypal的认证和审核以及实名，这就让老外觉得心里踏实了很多，即，不要用我们自己的认知去看世界上其他角落的文化和思维的差异，因地制宜的去进行商业活动。目前Shopify并不是很安全，从2023年开始，很多做saas的公司，推出了自己的独立站搭建系统，都是低代码设计，这个领域对于开发人员来说很容易入门和理解，不过这个领域的软件方面的创业竞争现在也很激烈了，没有进入的必要，roi太低了。</li>
<li>eBay、Lazada、Shopee没有过多了解。</li>
<li>阿里巴巴国际站其实就是1688的跨境版本，提供的批发服务部，没有过多了解。</li>
</ul>
<h2 id="做跨境电商的目的是什么？"><a href="#做跨境电商的目的是什么？" class="headerlink" title="做跨境电商的目的是什么？"></a>做跨境电商的目的是什么？</h2><p>  在回答这个问题之前，我们先回答一个问题，我们工作的目的是为了什么？为了赚钱吗？为了生活吗？还是为了家庭？这些答案太大了，我们打工的目的是为了不工作，打工的目的是为了完成原始积累，有了原始积累才能进入资本主义的资格，通过资本主义的积累完成财富的积累，才能完成无产阶级的翻身，摆脱打工奴隶的枷锁，资本主义的积累是通过剥削和提高生产效率获取的，这里需要劳动力+生产资料+提高生产效率&#x3D;剩余价值，剩余价值就是资本，劳动力就是工人、生产资料就是劳动力生产商品的载体和介质，比如工人用的电脑，以及电能、打印纸、物料，矿石等，都是生产资料，提高生产效率就是提高机器制造商品的效率，那么这个过程要想获得最大剩余价值，就需要让劳动力加班或者增加工作强度，同时采购的生产资料价格低和耐用，以及提高机器的生产效率，那这个和选择做跨境电商有啥关系呢，关系就是这个等式需要进行产品的生产和市场运作，是一个资本积累的过程，跨境电商是一个和微型的资本主义积累的模型，很适合小白起步，你怎么选品就是提高产品的竞争力，以及你自己是劳动力，同时你要高效的完成运营工作，这些步骤都在这个等式里边，从而达到剩余价值，完成积累，这个很适合小白练手，投入最大也就是亏损几万块钱，如果赚了，你同事经商思维也就建立了起来了，以后也就脱离打工思维了，这样就逐步开始了创业经商的道理，以后干什么不重要，但是建立了一套经商的模型。</p>
<h1 id="自动化领域"><a href="#自动化领域" class="headerlink" title="自动化领域"></a>自动化领域</h1><p>  这个涉及到嵌入式技术领域的学习，当前进度都在可控制的范围之内，嵌入式领域学习的动机是从当前人类技术发展趋势去思考推理的。<br>  从马斯克特斯拉的无人工厂汽车制造产线，到国内的无人水饺生产，以及通用机器人的发展，都在暗示一个信息：这个人类文明都在讲进入自动化革命，工厂的终极形式是无人工厂、交通的终极形式<br>是无人交通和无人驾驶，太空旅游的终极形式是无人发射和回到地面，这种自动化会给整个人类文明带来变革，是生产力的提高，是生活水平的提高，自动化设计的领域有人工智能、机器人、大数据三个领域，先说人工智能领域，对于创业的入门们楷很高，它的方向当前不是技术创业，而是应用层创业，因为大模型还在发展阶段，openai和谷歌、特斯拉的人工智能目前还在竞争阶段，没有稳定下来，国内的企业没有一个能打的，都是垃圾，和美国的人工智能水平差距最起码有2年的时间才能追赶美帝国。那么创业者只能从人工智能的应用层面去实现财富的积累，比如教育、办公、培训之类的，这些事情本质是运用，而不是技术，都是赚快钱，如果全国人民都干这些通过短视频或者自媒体去玩这个，中国的技术实力怎么提升？底层都是垃圾，除了华为能打，其他的都是弱鸡，因此人工智能的应用领域这条路了不符合我的尿性。再说回自动化的第二个领域，机器人，机器人是宽泛的概念，并不是人型的机器人，说的是所有完成自动化流程的机器，比如自动化的流水线也算是机器人，这个领域很适合我们玩技术的去突破，去学习，未来的方向很多：无人工厂、无人加油站等。第三个领域是大数据领域，这个领域其实是可以归类到人工智能领域，把它单独拿出来是因为数据一个独特的领域，他可以做推荐系统、为人工智能提供数据资料学习、以及数据的存储。</p>
<h1 id="非洲市场调研"><a href="#非洲市场调研" class="headerlink" title="非洲市场调研"></a>非洲市场调研</h1><p>  肯尼亚、卢旺达、赞比、津巴布韦、埃及这几个国家在非洲还算是比较和平的，适合开展商业活动，对于普通人角度，怎么坐上这些国家从一贫如洗到国家飞速发展的快车是很重要的，这类国家经过了几年的战争的洗礼，没多少钱，老百姓也适合中国刚开始建<br>国时期差不过的生活，不适合开张重工业、高科技领域的商业活动，但是很适合从事轻工业、电子方向的创业，比如做服装、鞋子的华坚集团在埃塞尔比亚建立了 <span class="exturl" data-url="aHR0cHM6Ly93d3cuaHVhamlhbi5jb20vY2hhbmd5ZS9jaGFuZ3llNDkuaHRtbA==">轻工业城<i class="fa fa-external-link-alt"></i></span>，制造鞋子和服装以及简单的电子产品，这类产业第一是可以收割非洲兄弟廉价的劳动力，第二是轻工业在贫穷国家他们能消费的起，有庞大的消费群体，这对企业来说缩小了劳动成本，第二市场空间巨大，商人无利不起早，这就是利用杠杆快速收割和积累资本的真实案例。<br>  华坚集团董事长的女儿，目前也在非洲从事家族企业的拓展和业务开展，同时在国内通过自媒体扩大国内的商人重视非洲的商业机会，华坚为中国的小微企业进入非洲市场软着陆做引导，当时这也是华坚商业版图里边的一个拼图，他们计划垄断非洲轻工业，从<br>供应链到当地政府和劳动力，还有陆续进入非洲市场的中国商人都纳入他的商业圈子当中，形成资本控股和投资绑定，这个是非常高端的商业战略，是一种长期注意商业谋略，如果你对非洲市场和华坚集团有兴趣，可以关注微信公众号“非洲大小姐”。</p>
<h2 id="航天行业调研"><a href="#航天行业调研" class="headerlink" title="航天行业调研"></a>航天行业调研</h2><p><span class="exturl" data-url="aHR0cHM6Ly9wZGYuZGZjZncuY29tL3BkZi9IM19BUDIwMjAxMDIyMTQyMjk0NTMwOF8xLnBkZg==">2020年中国商业发射行业概览<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><h2 id="谈一下理性"><a href="#谈一下理性" class="headerlink" title="谈一下理性"></a>谈一下理性</h2><p>  先说结论：这个世界是非理性的，但是存在自发秩序。<br>这里界定一下理性的范围，只讨论理性的哲学分类和利弊，而不讨论什么是理性的什么是感性的。<br>  在哲学范畴，诺贝尔经济学奖得主哈耶克认为，理性分为两个流派——构建理性和演进理性。<br>构建理性认为这个世界是可以被规划的，它假定人生具有知识和道德禀赋，是理性的，我在设计一个花园的时候，我根据归纳和演绎推理设计了三条小路，它是完美的理性产物，在经济学里边，计划经济属于构建理性的产物，哲学上卢梭和笛卡尔是这个分支的代表。<br>  演绎理性认为：个人理性是十分有限的和不完全的，理性在人类事务中起着相当小的作用，各种实在的制度，如道德、语言、法律等并不是人类智慧预先设计的产物，而是以一种累积的方式进化而来的，所以我在建设一个公园的时候，没有在里边铺路，人们自己<br>会在公园里边走出来很多路，这个在经济学上叫市场经济，哈耶克叫这个为自发秩序，有一只无形的手在控制着市场的流动，那是什么形成了这只无形的手？<br>人类商业活动中最关键的因素，深藏在能看见的表象之后，商业的驱动力不依赖人的某种道德，也不依赖于人的某种善心，更不依赖于“管理者”的计划，而是依赖于一种自由交换中利己主义，也就是说人类自私的基因驱动人做出不断利他的事，不断拓展了商业的新边疆，管理者的干预只会干扰这种精妙而又有序的自发秩序。<br>  那么构建理性为什么不能设计和构建出更好的社会或者市场呢？为什么构建理性应用在人类社会和人性时总会引发文明危机和反抗呢？为什么公司的管理者对底层越是无微不至的控制、亲力亲为、说服、pua、制造361焦虑长期来看会给管理者和企业带来反噬呢？<br>今天逼人王某来回答下这个问题，第一，知识的分散性导致无法被计划，在社会实践中，有一种知识是特定情形下人的特定判断，比如你去逛街看到商场琳琅满目的衣服你想购买，而你的这种购买需求是基于你的个人需求，美学判断，性价比评估，自身的经济条件作出的综合判断，这种判断藏在每个人的脑中，是一种分散的知识，而那个高高在上的计划者、管理者是永远也不会知道的，就算是交流沟通，也会被人性的自利所隐藏。它是一种个体对市场的洞察和判断，是我们所说的市场的敏锐度，一个统一的管理者、计划者是无法具备这种洞察的，只有依靠无数的个体，在复杂的市场中独立做出决定，他才能比哪个不接触市场的高高在上的管理者拍脑袋所做的决定是更好的。我们经常说的大公司病，体制病，其实，归根结底是计划思维下从上到下的指令性组织模式导致的，所以现代公司都以事业部或者小部门独立运营的模式存在，而所谓的扁平化管理就是为了减少层级，减少计划过程中你和计划中枢即管理者之间的沟通成本，而把决定权交给底层部门，这是考虑到知识的分散性。<br>构建理性无法获得成功的主要原因是在于价值的主观性，这个问题的原因是：计划可以做，但是到底应该由谁来做，比如你正在谈恋爱，你需要对自己的未来幸福负责，于是你计划找一个什么样的哥们，你自己做这种计划当然没有什么问题，因为自己的选择结果自己承担就好，因为自己约的网友含着泪也要陪他吃完饭，但是你把这种计划的权利交给隔壁的美女主播心机好闺蜜翠花，事情就会发展成这样：翠花觉得楼下的抠脚武大郎很憨厚老实，很符合你的气质，让你去勾引他，于是矛盾就产生了，楼下抠脚武大郎是隔壁翠花的爱好，和你一毛钱关系没有，你只爱高富帅，但是隔壁翠花只帮你做计划，他也不会对你的最终结果兜底，你勾引了楼下的抠脚武大郎，只能导致你的心情抑郁烦躁，最后干脆自闭沉默，你说这样的计划和理性能成功吗？所以因为价值的主观性，计划的主体必须由个体完成，如果由隔壁翠花帮你做计划，会导致这种计划的必然失败。<br>  综上，构建理性在构建复杂的人类社会必然失败的原因主要还在于理性有限，而是在于知识的分散性和价值的主观性，知识的分散性导致计划者不能及时掌握事物的变化，而价值的主观性导致计划者无法了解你的心理需求，他们共同导致计划思维的必然失败，所<br>以苏联的计划经济必然失败，管理者强制施压下层按照自己个人的意志思想行事必然失败，你强迫你的对象按照你个人的独行的爱好和风格去治理感情和家庭关系必然失败。<br>有人说大数据技术现在这么成熟，用大数据可以提高效率和审批速度，便于计划者快速掌握所有的数据，这样就可以实现纯粹的构建理性了吧，也不能，因为大数据在牛逼，也无法计划人性，更加无法计划人的自由意志，就像三体中的智子它秒杀了现在AI几个数量级，它神一样无所不在无所不知，但它依然无法知道人们大脑中的想法，人类的思维人类的自由意志，是任何机器无法预测的。<br>我们要承认我们的知识和理性的局限性，承认人的自私，我们要尊重一种基于人的主观的行动，所带来的结果，而不认为理性是无所不能，因为完全相信理性就是一种理性的自负。<br>不过构建理性的主场是用在和人和社会没有多大关系的领域，科学研究、实验推理、软件开发、制造工艺提升等领域。</p>
<h2 id="义乌小商品市场调研思考"><a href="#义乌小商品市场调研思考" class="headerlink" title="义乌小商品市场调研思考"></a>义乌小商品市场调研思考</h2><p>  义乌国际商贸城五个大区，每个大区在电商品类里边都有商品，厂家直销批发，进来选品溜达了一天多，看到最多的是中东，非洲的商人，义乌商品交易所大部分广告都是四种语言介绍（中英俄和伊斯兰国家语言），很多商品是你在各大电商平台看到的爆品，<br>但是在这里它就摆再一个普通的角落，如果做电商，选品是核心，菜鸟要对商品和品类先有一个概要的认识，学习电商运营知识，以前我们都在提跨界学习，复合型人才，鄙人觉得技术➕运营➕自媒体➕外贸就是跨界，外贸其实可以放在自媒体里边，自媒体的核心是跪舔自媒体平台的算法，同时佐以人的欲望为杠杆。</p>
<p>  目前我们处于一个混沌期，不知道全球商业趋势要去哪里，国内AIGC、还有自研的芯片纳米级别还在蓄力阶段，但是正是由于这种混沌过渡期，以及全球对社畜裁员频繁，可以看出全球商业版图要变天，这几年会有大的事情发生，我认为可以归纳预测出2个核心<br>思想：<br>  第一，单一化生存技能抗风险能力不可控，学习更多的编程技术，只会变得迟钝和更加贫穷，但是保持对新技术的关注和思考他的应用价值，然后指导你是否去投入时间成本学习，最后需要多领域能力建设，从0开始摸索，寻找商业机会，必须是蓝海领域，建立<br>此领域认知，思考，融合，设计，生产，运营，变现。<br>  第二，独立思考和认识更多能够独立思考的人，远离沙雕微博、沙雕抖音、沙雕微信视频号的信息茧房，对当前工作持上帝视角看背后本质逻辑和商业模式，对不是志同道合的人沉默即可，只有同一类人才能看懂同一片风景。</p>
<p>  最后温馨提示一下，义乌小商品商贸城，一个店铺400万起步。</p>
<p><img src="https://s2.loli.net/2023/12/15/GZXe5Hh87C6kQtr.jpg" alt="42cfc5d5235eae2659b1fb1bc7340c9.jpg"></p>
<p><img src="https://s2.loli.net/2023/12/15/rXPEuxL96IDTJ3O.jpg" alt="4d97b33d8791ed665fd8903abdae927.jpg"></p>
<p><img src="https://s2.loli.net/2023/12/15/IG4ABWqFnkNmjZO.jpg" alt="cbc28d384413c12256bcbaf5886d8db.jpg"></p>
<p><img src="https://s2.loli.net/2023/12/15/sAeXJQmF76xCabM.jpg" alt="2fa25e10a7c01b862f1363670239d47.jpg"></p>
<p><img src="https://s2.loli.net/2023/12/15/sRD4Lpm9yQEaNhw.jpg" alt="e54464ceeb53459094ffab89bf47889.jpg"></p>
<p><img src="https://s2.loli.net/2023/12/15/el9SkmCqUijM2Jg.jpg" alt="945cf7f97c36773ad8da7a510c13458.jpg"></p>
<p><img src="https://s2.loli.net/2023/12/15/vbKcryBmpxJ8IaY.jpg" alt="e12084daa92a0f3abbb0bebb92d4ac7.jpg"></p>
<p><img src="https://s2.loli.net/2023/12/15/R1jafC5quliJENQ.jpg" alt="65a5b2a1556ca3e7a494f5f552da075.jpg"></p>
<p><img src="https://s2.loli.net/2023/12/15/rsSgyP2EGMlXfjn.jpg" alt="2b006f0d48759b3a357ec05191315f5.jpg"></p>
<h2 id="参加google-IO开发者大会的思考"><a href="#参加google-IO开发者大会的思考" class="headerlink" title="参加google IO开发者大会的思考"></a>参加google IO开发者大会的思考</h2><p>鬼混了一天，说几点在AI赛道的点：</p>
<ol>
<li>垃圾分类不久就会脱离人工筛选，实现机器垃圾分类，随着机器人技术结合大模型的端到端打通，依托AIGC的训练知识库，机械臂天然的就知道当前处理的是什么垃圾，这个能提高垃圾分类效率，每个小区里边的“垃圾分类专员”会消失，工业固体废料领域也会赢来改革，其他制造业想象空间很大，制造业会迎来提效</li>
<li>谷歌的aigc（palm之类的） 收费很贵，一次图片生成两美分</li>
<li>像是生成式电商模特（参考阿里的塔玑）、试衣、工业物件识别等依托人工智能技术的创业项目，很多企业已经借助谷歌的大模型已经获得了成功，并且拿到了VC，而且谷歌针对这类项目非常青睐，谷歌单独针对这类项目的创业公司和投资机构牵线，有红杉资本，IDG，高瓴创投，帮助创业者更好的出海，谷歌内部有一个单独的团队干这个事情，叫出海加速器，该团队提供商业模式指导，投资人牵线，技术指导，其中一个人工智能支撑很友好的平台是Mediapipe，开放式的API。</li>
<li>谷歌做广告很专业（它的老本行），ADMob这个很有意思，得研究下，天下的生意归纳为一个概念就是“卖货”，广告、营销是摸索商业模式当中必须搞明白的环节，学习下巨头再这方面的沉淀，很有指导用途</li>
<li>谷歌很多服务都是开源的，但是我为啥不知道？，国内的人工智能技术发展和国外距离还不小，如果要让墙外的技术公司进入国内市场，国内能打的企业都不行，而且我觉得，卷大模型没必要，它变化速度很快，并且都在逐渐开源，你大兴土木做出来以后，可能已经被淘汰了，智能道路上，卷应用才是正确的方向，找适合智能改造的行业和应用或者场景，变现快，技术门槛低，不过我们的国内市场一直是向钱看，技术创新都是“GitHub 进口”，很多人抱怨中国人太肤浅了，全是生意，毫无技术创新能力，这个是另一个问题，今天不讨论。</li>
<li>机器人端到端谷歌已经开始搞了，国内智晖君也在入场，将大模型的一端的输出给机械，机械这一端做出行为动作，物体识别都在大模型这一侧，智晖君是不是在做b站博主的时候，就已经规划到了这一步，非常的超前，步子迈得很大，风险极高。</li>
<li>这次大会谷歌不仅炫技，重要的一个点是它在帮助国内创业团队起步，有商业模式指导，有具体行业数据报表，有基于它的技术能力的创新应用，回到个体你会发现这些虽然他给你提供指导，但是你可能吃不下，因为很多创业者缺少商业思维逻辑，没有方法论，步子太大，很容易死掉，从我个人来说就缺少运营、销售、创投圈交流资源、线上流量，全部都需要学习，也不是说学完了再干，而是选对方向，边踩坑边学习，而且这个个人去玩，过程不能说你不喜欢这个思路你就不做了，市场淘汰你不会和你打招呼，市场遵循的是客观规律，遵循市场经济自我调节规律，这个不以人的意志为转移，尊重客观规律，就是在顺应风口，切勿有不切实际的个人坚持，除非这种坚持符合市场客观规律……</li>
</ol>
<p><img src="https://s2.loli.net/2023/12/15/f8OE3mVJhWucF4C.jpg" alt="d66e471dc4378457d16d2812757232f.jpg"></p>
<p><img src="https://s2.loli.net/2023/12/15/1o8dswLSnTHrQva.jpg" alt="5ce98d7bf6553af26ca203490bfc23c.jpg"></p>
<p><img src="https://s2.loli.net/2023/12/15/ynkQzrsU5d7paIm.jpg" alt="33ae267deacbb89868e2ddb0e1b8dd2.jpg"></p>
<p><img src="https://s2.loli.net/2023/12/15/AedpWykLMBDqPhE.jpg" alt="e0788be2ff20c9f7e36b3af7da23841.jpg"></p>
<p><img src="https://s2.loli.net/2023/12/15/2kZlJoRvbgYd31C.jpg" alt="3eb7e7204d34e12b2f290c9b5fb29b3.jpg"></p>
<p><img src="https://s2.loli.net/2023/12/15/bpR6mA3VgxTCrFa.jpg" alt="feb33f72b54c763d0b351d0389d2834.jpg"></p>
<p><img src="https://s2.loli.net/2023/12/15/YToE1pc8LIW7djD.jpg" alt="bed5e727731bcb9f7a2f6d9b4e4aee1.jpg"></p>
<p><img src="https://s2.loli.net/2023/12/15/47CLctvbpJ61qlR.jpg" alt="3dba7ed81e989659bb0b199a6c0858e.jpg"></p>
<p><img src="https://s2.loli.net/2023/12/15/imPNYJ9rFlBgGT6.jpg" alt="f79f8c22265896872bb2e51e6051d42.jpg"></p>
<h2 id="为什么西方不断涌现理论创新？"><a href="#为什么西方不断涌现理论创新？" class="headerlink" title="为什么西方不断涌现理论创新？"></a>为什么西方不断涌现理论创新？</h2><p>为什么西方不断涌现理论创新？<br>人的创新能力到底是哪儿来的？<br>它能不能被规划出来？</p>
<p>我从思想哲学的角度阐释这个问题，同时挖出西方创新的根本性来源。</p>
<p>  先举个例子，如果你问我火星的土壤成分是什么，我虽然不知道答案，但是我知道如何获取答案。因为这个问题有着清晰的路径，虽然答案也不一定正径，但是这个问题本身非常清晰。但是如果你问我宇宙有没有尽头，物质世界到底是不是真实的，什么是正义<br>等等，那么我可能就没法回答，因为这种问题没有确定的方向，更不要说标准的答案。这类问题面对的是茫茫的人类认知的未知领域，我们根本不知道要往哪走。<br>  我们把第一类问题叫做技术问题，第二类问题叫做理论问题。<br>  技术问题其实并不难，它的路径清晰，基于现有的理论，做实验、做观测，总会靠近答案。比如基于电磁波理论的通讯技术，基于图灵理论或者量子力学理论的计算机技术。技术问题其实是可以设计和规划的，因为技术的背后有确定的理论、确定的方法，只要<br>研发团队庞大、资金充裕，持续深耕，都可以实现局部的技术创新。比如日本，他们就非常擅长技术创新，把很多技术发展到了一个较高的水平。但是第二类问题就完全不一样，比如什么是正义物质世界是否是真实存在的，宇宙有没有尽头等等。这些问题没有清晰的路径，它的背后是人类认知的莽荒地带。对这些问题，我们需要解决的不是答案是否正确的问题，而是通过什么样的路径去寻找答案的问题。所以，第二类的问题，也就是理论的问题，它的本质是一种尝试，我们需要找到的是抵达答案的那一条路。这就好像掷骰子，也好像是在黑屋里抓一只黑猫，它充满了不确定性，我们无法依靠规划去把投子掷出一个你想要的点，我们也无法依靠规划去抓到一个黑屋子里的黑猫。面对未知，就算是庞大的研发团队、大量的资金投入，或者是持续的深耕，都可能打了水漂，你的资金可能达到了错误的方向。你庞大的研发团队可能在做无用功，你持续的生根可能是老驴拉磨在兜圈子。其实，人类所有的那些前沿的理论创新，它根本不需要技术的积累，也不需要经验的传承和循序渐进。他们的发生往往是突变的、偶然的、无法被计划的，它只能依托于个体的天才和灵感。<br>  创新一般具有这两个特征，第一，创新阐释问题。比如牛顿用引力假说和惯性假说重新阐释了亚里士多德四元素的运动观，他重新定义了运动的本质，拉开了古典力学的大门。第二一种颠覆式的破坏。比如康德的认识论，他把人们传统上认为的人是围绕着自然<br>课题去认识世界的思想做了彻底的破坏。他指出了只有自然课题符合人的先验形式，才可以被人认知。这一伟大的变革，不管是重新阐释问题还是对原有问题的破坏，都取决于个体的灵光乍现。这种知识隐藏在每个个体中，他无法通过规划和设计实现，甚至和努力积累都没有关系，他属于绝对的个体天赋。这些天才通过转移重点、置换条件、颠覆思维等等方式，从那些司空见惯的问题中找到了前人看不到的角度，从而颠覆了人们的宇宙观。所以，要保持创新，就要捍卫天才的想象力和思想的自由度。但是因为创造力源于对传统观念的颠覆。不可打破。所以天才的想象力往往具有破坏性，他们对传统社会是危险的，正如哥白尼的日心说对基督教是危险的，达尔文的进化论对神创论是危险的。所以，当一种文明以稳定作为唯一的追求时，会本能地把这些危险的创新扼杀在摇篮里。因为解决掉这些危险的思想、危险的创新比解决那些问题更加重要，也更加简单。所以，我们现在可以理解为什么西方成为理论创新的摇篮。<br>  这一切都因为西方并不是一个稳定的社会结构，而是典型的二元对立的结构。神权、世俗权力的博弈，私权和公权的对峙，以及不断谋求发展、寻求变革的工商业文明，都让西方处于一种绝对的、动态的变化之中。这种动态的二元结构非常危险，但是也充满。<br>张力，他为创新保留了一片土壤，让众多的理论得以萌发和生长。</p>
<h2 id="怎样洞察本质？"><a href="#怎样洞察本质？" class="headerlink" title="怎样洞察本质？"></a>怎样洞察本质？</h2><p>  很多人在看热点新闻评论时，总会觉得自己像个二傻子，因为他看到每一派的观念都觉得说的对说的好说的有理，到最后把自己搞得精神分裂，骑在墙头，左右为难。比如，经管游戏行业出于何种目的考虑取缔，校外教培行业要不要支持？我们应该如何看待饭<br>圈文化等等。如果你看一个问题，最后总是选择了貌似公允的各打五十大板，并试图通过自己都没搞明白的辩证逻辑安慰自己，这是允之阙中的中庸之道。那么这里可能存在很大的误会，因为你可能并不是允之阙中，而是压根儿没有自己的观点。因为真正的大师一般观点鲜明，很少骑墙。出现骑墙的最大可能是你没有价值观。价值观缺失是因为没有找到自己的逻辑原点。我们所有的观念都源于一个原点，这就是底层价值。它类似于几何中的公理系统，比如两点之间直线最短，比如凡是直角都相等这些自名的理论。只有当我们根植于这些底层价值观，并依托底层价值观对一个问题做出推导和判断时，我们才可以形成自己的逻辑体系。比如关于饭圈文化，一个你认为的弱智顶流，饭圈女孩有疯狂追捧的自由吗？而他们的追星的自由边界在哪里？在这个思考的过程中，你会逐步追溯到自由的边界这个原点。当你认为顶流靠脸吃饭的小鲜肉赚几个亿，而你辛辛苦苦月薪和我一样2800的时候，你就会追溯到诺契克和罗尔斯怪异天赋和公平的理论。你会认识到诺奇克说的更符合逻辑，其实脸就是天赋。比如在分析监管游戏行业到底应不应该这个问题上，我们会考虑到儿童到底具不具备自由意志这个问题，多少岁的儿童可以默认为无自由意志，而对于无自由意志的儿童，我们如何通过父权意志对其进行管理等问题。比如，在分析取缔校外教培行业的问题时，我们可以考虑教培行业到底有没有导致内卷？如何定义内卷内卷和市场正当竞争的区别是什么？在对这个问题进行深入思考中，我们会逐步认识到，内卷是没有增量而在系统内做低水平重复的一种行为，而竞争是产生增量并且突破现有系统的一个过程。我们如果用这个底层价值去衡量校外教育培训是内卷还是正当的竞争，思路就会非常清晰。再比如关于安乐死的问题，如果你反对安乐死，你依据的价值观可能是宗教信仰、儒家孝道或者生命第一原则等等。而如果你赞同安乐死，你依据的价值观可能是个人主义，个人对自己的生命具备完全的主导权。<br>  这个原则不同的底层价值观，会导致对一个命题完全不同的判断。而大多数问题追溯到最后，我们都会来到一堵墙边。这个墙就是我们最底层的价值观，是我们的逻辑原点。它类似于电脑的操作系统，在这个操作系统上只能搭载符合这个操作系统的软件。这个<br>思想操作系统大概有几个类型，我简单归纳如下：</p>
<ol>
<li>集体主义和个人主义的区别。</li>
<li>自由市场和监管主义的区别。</li>
<li>古典自由主义和新自由主义的区别。</li>
<li>自由意志和父系意志的区别。这里不做展开。<br>  有些人说，观念没有对错，只有阐释的立场不同。尼采也说过，没有本质，只有对本质的阐释。这个说法在某些角度是对的。在不同的观念冲突中，只有保留了多元的观点，才能对事实做出清晰的认知。但是，现代文明也形成了一些基本的价值共识，这些共识<br>除了逻辑的先进性，更是靠无数的历史经验总结而来。当你违背了这些思想，就会对文明构成巨大的损害。比如古典自由主义原则，比如保障个体的自由、财产生命的原则，比如自由意志的原则等等。只有我们找到我们观念中的逻辑起点、价值起点、道德起点，才能在纷杂繁琐的社会问题中拨云见影，洞察本质。</li>
</ol>
<h2 id="读《资本论》有感和思考"><a href="#读《资本论》有感和思考" class="headerlink" title="读《资本论》有感和思考"></a>读《资本论》有感和思考</h2><p>  最近在看《资本论》抒发和摘录一些个人的观点：</p>
<p>  如果在一个社会经济形态中占优势的不是产品的交换价值，而是产品的使用价值，剩余劳动就受到或大或小的需求范围的限制，而生产本身的性质就不会造成对剩余劳动的无限制的需求。如美国当年黑人奴隶种棉花，若只是满足自己需要，就会显得温和；但若<br>是出口，就会迅速变化为恨不得把黑人生命耗尽。由这可以看出，资本家对工作日的延长，和领主对徭役劳动的追求，是一样的，即对剩余劳动的追求，或者说对剩余价值的无尽贪欲。<br>﻿<br>  但是，这种贪欲是要限制的，不仅是从工人的角度，哪怕是从资本的角度，可类比田地枯竭，过度掠夺剩余劳动，是对国家生命力的摧残。对此，马克思列了大量英国十九世纪关于陶工、面包工、铁路工的记录和调查报告，充分展示了过度的剥削带来的集体性<br>的触目惊心的严重后果。在此不做展开，但得说一句，详细的冰冷的数据，搭配《觉醒年代》观看，确乎让人生出“资本家，即资本的人格化身，都应该挂路灯”的想法，并意识到为什么要建立共产主义社会，为什么要革命！这不仅是站在工人阶级的立场，为了自己的权益而斗争；更是站在全人类的立场，若任资本及资本家肆无忌惮，可能整个人类都会在极短的时间内将所有未来的潜力挥霍一空，更遑论生产力的发展会受限了！</p>
<p>  这里马克思列了大量从14世纪末到成书前（19世纪末）的关于争取正常工作日的斗争，详细的起因经过结果调查和反思，在此挑选几个列举，可自行感受：</p>
<ul>
<li>1349年，第一个劳工法，以鼠疫为由，强制规定了“合理”工资和工作日界线——5点到20点，即15个小时。</li>
<li>1833年，英国议会把四种工业部门的13-18岁童工的工作日缩短为12小时。</li>
<li>1844年，工人的反抗开始，《补充工厂法》，保护妇女——工作时间限制为12小时，禁止做夜工。</li>
<li>1847年，新工厂法，少年和女工工作日限制为10小时。</li>
<li>1866年，日内瓦召开的国际工人代表大会上，根据马克思的倡议，首先提出“8小时工作制”的口号。</li>
<li>由此往后，续上20世纪时间线：</li>
<li>1917年11月11日，苏联颁布了《关于8小时工作制》的法令。</li>
<li>1919年10月，第一次世界大战后，8小时工作制被国际劳工会议所承认，此后资本主义各国被迫陆续确认了8小时工作制。</li>
<li>再往后进入21世纪：<ul>
<li>2019年，“996是福报！”</li>
<li>2021年，“取消大小周！”</li>
<li>2023年，“pdd 11-11-6 at least”</li>
<li>……<br>我们可以清晰地意识到，所有似乎理所应当的权利，都是斗争来的；所有斗争一但放松，资本家就会骑到工人头上来（无人不怀念苏联，怀念那个真正的赤色联盟，而不是那个变了质的红色帝国）。<br>“我们要实行八小时工作制，我们要闻闻花香，我们要晒晒太阳，因为我们相信，上帝只让我们工作八小时，我们争取八小时工作，八小时休息，另外的八小时，留给我们自己！”——李大钊</li>
</ul>
</li>
</ul>
<h2 id="思考力的重要性"><a href="#思考力的重要性" class="headerlink" title="思考力的重要性"></a>思考力的重要性</h2><p>  在一个组织里边，不知道大家有没有这样的感觉，你和别人在家境、家庭资产、配偶、教育过程、人生经历，都么有差距十分悬殊的个例，比如富二代，有家族企业，或者祖上是革命烈士和文史大<br>家，等等，但是为啥会出现那么多的职级？p6，p7，p8，p9，p10，是因为他们脑子聪明吗？我承认有个别清华、北大、复交的，他们从小就是成绩优异，积累了好的学习惯性，但是你和这批人去交流和互动的时候，你发现他们的生活、做事情也是和你差不多的，那么出现差距的问题是在哪里呢？<br>    个人认为是出现在思考力的差距上，你可以理解为是“善于思考的勤奋”，而大部分是“善于体力劳动的勤奋”，同样的一个现实问题，比如做一个数据看板，“善于体力劳动的勤奋”这批人仅仅是按照<br>业务侧的需求，老老实实的去用技术的语言实现出来，到这里就截止了，第一，他们没有去深度理解和思考这个需求背后的逻辑，第二就是没有站在现实世界去看待这个问题，从现实的生产制造人类的需求的角度出发去看待这个问题，总是就是做这个事情的维度在狭窄了，以至于限制了自己，从而没有调动自己的脑子去思考，但是说回来，大部分牛马的工作态度仅仅是为了养活家庭和自己，打工的心态，为了生活而已，不会关注一些和自己赚钱没关系的“深度思考”，拿钱干活，界限分明，最后永远在这个怪圈里边死循环。<br>    思考力是一个过程，而结果是认知，认知的获取可以是读书、交流、痛苦的经历，但是这些都是人的思考在推动去执行的读书，思考去推动执行的交流，由于发生了痛苦的事情，逼迫人去思考，从<br>而产生了动力和实践。<br>    我们要把我们的工作、生活当做一个训练场地，而不是实战，有了这个心态，你就会觉得，人生就是一个游戏，而这个游戏的目的是为了提升人的能量和认知，有了这个2个结果，你会发现，你已<br>经超越了大部分人的圈层，最起码现在意识形态上超越了，你做任何的事情，都会全情投入，高超的精力、专注力、思考力投入进去，这个过程充满了紧张、刺激、激动、热血和眼泪，你在激流当中存在，你在游戏当中升华，你在自己的付出和结果当中迎来开悟，这就是人活着的意义。</p>
<h2 id="守护自己的能量"><a href="#守护自己的能量" class="headerlink" title="守护自己的能量"></a>守护自己的能量</h2><p>  做一件事情，尤其是一件很难的事情，要想拿到结果，需要一个人的冲击，不畏失败的冲劲，这个冲劲就是能量，他也体现在解决问题的能力上，在学习嵌入式和相关硬件知识的过程中，需要去思考<br>一些问题，投入精力，这个过程经常会被打断，朋友之间的讨论、公司电话、为别人处理生活工作问题、家人电话等，你有时候一唠就是几个小时，后来你一想，完全没必要花那么多时间去啰嗦和在交流当中去发散，以至于浪费了很多时间和能量，你再把上下文切换到你的学习领域，你会感觉没劲了，泄气了，然后陷入给自己找借口今天休息和继续学习的纠结混乱之中。<br>  其次就是远离能量低的人或者消耗你能量的人，这个在工作、生活、婚姻、感情当中都存在，这类人还没有开窍，没有完全的认识自己，全凭一腔热血和情绪在做事情，没有理性系统和自己的人生模<br>型，这会让你陷入低能量的漩涡，拉低你的能量，我们要和比我们高能量的人在一起交流，但是我们也要向高能量的人提供价值，而价值需要原始积累和知识，这个是需要拼接自己的意志力去积累的。</p>
<h2 id="讲一个原始积累的寓言故事"><a href="#讲一个原始积累的寓言故事" class="headerlink" title="讲一个原始积累的寓言故事"></a>讲一个原始积累的寓言故事</h2><p>  很多人一辈子做牛马，就是因为不懂得原始积累四个字，他往往在享乐中就把好不容易辛苦赚来的一点积累就消耗掉了啊，所以呢，永远在牛马中轮回啊，甚至世世代代无法脱离。那我们说要回到<br>原始社会才能看清人的本质啊，今天我们就来到了原始部落，<br>这个部落有一个山，山顶上是小白在居住，他们荣华富贵，不用去打猎，不用去摘果子，就想不尽的什么吃的喝的玩的啊，然后半山腰是小黄，小黄呢是一些技术专家啊，他们会知道怎么最快的把这个果子打下来，或打猎的时候怎么走什么路线，对吧？或者这个小黄是一部分是管理者，他会传达这个小的什么命令给下面，最下层是什么呢，非常多的什么牛马啊，就是村子里面有非常多的牛马，是小黑居住的地方。<br>那么在这个村子里面有一个第一代小黑啊，他刚开始不合群啊，自己饿了就摘果子对吧，渴了就喝水啊，有时候还打打猎，但是呢，打完猎之后他就躺下了。<br>于是也没有结婚，对吧，也也娶不上媳妇儿，更不用谈孩子了。很快在他20多岁30岁的时候，由于没有积累，导致什么饿死了。<br>于是他心里面非常不甘心，他说村子里面其他人都活得好好的，为什么就我早早饿死了呢？原来是我不够勤奋，我一定要融入到这个村子里面，向大家学习，这样才能活下去。所以他发奋，呃，这个发誓啊，如果再给我，顺便再给我一次机会，我一定要向大家学习啊。很庆幸的是，他投胎继续来到了这个村子。<br>这一世的时候，他积取了上一世的经验，在村子里面什么积极的融入大家的社会啊，这个小村子里面的其他的小黑黑啊，跟他们呢，一起什么努力的去打猎，努力的去摘果子啊，这样有一点银余，还能什么给自己的房子装饰装饰啊，也还能什么？呃，攒点这个小贝壳去娶个老婆，生个孩子，再给孩子在一部分积蓄，用来孩子的什么养育呀啊，以及自己穿一点好穿的衣服呀，吃点好吃的，偶尔可以这样，但大多都是都要日夜的劳累啊，非常的辛苦，但是起码他活了下来，而且其他村子里面，村子里面的其他人也是像他一样这么辛苦，这么活着啊，偶尔自己还能在别人面前装个逼啊，他非常开心，于是他就告诫他自己的孩子下一代说，你看，你一定要努力啊，一定要向村子里面的其他人学习，大家一定要日夜的辛苦的劳动，这样我们才能活下去啊。他们的子孙一看啊，周边的人都是如此，而且自己的父亲也这样教育了，于是觉得这就是真理啊，也按照这个方法去去。<br>于是他们整整三代啊，整整三代都是这样的牛马。<br>然后在第四代的时候，可能是基因突变啊，他们的一个孩子小黑。<br>从小这孩子与众不同，比如说他们村子里面有小学教怎么摘果子，教什么打猎这些东西，他发现学的这些东西吧，呃，好像学出来还是要做牛马。<br>他觉得不对，他自己不想做牛马啊，这个孩子野心勃勃，他听说山上有什么这个，呃，小白和小黄他们活得很滋润，我为什么不能像他们活的一样滋润呢？<br>然后他听说那个山上为什么那些人活得滋润，是因为他们有一个智者生存学院，里面有一个老师专门教怎么才能逍遥自在的活着啊，但是呢，下面他们村子里面的有些人说这个学院是不存在的啊，都是骗人的啊，只因为啥呢，他们上面活的好，是因为他们都是天才啊，那些人听说什么有特异功能啊，他们会飞啊，他们可能就像导弹一样跑得特别快啊，所以他们很快就能把猎物抓住，一天能抓一一千头，什么狮子啊，这个东西我们做不到啊，我们智商不够，我没有人家的天赋，所以做不到，你就别想了啊，这什么学院那扯淡的啊，你看我们村子里面也有学院教大家去这样打猎这些东西，但你看这样教出来有几个人跑到山上去了呢？没有啊，对不对啊，所以不可能有的啊，不可能有的。<br>很多人阻止他说你不要傻了，而且听说要进那个学院的门，要交100个贝壳，你想想，你一天什么连0.1个贝壳都装不上啊？交1000个贝壳吧，你现在只能赚一个贝壳，还要自己吃，吃掉半个就没了，你何必呢？那都是假的，对吧？你干嘛要去呢？但是小黑想着啊，如果这样窝囊的活着，还不如死了算了。他野心勃勃，他想着我一定要去什么体验一次，于是呢？<br>他每天只吃两个果子，非常的节俭，就为了攒够1000个贝壳啊，就这样他攒了十年，这十年他没有参与什么别人的这个消费啊，自己穿的破破烂烂，然后呢，<br>也不去什么吃好吃的。<br>于是在整个村子里面人看来。<br>Loser。<br>这简直是个傻子啊，因为他干嘛要那么虐待自己呢，而且你看穿的又破又烂又吃不到好吃的，呃，各方面都不行，身上又也没什么饰品啊，就是最垃圾的存在，别人都在笑话他啊，但是呢，他不在乎众人的笑话，他依然坚持，我就想试一下啊，这十年，他忍辱负重，终于。<br>他攒够了一一千个贝壳，要开始上路了，但他不知道这个智者学院到底在哪里啊，于是他一路啊，绕了非常多的弯路，有时候把路走错了，有时候问别人，结果问到沟里面去了，还有的时候呢，问到另外一个学院去了，人家挂羊头卖狗肉，把他的钱骗了一部分，他说啊，这就是学院啊，然后呢，又骗到他的200个贝壳，结果他进去发现，哦，这就是什么成功学割韭菜的地方，骗人的。他于是又出来了，然后又开始经过了一年的寻找，已经把500个贝壳花掉了，最后他终于啊，历经千辛万苦来到了山顶。<br>看到了一座什么非常辉煌的学院？<br>但是呢，这个学院的门票要1000个贝壳，而他只有500个贝壳。<br>人家拒绝了他，他想着我就这样无功而返吗？不行，我还要搏一搏。于是他给那个门卫啊。<br>贿赂了什么？200个贝壳，求求他自己只希望能把什么看一眼，能进去什么稍微，见识一下世面，自己就走啊，门卫看他态度如此的啊，端正对吧？那两百个贝壳也点起来比较重嘛，他就把他放行了。于是他进到内门的时候，发现有一个雄伟的柱，有一个雄伟的大门，有两个非常又粗又高的柱子。<br>左边的柱子写着四个字，原始积累啊，右边的柱子写着知识就是权力，他不懂啊，什么意思啊，然后呢，他爬到一个树上，偷偷看里面这个学院里面到底什么景色，恰好看到学院的什么新生的第一天开学。<br>在学院下面啊，密密麻麻啊，大概有十几个学生都跪在地上一动不动。<br>当时的天气非常的晒啊，这些人跪在地上晒的什么汗流浃背，他在树上啊，还稍微阴凉一点。<br>从早晨跪到中午，他不明白为什么要跪，然后这些孩子又跪到下午，然后又跪到晚上。就这样，第二天又下了暴雨，他们依然在雨中跪着，整整跪了三天三夜，风吹日晒。<br>到了第四天的时候。<br>突然，他发现在讲台上才出现了一个老师，这个老师问下面的这些学生说，你们知道为什么让你们跪三天三夜吗？学生很懵逼，茫然不知，老师说，我就要教会你。<br>第一节课，知识就是力量，知识就是权力，而获得知识并不是那么容易的。<br>三天三夜算什么，仅仅是让你们稍微的体验一下，知识有多么的难得，多么的不容易，你要求得知识是多么的艰难。<br>然后他问，你知道你们为什么在这里能吃香喝辣吗？你们为什么有荣华富贵？而下面，你看山村下面的那些憨憨们，每天累死累活，一辈子都享受不到你们的这种财富呢，知道为什么吗？难道是因为你们有三个鼻子四个眼睛？难道你们会飞吗？<br>是这样吗？难道你们比别人更强壮吗？下面同学纷纷摇头，你发现好像大家长得都一样，那到底是什么区别导致了你和下面的人不一样的人生呢？<br>他们不懂啊，老实告诉他，因为下面的憨憨们不懂知识的力量，我们唯一的枪，就是因为我们的脑子好使。<br>我们是靠脑子在活着，而下面的憨憨是靠什么？靠体力，靠感觉啊，就像一个牛马一样。<br>然后他说，下面的憨憨们难道不知道这事很重要吗？他们也知道，因为我们曾经的智者下去给他们说过。<br>知识很重要，但是他们理解的东西理解错了啊。<br>他们觉得啊，知识就我们村子里面教的那些东西，对吧？我就是不学我也能打猎，那知识好像并没有什么重要的啊。智者说，因为下面的憨憨们学的知识呢，是专门什么一种弱者的生存知识，专门为了打工当牛马用的，他们接触的是一些最底层的知识。<br>而我们在山顶上的人，我们家的知识是最真实的东西，他从一开始就不是为了当牛马的，是为了当一个强者的，懂不懂我们的知识系统就不一样，这是第一个。第二个，当我们的一些智者心怀天下，把我们在山顶上的优秀的知识拿到山下去传授的时候，他说我们的这个智者老师们曾经对下面说，大道至简告诉他们，知识就是力量，知识就是权力。大道至简，世界上的一切东西都非常简单，想成功非常简单，然后呢，下面的一群憨憨大声的嗤笑他说，大道至简，狗屁吧，我知道，我打个猎那么复杂，你还说简单，你还配当我的老师？于是纷纷把这个智者给喷走了，耻笑他。<br>只有极少数悟性特别高的发现了这个智者的智慧，于是偷偷的跟他去学，一旦学成之后，这些人就脱离了原来的这个山村，他们已经走到半山腰，或者甚至有一部分爬到了我们的山顶，这些人不再回去了，于是下面的憨憨互相之间永远是互相养蛊。<br>你们知道为什么吗？因为他们看到的只是我们这个智者，说的只是一个结论，是一种经典，而经典是需要有人解读的。他们很多人不知道什么大道至简的具体意思是什么，他们只看了表面的名字，他觉得好像这几个字我认识，我好像也会啊，道理都是简单的，他就这么理解。而我告诉你，在我们的智者生存学院，大道至简需要用一辈子来学习。而他们下面的人啊，一群废物，憨憨牛马，还自以为是，懂不懂？所以我让你知道知识有多么重要。你看山村下面的人，有几个人会为了知识跪三天三夜的，有没有？没有的，他们觉得知识无所谓啊，但你们一定要知道，你比别人强，是因为你脑子好使，而知识是来之不易的，是需要请老师去教学的，而这个请呢，你至少要付出一点真诚和努力。<br>下面的人是不懂的，然后小黑看到这一幕的时候震惊了。<br>怎么这里的教学和我们那里的教学不一样，我们那里的教学对吧，学生还骂老师呢，说这个老师是个傻憨憨对吧，骂一顿，好像自己学校确实如人家所说的呀，这是第一步，对知识不够敬畏，第二步，然后这个老师说我们现在第一个知识就教你们什么是原始积累。<br>怎么成为什么比别人更逍遥自在的人呢？一定要有原始积累。<br>因为只有有了原始积累之后，当我们有了没有后顾之忧的时候，我们才敢于去思考更多的未来，去研究啊，怎么这个学习知识，怎么用知识用脑力来变现，用脑力来提高我们的生产力，让我们摘更多的果子，能打更多的业务。<br>但很多人，你知道山村下的人为什么变成牛马吗？因为他不懂得原始积累啊。他们往往通过辛苦的体力，从早晨劳动到晚上，好不容易游离一点结余，但把这点结余用来干嘛呢？用来消费了。<br>他给自己买了一顿好吃的啊，好穿的。<br>好住的结果导致他消费完之后就没钱了，又得像牛马一样去劳作，这样周而复始，让他根本什么喘不过气来。即使他们偶尔有时候想要静下心来思考一下，但经过一天的劳累，他晚上只想休息啊，休息一会儿之后，即使想思考的时候已经有心无力了。<br>然后第二天紧接着又要劳动，他永远没有什么一个完整，比如说有一年的思考的时间，没有的。<br>所以他只能永远做牛氓，而且你们知道吗，下面这些牛马他们的消费其实是谁制定的呢？是我们制定的啊，因为他看我们山上的人今年穿的红色的衣服，他觉得红色衣服就是高贵的，于是山腰的和下面的人纷纷穿红色的衣服，只不过半山腰的呢，穿的比我们劣质一点啊，在下面这个山村的人穿的比我们更劣质啊，他模仿啊，那种劣质的红色的颜料模仿。<br>今年就流行这个，他就花这个钱，然后明年呢，我们又穿黄色的，他们又把红色的衣服扔掉了，他就开始买黄色的衣服哇，说黄色的衣服穿上更彰显他们牛逼，他觉得好像穿上这个衣服他就和我们一样了啊，然后我们的房子今年里面摆了一张树木做的凳子啊，他们下面也开始模仿。<br>然后呢，我们这边的人呢，出门的时候啊，手里面遛一条小蚂蚁啊，他们下面的人也跟着模仿啊，花了半辈子的积蓄买了一条小蚂蚁啊，然后每天溜着走。<br>他们往往不知道我们是规则的制定者啊，我们那个蚂蚁呢，那个价格成本就十块钱啊，十个贝壳。<br>但是呢，我们就说我们逼格高对吧，是我们成功人士用的，所以我这种东西就可以卖到一百一千，所以这剩下的90块钱，900块钱都是什么，我们自己赚的，知道吧，我们的成本只有十块钱，但你你们赚了90块钱，9000块钱，这就是我们为什么躺在这儿轻松逍遥自在的原因，因为下面是一群憨憨，他们在养着我们。<br>我们能这么轻松，是他们养着你懂不懂啊？他们把他们一生的积蓄拿来买了这一点虚荣的东西。<br>他们从此不知道，永远不知道。<br>这一切底层的逻辑是什么啊？甚至他们那边还没几个钱，还花了一辈子积蓄，就什么买了一个小洞穴，又去结婚了，结婚了之后又生了个孩子，结果孩子也和他们一样，甚至还不如他们世代的劳累啊。<br>而我们教你什么？第一步一定要有原始积累，在积累的前期，当你没有知识的时候，你只有通过一种方式来积累，就是要<strong>够狠</strong>。<br>啊，一定要够狠，狠到什么呢？<br>在保持基本生存的。<br>能活着的线上，把其他的一切结余全部储存起来，全部储存起来，不要进行任何消费啊，不要为了迎合别人，别人说穿这个衣服好，你就傻乎乎的穿着啊，你穿个衣服不会改变你的。<br>而你那种消费只是在消耗。<br>那是一种傻憨憨的行为啊，绝对不是智者的行为，而且他们对吧？他们竟然还觉得自己很牛逼啊。<br>我听说未来有个现代社会中很多人攀比，今天我买了个车子，明天我穿个好衣服啊，后天啊，我用的这个手里面拿个什么玩意儿啊，什么苹果的什么这些东西在攀比这些东西啊，他从来不知道啊，那些东西都是我们给他提供的，我们给他制定的。<br>你们现在明白了吗？<br>那些孩子一下就明白了，这时候小黑听的浑身流汗，他被震惊了。<br>他发现他的祖祖辈辈正好就是如此啊，他祖上三代啊，这个家族前三代都是这么辛苦的劳累了，要不是因为自己从小野心勃勃，与众不同，受尽大家的耻笑。<br>才爬到这里，才听到了真相，原来自己做的是对的，只不过他没意识到原始积累，他只是想要更牛一点，但相当于是今天他学到了第一课，原始积累是这么的重要。<br>然后老师接着说，有了原始积累之后，我们就要什么，有了活着的底气，你知道你怎么样都死不了的时候，对吧？<br>你甚至能够什么，即使不去工作，你可以让你维持比如说半年到一年的什么生存的时候。<br>那么这一年你不用工作的时候可以怎么样？你可以非常专心的把你的所有的精力和时间用来什么，去学习什么技术，去提高自己的生产劳动效率。因为就是靠知识成功的，而不是靠体力劳动。<br>而如果你没有这样的积蓄呢？或者你没有这样的想法，你总是什么赚一点花一点，赚一点花一点，还把自己沾沾自喜的不行，你这样及时享乐的人，一辈子就是为奴的，而且他还想不到快乐，因为他发现他想到快乐和我们山顶和山腰的人想的不是一个快乐，所以他很迷茫啊，非常累，休息一下吧，又为了迎合别人啊，又为了想让自己变得牛一点，又买了一点我们那种劣质品。<br>然后他又觉得依然没让自己活得很开心，没有掌控感啊，所以他活在一种虚无之中。<br>而我们呢，一定要规划好啊，抛弃所有的这些。<br>体系啊，你们记住，如果有一天你们沦落到那个山村的憨憨群里面，进去一定要走好他们不一样的道路，第一步就是积累，原始积累啊。<br>最好能够让半年或一年不去什么工作也能活着，而且是最低限度的工作活着。这条道理呢，我们曾经有一个智者啊，到了山村去给他们讲过，但是下面的村民呢，竟然骂这个智者是什么？<br>蠢货啊，他说哎，以前吃两个果子哎，把自己虐待的不行啊，而且我们家里面还有上有老下有小，你让我父母也吃两个果子，我的孩子也吃两个果子啊，这样说出去别人会说不孝顺，这样我还能当一个什么好父亲当一个好母亲吗？啊，我还能当一个孩子吗？我这样不孝顺对吧？于是呢，或者说啊，我每天呃，吃两个果子啊，要是这个生病了怎么办啊，就这些东西啊，智者最后没办法啊，一看啊，妥妥的蠢，蠢货废物啊。于是呢，他只带着什么极少数有几个有慧根的啊，有智慧领悟力强的，带他们几个打怪升级，其他人就放弃了啊，他终于知道为什么憨憨是憨憨，就因为什么命该如此啊，憨憨这个地方的这种有一种憨憨的能量，他们众人抱团，这个窝太强大了啊。憨憨之间互相认可都认为每天就得吃三个果子，每天就要穿好一点的啊，这种像一个黑洞一样，这种力量太强大了，一般人根本逃不出来，只有极少数什么天纵奇才的人才能从这个憨憨窝里面跑出来，这样才能得到另外一个不一样的人生。<br>所以呢，最后我们的很多智者就已经放弃去拯救这些憨憨了，因为夏虫不可语冰。<br>他们从来不知道啊，没有体验过真相，不领悟这个东西。但为什么你们在下面坐着听我说你们会相信呢？因为你们现在正好就生在山顶上，山顶的最好的学院难道能教你们当下面的憨憨吗？不会的啊，所以你会认可，因为你们享受到了荣华富贵，然后我说的话你们就会信服，对不对啊？那下面的他还不相信嘛，因为他们老师教的就是怎么去打猎，对吧？打完猎之后还得日夜当牛马去劳动，对吧？所以他不相信知识有多重要。<br>所以本质原因是因为他们学的是牛马的知识，而你们学的是什么潇洒自由的知识啊，这就是原始积累的重要性，走一条不一样的路，你们学会了没啊，下面的孩子立马就掌握了。</p>
<p>  然后小黑呢，在那趴着听了半天之后。<br>非常的无奈又震惊又愤恨。<br>一方面呢，愤恨的是，自己怎么这么蠢啊，当年对吧，自己的父亲呀，这些怎么都不听对吧，曾经的智者说的话呢，然后又无奈又为自己这种憨憨，一辈子世世辈辈为牛马感到什么无可救药啊，但震惊的是，幸亏自己什么跑出来了啊，幸亏自己在。<br>也不知道为什么就莫名其妙，只想着成功，莫名其妙来到这个地方，竟然听到了这么重要的一节课。所以他决定。<br>他回去一定要再继续原始积累啊，然后呢，最好再攒上什么2000个贝壳，一定要再来这个学员来进修，因为他只学到了第一节课啊，原始积累才是入门的，后面这个知识就是力量，知识就是权力，听说这里面有好多知识啊，有几十项生存的，这是他一直都还没听到，他只是今天学到了第一课啊，有了原始积累，人就有了底气，有了底气也就有了精力和时间，可以不去当牛马，这样安心的去什么思考，去学习。<br>他训练他的脑子，脑子越来越强大的时候，它的生产效率就高了，他制作的弓箭对吧，打猎打的更多的猎物啊，生产效率越高，它越来越会强大起来，而如果没有这个积累呢？<br>只能世代当牛马，于是他心满意足的回去了，回去之后又经过了十年的奋斗，省吃俭用，这十年他没有结婚啊，因为一结婚的话就没钱了啊，也没有去买了些奢侈的好吃的，然后这时候又攒了1500块钱的积蓄啊，他准备下一次再到山上学一点第二节课。<br>好，我讲完这个个故事了，首先定位一下你自己属于什么。<br>我们对比一下，如果是现代人的话，你自己现在属于山下那些憨憨大聪明呢？还是你是属于小黑呢，还是属于小黄呢，还是属于小白呢，这是第一个啊，你的定位。<br>第二个，你有没有意识到原始积累的重要性？有没有这样的意识，为什么要进行原始积累？<br>第三，请问你把你的原始积累都花在哪里了？<br>第四，你有没有领悟到知识就是权利，知识就是力量，你对知识有这么尊敬吗？<br>你还说，你觉得他妈你的学习怎么样？累死了啊，傻憨憨才学吧。爆一通牢骚？<br>然后如果你觉得很认可这个智者的话，那就请你规划一下。<br>你如果要进行原始治理，要把哪些东西要砍掉，哪些消费要砍掉？<br>你打算在在一年内要原始积累多少东西？</p>
<h2 id="知识就是权力"><a href="#知识就是权力" class="headerlink" title="知识就是权力"></a>知识就是权力</h2><p>  小黑花了十年时间，怀揣1500个贝壳，再次来到了学院。<br>看着学院的新一批的学生，自己感慨到，我花了十年的弯路，十年的时间，才有资格和这些人坐在同一个教室里面。而现在的学生已经是这个学院的第十批了。<br>他当年观察的那一批学员，人家早已经打怪升级去了。<br>然后老师说正好讲到了第二节课：知识就是权利。<br>老师对这些下面学生说，知道为什么原始积累的时候不让你们去实践吗？<br>因为你们的父母通过五代的努力，已经为你们积累了雄厚的资本，你们自己不需要打拼原始积累，但为什么还要昨天讲了第一节的原始积累课呢？<br>有两个原因。<br>一个是为自己，一个是为他人，为自己的是：假设有一天发生意外，<br>我们从山顶掉到了山低。<br>那么我们也知道这套规律的时候，就可以为自己所用，让自己快速的打怪升级，从山底再爬上来，你知道这条规律，而别人不知道，他就爬不上来，这是第一个，第二个。<br>如果在正常情况下，既然知道了这套规律。<br>就可以让别人来服务于这条规律，也就是我们可以管理别人，用这条规律来管理别人啊。<br>这就是个目的。<br>那我们的第二节课，知识就是权力现在开始。<br>我们讲第一个知识，就是一个人要变得强大，是要靠自己还是要靠别人？<br>你们觉得一个人要成就自我，靠的是自己还是靠的是别人呢？<br>一定要靠别人。<br>是不是很多人都认为是靠自己是吧，，，<br>你有多大本事？<br>靠自己？<br>一大还是二大？各位告诉我，哪个大？肯定是二大，这么简单的道理你不懂，你一个人一天能摘多少果子？<br>你一天能摘十斤果子，不错了，你能摘100斤、1000斤吗？能不能，但为什么你现在坐在这里不摘果子呢？<br>为什么？<br>为什么你自己不摘果子呢？你为什么不做饭呢？是因为有人在替你做饭。<br>让别人干，要靠别人懂不懂。你们能在这儿轻松的听课一定是什么，让你们能吃饱喝足穿暖。<br>一定是有人在替你们在地里面劳作。<br>如果没人替你们劳作，你自己根本不可能来到这个教室，你们也得什么去山村下面从早到晚的开始劳作，你根本不可能有学习机知识的机会，你只能挣扎在温饱线上。<br>所以啊，一定要靠别人。<br>而我们对比一下在山底的那些人，他们觉得靠谁呢？他们觉得要靠自己。<br>他们充满了自大和骄傲。<br>他们根本不懂得谦卑和敬畏。<br>他们觉得自己很厉害。<br>所以一切事情要靠自己，他的本事大的很，他有多大的本事呢？一个人能有多大的本事呢？<br>但是他们不懂，他们觉得靠自己感觉有面子啊，靠自己感觉自己就牛逼了。<br>你看我是靠自己的啊，我多么厉害，我靠自己，你看你靠别人的这些人，你们都是什么懦弱的人啊，他们有一种虚伪的自尊。<br>你要说让他靠别人，他说我才不呢，哼，我妈给我打江山不要，我就要凭自己的本事去打拼。他对人在社会生存，对这个社会毫无敬畏心，对知识毫无敬畏心。<br>它是一种又懦弱又自大。<br>这种人。<br>我说了二大于一，所以但凡说要靠自己。<br>你靠一个我看看。<br>你要靠自己是吧，好了，今天别吃饭别喝水，因为没人给你提供饭，没人给你提供水，你自己去山里面去种去，自己去找泉水去，自己去搭房子去去吧，所以这是第一个是人的误解啊，为什么90%的人都觉得人生在世一定要靠自己。<br>靠别人，靠别人，一个人的力量就是一，如果你能靠100个人。<br>你就拥有100个人的力量，如果你能靠1000个人，就是1000个人的力量，如果你能靠1万个人，你就是1万个人的力量。<br>这就是知识。<br>那靠别人的什么呢？<br>靠别人的能力，能力分为他们的体力和他们的脑力，因为一个人做的永远是有限的。<br>你的体力有限，你的脑力也有限，你自己没有怎么办？我们去依靠别人，去学别人的，去学别人的，尤其是脑力的部分，体力的部分啊，支配它就够了，但脑力的部分。<br>一定要主动去学，你不要那么自尊自大，因为你只活了一辈子。你们现在才十几岁，年纪轻轻，你们甚至一无所有，在脑力方面、经验方面毫无经验。<br>那去学别人的经验，你比如说啊，我们这个半山腰的小黄有一个猎户。<br>人家为什么到了半山腰，因为人家打猎特别厉害，人家一个人打猎就可以一周可以猎到五头熊，就凭一个人就能打五头熊。<br>而你知道山底下的村民。他们打猎。，他们十个人一周都不一定能打得到一头熊。<br>看到区别了没？那你知道为什么山顶的那个小黄打这么这么厉害呢？一个人顶十个人，一个人能创造的价值是顶别人几个月几十个人的呢，知道为什么吗？<br>因为山顶上的小黄。<br>家传的五代都是猎户。<br>他们的打猎技术是从第一代的。<br>祖祖辈辈上干这个，可能花了30年的经验才学会了其中的一个小技巧，比如说怎么设陷阱，设的陷阱最好。<br>又到了第二代人，又花了三一辈子的时间才知道了怎么去寻找猎物，怎么去知道猎物藏在哪个地方，根据踪迹去判断。<br>后面是每一代都在上面不断的什么积累，这个经验，他们是家家世传。<br>传到第五代，他才综合了所有的技能。<br>所以一个人就能一周打到五头熊，五代人啊，一代人按三十年的经验算，五代人就是150年的经验。<br>这样的知识。<br>为什么我们不保持敬畏呢？<br>而你自觉得靠你自己，靠你自己。<br>你能活150年吗？而你活了150年，仅仅也才达到了人家的第六代的起点。<br>那为什么我们就不直接把它给学过来呢？<br>他们的经验耗费了30年，但最后那一个经验的结果就那一条，成功是简单的，而失败是复杂的。就像在一个系统里面，永远有且只有一条路线是最短的，最正确的，其他路全是错的。你比如说在一个平面系统里面啊，这个平地上有两个点，A点和B点，请问A点和B点之间最短距离是什么？<br>有几条线路，告诉我有几条线路。<br>只有一条线路，就是它之间连一个直线。<br>这是最短最最好的吧，那除此之外，只要不走这个B点，不走这条直线，你随便去走，你走1000条，1万条，1亿条，永远都是要大于这个直线，这个线段的都是费劲的是不是，但成功呢？成功就只有这一条线路。<br>在一个系统里面成功只有一条线路。<br>但如果说在另外一套系统，不在平面系统里面，AB2点可能都不用走直线啊，直接折叠了对不对，但在我们这个平面系统里面，有且只有一条线是正确的，其他线全是错的，就像打猎一样。<br>打猎的设的陷阱，就是抓熊的这个陷阱，系统里面只有一个系统是最完善的，最优秀的，其他的系统一定都是有问题的。30年换来了一个系统，而你学习他可能只需要不到一年甚至一个月就能学会，他用了30年，我们用一个月，但这要求我们必须对知识有十分的敬畏。我们知道这一条信息，可能人家就说出来，就短短几个字，但它上面浓缩了30年的经验，我们谁敬畏过？没人敬畏过。<br>你像山下面山村的那些村民，他们敬畏吗？他们毫不敬畏，他们看到这条经验的时候大笑，为什么呢？他觉得，哈哈，就这么简单啊，就这么简单，我不信，真的吗？他们不相信，他们觉得如果一个人打到那么多头熊，一定这个人掌握了非常非常复杂的技术对吧？非常复杂高深奥妙的一种技巧，绝对不可能这么简单，绝对不可能。<br>因为他试过，他发现他打熊十个人都打不到一头熊，这么艰难，然后你告诉我射个箭就这么射，怎么可能呢？因为他不敬畏，不相信，所以那么他的有些人可能会去尝试，但试的时候他没有敬畏心，导致他试的时候就不认真，严格的去按照人家的那个步骤，一步一步严丝合缝的去执行，他不会的，他觉得真的吗？就这么简单，那我随便试一试吧，就这一个随便，那必然动作会变形，我说了正确路只有一条，动作稍微变形那么一丁点，绝对就不是正确的路了，已经偏了，一偏的话，对效果会千差万别。所以他一试发现，诶，没有呀，我这样没有达到呀，对吧，甚至还不如我原来的那个系统好，于是他说你看果然都是骗人的。<br>这就是很多人对知识毫无敬畏心啊，人家30年浓缩的那一个精华，那每个字上面都包含了几十年的经验，那一个字的理解是这么轻松的吗？让你看一下就随便就飘过去了吗？<br>能这样去做吗？不能。<br>所以我们一定要记住。<br>世世代代别人经总结了那么多的经书，那么多的经典。<br>那都是成功人士写下来的，但为什么后面的人看了之后没学会呢？因为他不相信。<br>就像我们曾经有位智者写过一本兵书，上面写着上战伐谋，下战伐兵。<br>就是战争，用脑子就能解决掉的事情，最垃圾的是什么？直接动用别人士兵来体力来打仗，这是最垃圾的。同样我教你们，我说人活着一定要靠别人，而不是靠自己，很多人完全是理解偏了。同样我说一定要这个学知识一定是简单的，而不是复杂的。<br>但没人相信，大家总觉得成功是多么复杂、多么难的事情。<br>他忘了失败才是难和复杂的，经过无数次的失败，当成功的时候，成功的一条路是非常简单的。<br>就相当于我们有一个宝库上面有个密码，他成功的密码就只有什么六个字母，213433。<br>请问213433难吗？难吗？是个傻子都知道会按个213433非常简单，只要按了这个宝库就开了。但问题就是很多人试了几千遍，他就试不到这个正确的密码上，他永远在错误的密码上试，试几千次、几万次、几亿次，没用。<br>没用，于是他们觉得开宝库太难了。<br>但有人一天告诉他说，这个宝库很简单呀，我上去就开了。大家不但不会相信，反而会觉得人在吹牛，会耻笑他。<br>这就是什么愚蠢的事人。<br>他们相信成功是简单的。<br>他们也不敬畏知识。<br>对别人的经验毫不在意。<br>所以你看他们那些人。<br>我们这些智者，还有半山腰的什么这些技术专家，他们浓缩的东西可能写成一种纸，写到纸上，像一本书一样，他们写了各行各业，写了那么多本书啊，那么多经验的浓缩。<br>但底层的人，他们能接触到，书是能接触到的，但他们却学不会，为什么呢？他们觉得这玩意儿就这？就这！就这？！<br>他们是鄙视他的，把那个东西当垃圾去看的。<br>所以注定了他们是牛马。<br>那现在在座的各位，你们觉得呢？你们是要自己花150年去日日夜夜去劳动，去获得这个打猎的技术呢？<br>还是想怀怀着什么100分的敬畏。<br>当打猎的那个字可能就一张纸，上面记了三个步骤，当这三个步骤出现的时候。<br>你还是愿意去跪着把它供奉上三天三夜，然后对里面的每一个步骤的每一个字。<br>都认认真真的去拜读，去揣摩，去验证，把它当做宝一样拿来。<br>还说你像下面的山村民一样，他看到这个过程说，哎，这么简单，啥玩意儿吗？翻过。<br>他总在找更牛逼更酷炫的东西。<br>所以你们各位不要学愚蠢的事了。<br>好，这就是第二节课。</p>
<p>  小黑听到这个的时候。<br>痛哭流涕。他回想自己这十年在干嘛？他靠自己在辛辛苦苦的一天摘果子，从早摘到晚，从早摘到晚，每天节省那么一点点，靠十年，靠自己，靠了十年，才赚了1500个贝壳。<br>而实际上根本不需要十年，但凡他能敬畏知识，他去跟他们村子里面那些摘果子速度最快的人去学一下，去靠别人去学别人的东西。<br>他可能需要一年就早已赚够1500个贝壳了，但他走了十年的弯路。<br>十年，他的青春就这样白白的消耗掉了。<br>因为他觉得他们村子人都说，人人要自强，要靠自己啊，一定要自强，千万不能靠别人。他正感叹这个世界上的学问怎么会如此的奇怪，既然是截然相反的学问，当大众都以为真的事情，都以为某个东西是真理的时候，反而它恰恰就是谬误，而真理正好与他完全相反，难以置信。<br>他因为这十年的痛苦的经历，让他第一次确确实实体验到了自己过去学的都是什么玩意儿，在那个村子里面，那些人给他传递的是什么样的观念。<br>怪不得这个村子里面的人都是一群憨憨，爬不起来。<br>因为他们总想着都说的要靠自己啊，男儿当自强，你自己才有多大的力量，你自己才活了多少年，你靠你自己。<br>你是多么的自大与骄傲，而我们一定要学会谦卑。我们知道人的渺小性，我们只所以伟大，是因为借助别人。君子性非义也，善假于物也。我们的智者曾经说过这样的话，他们曾经都读到过，但他们只把它读到过当做一句话而已。<br>他们从来不知道这句话什么意思。<br>他们也不相信君子难道这么简单？<br>他们完全难以置信，所以他们去追逐那种非常复杂又华丽的东西。<br>结果看遍了那么多，他迷茫了，不知道哪个是对，哪个是错的。<br>而是在复杂的过程中，他们也学不下去，那些非常复杂难，他也学不下去。<br>于是他就他们就自我放弃了。<br>可他们从来没知道，只要是复杂的东西，谁都学不进去，这是第一个，第二个，只要复杂的东西说明就已经错了呢，就不对啊，真正对的东西一定是非常非常简单的，打开山的这个宝库的钥匙密码就只有六个数字。<br>并没有那么复杂，输进去宝库就开了。小黑内心拔凉拔凉的，但同时就充满了希望。他终于知道了我如何提高生产力，那就是<strong>靠别人，别人的经验，这种经验就是一种权利，就是可以支配别人的</strong>。你看半山腰的小黄，就因为掌握了这种经验，他就可以支配下面的人，让别人为自己工作。就像你们在山顶的各位，你们正因为在这儿躺着，是因为你们接受了高深的知识，拥有这种知识，就可以让别人为你去工作。<br>因为我们知道，善于借力，我们自己不行，我们自己哪怕是个废物，你脑子不如别人，没关系，可以让别人去替你工作，或者你去学习，他把他的学费抄过来，就是我们自己的。</p>
<p>  各位，请问我们人生在世，想强大靠自己还是靠别人？<br>你自己什么水平？你自己有啥可靠的，就你那脑子一团浆糊，你还靠自己。<br>这是第一个。<br>就是因为你这个不谦卑呀，你但凡谦卑一点，想着我要什么，汲取别人，让别人来为我工作，让别人的经验为我所用的时候，你会非常的谦虚，这个时候你自然就会敬重别人的知知识，因为这个别人的知识是人家几十年甚至几百年的经验浓缩而成的，人家花了几百年才浓缩成的。<br>在你眼里竟然啥都不是，你是多么的自大和骄傲，你是多么的无知和愚蠢。<br>于是各位读者，我问一下，你们是不是一直想着是要靠自己，这是第一个，这个思想观念就错着呢？第二个你们是不是一直想着别人的东西，好像也就那样吧？但你有没有想过，人家能写书的人很多都是成功人士，人家写的那个书里面，你觉得他好像在说理论，那不是，那只是把几十年的经验是浓缩成的，，但不代表人家说的东西是错的。<br>那个大白话就是好像是个三岁小孩子都懂的话，他竟然拿出来来炫耀，好像是他掌握了真理一样，他在那炫耀恬不知耻，你羞不羞啊？</p>
<p>  他总觉得真理永远是很复杂的啊，从来没想过真理就是非常非常简单的，简单到不可思议，就是因为不可思议，所以你不相信，不相信所以你不会认真去做，不会认真对待，所以你就永远的错失了，<br>你不认真对待，你执行就动作变形，一变形就不是那个真理，那肯定失败呀，一失败你反而正好找了一个，正好借口，你看，果然我说这玩意儿是垃圾吧，你看我一做，你看不对呀，这不对呀啊。<br>各位看我博客的读者，你靠自己还是靠别人？第二，你对知识有没有敬畏啊？<br>然后从今天开始，你要应该怎么去规划自己的人生？</p>
<h2 id="上车浙A蓝牌"><a href="#上车浙A蓝牌" class="headerlink" title="上车浙A蓝牌"></a>上车浙A蓝牌</h2><p>  今年通过成功申请杭州E类人才，从车管所获得了浙A蓝牌指标，在计划先搞一辆二手五菱之光去秋名山练练手，还能拉货，哈哈哈</p>
<h1 id="运动打卡和挑战"><a href="#运动打卡和挑战" class="headerlink" title="运动打卡和挑战"></a>运动打卡和挑战</h1><p>今年参加马拉松4场，徒步多条路线，其中3条涉及到高海拔穿越，总计运动距离接近250KM.<br>运动主要目的有2个：</p>
<ul>
<li><p>第一、保持好的身体素质，有了这个才能有人生后续的梦想。</p>
</li>
<li><p>第二：锻造自己的意志力，马拉松、长距离越野，高原徒步越野都是很考验人的意志力的运动，这种在物理世界获得意志力的经验迁移到人的精神世界，让你在其他工作、生活领域提高坚韧度。</p>
</li>
<li><p>2023路线<br><img src="https://s2.loli.net/2023/12/22/Woe5lczB8rbGJtk.jpg" alt="3b0cbdb2949eff6e2eb22469f14c609.jpg"></p>
</li>
<li><p>两岸桃花奉化马拉松<br><img src="https://s2.loli.net/2023/12/22/8xH5YoaSuIhgOEc.png" alt="97d4c78700e84dbb8b1d09dda070fe2.png"></p>
</li>
<li><p>2022年遗留的横店马拉松<br><img src="https://s2.loli.net/2023/12/22/UJEmuxqwA9nH3Iv.png" alt="c8a5ab099683ce8e436663c55598acc.png"></p>
</li>
<li><p>2023-06-03杭州越野赛路线<br><img src="https://s2.loli.net/2023/12/22/gWcbOzhA7HrGBCX.png" alt="image.png"></p>
</li>
<li><p>2023-07-09西湖区狐狸路线<br><img src="https://s2.loli.net/2023/12/22/lLYgJcwj3yV6ua7.png" alt="image.png"></p>
</li>
<li><p>2023-07-15天目七尖(四尖)【年度难度最大路线】<br><img src="https://s2.loli.net/2023/12/22/CI7lGz39BTgDZKc.png" alt="image.png"></p>
</li>
<li><p>2023-07-30徽杭古道<br><img src="https://s2.loli.net/2023/12/22/uTkDEaRmUqgbjBS.png" alt="image.png"></p>
</li>
<li><p>2023-09-02西湖松鼠路线<br><img src="https://s2.loli.net/2023/12/22/zXpwklqKvtPAbnN.png" alt="image.png"></p>
</li>
<li><p>2023-10-01九寨沟(高原徒步局)<br><img src="https://s2.loli.net/2023/12/22/UAPeCygLGdZlTtN.png" alt="image.png"></p>
</li>
<li><p>2023-10-04四姑娘山-长坪沟(高原徒步局)<br><img src="https://s2.loli.net/2023/12/22/5BeyUjvmPw2dLpK.png" alt="image.png"></p>
</li>
<li><p>2023-10-05四姑娘山-双桥沟(高原徒步局)<br><img src="https://s2.loli.net/2023/12/22/JWj93cKtpgk5dEv.png" alt="image.png"></p>
</li>
<li><p>2023-10-21吴越古道<br><img src="https://s2.loli.net/2023/12/22/Vi531WKE62UywDf.png" alt="image.png"></p>
</li>
<li><p>2023-11-05横店马拉松(2023年的)<br><img src="https://s2.loli.net/2023/12/22/1pf9FZRjmbuyPMk.png" alt="image.png"></p>
</li>
<li><p>2023-12-03千岛湖马拉松<br><img src="https://s2.loli.net/2023/12/22/QMp7SazibsvU5LB.png" alt="image.png"></p>
</li>
<li><p>2023-12-17杭州马拉松<br>不好意思，没有中签，哈哈哈，去现场终点观摩了下冠军冲线。。。。。下次我抽签之前拜拜佛，争取明年再战杭马。</p>
</li>
<li><p>2023-12-23 钱塘标毅路线<br><img src="https://s2.loli.net/2023/12/24/5E6yxObJWHk8SVM.png" alt="image.png"></p>
</li>
</ul>
<h1 id="番外-博客访问量问题分析"><a href="#番外-博客访问量问题分析" class="headerlink" title="番外-博客访问量问题分析"></a>番外-博客访问量问题分析</h1><p>自从我把博客从csdn迁移到自有域名以后，很多内容和帖子曝光量降低，定位了下原因有二，其一是csdn有很过自带的流量，csdn是一个技术社区，都是技术领域的人在看，所以访问量会高，其二是我迁移到自有域名以后，帖子的曝光量大部分是从谷歌搜索过来的流量，而百度、必应的搜索，很少，哪一个例子说明，“在人间做韭菜的那些年(3)–项目推进迭代流程”这篇文章我们分别用百度、必应、谷歌去所有看看得到的结果:</p>
<ul>
<li><p>百度<br><img src="https://s2.loli.net/2023/12/31/qL3l57yGa8fUBgW.png" alt="image.png"><br>百度出来的结果，很乱，用户注意力被分散，而且搜索出来的结果和搜索关键字有差距，造成帖子的访问量被静默抹杀了。</p>
</li>
<li><p>必应<br><img src="https://s2.loli.net/2023/12/31/Uw4QfB6s1ovIxAS.png" alt="image.png"><br><img src="https://s2.loli.net/2023/12/31/FEqMkGxiWLPVUXB.png" alt="image.png"><br><img src="https://s2.loli.net/2023/12/31/Com5yWTkIwNL16D.png" alt="image.png"><br>必应是更加差劲，我的帖子在第三屏才滚出来，这无疑减少了访问流量。</p>
</li>
<li><p>谷歌<br><img src="https://s2.loli.net/2023/12/31/Iu4aBLnj3P85vwF.png" alt="image.png"><br><img src="https://s2.loli.net/2023/12/31/aHe45DwWuNzmM2X.png" alt="image.png"><br>谷歌是最准确的！but，用谷歌的都是外国人，而搜索中文关键词的是中国人，而中国被墙了，，，，所以，访问量也不会很多，但是可以通过谷歌的搜索排名优化去做，用谷歌支持的开发者插件区处理。</p>
</li>
</ul>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p><img src="https://s2.loli.net/2023/12/09/mACnaKHwcRhp7F6.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>2023</tag>
      </tags>
  </entry>
  <entry>
    <title>在人间做韭菜的那些年(4)--2021年终总结回顾</title>
    <url>/2021/12/31/life/leeklife_4/</url>
    <content><![CDATA[<p>  <img src="https://s2.loli.net/2022/01/04/NokXETPJj4UuZzR.jpg" alt="hinata.jpg"><br>  自从疫情以来，基本上没啥好的事情，中美对抗，股市跌宕，美股熔断，互联网内卷、房市末路，男女对立加重，青春也随着时间流逝，越是艰难的时候，越是需要思考总结，复盘，否则过了这个时间，铁就打不热了。</p>
<span id="more"></span>
<h3 id="不要拒绝成长"><a href="#不要拒绝成长" class="headerlink" title="不要拒绝成长"></a>不要拒绝成长</h3><p>  不以实体产业为根基的互联网就是空中楼阁，<br>  不敢正视自身缺点都是自欺欺人<br>  不制定目标的冲锋那是自我毁灭 ​​​<br>        — 杭州某不知名程序员</p>
<p>  我们拿”不敢正视自身缺点都是自欺欺人”这句话作为引导开始展开。<br>  <strong>聪明人从来不会拒绝成长。</strong><br>  在进行一个业务诉求从业务沟通到上线中间有很多过程，沟通、开发、测试、架构、稳定性等等，这里边很多环节都无时无刻体现着一个开发人员各个方面的专业素养，其中最关键是2个：<br>  架构、沟通，本节说沟通。</p>
<h3 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h3><p>  我们在面试的时候，总会看到招聘要求会有好的沟通能力，以前觉得是个小问题，但是如今我却在这里大谈沟通，属实打脸。</p>
<h4 id="语言沟通"><a href="#语言沟通" class="headerlink" title="语言沟通"></a>语言沟通</h4><ol>
<li>语言沟通和文字表达沟通都可以归一为一套方法论，语言沟通体现在表达清楚问题以及你的需求，让接受者和你在讨论一个问题点上，不要出现你说南，她在说北，浪费时间。<br>  个体的差异性格也会导致沟通障碍，沟通要本着客观的心态去输出和输入信息，不要让自己的主观思想一偏概全客观思想，比如小明性格好强，当有人给他指出一个问题或者不合理的事情的时候，由于人的自尊或者面子问题，会遭到小明情绪上的反抗，而没有直接面对问题，这就是自欺欺人，不敢正视自身缺点都是自欺欺人，也是在拒绝成长，这也可能是很多大龄程序员一直没有原地踏步的一个原因，这个思维扩展到脱离工作，回到其他行业，或者自主创业都是一样的道理。</li>
<li>针对事情的合理性去客观分析问题，然后沟通，一味的甩锅，只会蒙蔽问题的本质，助长了浮躁的技术沟通氛围，拿代码评审举例，小明的代码在进行CR，然后同事A给他提出了一个问题，<br>  针对这个问题，小明认为没有必要，A同事认为很有必要，同时小明认为同事A是有不对的编程洁癖，太过于主观或者将自己的想法强加到别人身上，双方争执不下，最后上升为人的问题（现实是真的存在的），个人认为，只要A同事说的合理，而且小明无法有理有据的说服对方，那么解决问题小明应该走第2条路，按照同事A的想法fix这个代码问题，第二，如果不是很严重的问题，可以下一个迭代修复，todo一下即可，但是切记，不要情绪用事，不要过于主观色彩去工作沟通。</li>
<li>然后要发现自己在沟通过程中的问题，怎么发现这就需要思考，思考和学习本篇第三部分说一下，发现之后才能对症下药，人的自身问题，不可能一下就能解决，<br>  但是可以量变引起质变，你知道你自身的问题，但是还是在实际沟通中犯错了，并且你也知道你犯错了，没必要谴责自己，下次一定即可，这里的下次一定并不是接口和开拓，而是一次比一次更加“正规”，在每一次都尽力做到极致，当这种极致的思维你用它作为实际工作指导，完成那么几次之后，你会从中感受到成就感，从而驱动下一次的“极致”。</li>
<li>最后如果你还是无法做到那么几次极致的案例，那只有一个原因，你容许自己普通，你接受自己的无能，这就不是能力的问题了，是人的问题，是价值观的懈怠，是人的性格使然，<br>  你会发现所有的问题都会回到人自身。</li>
<li>这里推荐书籍：《非暴力沟通》<h4 id="文字沟通"><a href="#文字沟通" class="headerlink" title="文字沟通"></a>文字沟通</h4>  文字沟通的方法论最大化的往金字塔原理对齐。<br>  这里简单列举下构建金字塔的步骤。<br>  自上而下：</li>
</ol>
<ul>
<li>提出主题思想</li>
<li>设想受众的主要疑问</li>
<li>写序言：背景-冲突-疑问-回答</li>
<li>与受众进行疑问&#x2F;回答式对话</li>
<li>对受众的新疑问，重复进行疑问&#x2F;回答式对话<br>  自下而上：</li>
<li>列出你想表达的所有思想要点</li>
<li>找出各要点之间的逻辑关系。</li>
<li>得出结论<br>  这里推荐书籍：《金字塔原理》 、<h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4>  当然这里有个个例，谈情说爱当中，不要和女人用这种理性系统去沟通，没啥吊用，女人是形式逻辑的典范，是辩证逻辑的障碍。</li>
</ul>
<h3 id="架构和抽象"><a href="#架构和抽象" class="headerlink" title="架构和抽象"></a>架构和抽象</h3><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p>  专业能力是架构师的安身立命之本，如何站在技术专业的视角去解决业务发展过程中的关键问题是架构师的成长之问。<br>  架构是关乎抽象与结构以及结构间关系的一门学问，面向未来，如何在横向统筹高效协同以及引领关键技术领域突破上探索一条特色的企业架构方法之路是架构师的理论和实践共同命题。</p>
<h4 id="抽象是架构师的基础能力。"><a href="#抽象是架构师的基础能力。" class="headerlink" title="抽象是架构师的基础能力。"></a>抽象是架构师的基础能力。</h4><p>  苹果-水果-果实-食物-有机物-固体<br>  以上抽象层次逐渐升高。<br>  抽象的深度根据模块所在的大环境的位置不同而不同，销售系统里边的登录人可以是售前和售后，他们都可以抽象为销售员用户，但是不能抽象为用户，用户的概念超出了销售系统的范畴。<br>  因为用户的抽象高度覆盖了销售系统、crm系统、oa系统。</p>
<p>  抽象的方法论有2个：归纳法、演绎法。<br>  关于归纳法和演绎法的介绍和使用，推荐书籍：《第一性原理》。</p>
<h4 id="边界划分"><a href="#边界划分" class="headerlink" title="边界划分"></a>边界划分</h4><p>  当前主流模式是DDD(领域驱动设计)，DDD的核心之道是边界划分，在完美的边界之后，体现的是架构里边的结构，架构当中的结构需要有关系，在DDD里边就是通信和防腐，这里边原子化编排贯穿其中，所以可以看出优雅架构的基础是边界划分，边界的划分要和抽象（技术结构抽象或者业务抽象，取决于是技术架构是业务架构）交火，又回到了结构的2大核心因素—-抽象和结构。</p>
<h3 id="思考和学习"><a href="#思考和学习" class="headerlink" title="思考和学习"></a>思考和学习</h3><p>  思考首先是学习的基石，没有思考的学习都是空中楼阁，思考的本质是创新和提效，那么怎么思考？<br>  其实这一年我都在思考这个问题，思考怎么思考~~<br>  但是通过阿里的一些高P的而与墨染，我还是总结出来了一些东西，这里借鉴埃隆马斯克的一段话:<br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWJyNHkxUTd6OT9mcm9tPXNlYXJjaCZzZWlkPTE4MDIxMDE4MDEzMjIxODg5NzYwJnNwbV9pZF9mcm9tPTMzMy4zMzcuMC4w">埃隆 · 马斯克的工程哲学 （5步法）<i class="fa fa-external-link-alt"></i></span></p>
<ol>
<li>简化需求</li>
<li>去掉不必要的流程和部件</li>
<li>内部的优化</li>
<li>稳定加速</li>
<li>自动化<br>  这5个步骤，只是思考的上层的东西，但是遇到具体问题，我们可能还是迷茫，我个人列举了几个我认为比较重要的点：</li>
</ol>
<ul>
<li>规模大的问题，先按照事情的常规演进和逻辑拆分为N个子问题，然后各个击破。</li>
<li>复杂规模大的问题，面临复杂和大量2个问题，复杂的解决之道是寻找块之间的联系和规律，然后边界划分，各个击破，大的问题解决思路是假定块之间没有联系，但是问题规模大，解决之道是<br>拆分，然后各个击破，那么是复杂驱动大量，还是大量驱动复杂？我认为首先要解决复杂，如果先把大量解决，复杂会带到每一个小块，那个时候会产生更多的复杂，但是先把复杂边界划分掉，复杂的影响范围降低到小块，小块的复杂和大量的小块能够match起来，不仅复杂度在类聚，大量也在减少，可谓一箭双雕。</li>
<li>认真做每一件事情，有些事情，你大体一看不复杂，去实践的时候就不会有敬畏之心，然后出来的产品的质量会迟早买单，当我们遇到一件能挑战我们的事情非常的认真的做完一次，你就会树立<br>自信，这种自信多做那么一两次让它成为习惯，以后所有的事情你都会养成强迫症，不优秀都难。</li>
<li>关于犯错的反省，不要以为犯错而自责，犯错之后你要窃喜，犯错是非常宝贵的经验，要认真思考总结每一次犯错，从中得到经验，踩得坑越多，以后越顺利，针对犯的错误，4思考的层次<br>每个人各有深浅，表面的反思只是问题的直接解决方案，但是每个问题背后有设计和流程上的不足导致，这个时候你在想办法解决的是设计上或者流程上的问题，档次一下就上去了，这样的思考方式能打开你的格局，看到的东西就越多，反哺到实践能让你很快的速度漂移过弯。</li>
<li>做技术要充分理解业务需求，技术的价值是为了解决现实世界的问题，这些问题你如果都没有搞明白，就去做设计和编程，那可能会做出不合理或者不稳定的软件，这是灾难，但是这里边有<br>一些现实存在的障碍，阻碍我们去很熟络的了解业务，比如工期紧张，紧急需求，跨多团队合作，沟通协调混乱，都是一些落实优雅设计的障碍，这类问题我的想法是第一提前主动了解需求背景，<br>提前准备，未雨绸缪，第二，质量和速度产生冲突的时候，阉割非核心链路功能，设计和编程上预留坑位，这里预留坑位是真的预留，不是说说而已，如果你明知道下一次迭代会填充这个坑位，你还是做的不易扩展（人的惰性，不想思考，人自身的问题），那就是自欺欺人，自欺自人就是拒绝成长，望周知，只有很透彻的了解业务，你才能做出高瞻远瞩的架构和设计，这个和技术能力无关，和你掌握了多少框架以及中间件无关（框架和中间件只是提效或者解决问题的不同手段），集团高P，都是对业务能够很快吃透和思考的人，用第一性原理来说就是想把核心问题思考出来，业务合理不合理、业务这么做的原因是什么、这个概念到底是什么意思、这个缩写是什么意思、等等，你都要搞清楚，这是通往架构的或者高P的必经之路。</li>
<li>沟通，不好意思，我又提到了沟通，因为很重要，前边我们说的沟通是出于解决工作问题的沟通之道，这里的沟通我想说的是同事之间的请教，很多创作都是站在巨人的肩膀上取得的成就，那么<br>这样的肩膀我们要多站站，同事之间讨论的问题要有目的性，先提出自己的困惑，然后让对方发表看法，我们针对对方发表的观点，思考是否可以借鉴，是否合理。</li>
</ul>
<h3 id="通过现象看本质"><a href="#通过现象看本质" class="headerlink" title="通过现象看本质"></a>通过现象看本质</h3><p>  从今年开始，国家出台很多政策，做了很多事情，透露了很多信息：</p>
<ul>
<li>互联网在国内不能说走到末路了，但是已经到了下半程，作为韭菜是时候部署新的战略了。</li>
<li>房市走到头了，如果不是刚需，杭州房市不会出现大的涨幅，杭州从2018年开始买房人，万人摇，如今看交易数量，呵呵哒，以后只能是阴跌，买房没有多大投资价值，<br>身负债务，只会让人蜜汁自信而已。</li>
<li>共同富裕之下，资本也是国家的机器的消耗品，如果在国内做生意，要严格遵守法律和纳税义务等。</li>
<li>人工智能和工业4.0是未来几十年的风口和趋势，也是重要创业方向，但是范围不要局限于国内，国人做企业没有很大的家国情怀，都是生意，不过华为做的还可以。</li>
<li>35岁焦虑是留给焦虑的人去焦虑的，有方向的人都在行动，从来不会考虑这个问题，即使考虑也是在构思解决之道，解决问题是人生主要课题，不以人的意志力为转移，此乃强势文化。</li>
<li>制造业会在国内死灰复燃，这波起死回生，又会让无数人脱离现有的阶级，无论是升级还是降级，我们一定要想办法抓住，目前已经有了初步的构思和想法，以及产品要解决的实际问题了。</li>
<li>AI和电子科技需要 学习一波，这不是为了工作，而是为了星辰大海。</li>
<li>时间是验证一个人是不是人渣，是不是同一类人的最直接有效的方法，没有之一，不要试图走捷径，那都是自找无趣。</li>
<li>keep real，此处向EDC salute！</li>
<li>团结有生力量，团建能团结的朋友，创造你我的人类文明价值。</li>
<li>不承认自己的问题，或者没有勇气放下自身不够客观的执念，江湖会教你做人，男女通用。</li>
<li>架构三板斧：多元多维+分而治之+各个击破，解决一切架构问题的方法。</li>
<li>分层架构和模块架构能解决80%的架构问题。</li>
</ul>
<h3 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h3><p>  《第一性原理》、《金字塔原理》、《假性亲密关系》、《非暴力沟通》</p>
<h3 id="新年快乐"><a href="#新年快乐" class="headerlink" title="新年快乐"></a>新年快乐</h3><p>  2021年，成长很多，非常感谢！<br>  2022年，万事如意，枝繁叶茂！<br>  happy new year ~~~<br>  <img src="https://s2.loli.net/2021/12/31/aDvFJZGchUW3YgS.jpg" alt="28551b4cb1c76ad3d62afcc5_1_.jpg"></p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>leek</tag>
      </tags>
  </entry>
  <entry>
    <title>spring_core(1)EnvironmentBuildAndExecuteProcessParse</title>
    <url>/2020/07/02/spring_core/spring_core(1)EnvironmentBuildAndExecuteProcessParse/</url>
    <content><![CDATA[<p>我们要创建一个spring的工程，然后注册一个bean到容器当中。</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><h4 id="工程创建"><a href="#工程创建" class="headerlink" title="工程创建"></a>工程创建</h4><p>创建工程spring-kernel-lecture，地址: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzExNTY3MjE4NzQvc3ByaW5nLWtlcm5lbC1sZWN0dXJlJUVGJUJDJThDJUU1JUJDJTk1JUU1JTg1JUE1JUU0JUJFJTlEJUU4JUI1JTk2JUU1JUE2JTgyJUU0JUI4JThC">https://github.com/1156721874/spring-kernel-lecture，引入依赖如下<i class="fa fa-external-link-alt"></i></span>:</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile(</span><br><span class="line">            &quot;org.springframework:spring-core:5.2.5.RELEASE&quot;,</span><br><span class="line">            &quot;org.springframework:spring-aop:5.2.5.RELEASE&quot;,</span><br><span class="line">            &quot;org.springframework:spring-beans:5.2.5.RELEASE&quot;,</span><br><span class="line">            &quot;org.springframework:spring-context:5.2.5.RELEASE&quot;,</span><br><span class="line">            &quot;org.springframework:spring-context-support:5.2.5.RELEASE&quot;,</span><br><span class="line">            &quot;org.springframework:spring-web:5.2.5.RELEASE&quot;,</span><br><span class="line">            &quot;org.springframework:spring-orm:5.2.5.RELEASE&quot;,</span><br><span class="line">            &quot;org.springframework:spring-aspects:5.2.5.RELEASE&quot;,</span><br><span class="line">            &quot;org.springframework:spring-webmvc:5.2.5.RELEASE&quot;,</span><br><span class="line">            &quot;org.springframework:spring-jdbc:5.2.5.RELEASE&quot;,</span><br><span class="line">            &quot;org.springframework:spring-instrument:5.2.5.RELEASE&quot;,</span><br><span class="line">            &quot;org.springframework:spring-tx:5.2.5.RELEASE&quot;,</span><br><span class="line">            &quot;mysql:mysql-connector-java:8.0.20&quot;,</span><br><span class="line">            &quot;org.apache.tomcat:tomcat-jdbc:9.0.34&quot;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="新建一个bean-class"><a href="#新建一个bean-class" class="headerlink" title="新建一个bean class"></a>新建一个bean class</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.tdl.spring;</span><br><span class="line"></span><br><span class="line">import org.springframework.core.io.ClassPathResource;</span><br><span class="line">import org.springframework.core.io.Resource;</span><br><span class="line"></span><br><span class="line">public class SpringClient &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Resource resource = new ClassPathResource(&quot;applicationContext.xml&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在applicationContext-xml当中配置bean"><a href="#在applicationContext-xml当中配置bean" class="headerlink" title="在applicationContext.xml当中配置bean"></a>在applicationContext.xml当中配置bean</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;student&quot; class=&quot;com.tdl.spring.bean.Student&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<h4 id="创建资源的抽象"><a href="#创建资源的抽象" class="headerlink" title="创建资源的抽象:"></a>创建资源的抽象:</h4><p>在spring当中，类路径下的类和文件，文件系统当中的文件，网络上获取的信息等都被抽象为了资源，都是Resource的实现，这次我们要加载的资源是applicationContext.xml当中的bean，因此是从class path下的资源加载，使用ClassPathResource。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Resource resource = new ClassPathResource(&quot;applicationContext.xml&quot;);</span><br></pre></td></tr></table></figure>
<p>spring当中的所有bean都会委托bean的工厂来管理，即，ioc.</p>
<p>IOC: [Inverse of control]控制反转<br>DI： [Dependency Injection] 依赖注入</p>
<p>对象的创建无需用户去创建，而是交给工厂来接手。</p>
<h4 id="工厂的创建"><a href="#工厂的创建" class="headerlink" title="工厂的创建"></a>工厂的创建</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DefaultListableBeanFactory defaultListableBeanFactory = new DefaultListableBeanFactory();</span><br></pre></td></tr></table></figure>
<p>工厂创建完毕之后，我们要使用读取器读取资源，然后把资源放到工厂里边。</p>
<h4 id="bean的读取器"><a href="#bean的读取器" class="headerlink" title="bean的读取器"></a>bean的读取器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BeanDefinitionReader beanDefinitionReader =</span><br><span class="line">  new XmlBeanDefinitionReader(defaultListableBeanFactory);</span><br><span class="line">  beanDefinitionReader.loadBeanDefinitions(resource);</span><br></pre></td></tr></table></figure>
<p>XmlBeanDefinitionReader是xml文件读取器，它将要从applicationContext.xml读取资源，然后放到defaultListableBeanFactory<br>里边。</p>
<h4 id="从工厂获取bean"><a href="#从工厂获取bean" class="headerlink" title="从工厂获取bean"></a>从工厂获取bean</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Student student = defaultListableBeanFactory.getBean(&quot;student&quot;, Student.class);</span><br><span class="line">System.out.println(student.getName());</span><br><span class="line">System.out.println(student.getAge());</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>以上步骤汇总 就是一个spring的标准的过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.tdl.spring.bean.Student;</span><br><span class="line">import org.springframework.beans.factory.support.BeanDefinitionReader;</span><br><span class="line">import org.springframework.beans.factory.support.DefaultListableBeanFactory;</span><br><span class="line">import org.springframework.beans.factory.xml.XmlBeanDefinitionReader;</span><br><span class="line">import org.springframework.core.io.ClassPathResource;</span><br><span class="line">import org.springframework.core.io.Resource;</span><br><span class="line"></span><br><span class="line">public class SpringClient &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Resource resource = new ClassPathResource(&quot;applicationContext.xml&quot;);</span><br><span class="line">        DefaultListableBeanFactory defaultListableBeanFactory</span><br><span class="line">                = new DefaultListableBeanFactory();</span><br><span class="line">        BeanDefinitionReader beanDefinitionReader =</span><br><span class="line">                new XmlBeanDefinitionReader(defaultListableBeanFactory);</span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(resource);</span><br><span class="line"></span><br><span class="line">        Student student = defaultListableBeanFactory.getBean(&quot;student&quot;, Student.class);</span><br><span class="line">        System.out.println(student.getName());</span><br><span class="line">        System.out.println(student.getAge());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于spring容器管理bean以及加载模式：</p>
<ol>
<li>需要将bean的定义信息声明在bean的配置文件当中。</li>
<li>需要通过spring抽象出的各种Resource来指定对应的配置文件。</li>
<li>需要显式声明一个spring工厂，该工厂用来掌控我们在配置文件中所声明的各种bean以及bean之间的依赖关系与注入关系。</li>
<li>需要定义一个配置信息读取器，该读取器用来读取之前所定义的bean配置文件信息。</li>
<li>读取器的作用是读取我们所声明的配置文件信息，并且将读取后的信息装配到之前所声明的工厂当中。</li>
<li>需要将读取器与工厂以及资源对象进行相应的关联处理。</li>
<li>工厂所管理的全部对象装配完毕，可以供客户端直接调用，获取客户端想要使用的各种bean对象。</li>
</ol>
<p>spring 对于bean管理的核心组件：</p>
<ol>
<li>资源抽象</li>
<li>工厂</li>
<li>配置信息读取器</li>
</ol>
<p>BeanFactory：<br>BeanFactory是spring bean工厂最顶层的抽象<br>The root interface for accessing a Spring bean container. This is the basic client view of a bean container; further interfaces such as ListableBeanFactory and org.springframework.beans.factory.config.ConfigurableBeanFactory are available for specific purposes.</p>
<p>spring bean容器最根的访问接入接口，是客户端展现的基础bean容器，更进一步像ListableBeanFactory、ListableBeanFactory都是对特定目的使用的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.beans.factory.BeanFactory</span><br><span class="line">org.springframework.beans.factory.BeanFactory#getBean(java.lang.String)</span><br><span class="line">org.springframework.beans.factory.BeanFactory#getBean(java.lang.String, java.lang.Class&lt;T&gt;)</span><br><span class="line">org.springframework.beans.factory.BeanFactory#getBean(java.lang.String, java.lang.Object...)</span><br><span class="line">org.springframework.beans.factory.BeanFactory#getBean(java.lang.Class&lt;T&gt;)</span><br><span class="line">org.springframework.beans.factory.BeanFactory#getBean(java.lang.Class&lt;T&gt;, java.lang.Object...)</span><br><span class="line">org.springframework.beans.factory.BeanFactory#getBeanProvider(java.lang.Class&lt;T&gt;)</span><br><span class="line">org.springframework.beans.factory.BeanFactory#getBeanProvider(org.springframework.core.ResolvableType)</span><br><span class="line">org.springframework.beans.factory.BeanFactory#containsBean</span><br><span class="line">org.springframework.beans.factory.BeanFactory#isSingleton</span><br><span class="line">org.springframework.beans.factory.BeanFactory#isPrototype</span><br><span class="line">org.springframework.beans.factory.BeanFactory#isTypeMatch(java.lang.String, org.springframework.core.ResolvableType)</span><br><span class="line">org.springframework.beans.factory.BeanFactory#isTypeMatch(java.lang.String, java.lang.Class&lt;?&gt;)</span><br><span class="line">org.springframework.beans.factory.BeanFactory#getType(java.lang.String)</span><br><span class="line">org.springframework.beans.factory.BeanFactory#getType(java.lang.String, boolean)</span><br><span class="line">org.springframework.beans.factory.BeanFactory#getAliases</span><br><span class="line">org.springframework.beans.factory.BeanFactory#FACTORY_BEAN_PREFIX</span><br></pre></td></tr></table></figure>

<p>实现类： DefaultListableBeanFactory</p>
<p>Resource：<br>Interface for a resource descriptor that abstracts from the actual type of underlying resource, such as a file or class path resource.<br>对实际资源的一个抽象描述，比如文件 、class path下的资源。</p>
<h3 id="ClassPathResource"><a href="#ClassPathResource" class="headerlink" title="ClassPathResource"></a>ClassPathResource</h3><p>首先看一下ClassPathResource的构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ClassPathResource(String path) &#123;</span><br><span class="line">  this(path, (ClassLoader) null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ClassPathResource(String path, @Nullable ClassLoader classLoader) &#123;</span><br><span class="line">  Assert.notNull(path, &quot;Path must not be null&quot;);</span><br><span class="line">  //将windows下的路径分割标示替换为标准的路径分割、路径中存在&quot;.&quot;的话要进行处理。</span><br><span class="line">  String pathToUse = StringUtils.cleanPath(path);</span><br><span class="line">  //以&quot;/&quot;开头的路径把&quot;/&quot;去掉</span><br><span class="line">  if (pathToUse.startsWith(&quot;/&quot;)) &#123;</span><br><span class="line">    pathToUse = pathToUse.substring(1);</span><br><span class="line">  &#125;</span><br><span class="line">  this.path = pathToUse;</span><br><span class="line">  this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ClassLoader getDefaultClassLoader() &#123;</span><br><span class="line">  ClassLoader cl = null;</span><br><span class="line">  try &#123;</span><br><span class="line">    //使用当前上下文类加载器</span><br><span class="line">    cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">  &#125;</span><br><span class="line">  catch (Throwable ex) &#123;</span><br><span class="line">    // Cannot access thread context ClassLoader - falling back...</span><br><span class="line">  &#125;</span><br><span class="line">  //当前上下文类加载器为null则使用ClassUtils的类加载器</span><br><span class="line">  if (cl == null) &#123;</span><br><span class="line">    // No thread context class loader -&gt; use class loader of this class.</span><br><span class="line">    cl = ClassUtils.class.getClassLoader();</span><br><span class="line">    //ClassUtils的类加载器为空，意味着ClassUtils的类加载器是启动类加载器，那么使用系统类加载器加载</span><br><span class="line">    if (cl == null) &#123;</span><br><span class="line">      // getClassLoader() returning null indicates the bootstrap ClassLoader</span><br><span class="line">      try &#123;</span><br><span class="line">        cl = ClassLoader.getSystemClassLoader();</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Throwable ex) &#123;</span><br><span class="line">        // Cannot access system ClassLoader - oh well, maybe the caller can live with null...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return cl;</span><br><span class="line">&#125;</span><br><span class="line">//提供类路径和class参数的构造器，有了class就可以使用class的类加载器</span><br><span class="line">public ClassPathResource(String path, @Nullable Class&lt;?&gt; clazz) &#123;</span><br><span class="line">  Assert.notNull(path, &quot;Path must not be null&quot;);</span><br><span class="line">  this.path = StringUtils.cleanPath(path);</span><br><span class="line">  this.clazz = clazz;</span><br><span class="line">&#125;</span><br><span class="line">//不被推荐使用的构造器，因为即提供了类加载器又提供了class，造成了歧义和冗余</span><br><span class="line">@Deprecated</span><br><span class="line">protected ClassPathResource(String path, @Nullable ClassLoader classLoader, @Nullable Class&lt;?&gt; clazz) &#123;</span><br><span class="line">  this.path = StringUtils.cleanPath(path);</span><br><span class="line">  this.classLoader = classLoader;</span><br><span class="line">  this.clazz = clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DefaultListableBeanFactory"><a href="#DefaultListableBeanFactory" class="headerlink" title="DefaultListableBeanFactory"></a>DefaultListableBeanFactory</h3><p>构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public DefaultListableBeanFactory() &#123;</span><br><span class="line">  super();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DefaultListableBeanFactory的父接口AbstractAutowireCapableBeanFactory</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  /**</span><br><span class="line">	 * Dependency interfaces to ignore on dependency check and autowire, as Set of</span><br><span class="line">	 * Class objects. By default, only the BeanFactory interface is ignored.</span><br><span class="line">	 */</span><br><span class="line">	private final Set&lt;Class&lt;?&gt;&gt; ignoredDependencyInterfaces = new HashSet&lt;&gt;();</span><br><span class="line">public AbstractAutowireCapableBeanFactory() &#123;</span><br><span class="line">  super();</span><br><span class="line">  ignoreDependencyInterface(BeanNameAware.class);</span><br><span class="line">  ignoreDependencyInterface(BeanFactoryAware.class);</span><br><span class="line">  ignoreDependencyInterface(BeanClassLoaderAware.class);</span><br><span class="line">&#125;</span><br><span class="line">public void ignoreDependencyInterface(Class&lt;?&gt; ifc) &#123;</span><br><span class="line">  this.ignoredDependencyInterfaces.add(ifc);</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line">ignoreDependencyInterface的作用是忽略掉ignoredDependencyInterfaces集合里边接口的实现的bean，这些bean不会进行依赖注入</span><br><span class="line">AbstractAutowireCapableBeanFactory的父类AbstractBeanFactory</span><br></pre></td></tr></table></figure>
<p>public AbstractBeanFactory() {<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### XmlBeanDefinitionReader</span><br><span class="line">BeanDefinitionReader beanDefinitionReader =  new XmlBeanDefinitionReader(defaultListableBeanFactory);</span><br><span class="line">defaultListableBeanFactory实现了BeanDefinitionRegistry接口。</span><br><span class="line">构造器：</span><br></pre></td></tr></table></figure>
<p>public XmlBeanDefinitionReader(BeanDefinitionRegistry registry) {<br>  super(registry);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XmlBeanDefinitionReader继承了AbstractBeanDefinitionReader:</span><br></pre></td></tr></table></figure>
<p>protected AbstractBeanDefinitionReader(BeanDefinitionRegistry registry) {<br>  Assert.notNull(registry, “BeanDefinitionRegistry must not be null”);<br>  this.registry &#x3D; registry;</p>
<p>  &#x2F;&#x2F; Determine ResourceLoader to use.<br>  &#x2F;&#x2F;判断defaultListableBeanFactory是否实现了ResourceLoader，如果实现了ResourceLoader，赋值给resourceLoader<br>  &#x2F;ResourceLoader: Strategy interface for loading resources (e.. class path or file system resources)<br>  &#x2F;&#x2F; ResourceLoader是用来加载文件，classpath下的文件的策略接口<br>  if (this.registry instanceof ResourceLoader) {<br>    this.resourceLoader &#x3D; (ResourceLoader) this.registry;<br>  }<br>  else {<br>    &#x2F;&#x2F;否则，创建一个PathMatchingResourcePatternResolver(内部封装了类加载器的逻辑，即ClassUtils.getDefaultClassLoader())<br>    this.resourceLoader &#x3D; new PathMatchingResourcePatternResolver();<br>  }</p>
<p>  &#x2F;&#x2F; Inherit Environment if possible<br>  &#x2F;&#x2F;defaultListableBeanFactory实现了EnvironmentCapable，直接得到环境对象<br>  if (this.registry instanceof EnvironmentCapable) {<br>    this.environment &#x3D; ((EnvironmentCapable) this.registry).getEnvironment();<br>  }<br>  else {<br>    &#x2F;&#x2F;否则直接new 一个StandardEnvironment<br>    this.environment &#x3D; new StandardEnvironment();<br>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### Environment</span><br><span class="line">Interface representing the environment in which the current application is running. Models two key aspects of the application environment: profiles and properties. Methods related to property access are exposed via the PropertyResolver superinterface.</span><br><span class="line">代表当前应用运行的环境的接口，对2个方面的应用环境进行处理：profiles和properties。</span><br><span class="line">属性的接入是通过暴露的PropertyResolver接口进行的。</span><br><span class="line">profiles：决定应用运行在什么环境之下，dev，test，uat，pro etc。</span><br><span class="line">properties: 应用当中运行的各种属性。</span><br></pre></td></tr></table></figure>
<p>public interface Environment extends PropertyResolver {<br>  org.springframework.core.env.Environment#getActiveProfiles<br>  org.springframework.core.env.Environment#getDefaultProfiles<br>  org.springframework.core.env.Environment#acceptsProfiles(java.lang.String…)<br>  org.springframework.core.env.Environment#acceptsProfiles(org.springframework.core.env.Profiles)<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Environment继承了PropertyResolver，得到了处理属性(properties)相关的功能。</span><br><span class="line"></span><br><span class="line">### 加载BeanDefinition</span><br><span class="line">beanDefinitionReader.loadBeanDefinitions(resource);</span><br></pre></td></tr></table></figure>
<p>public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {<br>  return loadBeanDefinitions(new EncodedResource(resource));<br>}<br>public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {<br>  Assert.notNull(encodedResource, “EncodedResource must not be null”);<br>  if (logger.isTraceEnabled()) {<br>    logger.trace(“Loading XML bean definitions from “ + encodedResource);<br>  }<br>  &#x2F;&#x2F;resourcesCurrentlyBeingLoaded是一个ThreadLocal<br>  Set<EncodedResource> currentResources &#x3D; this.resourcesCurrentlyBeingLoaded.get();<br>  if (currentResources &#x3D;&#x3D; null) {<br>    currentResources &#x3D; new HashSet&lt;&gt;(4);<br>    this.resourcesCurrentlyBeingLoaded.set(currentResources);<br>  }<br>  &#x2F;&#x2F; 循环导入，即存在一个资源被导入2次，一般出现在嵌套循环依赖里边。<br>  if (!currentResources.add(encodedResource)) {<br>    throw new BeanDefinitionStoreException(<br>        “Detected cyclic loading of “ + encodedResource + “ - check your import definitions!”);<br>  }<br>  &#x2F;&#x2F;InputStream是Closeable的，不需要手动关闭流<br>  try (InputStream inputStream &#x3D; encodedResource.getResource().getInputStream()) {<br>    &#x2F;&#x2F;InputSource是对xml解析sax方式的封装，InputSource是通过流的方式进行解析的<br>    InputSource inputSource &#x3D; new InputSource(inputStream);<br>    &#x2F;&#x2F;编码设置<br>    if (encodedResource.getEncoding() !&#x3D; null) {<br>      inputSource.setEncoding(encodedResource.getEncoding());<br>    }<br>    return doLoadBeanDefinitions(inputSource, encodedResource.getResource());<br>  }<br>  catch (IOException ex) {<br>    &#x2F;&#x2F;解析xml文档异常<br>    throw new BeanDefinitionStoreException(<br>        “IOException parsing XML document from “ + encodedResource.getResource(), ex);<br>  }<br>  finally {<br>    &#x2F;&#x2F;防止内存泄露<br>    currentResources.remove(encodedResource);<br>    if (currentResources.isEmpty()) {<br>      this.resourcesCurrentlyBeingLoaded.remove();<br>    }<br>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EncodedResource的底层构造器，将参数Resource赋值给resource，encoding和encoding是编码方式，</span><br><span class="line">不能同时都设置。EncodedResource封装了待加载的资源以及资源的编码方式。</span><br></pre></td></tr></table></figure>
<p>private EncodedResource(Resource resource, @Nullable String encoding, @Nullable Charset charset) {<br>  super();<br>  Assert.notNull(resource, “Resource must not be null”);<br>  this.resource &#x3D; resource;<br>  this.encoding &#x3D; encoding;<br>  this.encoding &#x3D; charset;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 从指定的文件里边加载bean</span><br><span class="line">loadBeanDefinitions返回的int是加载的bean的数量，doLoadBeanDefinitions完成真正的加载</span><br><span class="line">XmlBeanDefinitionReader:</span><br></pre></td></tr></table></figure>
<p>private DocumentLoader documentLoader &#x3D; new DefaultDocumentLoader();<br>private Class&lt;? extends BeanDefinitionDocumentReader&gt; documentReaderClass &#x3D;<br>    DefaultBeanDefinitionDocumentReader.class;<br>protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)<br>    throws BeanDefinitionStoreException {</p>
<p>  try {<br>    &#x2F;&#x2F;读取并解析，Document代表整个xml文档<br>    Document doc &#x3D; doLoadDocument(inputSource, resource);<br>    &#x2F;&#x2F;注册bean的定义<br>    int count &#x3D; registerBeanDefinitions(doc, resource);<br>    if (logger.isDebugEnabled()) {<br>      logger.debug(“Loaded “ + count + “ bean definitions from “ + resource);<br>    }<br>    return count;<br>  }<br>  ……<br>}</p>
<p>public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {<br>  &#x2F;&#x2F;创建一个读取xml文档BeanDefinition的读取器<br>  BeanDefinitionDocumentReader documentReader &#x3D; createBeanDefinitionDocumentReader();<br>  &#x2F;&#x2F;解析之前的bean的个数，<br>  int countBefore &#x3D; getRegistry().getBeanDefinitionCount();<br>  documentReader.registerBeanDefinitions(doc, createReaderContext(resource));<br>  &#x2F;&#x2F;解析之后bean的个数减去解析之前的bean的个数，这种出现不一致的情况往往是由于xml里边有import的情况导致的。<br>  return getRegistry().getBeanDefinitionCount() - countBefore;<br>}</p>
<p>protected BeanDefinitionDocumentReader createBeanDefinitionDocumentReader() {<br>  return BeanUtils.instantiateClass(this.documentReaderClass);<br>}<br>……</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">BeanUtils的相关方法：</span><br></pre></td></tr></table></figure>
<p>public static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {<br>  Assert.notNull(clazz, “Class must not be null”);<br>  if (clazz.isInterface()) {<br>    throw new BeanInstantiationException(clazz, “Specified class is an interface”);<br>  }<br>  try {<br>    return instantiateClass(clazz.getDeclaredConstructor());<br>  }<br>  catch (NoSuchMethodException ex) {<br>    &#x2F;&#x2F;找不到方法通过另外一种方式进行，findPrimaryConstructor使用的是kotlin的方式<br>    Constructor<T> ctor &#x3D; findPrimaryConstructor(clazz);<br>    if (ctor !&#x3D; null) {<br>      &#x2F;&#x2F;反射进行实例化<br>      return instantiateClass(ctor);<br>    }<br>    throw new BeanInstantiationException(clazz, “No default constructor found”, ex);<br>  }<br>  catch (LinkageError err) {<br>    throw new BeanInstantiationException(clazz, “Unresolvable class definition”, err);<br>  }<br>}</p>
<p>public static <T> T instantiateClass(Constructor<T> ctor, Object… args) throws BeanInstantiationException {<br>  Assert.notNull(ctor, “Constructor must not be null”);<br>  try {<br>    &#x2F;&#x2F;突破访问修饰符的限制<br>    ReflectionUtils.makeAccessible(ctor);<br>    &#x2F;&#x2F;对kotlin的支持<br>    if (KotlinDetector.isKotlinReflectPresent() &amp;&amp; KotlinDetector.isKotlinType(ctor.getDeclaringClass())) {<br>      return KotlinDelegate.instantiateClass(ctor, args);<br>    }<br>    else {<br>      &#x2F;&#x2F;得到构造器的参数<br>      Class<?>[] parameterTypes = ctor.getParameterTypes();
      Assert.isTrue(args.length <= parameterTypes.length, "Can't specify more arguments than constructor parameters");
      Object[] argsWithDefaultValues = new Object[args.length];
      for (int i = 0 ; i < args.length; i++) {
        if (args[i] == null) {
          Class<?> parameterType &#x3D; parameterTypes[i];<br>          argsWithDefaultValues[i] &#x3D; (parameterType.isPrimitive() ? DEFAULT_TYPE_VALUES.get(parameterType) : null);<br>        }<br>        else {<br>          argsWithDefaultValues[i] &#x3D; args[i];<br>        }<br>      }<br>      &#x2F;&#x2F;反射得到实例<br>      return ctor.newInstance(argsWithDefaultValues);<br>    }<br>  }<br>……<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BeanDefinitionDocumentReader构建完毕之后，接下来就是文档的解析和bean的注册。</span><br><span class="line"></span><br><span class="line">回到XmlBeanDefinitionReader的registerBeanDefinitions方法，继续往下分析</span><br><span class="line">【documentReader.registerBeanDefinitions(doc, createReaderContext(resource));】</span><br><span class="line">DefaultBeanDefinitionDocumentReader:</span><br></pre></td></tr></table></figure>
<p>public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {<br>  this.readerContext &#x3D; readerContext;<br>  doRegisterBeanDefinitions(doc.getDocumentElement());<br>}</p>
<p>&#x2F;&#x2F;在给定的root元素下，注册每个bean的定义<br>protected void doRegisterBeanDefinitions(Element root) {<br>  &#x2F;&#x2F; Any nested <beans> elements will cause recursion in this method. In<br>  &#x2F;&#x2F; order to propagate and preserve <beans> default-* attributes correctly,<br>  &#x2F;&#x2F; keep track of the current (parent) delegate, which may be null. Create<br>  &#x2F;&#x2F; the new (child) delegate with a reference to the parent for fallback purposes,<br>  &#x2F;&#x2F; then ultimately reset this.delegate back to its original (parent) reference.<br>  &#x2F;&#x2F; this behavior emulates a stack of delegates without actually necessitating one.<br>  &#x2F;&#x2F; 任何嵌套的元素都可能导致递归。</p>
<p>  &#x2F;&#x2F;this.delegate是一种委托，这里使用了委托的设计模式<br>  BeanDefinitionParserDelegate parent &#x3D; this.delegate;<br>  this.delegate &#x3D; createDelegate(getReaderContext(), root, parent);</p>
<p>  if (this.delegate.isDefaultNamespace(root)) {<br>    String profileSpec &#x3D; root.getAttribute(PROFILE_ATTRIBUTE);<br>    if (StringUtils.hasText(profileSpec)) {<br>      String[] specifiedProfiles &#x3D; StringUtils.tokenizeToStringArray(<br>          profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);<br>      &#x2F;&#x2F; We cannot use Profiles.of(…) since profile expressions are not supported<br>      &#x2F;&#x2F; in XML config. See SPR-12458 for details.<br>      if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {<br>        if (logger.isDebugEnabled()) {<br>          logger.debug(“Skipped XML bean definition file due to specified profiles [“ + profileSpec +<br>              “] not matching: “ + getReaderContext().getResource());<br>        }<br>        return;<br>      }<br>    }<br>  }<br>  &#x2F;&#x2F;默认空实现，留给用户的扩展【模板方法模式】<br>  preProcessXml(root);<br>  &#x2F;&#x2F;从root开始解析【模板方法模式】<br>  parseBeanDefinitions(root, this.delegate);<br>  &#x2F;&#x2F;默认空实现，留给用户的扩展【模板方法模式】<br>  postProcessXml(root);</p>
<p>  this.delegate &#x3D; parent;<br>}</p>
<p>protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {<br>  &#x2F;&#x2F;根元素的解析<br>  if (delegate.isDefaultNamespace(root)) {<br>    NodeList nl &#x3D; root.getChildNodes();<br>    for (int i &#x3D; 0; i &lt; nl.getLength(); i++) {<br>      Node node &#x3D; nl.item(i);<br>      &#x2F;&#x2F;xml当中的注释(<!-- -->)也会被加载，但是不是Element对象<br>      if (node instanceof Element) {<br>        Element ele &#x3D; (Element) node;<br>        &#x2F;&#x2F;默认命名空间<br>        if (delegate.isDefaultNamespace(ele)) {<br>          parseDefaultElement(ele, delegate);<br>        }<br>        else {<br>          delegate.parseCustomElement(ele);<br>        }<br>      }<br>    }<br>  }<br>  else {<br>    &#x2F;&#x2F;默认命名空间之外的元素<br>    delegate.parseCustomElement(root);<br>  }<br>}<br>&#x2F;&#x2F;某个元素的解析都是由委托对象完成的<br>private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {<br>  &#x2F;&#x2F;impot是顶级元素<br>  if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {<br>    &#x2F;&#x2F;读取另外一个xml文件进行加载<br>    importBeanDefinitionResource(ele);<br>  }<br>  &#x2F;&#x2F;alias是顶级元素<br>  else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {<br>    processAliasRegistration(ele);<br>  }<br>  &#x2F;&#x2F;bean是顶级元素<br>  else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {<br>    processBeanDefinition(ele, delegate);<br>  }<br>  &#x2F;&#x2F;嵌套的情况<br>  else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {<br>    &#x2F;&#x2F; recurse<br>    &#x2F;&#x2F;递归调用<br>    doRegisterBeanDefinitions(ele);<br>  }<br>}<br>&#x2F;&#x2F;bean元素的解析和注册<br>protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {<br>  &#x2F;&#x2F;解析bean的定义，构造成BeanDefinitionHolder，是bean的完整的定义<br>  BeanDefinitionHolder bdHolder &#x3D; delegate.parseBeanDefinitionElement(ele);<br>  if (bdHolder !&#x3D; null) {<br>    &#x2F;&#x2F;对bean的定义进行最终修饰<br>    bdHolder &#x3D; delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);<br>    try {<br>      &#x2F;&#x2F; Register the final decorated instance.<br>      &#x2F;&#x2F;bdHolder是解析出来的bean的定义信息，getReaderContext().getRegistry()是工厂，即<br>      &#x2F;&#x2F;将bean注册到工厂里边<br>      BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());<br>    }<br>    catch (BeanDefinitionStoreException ex) {<br>      getReaderContext().error(“Failed to register bean definition with name ‘“ +<br>          bdHolder.getBeanName() + “‘“, ele, ex);<br>    }<br>    &#x2F;&#x2F; Send registration event.<br>    getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));<br>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delegate.parseBeanDefinitionElement(ele)完成对Element的解析：</span><br><span class="line">BeanDefinitionParserDelegate:</span><br></pre></td></tr></table></figure>
<p>public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {<br>  return parseBeanDefinitionElement(ele, null);<br>}</p>
<p>public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {<br>  &#x2F;&#x2F;bean的id<br>  String id &#x3D; ele.getAttribute(ID_ATTRIBUTE);<br>  &#x2F;&#x2F;bean的name<br>  String nameAttr &#x3D; ele.getAttribute(NAME_ATTRIBUTE);</p>
<p>  List<String> aliases &#x3D; new ArrayList&lt;&gt;();<br>  if (StringUtils.hasLength(nameAttr)) {<br>    String[] nameArr &#x3D; StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);<br>    aliases.addAll(Arrays.asList(nameArr));<br>  }</p>
<p>  String beanName &#x3D; id;<br>  if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) {<br>    beanName &#x3D; aliases.remove(0);<br>    if (logger.isTraceEnabled()) {<br>      logger.trace(“No XML ‘id’ specified - using ‘“ + beanName +<br>          “‘ as bean name and “ + aliases + “ as aliases”);<br>    }<br>  }</p>
<p>  if (containingBean &#x3D;&#x3D; null) {<br>    &#x2F;&#x2F;bean名称唯一性检查<br>    checkNameUniqueness(beanName, aliases, ele);<br>  }<br>  &#x2F;&#x2F;parseBeanDefinitionElement里边会解析xml得到bean的class的名字<br>  AbstractBeanDefinition beanDefinition &#x3D; parseBeanDefinitionElement(ele, beanName, containingBean);<br>  if (beanDefinition !&#x3D; null) {<br>    if (!StringUtils.hasText(beanName)) {<br>      try {<br>        if (containingBean !&#x3D; null) {<br>          &#x2F;&#x2F;definition.getParentName() + “$child” + “#1” or<br>          &#x2F;&#x2F;definition.getFactoryBeanName() + “$created” + “#1”<br>          beanName &#x3D; BeanDefinitionReaderUtils.generateBeanName(<br>              beanDefinition, this.readerContext.getRegistry(), true);<br>        }<br>        else {<br>          beanName &#x3D; this.readerContext.generateBeanName(beanDefinition);<br>          &#x2F;&#x2F; Register an alias for the plain bean class name, if still possible,<br>          &#x2F;&#x2F; if the generator returned the class name plus a suffix.<br>          &#x2F;&#x2F; This is expected for Spring 1.2&#x2F;2.0 backwards compatibility.<br>          &#x2F;&#x2F;获取到bean的类的名字，类的全限定名<br>          String beanClassName &#x3D; beanDefinition.getBeanClassName();<br>          if (beanClassName !&#x3D; null &amp;&amp;<br>              beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;<br>              !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {<br>            aliases.add(beanClassName);<br>          }<br>        }<br>        if (logger.isTraceEnabled()) {<br>          logger.trace(“Neither XML ‘id’ nor ‘name’ specified - “ +<br>              “using generated bean name [“ + beanName + “]”);<br>        }<br>      }<br>      catch (Exception ex) {<br>        error(ex.getMessage(), ele);<br>        return null;<br>      }<br>    }<br>    String[] aliasesArray &#x3D; StringUtils.toStringArray(aliases);<br>    &#x2F;&#x2F;BeanDefinitionHolder持有beanDefinition、bean的名字，bean的别名数组<br>    return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);<br>  }</p>
<p>  return null;<br>}<br>    public static final String CLASS_ATTRIBUTE &#x3D; “class”;<br>public AbstractBeanDefinition parseBeanDefinitionElement(<br>    Element ele, String beanName, @Nullable BeanDefinition containingBean) {</p>
<p>  this.parseState.push(new BeanEntry(beanName));<br>  &#x2F;&#x2F;bean的类型解析<br>  String className &#x3D; null;<br>  if (ele.hasAttribute(CLASS_ATTRIBUTE)) {<br>    className &#x3D; ele.getAttribute(CLASS_ATTRIBUTE).trim();<br>  }<br>  String parent &#x3D; null;<br>  if (ele.hasAttribute(PARENT_ATTRIBUTE)) {<br>    parent &#x3D; ele.getAttribute(PARENT_ATTRIBUTE);<br>  }</p>
<p>  try {<br>    &#x2F;&#x2F;创建AbstractBeanDefinition<br>    AbstractBeanDefinition bd &#x3D; createBeanDefinition(className, parent);<br>    &#x2F;&#x2F;bean的属性的解析<br>    parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);<br>    &#x2F;&#x2F;描述相关信息设置<br>    bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));<br>    &#x2F;&#x2F;元数据信息配置<br>    parseMetaElements(ele, bd);<br>    parseLookupOverrideSubElements(ele, bd.getMethodOverrides());<br>    parseReplacedMethodSubElements(ele, bd.getMethodOverrides());<br>    &#x2F;&#x2F;构造方法的参数的解析(bean的注入方式一种是set的方式注入(属性注入)，一种是构造器的注入)<br>    parseConstructorArgElements(ele, bd);<br>    &#x2F;&#x2F;属性解析(属性注入)，包括ref属性，value属性等<br>    parsePropertyElements(ele, bd);<br>    &#x2F;&#x2F;qualifier解析<br>    parseQualifierElements(ele, bd);</p>
<pre><code>bd.setResource(this.readerContext.getResource());
bd.setSource(extractSource(ele));

return bd;
</code></pre>
<p>  }<br>  catch (ClassNotFoundException ex) {<br>    error(“Bean class [“ + className + “] not found”, ele, ex);<br>  }<br>  catch (NoClassDefFoundError err) {<br>    error(“Class that bean class [“ + className + “] depends on not found”, ele, err);<br>  }<br>  catch (Throwable ex) {<br>    error(“Unexpected failure during bean definition parsing”, ele, ex);<br>  }<br>  finally {<br>    this.parseState.pop();<br>  }</p>
<p>  return null;<br>}</p>
<p>protected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName)<br>    throws ClassNotFoundException {</p>
<p>  return BeanDefinitionReaderUtils.createBeanDefinition(<br>      parentName, className, this.readerContext.getBeanClassLoader());<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BeanDefinitionReaderUtils根据类名和bean的父级名称封装为AbstractBeanDefinition.</span><br><span class="line">BeanDefinitionReaderUtils:</span><br></pre></td></tr></table></figure>
<p>public static AbstractBeanDefinition createBeanDefinition(<br>    @Nullable String parentName, @Nullable String className, @Nullable ClassLoader classLoader) throws ClassNotFoundException {</p>
<p>  GenericBeanDefinition bd &#x3D; new GenericBeanDefinition();<br>  bd.setParentName(parentName);<br>  if (className !&#x3D; null) {<br>    if (classLoader !&#x3D; null) {<br>      &#x2F;&#x2F;设置bean的class对象<br>      bd.setBeanClass(ClassUtils.forName(className, classLoader));<br>    }<br>    else {<br>      &#x2F;&#x2F;classloader是空的情况，直接返回类对象的名字<br>      bd.setBeanClassName(className);<br>    }<br>  }<br>  return bd;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GenericBeanDefinition是AbstractBeanDefinition的子类。</span><br><span class="line">AbstractBeanDefinition的setBeanClass和setBeanClassName都是对同一个成员变量的赋值：</span><br></pre></td></tr></table></figure>
<p>private volatile Object beanClass;<br>public void setBeanClass(@Nullable Class&lt;?&gt; beanClass) {<br>  this.beanClass &#x3D; beanClass;<br>}<br>public void setBeanClassName(@Nullable String beanClassName) {<br>  this.beanClass &#x3D; beanClassName;<br>}</p>
<p>public String getBeanClassName() {<br>  Object beanClassObject &#x3D; this.beanClass;<br>  if (beanClassObject instanceof Class) {<br>    return ((Class&lt;?&gt;) beanClassObject).getName();<br>  }<br>  else {<br>    return (String) beanClassObject;<br>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ClassUtils.forName是jdk的Class.forName的增强:</span><br></pre></td></tr></table></figure>
<p>public static Class&lt;?&gt; forName(String name, @Nullable ClassLoader classLoader)<br>    throws ClassNotFoundException, LinkageError {</p>
<p>  Assert.notNull(name, “Name must not be null”);<br>  &#x2F;&#x2F;原生类型的解析<br>  Class<?> clazz = resolvePrimitiveClassName(name);
  if (clazz == null) {
    clazz = commonClassCache.get(name);
  }
  if (clazz != null) {
    return clazz;
  }
  //数组类型的解析
  // "java.lang.String[]" style arrays
  if (name.endsWith(ARRAY_SUFFIX)) {
    String elementClassName = name.substring(0, name.length() - ARRAY_SUFFIX.length());
    Class<?> elementClass &#x3D; forName(elementClassName, classLoader);<br>    return Array.newInstance(elementClass, 0).getClass();<br>  }</p>
<p>  &#x2F;&#x2F; “[Ljava.lang.String;” style arrays<br>  if (name.startsWith(NON_PRIMITIVE_ARRAY_PREFIX) &amp;&amp; name.endsWith(“;”)) {<br>    String elementName &#x3D; name.substring(NON_PRIMITIVE_ARRAY_PREFIX.length(), name.length() - 1);<br>    Class&lt;?&gt; elementClass &#x3D; forName(elementName, classLoader);<br>    return Array.newInstance(elementClass, 0).getClass();<br>  }</p>
<p>  &#x2F;&#x2F; “[[I” or “[[Ljava.lang.String;” style arrays<br>  if (name.startsWith(INTERNAL_ARRAY_PREFIX)) {<br>    String elementName &#x3D; name.substring(INTERNAL_ARRAY_PREFIX.length());<br>    Class&lt;?&gt; elementClass &#x3D; forName(elementName, classLoader);<br>    return Array.newInstance(elementClass, 0).getClass();<br>  }</p>
<p>  ClassLoader clToUse &#x3D; classLoader;<br>  if (clToUse &#x3D;&#x3D; null) {<br>    clToUse &#x3D; getDefaultClassLoader();<br>  }<br>  try {<br>    &#x2F;&#x2F;调用jdk的Class.forName返回class的对象<br>    return Class.forName(name, false, clToUse);<br>  }<br>  catch (ClassNotFoundException ex) {<br>    int lastDotIndex &#x3D; name.lastIndexOf(PACKAGE_SEPARATOR);<br>    if (lastDotIndex !&#x3D; -1) {<br>      String innerClassName &#x3D;<br>          name.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR + name.substring(lastDotIndex + 1);<br>      try {<br>        return Class.forName(innerClassName, false, clToUse);<br>      }<br>      catch (ClassNotFoundException ex2) {<br>        &#x2F;&#x2F; Swallow - let original exception get through<br>      }<br>    }<br>    throw ex;<br>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">回到BeanDefinitionParserDelegate的parseBeanDefinitionElement方法，【AbstractBeanDefinition bd = createBeanDefinition(className, parent);】创建完毕之后，接下里是parseBeanDefinitionAttributes()，完成bean的属性的解析:</span><br></pre></td></tr></table></figure>
<p>private static final String SINGLETON_ATTRIBUTE &#x3D; “singleton”;<br>public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,<br>    @Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) {<br>      &#x2F;&#x2F;bean的作用域范围是singleton的时候不支持，报告错误【历史遗留问题】<br>      if (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {<br>        error(“Old 1.x ‘singleton’ attribute in use - upgrade to ‘scope’ declaration”, ele);<br>      }<br>      else if (ele.hasAttribute(SCOPE_ATTRIBUTE)) {<br>        &#x2F;&#x2F;将scope的值取出来，然后设置到AbstractBeanDefinition里边，默认是singleton。<br>        bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));<br>      }<br>    }</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">parseBeanDefinitionAttributes方法会对很对属性进行解析和配置:</span><br><span class="line">![bean-attribute.png](bean-attribute.png)</span><br><span class="line"></span><br><span class="line">#### 将bean注册到工厂</span><br><span class="line">回到DefaultBeanDefinitionDocumentReader的processBeanDefinition方法：</span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;bean元素的解析和注册<br>protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {<br>  &#x2F;&#x2F;解析bean的定义，构造成BeanDefinitionHolder，是bean的完整的定义<br>  BeanDefinitionHolder bdHolder &#x3D; delegate.parseBeanDefinitionElement(ele);<br>  if (bdHolder !&#x3D; null) {<br>    &#x2F;&#x2F;对bean的定义进行最终修饰<br>    bdHolder &#x3D; delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);<br>    try {<br>      &#x2F;&#x2F; Register the final decorated instance.<br>      &#x2F;&#x2F;bdHolder是解析出来的bean的定义信息，getReaderContext().getRegistry()是工厂，即<br>      &#x2F;&#x2F;将bean注册到工厂里边<br>      BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());<br>    }<br>    catch (BeanDefinitionStoreException ex) {<br>      getReaderContext().error(“Failed to register bean definition with name ‘“ +<br>          bdHolder.getBeanName() + “‘“, ele, ex);<br>    }<br>    &#x2F;&#x2F; Send registration event.<br>    getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));<br>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">经过对bean的解析，我们得到了bean的定义BeanDefinitionHolder。</span><br><span class="line">接下来时注册bean的定义到工厂里边，即【BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());】</span><br><span class="line">BeanDefinitionReaderUtils:</span><br></pre></td></tr></table></figure>
<p>public static void registerBeanDefinition(<br>    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)<br>    throws BeanDefinitionStoreException {</p>
<p>  &#x2F;&#x2F; Register bean definition under primary name.<br>  &#x2F;&#x2F;获取bean的名字<br>  String beanName &#x3D; definitionHolder.getBeanName();<br>  &#x2F;&#x2F;将bean的名字和bean的定义注册带工厂<br>  registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</p>
<p>  &#x2F;&#x2F; Register aliases for bean name, if any.<br>  String[] aliases &#x3D; definitionHolder.getAliases();<br>  if (aliases !&#x3D; null) {<br>    for (String alias : aliases) {<br>      registry.registerAlias(beanName, alias);<br>    }<br>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">工厂的注册方法registerBeanDefinition：</span><br><span class="line">org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition(String beanName, BeanDefinition beanDefinition);</span><br></pre></td></tr></table></figure>
<p>&#x2F;** Map of bean definition objects, keyed by bean name. *&#x2F;<br>private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap &#x3D; new ConcurrentHashMap&lt;&gt;(256);</p>
<p>public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)<br>    throws BeanDefinitionStoreException {</p>
<p>  Assert.hasText(beanName, “Bean name must not be empty”);<br>  Assert.notNull(beanDefinition, “BeanDefinition must not be null”);</p>
<p>  if (beanDefinition instanceof AbstractBeanDefinition) {<br>    try {<br>      &#x2F;&#x2F;对bean进行验证<br>      ((AbstractBeanDefinition) beanDefinition).validate();<br>    }<br>    catch (BeanDefinitionValidationException ex) {<br>      throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,<br>          “Validation of bean definition failed”, ex);<br>    }<br>  }<br>  &#x2F;&#x2F;根据bean的名字得到bean的定义对象，spring工厂最核心的容器就是一个ConcurrentHashMap<br>  BeanDefinition existingDefinition &#x3D; this.beanDefinitionMap.get(beanName);<br>  &#x2F;&#x2F;当前容器存在这个bean<br>  if (existingDefinition !&#x3D; null) {<br>    &#x2F;&#x2F;不允许复写，直接抛异常<br>    if (!isAllowBeanDefinitionOverriding()) {<br>      throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);<br>    }<br>    else if (existingDefinition.getRole() &lt; beanDefinition.getRole()) {<br>      &#x2F;&#x2F; e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE<br>      if (logger.isInfoEnabled()) {<br>        logger.info(“Overriding user-defined bean definition for bean ‘“ + beanName +<br>            “‘ with a framework-generated bean definition: replacing [“ +<br>            existingDefinition + “] with [“ + beanDefinition + “]”);<br>      }<br>    }<br>    &#x2F;&#x2F;当前bean和既有的bean不相同，打印日志<br>    else if (!beanDefinition.equals(existingDefinition)) {<br>      if (logger.isDebugEnabled()) {<br>        logger.debug(“Overriding bean definition for bean ‘“ + beanName +<br>            “‘ with a different definition: replacing [“ + existingDefinition +<br>            “] with [“ + beanDefinition + “]”);<br>      }<br>    }<br>    else {<br>      if (logger.isTraceEnabled()) {<br>        logger.trace(“Overriding bean definition for bean ‘“ + beanName +<br>            “‘ with an equivalent definition: replacing [“ + existingDefinition +<br>            “] with [“ + beanDefinition + “]”);<br>      }<br>    }<br>    &#x2F;&#x2F;往集合里边塞入当前bean的定义<br>    this.beanDefinitionMap.put(beanName, beanDefinition);<br>  }<br>  else {<br>    &#x2F;&#x2F;工厂中不存在当前参数的bean</p>
<pre><code>if (hasBeanCreationStarted()) &#123;
  // Cannot modify startup-time collection elements anymore (for stable iteration)
  //不能修改启动阶段的集合元素，这里要进行同步
  synchronized (this.beanDefinitionMap) &#123;
    this.beanDefinitionMap.put(beanName, beanDefinition);
    List&lt;String&gt; updatedDefinitions = new ArrayList&lt;&gt;(this.beanDefinitionNames.size() + 1);
    updatedDefinitions.addAll(this.beanDefinitionNames);
    updatedDefinitions.add(beanName);
    this.beanDefinitionNames = updatedDefinitions;
    removeManualSingletonName(beanName);
  &#125;
&#125;
else &#123;
  // Still in startup registration phase
  //直接加入到集合
  this.beanDefinitionMap.put(beanName, beanDefinition);
  this.beanDefinitionNames.add(beanName);
  removeManualSingletonName(beanName);
&#125;
this.frozenBeanDefinitionNames = null;
</code></pre>
<p>  }</p>
<p>  if (existingDefinition !&#x3D; null || containsSingleton(beanName)) {<br>    resetBeanDefinition(beanName);<br>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">此时工厂的ConcurrentHashMap里边就会存在bean的定义的key-value对。</span><br><span class="line">bean的定义注册完毕之后，回到DefaultBeanDefinitionDocumentReader的processBeanDefinition方法：</span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;Send registration event.<br>&#x2F;&#x2F;观察者模式，bean的注册的时候会触发一些事件，通知观察者<br>getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">回到org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#parseDefaultElement方法，</span><br><span class="line">此方法完成了bean的解析和注册。</span><br><span class="line">流程再往回返，来到org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#doRegisterBeanDefinitions</span><br></pre></td></tr></table></figure>
<p>protected void doRegisterBeanDefinitions(Element root) {<br>  ……<br>  preProcessXml(root);<br>  &#x2F;&#x2F;bean的解析和注册<br>  parseBeanDefinitions(root, this.delegate);<br>  postProcessXml(root);<br>  ……<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">###  总结</span><br><span class="line">至此我们完成了如下四行代码:</span><br></pre></td></tr></table></figure>
<p>Resource resource &#x3D; new ClassPathResource(“applicationContext.xml”);<br>DefaultListableBeanFactory defaultListableBeanFactory<br>        &#x3D; new DefaultListableBeanFactory();<br>BeanDefinitionReader beanDefinitionReader &#x3D;<br>        new XmlBeanDefinitionReader(defaultListableBeanFactory);<br>beanDefinitionReader.loadBeanDefinitions(resource);</p>
<pre><code>关于spring bean实例的注册流程
1. 定义好spring的配置文件
2. 通过Resource对象将spring配置文件进行抽象，抽象成一个具体的Resource对象(如ClassPathResource)
3. 定义好将要使用的bean工厂（各种BeanFactory）
4. 定义好XmlBeanDefinationReader对象，并将工厂对象作为参数传递进去，从而构建好二者之间的关联关系
5. 通过XmlBeanDefinationReader对象读取之前所抽取出的Rresource对象
6. 流程开始尽心解析
7. 针对XML文件进行各种元素属性的解析，这里面，真正的解析是通过BeanDefinationParserDelegate对象来完成的(委托模式)
8. 通过BeanDefinationParserDelegate对象在解析XML文件时，又使用了模板方法设计模式(pre,process,post)
9. 当所有的bean元素标签元素都解析完毕后，开始定义一个BeanDefination对象，该对象是一个非常重要的对象，里面容纳了一个bean相关的所有属性。
10. BeanDefination对象创建完毕后，Spring又会创建一个BeanDefinationHolder对象来持有这个BeanDefination对象。
11. BeanDefinationHolder对象主要包含两部分内容：beanName和BeanDefination。
12. 工厂将会解析出来的Bean信息存放到内部的一个ConcurrentHashMap中，该Map的键是beanName（唯一），值是beanDefination对象。
13. 调用bean解析完毕的触发动作，从而触发相应的监听器的方法的执行(使用到了观察者模式)
</code></pre>
]]></content>
      <categories>
        <category>spring_core</category>
      </categories>
      <tags>
        <tag>EnvironmentBuildAndExecuteProcessParse spring环境搭建 执行流程分析</tag>
      </tags>
  </entry>
  <entry>
    <title>spring_core(3)AOP剖析</title>
    <url>/2020/07/11/spring_core/spring_core(3)aop/</url>
    <content><![CDATA[<h3 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h3><h4 id="Spring-AOP目标"><a href="#Spring-AOP目标" class="headerlink" title="Spring AOP目标"></a>Spring AOP目标</h4><ul>
<li>将分散在程序各处的横切关注点剥离出来并以集中的方式进行表达</li>
<li>使得开发人员能够专注于业务逻辑的实现而非繁杂的非功能代码，简化了程序编写与单元测试</li>
<li>应用场景<ul>
<li>日志</li>
<li>安全</li>
<li>事物<span id="more"></span>
<h4 id="AOP-VS-继承"><a href="#AOP-VS-继承" class="headerlink" title="AOP VS 继承"></a>AOP VS 继承</h4></li>
</ul>
</li>
<li>AOP重点考虑的是程序的横切逻辑</li>
<li>继承重点考虑的是纵向的职责分派(面向对象推荐组合的方式，而不是滥用继承)</li>
</ul>
<h4 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h4><ul>
<li>Advice(通知)<ul>
<li>定义在连接点处的行为，围绕方法调用而进行注入</li>
</ul>
</li>
<li>Pointcut(切点)<ul>
<li>确定在哪些连接点处应用通知</li>
</ul>
</li>
<li>Advisor(通知器)<ul>
<li>组合Advice与Pointcut</li>
</ul>
</li>
</ul>
<h4 id="spring-aop实现"><a href="#spring-aop实现" class="headerlink" title="spring aop实现"></a>spring aop实现</h4><p>ProxyFactory</p>
<ul>
<li>FactoryBean implemention that builds an aop Proxy based on beans in spring BeanFactory</li>
<li>Spring AOP的底层实现与源头</li>
<li>FactoryBean可以理解为对BeanFactory中的bean的一个代理。</li>
</ul>
<h4 id="ProxyFactoryBean的构成"><a href="#ProxyFactoryBean的构成" class="headerlink" title="ProxyFactoryBean的构成"></a>ProxyFactoryBean的构成</h4><ul>
<li>target<ul>
<li>目标对象，需要对齐进行切面增强</li>
</ul>
</li>
<li>proxyInterfaces<ul>
<li>代理对象所实现的接口</li>
</ul>
</li>
<li>interceptorNames<ul>
<li>通知器(Advisor)列表，通知器中包含了通知(Advice)与切点(Pointcut)</li>
</ul>
</li>
</ul>
<h4 id="ProxyFactoryBean的作用"><a href="#ProxyFactoryBean的作用" class="headerlink" title="ProxyFactoryBean的作用"></a>ProxyFactoryBean的作用</h4><ul>
<li>总的来说，ProxyFactoryBean的作用可用下面这句话概括<ul>
<li>针对目标对象创建代理对象，将对目标对象方法的调用转到对应代理对象方法的调用，并且可以在代理对象方法调用前后执行与之匹配的各个通知器中定义好的方法</li>
</ul>
</li>
</ul>
<h4 id="目标代理对象的创建"><a href="#目标代理对象的创建" class="headerlink" title="目标代理对象的创建"></a>目标代理对象的创建</h4><ul>
<li>spring通过3种方式创建目标代理对象<ul>
<li>jdk动态代理</li>
<li>cglib</li>
<li>objenessCglibAopProxy</li>
</ul>
</li>
</ul>
<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><ul>
<li>代理模式的作用是：为其他对象提供一种代理以控制对这个对象的访问</li>
<li>在某些情况下，一个客户端或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用</li>
</ul>
<h5 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h5><ul>
<li>如果目标对象实现了接口，那么spring就会通过jdk动态代理为目标对象生成代理<br><img src="/proxy.png" alt="proxy.png"></li>
<li>java动态代理类似于java.lang.reflect包下，一般主要涉及到以下2个接口：<ul>
<li>interface InvocationHandler：该接口仅仅定义一个方法:public object invoke(Object obj, Method method,Object[] args)<ul>
<li>在实际使用时，第一个参数obj一般是指代理类，method是被代理的方法，args为该方法的参数数组，这个抽象方法在代理类中动态实现。</li>
</ul>
</li>
<li>Proxy：该类即为动态代理类，其中主要包含以下内容<ul>
<li>static Object newProxyInstance(classLoader loader,Class[] interfaces,InvocationHandler h)</li>
<li>返回代理类的一个实例，返回后的代理类可以被代理类使用</li>
</ul>
</li>
</ul>
</li>
<li>动态代理是这样一种class：<ul>
<li>在运行时生成class，在生成它时你必须提供一组interface给他，，然后该class就会声明它实现了这些interface。因此我们可以将该class的实例当做这些interface中的任何一个来用，当然，这个动态代理其实就是一个Proxy，他不会替你作实质的工作，在生成他的实例时你必须提供一个handler，由他接管实际的工作</li>
</ul>
</li>
</ul>
<h4 id="jdk动态代理的实现"><a href="#jdk动态代理的实现" class="headerlink" title="jdk动态代理的实现"></a>jdk动态代理的实现</h4><ol>
<li>创建一个接口InvocationHandler的类，他必须实现invoke方法</li>
<li>创建被代理的类以及接口</li>
<li>通过Proxy的静态以及接口<br>newProxyInstance(classLoader loader,Class[] iterfaces,InvocationHandler h)创建一个被代理</li>
<li>通过代理调用方法<br>参考之前的文章：<br><a href="https://ceaser.wang/2018/10/05/jvm%E5%8E%9F%E7%90%86%EF%BC%8836%EF%BC%89%E9%80%8F%E8%BF%87%E5%AD%97%E8%8A%82%E7%A0%81%E7%94%9F%E6%88%90%E5%AE%A1%E8%A7%86Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%BF%90%E4%BD%9C%E6%9C%BA%E5%88%B6/">jvm原理（36）透过字节码生成审视Java动态代理运作机制</a></li>
</ol>
<h4 id="CGLIB代理"><a href="#CGLIB代理" class="headerlink" title="CGLIB代理"></a>CGLIB代理</h4><ul>
<li>如果目标类未实现接口，那么spring就会使用cglib库为其创建代理</li>
</ul>
<h4 id="spring-aop的应用场景：事物"><a href="#spring-aop的应用场景：事物" class="headerlink" title="spring aop的应用场景：事物"></a>spring aop的应用场景：事物</h4><ul>
<li>事务是任何一个应用都要仔细考虑的问题</li>
<li>事务代理经常是一些程式化代码</li>
<li>手工处理程序事务较易出错</li>
<li>事务是spring aop非常好的一个应用场景<ul>
<li>极大减轻了程序员的工作量</li>
<li>将事务传播属性等内容交给spring来做</li>
<li>开发人员只需要考虑业务逻辑</li>
<li>程序代码中将见不到事务相关代码(声明式事务)</li>
</ul>
</li>
</ul>
<h4 id="spring事务的创建"><a href="#spring事务的创建" class="headerlink" title="spring事务的创建"></a>spring事务的创建</h4><ul>
<li>spring提供了一个统一的父类来表示不同的事务处理器<ul>
<li>PlatformTransactionManager</li>
</ul>
</li>
<li>事务的开启、提交、回滚等则由具体的事务管理器来实现</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>spring核心ioc与aop是整个审判日那个的基石</li>
<li>spring aop实现方式有3种<ul>
<li>动态代理</li>
<li>cglib库</li>
<li>ObjenessCgibAopProxy</li>
</ul>
</li>
<li>事务是spring aop应用的最佳范例</li>
</ul>
<h3 id="aop流程实现"><a href="#aop流程实现" class="headerlink" title="aop流程实现"></a>aop流程实现</h3><h4 id="定义目标类的接口"><a href="#定义目标类的接口" class="headerlink" title="定义目标类的接口"></a>定义目标类的接口</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface MyService &#123;</span><br><span class="line">    void myMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定义目标类的接口的实现类"><a href="#定义目标类的接口的实现类" class="headerlink" title="定义目标类的接口的实现类"></a>定义目标类的接口的实现类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyServiceImpl implements MyService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void myMethod() &#123;</span><br><span class="line">        System.out.println(&quot;my method invoke&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定义通知器MyAdvisor"><a href="#定义通知器MyAdvisor" class="headerlink" title="定义通知器MyAdvisor"></a>定义通知器MyAdvisor</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.aopalliance.intercept.MethodInterceptor;</span><br><span class="line">import org.aopalliance.intercept.MethodInvocation;</span><br><span class="line"></span><br><span class="line">public class MyAdvisor implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(MethodInvocation invocation) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;befor MyAdvisor invoke!&quot;);</span><br><span class="line">        Object result =  invocation.proceed();</span><br><span class="line">        System.out.println(&quot;after MyAdvisor invoke!&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="配置ProxyFactoryBean"><a href="#配置ProxyFactoryBean" class="headerlink" title="配置ProxyFactoryBean"></a>配置ProxyFactoryBean</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;myService&quot; class=&quot;com.tdl.spring.aop.service.impl.MyServiceImpl&quot;&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;myAdvisor&quot; class=&quot;com.tdl.spring.aop.advisor.MyAdvisor&quot;&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;myAop&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;proxyInterfaces&quot;&gt;</span><br><span class="line">            &lt;value&gt;com.tdl.spring.aop.service.MyService&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;interceptorNames&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;myAdvisor&lt;/value&gt;</span><br><span class="line">            &lt;/list&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;target&quot;&gt;</span><br><span class="line">            &lt;ref bean=&quot;myService&quot;&gt;&lt;/ref&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<h4 id="启动Example"><a href="#启动Example" class="headerlink" title="启动Example"></a>启动Example</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SpringClientAop &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Resource resource = new ClassPathResource(&quot;applicationContext2.xml&quot;);</span><br><span class="line">        DefaultListableBeanFactory defaultListableBeanFactory</span><br><span class="line">                = new DefaultListableBeanFactory();</span><br><span class="line">        BeanDefinitionReader beanDefinitionReader =</span><br><span class="line">                new XmlBeanDefinitionReader(defaultListableBeanFactory);</span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(resource);</span><br><span class="line"></span><br><span class="line">        MyService myService = (MyService)defaultListableBeanFactory.getBean(&quot;myAop&quot;);</span><br><span class="line">        myService.myMethod();</span><br><span class="line">        System.out.println(myService.getClass());</span><br><span class="line">        System.out.println(myService.getClass().getSuperclass());</span><br><span class="line">        System.out.println(myService.getClass().getInterfaces().length);</span><br><span class="line">        for( Class tclass : myService.getClass().getInterfaces())&#123;</span><br><span class="line">            System.out.println(tclass.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印：<br>befor MyAdvisor invoke!<br>my method invoke<br>after MyAdvisor invoke!<br>class com.sun.proxy.$Proxy4<br>class java.lang.reflect.Proxy<br>4<br>com.tdl.spring.aop.service.MyService<br>org.springframework.aop.SpringProxy<br>org.springframework.aop.framework.Advised<br>org.springframework.core.DecoratingProxy</p>
<p>从打印的接口可以看出，MyServiceImpl实现了MyService、SpringProxy、Advised、DecoratingProxy四个接口。</p>
<h3 id="aop实现方式源码解析"><a href="#aop实现方式源码解析" class="headerlink" title="aop实现方式源码解析"></a>aop实现方式源码解析</h3><h4 id="ProxyFactoryBean"><a href="#ProxyFactoryBean" class="headerlink" title="ProxyFactoryBean"></a>ProxyFactoryBean</h4><p>ProxyFactoryBean构建出一个aop的代理，基于spring ioc管理的bean创建的代理对象。<br>ProxyFactoryBean代理了我们的业务类，内部粘合和接口列表，拦截器名字的集合，以及通知器。<br>ProxyFactoryBean实现了FactoryBean。<br>FactoryBean是BeanFactory内部的bean需要去实现的接口，而且，FactoryBean往外暴露的不是bean本身，而是以bean的工厂的方式暴露出来。</p>
<p>org.springframework.beans.factory.FactoryBean:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.beans.factory.FactoryBean#getObject</span><br><span class="line">org.springframework.beans.factory.FactoryBean#getObjectType</span><br><span class="line">org.springframework.beans.factory.FactoryBean#isSingleton</span><br><span class="line">org.springframework.beans.factory.FactoryBean#OBJECT_TYPE_ATTRIBUTE</span><br></pre></td></tr></table></figure>
<p>FactoryBean和BeanFactory的区别：<br>BeanFactory是一个factory，即是一个工厂，这个工厂是用来管理bean的。<br>FactoryBean也是受到beanfactory的管理，FactoryBean和普通的bean在创建的时候并没有什么区别，也是使用反射，也会进入到缓存的管理，不同的是，当一个class是一个FactoryBean的时候(实现了FactoryBean接口)，那么在创建完毕之后，返回之前加了一些逻辑，在返回之前会调用FactoryBean的getObject()方法，getObject()方法会根据FactoryBean的一些属性和定义执行一些逻辑，就拿ProxyFactoryBean举例，ProxyFactoryBean会根据proxyInterfaces、interceptorNames、target等属性动态生成另外一个类(代理类)的对象，然后将这个动态生成的对象返回。<br>beanfactory是spring ioc的工厂，它里面管理着spring所创建出来的各种bean对象，当我们在配置文件（注解）中声明了某个bean的id后，通过这个id就可以获取到与该id所对应的class对象的实例（可能新建，也可能从缓存中获取）</p>
<p>FactoryBean本质上也是一个bean，它同其他bean一样，也是由BeanFactory所管理和维护的，当然它的实例也会缓存到spring的工厂中（如果是单例），它与普通的bean的唯一区别在于，当spring创建另一个FactoryBean的实例后，他接下来会判断当前所创建的bean是否是一个FactoryBean实例，如果不是，那么就直接将创建出来的bean返回给客户端；如果是，那么它会对其进行进一步的处理，根据配置文件所配置的target，advisor与interface等信息，在运行期间动态构建出一个类，并生成该类的一个实例，最后将该实例返回给客户端；因此，我们在声明一个FactoryBean时，通过id获取到的并非这个FactoryBean的实例，而是它的动态代理生成出来的一个代理对象（通过三种方式来进行生成）</p>
<p>AopProxy：<br>Delegate interface for a configured AOP proxy, allowing for the creation of actual proxy objects.<br>Out-of-the-box implementations are available for JDK dynamic proxies and for CGLIB proxies, as applied by DefaultAopProxyFactory。<br>针对于可配置的aop代理的接口，允许创建真实的代理对象。<br>开箱即用的DefaultAopProxyFactory实现有jdk的动态代理和cglib的代理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultAopProxyFactory implements AopProxyFactory, Serializable &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123;</span><br><span class="line">		if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">			Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">			if (targetClass == null) &#123;</span><br><span class="line">				throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +</span><br><span class="line">						&quot;Either an interface or a target is required for proxy creation.&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">				return new JdkDynamicAopProxy(config);</span><br><span class="line">			&#125;</span><br><span class="line">			return new ObjenesisCglibAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			return new JdkDynamicAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CglibAopProxy\JdkDynamicAopProxy\ObjenesisCglibAopProxy这三个是AopProxy的三种实现方式，<br>ObjenesisCglibAopProxy是基于CglibAopProxy实现的，ObjenesisCglibAopProxy是基于字节码创建的代理，可以不使用构造器，spring4默认的代理方式。</p>
<h4 id="微观解析"><a href="#微观解析" class="headerlink" title="微观解析"></a>微观解析</h4><p>我们的事例里边【MyService myService &#x3D; (MyService)defaultListableBeanFactory.getBean(“myAop”);】返回了我们想要的aop事例。<br>我们只要来到具体的特化的创建aop的代理分支就可以，因为bean的创建和普通bean没有区别。</p>
<p>org.springframework.beans.factory.support.AbstractBeanFactory<br>getBean(String name)<br>&#x3D;&gt;<br>doGetBean(final String name, @Nullable final Class<T> requiredType,	@Nullable final Object[] args, boolean typeCheckOnly)<br>&#x3D;&gt;<br>getObjectForBeanInstance(Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//返回bean，要么是bean自身，要么是FactoryBean创建出来的对象</span><br><span class="line">protected Object getObjectForBeanInstance(</span><br><span class="line">    Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) &#123;</span><br><span class="line"></span><br><span class="line">  // Don&#x27;t let calling code try to dereference the factory if the bean isn&#x27;t a factory.</span><br><span class="line">  if (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">    if (beanInstance instanceof NullBean) &#123;</span><br><span class="line">      return beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!(beanInstance instanceof FactoryBean)) &#123;</span><br><span class="line">      throw new BeanIsNotAFactoryException(beanName, beanInstance.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    if (mbd != null) &#123;</span><br><span class="line">      mbd.isFactoryBean = true;</span><br><span class="line">    &#125;</span><br><span class="line">    return beanInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Now we have the bean instance, which may be a normal bean or a FactoryBean.</span><br><span class="line">  // If it&#x27;s a FactoryBean, we use it to create a bean instance, unless the</span><br><span class="line">  // caller actually wants a reference to the factory.</span><br><span class="line">    //判断创建出来的bean是不是FactoryBean</span><br><span class="line">  if (!(beanInstance instanceof FactoryBean)) &#123;</span><br><span class="line">    return beanInstance;</span><br><span class="line">  &#125;</span><br><span class="line">  //以下逻辑是FactoryBean的流程</span><br><span class="line">  Object object = null;</span><br><span class="line">  if (mbd != null) &#123;</span><br><span class="line">    mbd.isFactoryBean = true;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    //缓存可能得到为null</span><br><span class="line">    object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">  if (object == null) &#123;</span><br><span class="line">    // Return bean instance from factory.</span><br><span class="line">    //将ProxyFactoryBean转换为接口的类型</span><br><span class="line">    FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">    // Caches object obtained from FactoryBean if it is a singleton.</span><br><span class="line">    //判断bean的定义在缓存是否存在</span><br><span class="line">    if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">      mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic());</span><br><span class="line">    //从工厂bean返回代理对象</span><br><span class="line">    object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">  &#125;</span><br><span class="line">  return object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//factory：org.springframework.aop.framework.ProxyFactoryBean</span><br><span class="line">//beanName：myAop</span><br><span class="line">//shouldPostProcess: true</span><br><span class="line">protected Object getObjectFromFactoryBean(FactoryBean&lt;?&gt; factory, String beanName, boolean shouldPostProcess) &#123;</span><br><span class="line">  if (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line">    synchronized (getSingletonMutex()) &#123;</span><br><span class="line">      Object object = this.factoryBeanObjectCache.get(beanName);</span><br><span class="line">      if (object == null) &#123;</span><br><span class="line">        //真正工厂获取的动作</span><br><span class="line">        object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">        // Only post-process and store if not put there already during getObject() call above</span><br><span class="line">        // (e.g. because of circular reference processing triggered by custom getBean calls)</span><br><span class="line">        Object alreadyThere = this.factoryBeanObjectCache.get(beanName);</span><br><span class="line">        if (alreadyThere != null) &#123;</span><br><span class="line">          object = alreadyThere;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">          if (shouldPostProcess) &#123;</span><br><span class="line">            if (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">              // Temporarily return non-post-processed object, not storing it yet..</span><br><span class="line">              return object;</span><br><span class="line">            &#125;</span><br><span class="line">            beforeSingletonCreation(beanName);</span><br><span class="line">            try &#123;</span><br><span class="line">              object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Throwable ex) &#123;</span><br><span class="line">              throw new BeanCreationException(beanName,</span><br><span class="line">                  &quot;Post-processing of FactoryBean&#x27;s singleton object failed&quot;, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            finally &#123;</span><br><span class="line">              afterSingletonCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          if (containsSingleton(beanName)) &#123;</span><br><span class="line">            this.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return object;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    Object object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">    if (shouldPostProcess) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Throwable ex) &#123;</span><br><span class="line">        throw new BeanCreationException(beanName, &quot;Post-processing of FactoryBean&#x27;s object failed&quot;, ex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return object;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//真正工厂获取的动作</span><br><span class="line">private Object doGetObjectFromFactoryBean(final FactoryBean&lt;?&gt; factory, final String beanName)</span><br><span class="line">    throws BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">  Object object;</span><br><span class="line">  try &#123;</span><br><span class="line">    if (System.getSecurityManager() != null) &#123;</span><br><span class="line">      AccessControlContext acc = getAccessControlContext();</span><br><span class="line">      try &#123;</span><br><span class="line">        object = AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) factory::getObject, acc);</span><br><span class="line">      &#125;</span><br><span class="line">      catch (PrivilegedActionException pae) &#123;</span><br><span class="line">        throw pae.getException();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      //调用FactoryBean的getObject方法，获取对象</span><br><span class="line">      object = factory.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  catch (FactoryBeanNotInitializedException ex) &#123;</span><br><span class="line">    throw new BeanCurrentlyInCreationException(beanName, ex.toString());</span><br><span class="line">  &#125;</span><br><span class="line">  catch (Throwable ex) &#123;</span><br><span class="line">    throw new BeanCreationException(beanName, &quot;FactoryBean threw exception on object creation&quot;, ex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Do not accept a null value for a FactoryBean that&#x27;s not fully</span><br><span class="line">  // initialized yet: Many FactoryBeans just return null then.</span><br><span class="line">  if (object == null) &#123;</span><br><span class="line">    if (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">      throw new BeanCurrentlyInCreationException(</span><br><span class="line">          beanName, &quot;FactoryBean which is currently in creation returned null from getObject&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    object = new NullBean();</span><br><span class="line">  &#125;</span><br><span class="line">  return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FactoryBean的getObject()方法具体实现:<br>org.springframework.aop.framework.ProxyFactoryBean:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//获取对象</span><br><span class="line">public Object getObject() throws BeansException &#123;</span><br><span class="line">  initializeAdvisorChain();</span><br><span class="line">  if (isSingleton()) &#123;</span><br><span class="line">    //返回代理对象的单例的实例</span><br><span class="line">    return getSingletonInstance();</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    if (this.targetName == null) &#123;</span><br><span class="line">      logger.info(&quot;Using non-singleton proxies with singleton targets is often undesirable. &quot; +</span><br><span class="line">          &quot;Enable prototype proxies by setting the &#x27;targetName&#x27; property.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return newPrototypeInstance();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//创建单例的实例</span><br><span class="line">private synchronized Object getSingletonInstance() &#123;</span><br><span class="line">  if (this.singletonInstance == null) &#123;</span><br><span class="line">    //targetSource内部引用了com.tdl.spring.aop.service.impl.MyServiceImpl</span><br><span class="line">    //即得到目标增强的目标对象</span><br><span class="line">    this.targetSource = freshTargetSource();</span><br><span class="line">    if (this.autodetectInterfaces &amp;&amp; getProxiedInterfaces().length == 0 &amp;&amp; !isProxyTargetClass()) &#123;</span><br><span class="line">      // Rely on AOP infrastructure to tell us what interfaces to proxy.</span><br><span class="line">      Class&lt;?&gt; targetClass = getTargetClass();</span><br><span class="line">      if (targetClass == null) &#123;</span><br><span class="line">        throw new FactoryBeanNotInitializedException(&quot;Cannot determine target class for proxy&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, this.proxyClassLoader));</span><br><span class="line">    &#125;</span><br><span class="line">    // Initialize the shared singleton instance.</span><br><span class="line">    super.setFrozen(this.freezeProxy);</span><br><span class="line">    //getProxy得到代理</span><br><span class="line">    //createAopProxy方法在org.springframework.aop.framework.ProxyCreatorSupport内部实现</span><br><span class="line">    this.singletonInstance = getProxy(createAopProxy());</span><br><span class="line">  &#125;</span><br><span class="line">  return this.singletonInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//初始化通知器链</span><br><span class="line">private synchronized void initializeAdvisorChain() throws AopConfigException, BeansException &#123;</span><br><span class="line">  if (this.advisorChainInitialized) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  //检查interceptorNames（myAop配置了interceptorNames字符串数组）</span><br><span class="line">  if (!ObjectUtils.isEmpty(this.interceptorNames)) &#123;</span><br><span class="line">    if (this.beanFactory == null) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;No BeanFactory available anymore (probably due to serialization) &quot; +</span><br><span class="line">          &quot;- cannot resolve interceptor names &quot; + Arrays.asList(this.interceptorNames));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Globals can&#x27;t be last unless we specified a targetSource using the property...</span><br><span class="line">    if (this.interceptorNames[this.interceptorNames.length - 1].endsWith(GLOBAL_SUFFIX) &amp;&amp;</span><br><span class="line">        this.targetName == null &amp;&amp; this.targetSource == EMPTY_TARGET_SOURCE) &#123;</span><br><span class="line">      throw new AopConfigException(&quot;Target required after globals&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Materialize interceptor chain from bean names.</span><br><span class="line">    for (String name : this.interceptorNames) &#123;</span><br><span class="line">      if (name.endsWith(GLOBAL_SUFFIX)) &#123;</span><br><span class="line">        if (!(this.beanFactory instanceof ListableBeanFactory)) &#123;</span><br><span class="line">          throw new AopConfigException(</span><br><span class="line">              &quot;Can only use global advisors or interceptors with a ListableBeanFactory&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        addGlobalAdvisors((ListableBeanFactory) this.beanFactory,</span><br><span class="line">            name.substring(0, name.length() - GLOBAL_SUFFIX.length()));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      else &#123;</span><br><span class="line">        // If we get here, we need to add a named interceptor.</span><br><span class="line">        // We must check if it&#x27;s a singleton or prototype.</span><br><span class="line">        Object advice;</span><br><span class="line">        if (this.singleton || this.beanFactory.isSingleton(name)) &#123;</span><br><span class="line">          // Add the real Advisor/Advice to the chain.</span><br><span class="line">          //从beanFactoy获取bean(beanFactory是DefaultListableBeanFactory)</span><br><span class="line">          //这里又会执行getBean的流程。</span><br><span class="line">          //获取通知器/通知</span><br><span class="line">          advice = this.beanFactory.getBean(name);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">          // It&#x27;s a prototype Advice or Advisor: replace with a prototype.</span><br><span class="line">          // Avoid unnecessary creation of prototype bean just for advisor chain initialization.</span><br><span class="line">          advice = new PrototypePlaceholderAdvisor(name);</span><br><span class="line">        &#125;</span><br><span class="line">        //把Advisor添加到链表当中</span><br><span class="line">        addAdvisorOnChainCreation(advice);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.advisorChainInitialized = true;</span><br><span class="line">&#125;</span><br><span class="line">//aopProxy是JdkDynamicAopProxy</span><br><span class="line">protected Object getProxy(AopProxy aopProxy) &#123;</span><br><span class="line">  return aopProxy.getProxy(this.proxyClassLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>addAdvisorOnChainCreation将通知器包装成Advisor，添加到通知器列表当中<br>org.springframework.aop.framework.AdvisedSupport:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private List&lt;Advisor&gt; advisors = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>org.springframework.aop.framework.ProxyCreatorSupport:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//DefaultAopFactory</span><br><span class="line">private AopProxyFactory aopProxyFactory;</span><br><span class="line">public ProxyCreatorSupport() &#123;</span><br><span class="line">  this.aopProxyFactory = new DefaultAopProxyFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final synchronized AopProxy createAopProxy() &#123;</span><br><span class="line">  if (!this.active) &#123;</span><br><span class="line">    //监听器的触发</span><br><span class="line">    activate();</span><br><span class="line">  &#125;</span><br><span class="line">  return getAopProxyFactory().createAopProxy(this);</span><br><span class="line">&#125;</span><br><span class="line">public AopProxyFactory getAopProxyFactory() &#123;</span><br><span class="line">  //aopProxyFactory是DefaultAopFactory，其在ProxyCreatorSupport构造器里边被初始的。</span><br><span class="line">  return this.aopProxyFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getAopProxyFactory().createAopProxy(this)会来到DefaultAopFactory的createAopProxy方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//spring4开始。使用ObjenesisCglibAopProxy代替CglibAopProxy，因此此处没有CglibAopProxy</span><br><span class="line">public class DefaultAopProxyFactory implements AopProxyFactory, Serializable &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123;</span><br><span class="line">		if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">			Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">			if (targetClass == null) &#123;</span><br><span class="line">				throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +</span><br><span class="line">						&quot;Either an interface or a target is required for proxy creation.&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">				return new JdkDynamicAopProxy(config);</span><br><span class="line">			&#125;</span><br><span class="line">			return new ObjenesisCglibAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			return new JdkDynamicAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>myAop实现了接口，这里会使用JdkDynamicAopProxy。<br>JdkDynamicAopProxy:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final class JdkDynamicAopProxy implements AopProxy, InvocationHandler, Serializable &#123;</span><br><span class="line">  public JdkDynamicAopProxy(AdvisedSupport config) throws AopConfigException &#123;</span><br><span class="line">    Assert.notNull(config, &quot;AdvisedSupport must not be null&quot;);</span><br><span class="line">    if (config.getAdvisors().length == 0 &amp;&amp; config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) &#123;</span><br><span class="line">      throw new AopConfigException(&quot;No advisors and no TargetSource specified&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.advised = config;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Object getProxy(@Nullable ClassLoader classLoader) &#123;</span><br><span class="line">    if (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(&quot;Creating JDK dynamic proxy: &quot; + this.advised.getTargetSource());</span><br><span class="line">    &#125;</span><br><span class="line">    //interface com.tdl.spring.aop.service.MyService</span><br><span class="line">    //interface org.springframework.aop.SpringProxy</span><br><span class="line">    //interface org.springframework.aop.framework.Advised</span><br><span class="line">    //interface org.springframework.core.DecoratingProxy</span><br><span class="line">    Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);</span><br><span class="line">    //对equals和hashcode方法的特殊处理</span><br><span class="line">    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">    //调用jdk的api创建代理，完成真正的代理类和对象的创建</span><br><span class="line">    return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>org.springframework.aop.framework.AopProxyUtils:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//得到目标代理对象需要的接口数组</span><br><span class="line">static Class&lt;?&gt;[] completeProxiedInterfaces(AdvisedSupport advised, boolean decoratingProxy) &#123;</span><br><span class="line">  Class&lt;?&gt;[] specifiedInterfaces = advised.getProxiedInterfaces();</span><br><span class="line">  if (specifiedInterfaces.length == 0) &#123;</span><br><span class="line">    // No user-specified interfaces: check whether target class is an interface.</span><br><span class="line">    //interface com.tdl.spring.aop.service.MyService</span><br><span class="line">    Class&lt;?&gt; targetClass = advised.getTargetClass();</span><br><span class="line">    if (targetClass != null) &#123;</span><br><span class="line">      if (targetClass.isInterface()) &#123;</span><br><span class="line">        advised.setInterfaces(targetClass);</span><br><span class="line">      &#125;</span><br><span class="line">      else if (Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">        advised.setInterfaces(targetClass.getInterfaces());</span><br><span class="line">      &#125;</span><br><span class="line">      specifiedInterfaces = advised.getProxiedInterfaces();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  boolean addSpringProxy = !advised.isInterfaceProxied(SpringProxy.class);</span><br><span class="line">  boolean addAdvised = !advised.isOpaque() &amp;&amp; !advised.isInterfaceProxied(Advised.class);</span><br><span class="line">  boolean addDecoratingProxy = (decoratingProxy &amp;&amp; !advised.isInterfaceProxied(DecoratingProxy.class));</span><br><span class="line">  //非用户添加的接口数量</span><br><span class="line">  int nonUserIfcCount = 0;</span><br><span class="line">  if (addSpringProxy) &#123;</span><br><span class="line">    nonUserIfcCount++;</span><br><span class="line">  &#125;</span><br><span class="line">  if (addAdvised) &#123;</span><br><span class="line">    nonUserIfcCount++;</span><br><span class="line">  &#125;</span><br><span class="line">  if (addDecoratingProxy) &#123;</span><br><span class="line">    nonUserIfcCount++;</span><br><span class="line">  &#125;</span><br><span class="line">  //长度为4的数组</span><br><span class="line">  Class&lt;?&gt;[] proxiedInterfaces = new Class&lt;?&gt;[specifiedInterfaces.length + nonUserIfcCount];</span><br><span class="line">  System.arraycopy(specifiedInterfaces, 0, proxiedInterfaces, 0, specifiedInterfaces.length);</span><br><span class="line">  int index = specifiedInterfaces.length;</span><br><span class="line">  if (addSpringProxy) &#123;</span><br><span class="line">    proxiedInterfaces[index] = SpringProxy.class;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line">  if (addAdvised) &#123;</span><br><span class="line">    proxiedInterfaces[index] = Advised.class;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line">  if (addDecoratingProxy) &#123;</span><br><span class="line">    proxiedInterfaces[index] = DecoratingProxy.class;</span><br><span class="line">  &#125;</span><br><span class="line">  return proxiedInterfaces;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关于Spring-AOP代理的生成过程小结"><a href="#关于Spring-AOP代理的生成过程小结" class="headerlink" title="关于Spring AOP代理的生成过程小结"></a>关于Spring AOP代理的生成过程小结</h4><ol>
<li>通过ProxyFactoryBean[FactoryBean接口的实现]来去配置相应的代理对象相关的信息。<br>即如下的信息:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;myAop&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;proxyInterfaces&quot;&gt;</span><br><span class="line">        &lt;value&gt;com.tdl.spring.aop.service.MyService&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;interceptorNames&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;myAdvisor&lt;/value&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;target&quot;&gt;</span><br><span class="line">        &lt;ref bean=&quot;myService&quot;&gt;&lt;/ref&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li>在获取ProxyFactoryBean实例时，本质上并不是获取ProxyFactoryBean的对象，而是获取到了ProxyFactoryBean所返回(getObject方法)的那个对象实例。</li>
<li>在ProxyFactoryBean实例的构建与缓存的过程中，其流程与普通的bean对象完全一致</li>
<li>差别在于，当创建了ProxyFactoryBean对象后，spring会判断当前所创建的对象是否是一个FactoryBean实例。</li>
<li>如果不是，那么spring就直接将所创建的对象返回。</li>
<li>如果是，spring则会进入到一个新的流程分支当中</li>
<li>spring会根据我们在配置信息中所指定的各种元素，如目标对象是否实现了接口以及Advisor等信息，使用动态代理或是cglib等方式为目标对象创建相应的代理对象。</li>
<li>当相应的代理对象创建完毕后，spring就会通过ProxyFactoryBean的getObject方法，将所创建的对象返回</li>
<li>对象返回到调用端(客户端)，它本质上是一个代理对象，可以代理对目标对象的访问与调用；这个代理对象对用户来说，就好像一个目标对象一样。</li>
<li>客户在使用代理对象时，可以正常调用目标对象的方法，同时在执行过程中，会根据我们在配置文件中所配置的信息在调用前后执行额外的附加逻辑</li>
</ol>
<p>注意：我们在使用idea调试动态代理的时候，动态代理对象的toString会被idea持续不断的调用，来更新调试窗口变量的名字，因此就会在控制台出现动态代理类invoke方法的内部的一些打印。</p>
<h3 id="aop动态代理方法的执行"><a href="#aop动态代理方法的执行" class="headerlink" title="aop动态代理方法的执行"></a>aop动态代理方法的执行</h3><p>先看下之前的实例代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyService myService = (MyService)defaultListableBeanFactory.getBean(&quot;myAop&quot;);</span><br><span class="line">myService.myMethod();</span><br></pre></td></tr></table></figure>
<p>myService是返回的一个代理对象。<br>myMethod调用的时候，会来到org.springframework.aop.framework.JdkDynamicAopProxy的invoke方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">  Object oldProxy = null;</span><br><span class="line">  boolean setProxyContext = false;</span><br><span class="line">  //目标对象SingletonTargetSource：包装了com.tdl.spring.aop.service.impl.MyServiceImpl</span><br><span class="line">  TargetSource targetSource = this.advised.targetSource;</span><br><span class="line">  Object target = null;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">      // The target does not implement the equals(Object) method itself.</span><br><span class="line">      return equals(args[0]);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">      // The target does not implement the hashCode() method itself.</span><br><span class="line">      return hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    else if (method.getDeclaringClass() == DecoratingProxy.class) &#123;</span><br><span class="line">      // There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span><br><span class="line">      return AopProxyUtils.ultimateTargetClass(this.advised);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (!this.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">        method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">      // Service invocations on ProxyConfig with the proxy config...</span><br><span class="line">      return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object retVal;</span><br><span class="line"></span><br><span class="line">    if (this.advised.exposeProxy) &#123;</span><br><span class="line">      // Make invocation available if necessary.</span><br><span class="line">      oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">      setProxyContext = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Get as late as possible to minimize the time we &quot;own&quot; the target,</span><br><span class="line">    // in case it comes from a pool.</span><br><span class="line">    //目标对象：com.tdl.spring.aop.service.impl.MyServiceImpl</span><br><span class="line">    target = targetSource.getTarget();</span><br><span class="line">    Class&lt;?&gt; targetClass = (target != null ? target.getClass() : null);</span><br><span class="line"></span><br><span class="line">    // Get the interception chain for this method.</span><br><span class="line">    //获取方法的拦截器链，我们只配置了一个：myAdvisor</span><br><span class="line">    List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">    // Check whether we have any advice. If we don&#x27;t, we can fallback on direct</span><br><span class="line">    // reflective invocation of the target, and avoid creating a MethodInvocation.</span><br><span class="line">    if (chain.isEmpty()) &#123;</span><br><span class="line">      // We can skip creating a MethodInvocation: just invoke the target directly</span><br><span class="line">      // Note that the final invoker must be an InvokerInterceptor so we know it does</span><br><span class="line">      // nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span><br><span class="line">      Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">      retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      // We need to create a method invocation...</span><br><span class="line">      封装一个方法调用</span><br><span class="line">      MethodInvocation invocation =</span><br><span class="line">          new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">      // Proceed to the joinpoint through the interceptor chain.</span><br><span class="line">      //执行方法调用</span><br><span class="line">      retVal = invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Massage return value if necessary.</span><br><span class="line">    Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">    if (retVal != null &amp;&amp; retVal == target &amp;&amp;</span><br><span class="line">        returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">        !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">      // Special case: it returned &quot;this&quot; and the return type of the method</span><br><span class="line">      // is type-compatible. Note that we can&#x27;t help if the target sets</span><br><span class="line">      // a reference to itself in another returned object.</span><br><span class="line">      retVal = proxy;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (retVal == null &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">      throw new AopInvocationException(</span><br><span class="line">          &quot;Null return value from advice does not match primitive return type for: &quot; + method);</span><br><span class="line">    &#125;</span><br><span class="line">    return retVal;</span><br><span class="line">  &#125;</span><br><span class="line">  finally &#123;</span><br><span class="line">    if (target != null &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">      // Must have come from TargetSource.</span><br><span class="line">      targetSource.releaseTarget(target);</span><br><span class="line">    &#125;</span><br><span class="line">    if (setProxyContext) &#123;</span><br><span class="line">      // Restore old proxy.</span><br><span class="line">      AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/MethodInvocation.png" alt="MethodInvocation.png"></p>
<p>org.springframework.aop.framework.ReflectiveMethodInvocation#proceed():</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object proceed() throws Throwable &#123;</span><br><span class="line">  // We start with an index of -1 and increment early.</span><br><span class="line">  if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) &#123;</span><br><span class="line">    return invokeJoinpoint();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Object interceptorOrInterceptionAdvice =</span><br><span class="line">      this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);</span><br><span class="line">  if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">    // Evaluate dynamic method matcher here: static part will already have</span><br><span class="line">    // been evaluated and found to match.</span><br><span class="line">    InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">        (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">    Class&lt;?&gt; targetClass = (this.targetClass != null ? this.targetClass : this.method.getDeclaringClass());</span><br><span class="line">    if (dm.methodMatcher.matches(this.method, targetClass, this.arguments)) &#123;</span><br><span class="line">      return dm.interceptor.invoke(this);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      // Dynamic matching failed.</span><br><span class="line">      // Skip this interceptor and invoke the next in the chain.</span><br><span class="line">      //可能的递归调用</span><br><span class="line">      return proceed();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    // It&#x27;s an interceptor, so we just invoke it: The pointcut will have</span><br><span class="line">    // been evaluated statically before this object was constructed.</span><br><span class="line">    //interceptorOrInterceptionAdvice是MyAdvisor,MyAdvisor实现了MethodInterceptor</span><br><span class="line">    //这里会进入MyAdvisor的invoke方法。</span><br><span class="line">    return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MyAdvisor的逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyAdvisor implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(MethodInvocation invocation) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;befor MyAdvisor invoke!&quot;);</span><br><span class="line">        Object result =  invocation.proceed();</span><br><span class="line">        System.out.println(&quot;after MyAdvisor invoke!&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>invocation.proceed()会进入org.springframework.aop.framework.ReflectiveMethodInvocation的process()：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) &#123;</span><br><span class="line">  最后一个，即目标方法，会被调用，MyServiceImpl的myMethod方法被调用</span><br><span class="line">  return invokeJoinpoint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>invokeJoinpoint方法逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Object invokeJoinpoint() throws Throwable &#123;</span><br><span class="line">  return AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/invokeJoinpointUsingReflection.png" alt="invokeJoinpointUsingReflection.png"></p>
<p>【本章代码位置：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzExNTY3MjE4NzQvc3ByaW5nLWtlcm5lbC1sZWN0dXJlJUUzJTgwJTkx">https://github.com/1156721874/spring-kernel-lecture】<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>spring_core</category>
      </categories>
      <tags>
        <tag>spring aop</tag>
      </tags>
  </entry>
  <entry>
    <title>spring_core(2)Bean的初始化和注入</title>
    <url>/2020/07/05/spring_core/spring_core(2)BeanInitinalAndInject/</url>
    <content><![CDATA[<p>上一章节bean只是从xml加载出来，放到map里边，但是bean的class并没有创建实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Student student = defaultListableBeanFactory.getBean(&quot;student&quot;, Student.class);</span><br></pre></td></tr></table></figure>
<p>当执行上述代码的时候才会实例化一个bean。</p>
<span id="more"></span>
<h3 id="Bean的创建缓存过程"><a href="#Bean的创建缓存过程" class="headerlink" title="Bean的创建缓存过程"></a>Bean的创建缓存过程</h3><p>org.springframework.beans.factory.support.AbstractBeanFactory#getBean:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException &#123;</span><br><span class="line">  return doGetBean(name, requiredType, null, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回一个单利或者一个独立的bean</span><br><span class="line">protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,</span><br><span class="line">    @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">  final String beanName = transformedBeanName(name);</span><br><span class="line">  Object bean;</span><br><span class="line"></span><br><span class="line">  // Eagerly check singleton cache for manually registered singletons.</span><br><span class="line">  //提早检查bean是否在缓存中存在</span><br><span class="line">  Object sharedInstance = getSingleton(beanName);</span><br><span class="line">	if (sharedInstance != null &amp;&amp; args == null) &#123;</span><br><span class="line">      ......</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    ......</span><br><span class="line">    //多线程创建bean会抛出异常</span><br><span class="line">    if (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">      throw new BeanCurrentlyInCreationException(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">    //检查bean的定义是否存在【默认是空的】</span><br><span class="line">    if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">    //不仅仅是类型检查，还有其他的检查</span><br><span class="line">    if (!typeCheckOnly) &#123;</span><br><span class="line">      //将所指定的bean标记为已经创建或者正在创建，防止bean重复创建</span><br><span class="line">      //标记放在ConcurrentHashMap里边</span><br><span class="line">      markBeanAsCreated(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    //RootBeanDefinition是一个汇总的bean信息，里边的信息是已经解析完毕的beanDefination的信息</span><br><span class="line">    final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    //检查，如果一个bean的定义是抽象的是不能实例化的。</span><br><span class="line">		checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">    // Guarantee initialization of beans that the current bean depends on.</span><br><span class="line">    //mbd依赖的其他的bean</span><br><span class="line">    String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">    if (dependsOn != null) &#123;</span><br><span class="line">      for (String dep : dependsOn) &#123;</span><br><span class="line">        //循环依赖引用，抛出异常</span><br><span class="line">        if (isDependent(beanName, dep)) &#123;</span><br><span class="line">          throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">              &quot;Circular depends-on relationship between &#x27;&quot; + beanName + &quot;&#x27; and &#x27;&quot; + dep + &quot;&#x27;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        registerDependentBean(dep, beanName);</span><br><span class="line">        try &#123;</span><br><span class="line">          getBean(dep);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">          throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">              &quot;&#x27;&quot; + beanName + &quot;&#x27; depends on missing bean &#x27;&quot; + dep + &quot;&#x27;&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Create bean instance.</span><br><span class="line">    //判断是否是singleton的作用域</span><br><span class="line">    if (mbd.isSingleton()) &#123;</span><br><span class="line">      //获取单例的bean，不存在就执行lambda表达式执行创建</span><br><span class="line">      sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          //创建bean，并且缓存到singletonObjects</span><br><span class="line">          return createBean(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (BeansException ex) &#123;</span><br><span class="line">          // Explicitly remove instance from singleton cache: It might have been put there</span><br><span class="line">          // eagerly by the creation process, to allow for circular reference resolution.</span><br><span class="line">          // Also remove any beans that received a temporary reference to the bean.</span><br><span class="line">          destroySingleton(beanName);</span><br><span class="line">          throw ex;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">    &#125;	else if (mbd.isPrototype()) &#123;</span><br><span class="line">					// It&#x27;s a prototype -&gt; create a new instance.</span><br><span class="line">					Object prototypeInstance = null;</span><br><span class="line">					try &#123;</span><br><span class="line">						beforePrototypeCreation(beanName);</span><br><span class="line">						prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">					&#125;</span><br><span class="line">					finally &#123;</span><br><span class="line">						afterPrototypeCreation(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">					bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (T) bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Object getSingleton(String beanName) &#123;</span><br><span class="line">  return getSingleton(beanName, true);</span><br><span class="line">&#125;</span><br><span class="line">/** Cache of singleton objects: bean name to bean instance. */</span><br><span class="line">//singletonObjects单例对象的缓存器，spring工厂单例的对象的存储集合，bean的name映射到bean的实例</span><br><span class="line">private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);</span><br><span class="line"></span><br><span class="line">protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123;</span><br><span class="line">  Object singletonObject = this.singletonObjects.get(beanName);</span><br><span class="line">  if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">    synchronized (this.singletonObjects) &#123;</span><br><span class="line">      singletonObject = this.earlySingletonObjects.get(beanName);</span><br><span class="line">      if (singletonObject == null &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">        ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);</span><br><span class="line">        if (singletonFactory != null) &#123;</span><br><span class="line">          singletonObject = singletonFactory.getObject();</span><br><span class="line">          this.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">          this.singletonFactories.remove(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return singletonObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回给定名字的bean对象，有的话返回，没有的话创建并返回</span><br><span class="line">public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123;</span><br><span class="line">  ......</span><br><span class="line">  synchronized (this.singletonObjects) &#123;</span><br><span class="line">    Object singletonObject = this.singletonObjects.get(beanName);</span><br><span class="line">    if (singletonObject == null) &#123;</span><br><span class="line">        ......</span><br><span class="line">      boolean newSingleton = false;</span><br><span class="line">			try &#123;</span><br><span class="line">        //执行lambda表达式【创建bean】</span><br><span class="line">        singletonObject = singletonFactory.getObject();</span><br><span class="line">        newSingleton = true;</span><br><span class="line">      &#125;</span><br><span class="line">      ......</span><br><span class="line">      finally &#123;</span><br><span class="line">        if (recordSuppressedExceptions) &#123;</span><br><span class="line">          this.suppressedExceptions = null;</span><br><span class="line">        &#125;</span><br><span class="line">        //并发的一些检查</span><br><span class="line">        afterSingletonCreation(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      ......</span><br><span class="line">    if (newSingleton) &#123;</span><br><span class="line">      addSingleton(beanName, singletonObject);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  return singletonObject;</span><br><span class="line">&#125;</span><br><span class="line">//缓存操作</span><br><span class="line">protected void addSingleton(String beanName, Object singletonObject) &#123;</span><br><span class="line">  synchronized (this.singletonObjects) &#123;</span><br><span class="line">    //将bean的(name-实例)映射塞入到singletonObjects(工厂的容器ConcurrentHashMap)当中</span><br><span class="line">    this.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">    this.singletonFactories.remove(beanName);</span><br><span class="line">    this.earlySingletonObjects.remove(beanName);</span><br><span class="line">    this.registeredSingletons.add(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//创建bean</span><br><span class="line">protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span><br><span class="line">    throws BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">  if (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(&quot;Creating instance of bean &#x27;&quot; + beanName + &quot;&#x27;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">  // Make sure bean class is actually resolved at this point, and</span><br><span class="line">  // clone the bean definition in case of a dynamically resolved Class</span><br><span class="line">  // which cannot be stored in the shared merged bean definition.</span><br><span class="line">  //拿到bean定义的class对象，后期用反射来实例化对象</span><br><span class="line">  //底层：Class&lt;?&gt; resolvedClass = ClassUtils.forName(className, classLoader);</span><br><span class="line">  Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">  if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) &#123;</span><br><span class="line">    mbdToUse = new RootBeanDefinition(mbd);</span><br><span class="line">    mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">  // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span><br><span class="line">  //bean的后置处理器，bean可以配置返回bean的代理对象【bean实例化之前处理】</span><br><span class="line">  Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">  if (bean != null) &#123;</span><br><span class="line">    return bean;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">  try &#123;</span><br><span class="line">    //执行真正创建bean实例</span><br><span class="line">    Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">    if (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(&quot;Finished creating instance of bean &#x27;&quot; + beanName + &quot;&#x27;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //返回</span><br><span class="line">    return beanInstance;</span><br><span class="line">  &#125;</span><br><span class="line">  catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">    // A previously detected exception with proper bean creation context already,</span><br><span class="line">    // or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span><br><span class="line">    throw ex;</span><br><span class="line">  &#125;</span><br><span class="line">  catch (Throwable ex) &#123;</span><br><span class="line">    throw new BeanCreationException(</span><br><span class="line">        mbdToUse.getResourceDescription(), beanName, &quot;Unexpected exception during bean creation&quot;, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>doCreateBean位于org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** Cache of unfinished FactoryBean instances: FactoryBean name to BeanWrapper. */</span><br><span class="line">//未创建的FactoryBean实例</span><br><span class="line">private final ConcurrentMap&lt;String, BeanWrapper&gt; factoryBeanInstanceCache = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">//执行真正创建bean实例</span><br><span class="line">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)</span><br><span class="line">    throws BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">  // Instantiate the bean.</span><br><span class="line">  //bean的包装器</span><br><span class="line">  BeanWrapper instanceWrapper = null;</span><br><span class="line">  if (mbd.isSingleton()) &#123;</span><br><span class="line">    //为创建的bean的缓存，当前是创建过程，需要从缓冲里边删除</span><br><span class="line">    instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">  if (instanceWrapper == null) &#123;</span><br><span class="line">    //创建包裹bean实例的BeanWrapper</span><br><span class="line">    instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">  &#125;</span><br><span class="line">  //返回被包裹的对象，即业务对象，Student对象</span><br><span class="line">  final Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">  //返回包裹的bean的class对象</span><br><span class="line">  Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">  if (beanType != NullBean.class) &#123;</span><br><span class="line">    mbd.resolvedTargetType = beanType;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Allow post-processors to modify the merged bean definition.</span><br><span class="line">  synchronized (mbd.postProcessingLock) &#123;</span><br><span class="line">    if (!mbd.postProcessed) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        //应用后置处理器</span><br><span class="line">        applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Throwable ex) &#123;</span><br><span class="line">        throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">            &quot;Post-processing of merged bean definition failed&quot;, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      mbd.postProcessed = true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Eagerly cache singletons to be able to resolve circular references</span><br><span class="line">  // even when triggered by lifecycle interfaces like BeanFactoryAware.</span><br><span class="line">  //尽早缓存bena的实例，以防止bean的循环引用问题</span><br><span class="line">  boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;</span><br><span class="line">      isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">  if (earlySingletonExposure) &#123;</span><br><span class="line">    if (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(&quot;Eagerly caching bean &#x27;&quot; + beanName +</span><br><span class="line">          &quot;&#x27; to allow for resolving potential circular references&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //一些缓存的操作</span><br><span class="line">    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Initialize the bean instance.</span><br><span class="line">  //初始化bean的实例，实例有了，但是bean里边的属性还没有初始化和赋值</span><br><span class="line">  Object exposedObject = bean;</span><br><span class="line">  try &#123;</span><br><span class="line">    //对bean实例的属性进行赋值，不做详细展开。</span><br><span class="line">    populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">    //bean创建完毕之后的一些初始化工作，比如用户自定义的初始化方法之类的。</span><br><span class="line">    exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">  &#125;</span><br><span class="line">  catch (Throwable ex) &#123;</span><br><span class="line">    if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">      throw (BeanCreationException) ex;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      throw new BeanCreationException(</span><br><span class="line">          mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (earlySingletonExposure) &#123;</span><br><span class="line">    Object earlySingletonReference = getSingleton(beanName, false);</span><br><span class="line">    if (earlySingletonReference != null) &#123;</span><br><span class="line">      if (exposedObject == bean) &#123;</span><br><span class="line">        exposedObject = earlySingletonReference;</span><br><span class="line">      &#125;</span><br><span class="line">      else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">        String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">        Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">        for (String dependentBean : dependentBeans) &#123;</span><br><span class="line">          if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">            actualDependentBeans.add(dependentBean);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">          throw new BeanCurrentlyInCreationException(beanName,</span><br><span class="line">              &quot;Bean with name &#x27;&quot; + beanName + &quot;&#x27; has been injected into other beans [&quot; +</span><br><span class="line">              StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">              &quot;] in its raw version as part of a circular reference, but has eventually been &quot; +</span><br><span class="line">              &quot;wrapped. This means that said other beans do not use the final version of the &quot; +</span><br><span class="line">              &quot;bean. This is often the result of over-eager type matching - consider using &quot; +</span><br><span class="line">              &quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Register bean as disposable.</span><br><span class="line">  try &#123;</span><br><span class="line">    registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">  &#125;</span><br><span class="line">  catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">    throw new BeanCreationException(</span><br><span class="line">        mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return exposedObject;</span><br><span class="line">&#125;</span><br><span class="line">//创建bean的实例</span><br><span class="line">protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) &#123;</span><br><span class="line">  // Make sure bean class is actually resolved at this point.</span><br><span class="line">  //确认bean已经被解析过</span><br><span class="line">  Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">  //不允许创建的情况检查：不是public修饰、并且设置不允许公共访问接入</span><br><span class="line">  if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">    throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">        &quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot; + beanClass.getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">  if (instanceSupplier != null) &#123;</span><br><span class="line">    return obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (mbd.getFactoryMethodName() != null) &#123;</span><br><span class="line">    return instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Shortcut when re-creating the same bean...</span><br><span class="line">  boolean resolved = false;</span><br><span class="line">  boolean autowireNecessary = false;</span><br><span class="line">  if (args == null) &#123;</span><br><span class="line">    synchronized (mbd.constructorArgumentLock) &#123;</span><br><span class="line">      if (mbd.resolvedConstructorOrFactoryMethod != null) &#123;</span><br><span class="line">        resolved = true;</span><br><span class="line">        autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (resolved) &#123;</span><br><span class="line">    if (autowireNecessary) &#123;</span><br><span class="line">      return autowireConstructor(beanName, mbd, null, null);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      return instantiateBean(beanName, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Candidate constructors for autowiring?</span><br><span class="line">  //候选的构造器进行装备</span><br><span class="line">  Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">  if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">      mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">    return autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Preferred constructors for default construction?</span><br><span class="line">  //获取优先的构造器</span><br><span class="line">  ctors = mbd.getPreferredConstructors();</span><br><span class="line">  if (ctors != null) &#123;</span><br><span class="line">    return autowireConstructor(beanName, mbd, ctors, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // No special handling: simply use no-arg constructor.</span><br><span class="line">  //没有特殊的情况需要处理，使用无参的构造器进行创建</span><br><span class="line">  return instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">//使用默认的构造器来去实例化所给定的bean</span><br><span class="line">protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    Object beanInstance;</span><br><span class="line">    final BeanFactory parent = this;</span><br><span class="line">    if (System.getSecurityManager() != null) &#123;</span><br><span class="line">      beanInstance = AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;</span><br><span class="line">          getInstantiationStrategy().instantiate(mbd, beanName, parent),</span><br><span class="line">          getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      //调用一个实例化策略，返回对应的实例</span><br><span class="line">      beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">    &#125;</span><br><span class="line">    //BeanWrapper实现类BeanWrapperImpl创建，BeanWrapperImpl持有bean的实例对象</span><br><span class="line">    BeanWrapper bw = new BeanWrapperImpl(beanInstance);</span><br><span class="line">    //BeanWrapper的初始化工作</span><br><span class="line">    initBeanWrapper(bw);</span><br><span class="line">    return bw;</span><br><span class="line">  &#125;</span><br><span class="line">  catch (Throwable ex) &#123;</span><br><span class="line">    throw new BeanCreationException(</span><br><span class="line">        mbd.getResourceDescription(), beanName, &quot;Instantiation of bean failed&quot;, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InstantiationStrategy是创建策略的封装<br>org.springframework.beans.factory.support.InstantiationStrategy#instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner)<br>instantiate方法的实现在【org.springframework.beans.factory.support.SimpleInstantiationStrategy】当中:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) &#123;</span><br><span class="line">  // Don&#x27;t override the class with CGLIB if no overrides.</span><br><span class="line">  if (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">    Constructor&lt;?&gt; constructorToUse;</span><br><span class="line">    //同步锁</span><br><span class="line">    synchronized (bd.constructorArgumentLock) &#123;</span><br><span class="line">      constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">      if (constructorToUse == null) &#123;</span><br><span class="line">        //获取对象</span><br><span class="line">        final Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line">        //是不是接口</span><br><span class="line">        if (clazz.isInterface()) &#123;</span><br><span class="line">          throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">          if (System.getSecurityManager() != null) &#123;</span><br><span class="line">            constructorToUse = AccessController.doPrivileged(</span><br><span class="line">                (PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) clazz::getDeclaredConstructor);</span><br><span class="line">          &#125;</span><br><span class="line">          else &#123;</span><br><span class="line">            //待使用的构造器，即，默认的无参构造器</span><br><span class="line">            constructorToUse = clazz.getDeclaredConstructor();</span><br><span class="line">          &#125;</span><br><span class="line">          bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable ex) &#123;</span><br><span class="line">          throw new BeanInstantiationException(clazz, &quot;No default constructor found&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //使用spring的BeanUtils实例化</span><br><span class="line">    return BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    // Must generate CGLIB subclass.</span><br><span class="line">    //CGLB的方式生成bean的实例</span><br><span class="line">    return instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据构造器实例化对象在BeanUtils#instantiateClass中,这里不再列举，参考上一节的介绍。<br>到此实例才算真正的创建出来！</p>
<h3 id="对象属性赋值与作用域"><a href="#对象属性赋值与作用域" class="headerlink" title="对象属性赋值与作用域"></a>对象属性赋值与作用域</h3><p>修改在applicationContext.xml当中配置bean</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;student&quot; class=&quot;com.tdl.spring.bean.Student&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name2&quot; value=&quot;zhangsan&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;age&quot; value=&quot;20&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>即将name改为name2.<br>那么如下程序在执行【defaultListableBeanFactory.getBean(“student”, Student.class)】之前不会抛出异常:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SpringClient &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Resource resource = new ClassPathResource(&quot;applicationContext.xml&quot;);</span><br><span class="line">        DefaultListableBeanFactory defaultListableBeanFactory</span><br><span class="line">                = new DefaultListableBeanFactory();</span><br><span class="line">        BeanDefinitionReader beanDefinitionReader =</span><br><span class="line">                new XmlBeanDefinitionReader(defaultListableBeanFactory);</span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(resource);</span><br><span class="line"></span><br><span class="line">        Student student = defaultListableBeanFactory.getBean(&quot;student&quot;, Student.class);</span><br><span class="line">        System.out.println(student.getName());</span><br><span class="line">        System.out.println(student.getAge());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有执行defaultListableBeanFactory.getBean的时候才会抛出异常。</p>
<p>属性的赋值在org.springframework.beans.BeanWrapperImpl.setValue(final Object value)throws Exception执行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void setValue(final @Nullable Object value) throws Exception &#123;</span><br><span class="line">  //得到写方法</span><br><span class="line">  final Method writeMethod = (this.pd instanceof GenericTypeAwarePropertyDescriptor ?</span><br><span class="line">      ((GenericTypeAwarePropertyDescriptor) this.pd).getWriteMethodForActualAccess() :</span><br><span class="line">      this.pd.getWriteMethod());</span><br><span class="line">  if (System.getSecurityManager() != null) &#123;</span><br><span class="line">    AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">      ReflectionUtils.makeAccessible(writeMethod);</span><br><span class="line">      return null;</span><br><span class="line">    &#125;);</span><br><span class="line">    try &#123;</span><br><span class="line">      AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt;</span><br><span class="line">          writeMethod.invoke(getWrappedInstance(), value), acc);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (PrivilegedActionException ex) &#123;</span><br><span class="line">      throw ex.getException();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    ReflectionUtils.makeAccessible(writeMethod);</span><br><span class="line">    //反射调用</span><br><span class="line">    writeMethod.invoke(getWrappedInstance(), value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GenericTypeAwarePropertyDescriptor初始化的时候，写方法的定义是以”set”开头的方法。</p>
<h3 id="从已有缓存获取对象"><a href="#从已有缓存获取对象" class="headerlink" title="从已有缓存获取对象"></a>从已有缓存获取对象</h3><p>bean的默认scope是单例的，如果将scope设置为prototype类型的，那么每次获取的bean的实例都是不一样的，二期也不会缓存bean实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单例的bean会在getSingleton方法里边进行缓存</span><br><span class="line">if (mbd.isSingleton()) &#123;</span><br><span class="line">  sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      return createBean(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (BeansException ex) &#123;</span><br><span class="line">      // Explicitly remove instance from singleton cache: It might have been put there</span><br><span class="line">      // eagerly by the creation process, to allow for circular reference resolution.</span><br><span class="line">      // Also remove any beans that received a temporary reference to the bean.</span><br><span class="line">      destroySingleton(beanName);</span><br><span class="line">      throw ex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else if (mbd.isPrototype()) &#123;</span><br><span class="line">  // It&#x27;s a prototype -&gt; create a new instance.</span><br><span class="line">  Object prototypeInstance = null;</span><br><span class="line">  try &#123;</span><br><span class="line">    //Prototype类型的bean不会进行缓存。</span><br><span class="line">    beforePrototypeCreation(beanName);</span><br><span class="line">    prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">  &#125;</span><br><span class="line">  finally &#123;</span><br><span class="line">    afterPrototypeCreation(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">  bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于spring Bean的创建流程</p>
<ol>
<li>Spring 所管理的Bean实际上是缓存在一个ConcurrentHashMap中的(singletonFactory对象中)</li>
<li>该对象本质上是一个key-value对的形式，key指的是bean的名字（id），value是一个Object对象，就是所创建的bean对象</li>
<li>在创建Bean之前，首先需要将该Bean的创建标示指定好，标示该Bean已经或是即将创建，目的是增强缓存的效率。</li>
<li>根据bean的scope属性来确定当前这个bean是一个singleton还是prototype的bean，然后创建相应的对象</li>
<li>无论是singleton还是prototype的bean，其创建的过程是一致的。</li>
<li>通过java反射机制来创建bean的实例，在创建之前需要检查构造方法的访问修饰符，如果不是public的，则会调用setAccessible(true)方法<br>来突破java语法限制，使得可以通过非public构造方法来完成对象实例的创建。</li>
<li>当对象创建完毕后，开始进行对象属性的注入。</li>
<li>在对象属性注入的过程中，spring除去使用之前通过BeanDefination对象获取的bean信息外，还会通过反射的方式获取到上面所创建的bean中的真实属性信息(还包括一个class属性，表示该Bean所对应的class类型)</li>
<li>完成bean属性的注入(或者抛出异常)</li>
<li>如果bean是一个单例的，那么将所创建出来的bean添加到singleton对象中(缓存中)，供程序后续再次使用。</li>
</ol>
<p>【本章代码位置：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzExNTY3MjE4NzQvc3ByaW5nLWtlcm5lbC1sZWN0dXJlJUUzJTgwJTkx">https://github.com/1156721874/spring-kernel-lecture】<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>spring_core</category>
      </categories>
      <tags>
        <tag>spring bean load init inject</tag>
      </tags>
  </entry>
  <entry>
    <title>spring_core(4)aop-transaction</title>
    <url>/2020/07/13/spring_core/spring_core(4)aop-transaction/</url>
    <content><![CDATA[<h3 id="事物实例"><a href="#事物实例" class="headerlink" title="事物实例"></a>事物实例</h3><ol>
<li><p>配置数据库驱动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile(</span><br><span class="line">            &quot;org.springframework:spring-core:5.2.5.RELEASE&quot;,</span><br><span class="line">            &quot;org.springframework:spring-aop:5.2.5.RELEASE&quot;,</span><br><span class="line">            &quot;org.springframework:spring-beans:5.2.5.RELEASE&quot;,</span><br><span class="line">            &quot;org.springframework:spring-context:5.2.5.RELEASE&quot;,</span><br><span class="line">            &quot;org.springframework:spring-context-support:5.2.5.RELEASE&quot;,</span><br><span class="line">            &quot;org.springframework:spring-web:5.2.5.RELEASE&quot;,</span><br><span class="line">            &quot;org.springframework:spring-orm:5.2.5.RELEASE&quot;,</span><br><span class="line">            &quot;org.springframework:spring-aspects:5.2.5.RELEASE&quot;,</span><br><span class="line">            &quot;org.springframework:spring-webmvc:5.2.5.RELEASE&quot;,</span><br><span class="line">            &quot;org.springframework:spring-jdbc:5.2.5.RELEASE&quot;,</span><br><span class="line">            &quot;org.springframework:spring-instrument:5.2.5.RELEASE&quot;,</span><br><span class="line">            &quot;org.springframework:spring-tx:5.2.5.RELEASE&quot;,</span><br><span class="line">            &quot;mysql:mysql-connector-java:8.0.20&quot;,</span><br><span class="line">            &quot;org.apache.tomcat:tomcat-jdbc:9.0.34&quot; 数据库连接池</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
<li><p>DAO配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.tdl.spring.bean.Student;</span><br><span class="line"></span><br><span class="line">public interface StudentDao &#123;</span><br><span class="line">    void saveStudent(Student student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.tdl.spring.bean.Student;</span><br><span class="line">import com.tdl.spring.dao.StudentDao;</span><br><span class="line">import org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line">public class StudentDaoImpl implements StudentDao &#123;</span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123;</span><br><span class="line">        this.jdbcTemplate = jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void saveStudent(Student student) &#123;</span><br><span class="line">        String sql = &quot;insert into student(name,age) values (?,?)&quot;;</span><br><span class="line">        this.jdbcTemplate.update(sql,student.getName(),student.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Service<br>接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface StudentService &#123;</span><br><span class="line">    void saveStudent(Student student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.tdl.spring.bean.Student;</span><br><span class="line">import com.tdl.spring.dao.StudentDao;</span><br><span class="line">import com.tdl.spring.service.StudentService;</span><br><span class="line"></span><br><span class="line">public class StudentServiceImpl implements StudentService &#123;</span><br><span class="line"></span><br><span class="line">    private StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    public void setStudentDao(StudentDao studentDao) &#123;</span><br><span class="line">        this.studentDao = studentDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void saveStudent(Student student) &#123;</span><br><span class="line">        this.studentDao.saveStudent(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置事物文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.tomcat.jdbc.pool.DataSource&quot; destroy-method=&quot;close&quot; autowire=&quot;no&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mytest&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;operater&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;minIdle&quot; value=&quot;1&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;maxIdle&quot; value=&quot;5&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;maxActive&quot; value=&quot;100&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;initialSize&quot; value=&quot;1&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;validationQuery&quot; value=&quot;select 1&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;testOnReturn&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;validationInterval&quot; value=&quot;500000&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;removeAbandoned&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;removeAbandonedTimeout&quot; value=&quot;30&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;fairQueue&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;defaultAutoCommit&quot; value=&quot;false&quot;/&gt; &lt;!-- 关闭自动提交 --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">     &lt;!-- 事物管理器 --&gt;</span><br><span class="line">    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;studentDao&quot; class=&quot;com.tdl.spring.dao.impl.StudentDaoImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;studentService&quot; class=&quot;com.tdl.spring.service.impl.StudentServiceImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;studentDao&quot; ref=&quot;studentDao&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;studentServiceProxy&quot; class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;target&quot; ref=&quot;studentService&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;transactionAttributes&quot;&gt;</span><br><span class="line">            &lt;props&gt;</span><br><span class="line">                &lt;prop key=&quot;save*&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=&quot;update*&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=&quot;remove*&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt;</span><br><span class="line">                &lt;prop key=&quot;get*&quot;&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;</span><br><span class="line">            &lt;/props&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>启动测试类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class SpringClientTransaction &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Resource resource = new ClassPathResource(&quot;applicationContext3.xml&quot;);</span><br><span class="line">        DefaultListableBeanFactory defaultListableBeanFactory</span><br><span class="line">                = new DefaultListableBeanFactory();</span><br><span class="line">        BeanDefinitionReader beanDefinitionReader =</span><br><span class="line">                new XmlBeanDefinitionReader(defaultListableBeanFactory);</span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(resource);</span><br><span class="line"></span><br><span class="line">        StudentService studentService = (StudentService)defaultListableBeanFactory.</span><br><span class="line">                getBean(&quot;studentServiceProxy&quot;);</span><br><span class="line">        Student student  = new Student();</span><br><span class="line">        student.setName(&quot;zhangsan&quot;);</span><br><span class="line">        student.setAge(23);</span><br><span class="line">        studentService.saveStudent(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="事物开启流程"><a href="#事物开启流程" class="headerlink" title="事物开启流程"></a>事物开启流程</h3><p>【StudentService studentService &#x3D; (StudentService)defaultListableBeanFactory.getBean(“studentServiceProxy”);】<br>这行代码的执行过程会伴随事物的开启，接下来开始看一下。<br>bean的实例化和普通 的bean没啥区别，不做过多介绍，最后 程序会来到org.springframework.beans.factory.support.AbstractBeanFactory#getObjectForBeanInstance()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Object getObjectForBeanInstance(</span><br><span class="line">    Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) &#123;</span><br><span class="line"></span><br><span class="line">  // Don&#x27;t let calling code try to dereference the factory if the bean isn&#x27;t a factory.</span><br><span class="line">  if (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">    if (beanInstance instanceof NullBean) &#123;</span><br><span class="line">      return beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!(beanInstance instanceof FactoryBean)) &#123;</span><br><span class="line">      throw new BeanIsNotAFactoryException(beanName, beanInstance.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    if (mbd != null) &#123;</span><br><span class="line">      mbd.isFactoryBean = true;</span><br><span class="line">    &#125;</span><br><span class="line">    return beanInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Now we have the bean instance, which may be a normal bean or a FactoryBean.</span><br><span class="line">  // If it&#x27;s a FactoryBean, we use it to create a bean instance, unless the</span><br><span class="line">  // caller actually wants a reference to the factory.</span><br><span class="line">  if (!(beanInstance instanceof FactoryBean)) &#123;</span><br><span class="line">    return beanInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Object object = null;</span><br><span class="line">  if (mbd != null) &#123;</span><br><span class="line">    mbd.isFactoryBean = true;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">  if (object == null) &#123;</span><br><span class="line">    // Return bean instance from factory.</span><br><span class="line">    FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">    // Caches object obtained from FactoryBean if it is a singleton.</span><br><span class="line">    if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">      mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic());</span><br><span class="line">    object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">  &#125;</span><br><span class="line">  return object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected Object getObjectFromFactoryBean(FactoryBean&lt;?&gt; factory, String beanName, boolean shouldPostProcess) &#123;</span><br><span class="line">  if (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line">    synchronized (getSingletonMutex()) &#123;</span><br><span class="line">      Object object = this.factoryBeanObjectCache.get(beanName);</span><br><span class="line">      if (object == null) &#123;</span><br><span class="line">        object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">        .......略</span><br><span class="line">      &#125;</span><br><span class="line">      return object;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    ......略</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Object doGetObjectFromFactoryBean(final FactoryBean&lt;?&gt; factory, final String beanName)</span><br><span class="line">    throws BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">  Object object;</span><br><span class="line">    ......略</span><br><span class="line">    //TransactionProxyFactoryBean是TransactionProxyFactoryBean，</span><br><span class="line">      object = factory.getObject();</span><br><span class="line">  ......</span><br><span class="line">  return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>factory.getObject()的实现是：<br>org.springframework.aop.framework.AbstractSingletonProxyFactoryBean#getObject():</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object getObject() &#123;</span><br><span class="line">  if (this.proxy == null) &#123;</span><br><span class="line">    throw new FactoryBeanNotInitializedException();</span><br><span class="line">  &#125;</span><br><span class="line">  return this.proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>proxy是生成的代理，代理的目标是com.tdl.spring.service.impl.StudentServiceImpl<br><img src="/proxy4.png" alt="proxy4.png"><br>因此【StudentService studentService &#x3D; (StudentService)defaultListableBeanFactory.getBean(“studentServiceProxy”);】中的<br>studentService是proxy4，是一个代理，studentService.saveStudent()会调用动态代理对象的invoke方法，完成代理。</p>
<h3 id="事务管理器层次体系分析与执行逻辑"><a href="#事务管理器层次体系分析与执行逻辑" class="headerlink" title="事务管理器层次体系分析与执行逻辑"></a>事务管理器层次体系分析与执行逻辑</h3><h4 id="TransactionProxyFactoryBean"><a href="#TransactionProxyFactoryBean" class="headerlink" title="TransactionProxyFactoryBean"></a>TransactionProxyFactoryBean</h4><p>TransactionProxyFactoryBean 继承了AbstractSingletonProxyFactoryBean，AbstractSingletonProxyFactoryBean实现了FactoryBean，同时在AbstractSingletonProxyFactoryBean里边维护了target(别代理的对象)。<br>TransactionProxyFactoryBean有三个重要属性需要配置：</p>
<ol>
<li>“transactionManager”: the PlatformTransactionManager implementation to use (for example, a org.springframework.transaction.jta.JtaTransactionManager instance)</li>
<li>“target”: the target object that a transactional proxy should be created for</li>
<li>“transactionAttributes”: the transaction attributes (for example, propagation behavior and “readOnly” flag) per target method name (or method name pattern</li>
</ol>
<h4 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface PlatformTransactionManager extends TransactionManager &#123;</span><br><span class="line">org.springframework.transaction.PlatformTransactionManager#commit</span><br><span class="line">org.springframework.transaction.PlatformTransactionManager#rollback</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This is the central interface in Spring’s transaction infrastructure. Applications can use this directly, but it is not primarily meant as API: Typically, applications will work with either TransactionTemplate or declarative transaction demarcation through AOP.<br>For implementors, it is recommended to derive from the provided org.springframework.transaction.support.AbstractPlatformTransactionManager class, which pre-implements the defined propagation behavior and takes care of transaction synchronization handling. Subclasses have to implement template methods for specific states of the underlying transaction, for example: begin, suspend, resume, commit.<br>The default implementations of this strategy interface are org.springframework.transaction.jta.JtaTransactionManager and org.springframework.jdbc.datasource.DataSourceTransactionManager, which can serve as an implementation guide for other transaction strategies.<br>PlatformTransactionManager是spring事物基础设施中心化的一个接口，应用可以直接使用它，一般应用会使用TransactionTemplate，或者声明式的事物去实现。<br>推荐具体的实现使用AbstractPlatformTransactionManager去驱动，它预实现了一些传播行为，以及事物的一些同步的处理，子类只需要根据具体的事物实现去实现一些模板的方法，比如事物开始，挂起，回滚，提交<br>PlatformTransactionManager的默认实现策略有org.springframework.transaction.jta.JtaTransactionManager 和 org.springframework.jdbc.datasource.DataSourceTransactionManager，他们可以作为一种其他事物管理器实现的一个指导。<br>PlatformTransactionManager的一些实现有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AbstractPlatformTransactionManager</span><br><span class="line">CallbackPreferringPlatformTransactionManager</span><br><span class="line">CciLocalTransactionManager</span><br><span class="line">DataSourceTransactionManager</span><br><span class="line">HibernateTransactionManager</span><br><span class="line">JpaTransactionManager</span><br><span class="line">JtaTransactionManager</span><br><span class="line">ResourceTransactionManager</span><br><span class="line">WebLogicJtaTransactionManager</span><br><span class="line">WebSphereUowTransactionManager</span><br></pre></td></tr></table></figure>
<p>AbstractPlatformTransactionManager作为一个模板，让其他的事物管理器去继承AbstractPlatformTransactionManager。</p>
<ul>
<li>PlatformTransactionManager<ul>
<li>AbstractPlatformTransactionManager<ul>
<li>CciLocalTransactionManager</li>
<li>DataSourceTransactionManager</li>
<li>HibernateTransactionManager</li>
<li>JpaTransactionManager</li>
<li>JtaTransactionManager</li>
<li>WebLogicJtaTransactionManager</li>
<li>WebSphereUowTransactionManager</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="执行逻辑-事物的执行"><a href="#执行逻辑-事物的执行" class="headerlink" title="执行逻辑-事物的执行"></a>执行逻辑-事物的执行</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SpringClientTransaction &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Resource resource = new ClassPathResource(&quot;applicationContext3.xml&quot;);</span><br><span class="line">        DefaultListableBeanFactory defaultListableBeanFactory</span><br><span class="line">                = new DefaultListableBeanFactory();</span><br><span class="line">        BeanDefinitionReader beanDefinitionReader =</span><br><span class="line">                new XmlBeanDefinitionReader(defaultListableBeanFactory);</span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(resource);</span><br><span class="line"></span><br><span class="line">        StudentService studentService = (StudentService)defaultListableBeanFactory.</span><br><span class="line">                getBean(&quot;studentServiceProxy&quot;);</span><br><span class="line">        Student student  = new Student();</span><br><span class="line">        student.setName(&quot;zhangsan&quot;);</span><br><span class="line">        student.setAge(23);</span><br><span class="line">        studentService.saveStudent(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在【studentService.saveStudent(student)】debug往下跟进流程，注意studentService是一个代理对象，因此方法进入JdkDynamicAopProxy。<br>org.springframework.aop.framework.JdkDynamicAopProxy：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">		Object oldProxy = null;</span><br><span class="line">		boolean setProxyContext = false;</span><br><span class="line">    //TargetSource的实现是SingletonTargetSource，SingletonTargetSource里面注入了StudentServiceImpl</span><br><span class="line">		TargetSource targetSource = this.advised.targetSource;</span><br><span class="line">		Object target = null;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">				// The target does not implement the equals(Object) method itself.</span><br><span class="line">				return equals(args[0]);</span><br><span class="line">			&#125;</span><br><span class="line">			else if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">				// The target does not implement the hashCode() method itself.</span><br><span class="line">				return hashCode();</span><br><span class="line">			&#125;</span><br><span class="line">			else if (method.getDeclaringClass() == DecoratingProxy.class) &#123;</span><br><span class="line">				// There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span><br><span class="line">				return AopProxyUtils.ultimateTargetClass(this.advised);</span><br><span class="line">			&#125;</span><br><span class="line">			else if (!this.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">					method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">				// Service invocations on ProxyConfig with the proxy config...</span><br><span class="line">				return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Object retVal;</span><br><span class="line"></span><br><span class="line">			if (this.advised.exposeProxy) &#123;</span><br><span class="line">				// Make invocation available if necessary.</span><br><span class="line">				oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">				setProxyContext = true;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Get as late as possible to minimize the time we &quot;own&quot; the target,</span><br><span class="line">			// in case it comes from a pool.</span><br><span class="line">      //target等于StudentServiceImpl</span><br><span class="line">			target = targetSource.getTarget();</span><br><span class="line">      //StudentServiceImpl的class对象</span><br><span class="line">			Class&lt;?&gt; targetClass = (target != null ? target.getClass() : null);</span><br><span class="line"></span><br><span class="line">			// Get the interception chain for this method.</span><br><span class="line">      //method等于StudentService.saveStudent，即StudentServiceImpl类里边的saveStudent方法对应的拦截器链</span><br><span class="line">      //chain只有一个对象是TransactionInterceptor</span><br><span class="line">			List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">			// Check whether we have any advice. If we don&#x27;t, we can fallback on direct</span><br><span class="line">			// reflective invocation of the target, and avoid creating a MethodInvocation.</span><br><span class="line">			if (chain.isEmpty()) &#123;</span><br><span class="line">				// We can skip creating a MethodInvocation: just invoke the target directly</span><br><span class="line">				// Note that the final invoker must be an InvokerInterceptor so we know it does</span><br><span class="line">				// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span><br><span class="line">				Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">				retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				// We need to create a method invocation...</span><br><span class="line">        //ReflectiveMethodInvocation是比较重要的一个类，封装了代理，目标对象，目标对象的方法调用，参数，以及</span><br><span class="line">        //拦截器链的引用</span><br><span class="line">				MethodInvocation invocation =</span><br><span class="line">						new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">				// Proceed to the joinpoint through the interceptor chain.</span><br><span class="line">				retVal = invocation.proceed();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Massage return value if necessary.</span><br><span class="line">			Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">			if (retVal != null &amp;&amp; retVal == target &amp;&amp;</span><br><span class="line">					returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">					!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">				// Special case: it returned &quot;this&quot; and the return type of the method</span><br><span class="line">				// is type-compatible. Note that we can&#x27;t help if the target sets</span><br><span class="line">				// a reference to itself in another returned object.</span><br><span class="line">				retVal = proxy;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (retVal == null &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">				throw new AopInvocationException(</span><br><span class="line">						&quot;Null return value from advice does not match primitive return type for: &quot; + method);</span><br><span class="line">			&#125;</span><br><span class="line">			return retVal;</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			if (target != null &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">				// Must have come from TargetSource.</span><br><span class="line">				targetSource.releaseTarget(target);</span><br><span class="line">			&#125;</span><br><span class="line">			if (setProxyContext) &#123;</span><br><span class="line">				// Restore old proxy.</span><br><span class="line">				AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>ReflectiveMethodInvocation#proceed()：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//List of MethodInterceptor and InterceptorAndDynamicMethodMatcher that need dynamic checks</span><br><span class="line">protected final List&lt;?&gt; interceptorsAndDynamicMethodMatchers;</span><br><span class="line">public Object proceed() throws Throwable &#123;</span><br><span class="line">  // We start with an index of -1 and increment early.</span><br><span class="line">  if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) &#123;</span><br><span class="line">    return invokeJoinpoint();</span><br><span class="line">  &#125;</span><br><span class="line">  //interceptorsAndDynamicMethodMatchers缓存了我们配置的拦截器，每次currentInterceptorIndex都会往前走伴随着下一个拦截器的到来</span><br><span class="line">  Object interceptorOrInterceptionAdvice =</span><br><span class="line">      this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);</span><br><span class="line">  if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">    // Evaluate dynamic method matcher here: static part will already have</span><br><span class="line">    // been evaluated and found to match.</span><br><span class="line">    InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">        (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">    Class&lt;?&gt; targetClass = (this.targetClass != null ? this.targetClass : this.method.getDeclaringClass());</span><br><span class="line">    if (dm.methodMatcher.matches(this.method, targetClass, this.arguments)) &#123;</span><br><span class="line">      return dm.interceptor.invoke(this);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      // Dynamic matching failed.</span><br><span class="line">      // Skip this interceptor and invoke the next in the chain.</span><br><span class="line">      return proceed();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    // It&#x27;s an interceptor, so we just invoke it: The pointcut will have</span><br><span class="line">    // been evaluated statically before this object was constructed.</span><br><span class="line">    //调用MethodInterceptor的invoke方法。</span><br><span class="line">    return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MethodInterceptor的invoke实现在TransactionInterceptor里边。<br>org.springframework.transaction.interceptor.TransactionInterceptor#invoke()方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object invoke(MethodInvocation invocation) throws Throwable &#123;</span><br><span class="line">  // Work out the target class: may be &#123;@code null&#125;.</span><br><span class="line">  // The TransactionAttributeSource should be passed the target class</span><br><span class="line">  // as well as the method, which may be from an interface.</span><br><span class="line">  //targetClass是StudentServiceImpl。</span><br><span class="line">  Class&lt;?&gt; targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);</span><br><span class="line"></span><br><span class="line">  // Adapt to TransactionAspectSupport&#x27;s invokeWithinTransaction...</span><br><span class="line">  //在事物当中去进行调用</span><br><span class="line">  return invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>invokeWithinTransaction的实现在【org.springframework.transaction.interceptor.TransactionAspectSupport】里边:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Object invokeWithinTransaction(Method method, @Nullable Class&lt;?&gt; targetClass,</span><br><span class="line">    final InvocationCallback invocation) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">  // If the transaction attribute is null, the method is non-transactional.</span><br><span class="line">  //tas的内容是我们在配置文件里边配置的一些属性：</span><br><span class="line">  //&quot;save*&quot; -&gt; &#123;RuleBasedTransactionAttribute@1914&#125; &quot;PROPAGATION_REQUIRED,ISOLATION_DEFAULT&quot;</span><br><span class="line">  //&quot;update*&quot; -&gt; &#123;RuleBasedTransactionAttribute@1912&#125; &quot;PROPAGATION_REQUIRED,ISOLATION_DEFAULT&quot;</span><br><span class="line">  //&quot;get*&quot; -&gt; &#123;RuleBasedTransactionAttribute@1910&#125; &quot;PROPAGATION_REQUIRED,ISOLATION_DEFAULT,readOnly&quot;</span><br><span class="line">  //&quot;remove*&quot; -&gt; &#123;RuleBasedTransactionAttribute@1908&#125; &quot;PROPAGATION_REQUIRED,ISOLATION_DEFAULT&quot;</span><br><span class="line">  TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">  //txAttr内容是事物的一些属性(针对于targetClass的method方法)：</span><br><span class="line">  //rollbackRules = null</span><br><span class="line">  //qualifier = null</span><br><span class="line">  //descriptor = null</span><br><span class="line">  //propagationBehavior = 0</span><br><span class="line">  //isolationLevel = -1</span><br><span class="line">  //timeout = -1</span><br><span class="line">  //readOnly = false</span><br><span class="line">  //name = null</span><br><span class="line">  final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null);</span><br><span class="line">  //根据事物属性构建事物管理器</span><br><span class="line">  final TransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line">  ......略</span><br><span class="line">  //转换为PlatformTransactionManager，因为PlatformTransactionManager是事物管理最基础的事物管理集权。</span><br><span class="line">  PlatformTransactionManager ptm = asPlatformTransactionManager(tm);</span><br><span class="line">  //com.tdl.spring.service.impl.StudentServiceImpl.saveStudent</span><br><span class="line">  final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</span><br><span class="line"></span><br><span class="line">  //真正开始创建事物，参数：事物管理器、事物属性、目标对象的实际方</span><br><span class="line">  //法(com.tdl.spring.service.impl.StudentServiceImpl.saveStudent)</span><br><span class="line">  TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">  Object retVal;</span><br><span class="line">  try&#123;&#125;</span><br><span class="line">    //环绕通知，调用拦截器链中的下一个拦截器，如果没有拦截器会调用目标对象的方法</span><br><span class="line">    retVal = invocation.proceedWithInvocation();</span><br><span class="line">  &#125;catch(Throwable e)&#123;</span><br><span class="line">    completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">    throw ex;</span><br><span class="line">  &#125;finally&#123;</span><br><span class="line">    cleanupTransactionInfo(txInfo);</span><br><span class="line">  &#125;</span><br><span class="line">    if (vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123;</span><br><span class="line">    // Set rollback-only in case of Vavr failure matching our rollback rules...</span><br><span class="line">    TransactionStatus status = txInfo.getTransactionStatus();</span><br><span class="line">    if (status != null &amp;&amp; txAttr != null) &#123;</span><br><span class="line">      retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  commitTransactionAfterReturning(txInfo);</span><br><span class="line">  return retVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建事物管理器</span><br><span class="line">protected TransactionManager determineTransactionManager(@Nullable TransactionAttribute txAttr) &#123;</span><br><span class="line">  // Do not attempt to lookup tx manager if no tx attributes are set</span><br><span class="line">  if (txAttr == null || this.beanFactory == null) &#123;</span><br><span class="line">    return getTransactionManager();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String qualifier = txAttr.getQualifier();</span><br><span class="line">  if (StringUtils.hasText(qualifier)) &#123;</span><br><span class="line">    return determineQualifiedTransactionManager(this.beanFactory, qualifier);</span><br><span class="line">  &#125;</span><br><span class="line">  else if (StringUtils.hasText(this.transactionManagerBeanName)) &#123;</span><br><span class="line">    return determineQualifiedTransactionManager(this.beanFactory, this.transactionManagerBeanName);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    //获取默认的事物管理器</span><br><span class="line">    TransactionManager defaultTransactionManager = getTransactionManager();</span><br><span class="line">    if (defaultTransactionManager == null) &#123;</span><br><span class="line">      defaultTransactionManager = this.transactionManagerCache.get(DEFAULT_TRANSACTION_MANAGER_KEY);</span><br><span class="line">      if (defaultTransactionManager == null) &#123;</span><br><span class="line">        defaultTransactionManager = this.beanFactory.getBean(TransactionManager.class);</span><br><span class="line">        this.transactionManagerCache.putIfAbsent(</span><br><span class="line">            DEFAULT_TRANSACTION_MANAGER_KEY, defaultTransactionManager);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //返回事物管理器</span><br><span class="line">    return defaultTransactionManager;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//直接返回事物管理器(XML已经配置过)</span><br><span class="line">public TransactionManager getTransactionManager() &#123;</span><br><span class="line">  return this.transactionManager;</span><br><span class="line">&#125;</span><br><span class="line">//将transactionManager转换为PlatformTransactionManager，因为PlatformTransactionManager是transactionManager的一个实现</span><br><span class="line">private PlatformTransactionManager asPlatformTransactionManager(@Nullable Object transactionManager) &#123;</span><br><span class="line">  if (transactionManager == null || transactionManager instanceof PlatformTransactionManager) &#123;</span><br><span class="line">    return (PlatformTransactionManager) transactionManager;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    //spring中的所有的事物管理器必须是实现PlatformTransactionManager接口</span><br><span class="line">    throw new IllegalStateException(</span><br><span class="line">        &quot;Specified transaction manager is not a PlatformTransactionManager: &quot; + transactionManager);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected TransactionInfo createTransactionIfNecessary(@Nullable PlatformTransactionManager tm,</span><br><span class="line">    @Nullable TransactionAttribute txAttr, final String joinpointIdentification) &#123;</span><br><span class="line"></span><br><span class="line">  TransactionStatus status = status = tm.getTransaction(txAttr);</span><br><span class="line">  return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TransactionInfo的结构如下<br><img src="/TransactionInfo.png" alt="TransactionInfo.png"><br>tm.getTransaction的实现在<br>org.springframework.transaction.support.AbstractPlatformTransactionManager:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition)</span><br><span class="line">    throws TransactionException &#123;</span><br><span class="line"></span><br><span class="line">  // Use defaults if no transaction definition given.</span><br><span class="line">  //表示事物的属性</span><br><span class="line">  TransactionDefinition def = (definition != null ? definition : TransactionDefinition.withDefaults());</span><br><span class="line">  //执行创建事物，transaction等于DataSourceTransactionObject，每次来一个事物就会创建一个DataSourceTransactionObject</span><br><span class="line">  //DataSourceTransactionObject是DataSourceTransaction的内部类</span><br><span class="line">  Object transaction = doGetTransaction();</span><br><span class="line">  boolean debugEnabled = logger.isDebugEnabled();</span><br><span class="line">  //是不是一个既有的事物（嵌套事物）</span><br><span class="line">  if (isExistingTransaction(transaction)) &#123;</span><br><span class="line">    // Existing transaction found -&gt; check propagation behavior to find out how to behave.</span><br><span class="line">    return handleExistingTransaction(def, transaction, debugEnabled);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Check definition settings for new transaction.</span><br><span class="line">  if (def.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">    throw new InvalidTimeoutException(&quot;Invalid transaction timeout&quot;, def.getTimeout());</span><br><span class="line">  &#125;</span><br><span class="line">  //事物传播行为的一些操作</span><br><span class="line">  // No existing transaction found -&gt; check propagation behavior to find out how to proceed.</span><br><span class="line">  if (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">    throw new IllegalTransactionStateException(</span><br><span class="line">        &quot;No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else if (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">      def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">      def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">    SuspendedResourcesHolder suspendedResources = suspend(null);</span><br><span class="line">    if (debugEnabled) &#123;</span><br><span class="line">      logger.debug(&quot;Creating new transaction with name [&quot; + def.getName() + &quot;]: &quot; + def);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      //开启事物，参数：事物的定义、事物对象、</span><br><span class="line">      return startTransaction(def, transaction, debugEnabled, suspendedResources);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (RuntimeException | Error ex) &#123;</span><br><span class="line">      resume(null, suspendedResources);</span><br><span class="line">      throw ex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    // Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.</span><br><span class="line">    if (def.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">      logger.warn(&quot;Custom isolation level specified but no actual transaction initiated; &quot; +</span><br><span class="line">          &quot;isolation level will effectively be ignored: &quot; + def);</span><br><span class="line">    &#125;</span><br><span class="line">    boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">    //设置事物状态</span><br><span class="line">    return prepareTransactionStatus(def, null, true, newSynchronization, debugEnabled, null);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doGetTransaction()的实现在org.springframework.jdbc.datasource.DataSourceTransactionManager：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Object doGetTransaction() &#123;</span><br><span class="line">  //DataSourceTransactionObject是一个事物对象</span><br><span class="line">  DataSourceTransactionObject txObject = new DataSourceTransactionObject();</span><br><span class="line">  txObject.setSavepointAllowed(isNestedTransactionAllowed());</span><br><span class="line">  ConnectionHolder conHolder =</span><br><span class="line">      (ConnectionHolder) TransactionSynchronizationManager.getResource(obtainDataSource());</span><br><span class="line">  txObject.setConnectionHolder(conHolder, false);</span><br><span class="line">  return txObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>startTransaction()返回一个事物状态对象，又回到了org.springframework.transaction.support.AbstractPlatformTransactionManager:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private TransactionStatus startTransaction(TransactionDefinition definition, Object transaction,</span><br><span class="line">    boolean debugEnabled, @Nullable SuspendedResourcesHolder suspendedResources) &#123;</span><br><span class="line"></span><br><span class="line">  boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">  DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">      definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">  doBegin(transaction, definition);</span><br><span class="line">  prepareSynchronization(status, definition);</span><br><span class="line">  return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doBegin的实现在org.springframework.jdbc.datasource.DataSourceTransactionManager：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * This implementation sets the isolation level but ignores the timeout.</span><br><span class="line"> * 实现一些隔离级别，但是忽略超时</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">protected void doBegin(Object transaction, TransactionDefinition definition) &#123;</span><br><span class="line">  DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;</span><br><span class="line">  Connection con = null;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    if (!txObject.hasConnectionHolder() ||</span><br><span class="line">        txObject.getConnectionHolder().isSynchronizedWithTransaction()) &#123;</span><br><span class="line">          //获取到数据源，即一个DataSource对象，xml有配置。然后获取数据库连接</span><br><span class="line">      Connection newCon = obtainDataSource().getConnection();</span><br><span class="line">      if (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(&quot;Acquired Connection [&quot; + newCon + &quot;] for JDBC transaction&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      txObject.setConnectionHolder(new ConnectionHolder(newCon), true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    txObject.getConnectionHolder().setSynchronizedWithTransaction(true);</span><br><span class="line">    con = txObject.getConnectionHolder().getConnection();</span><br><span class="line"></span><br><span class="line">    Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);</span><br><span class="line">    txObject.setPreviousIsolationLevel(previousIsolationLevel);</span><br><span class="line">    //是否设置成只读操作</span><br><span class="line">    txObject.setReadOnly(definition.isReadOnly());</span><br><span class="line"></span><br><span class="line">    // Switch to manual commit if necessary. This is very expensive in some JDBC drivers,</span><br><span class="line">    // so we don&#x27;t want to do it unnecessarily (for example if we&#x27;ve explicitly</span><br><span class="line">    // configured the connection pool to set it already).</span><br><span class="line">    //如果是自动提交，设置成非自动提交(如果是自动提交的话，事物的配置是没有意义的)</span><br><span class="line">    if (con.getAutoCommit()) &#123;</span><br><span class="line">      txObject.setMustRestoreAutoCommit(true);</span><br><span class="line">      if (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(&quot;Switching JDBC Connection [&quot; + con + &quot;] to manual commit&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      con.setAutoCommit(false);</span><br><span class="line">    &#125;</span><br><span class="line">    //只读事物</span><br><span class="line">    prepareTransactionalConnection(con, definition);</span><br><span class="line">    txObject.getConnectionHolder().setTransactionActive(true);</span><br><span class="line"></span><br><span class="line">    int timeout = determineTimeout(definition);</span><br><span class="line">    if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">      txObject.getConnectionHolder().setTimeoutInSeconds(timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Bind the connection holder to the thread.</span><br><span class="line">    if (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">      TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  catch (Throwable ex) &#123;</span><br><span class="line">    if (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">      DataSourceUtils.releaseConnection(con, obtainDataSource());</span><br><span class="line">      txObject.setConnectionHolder(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    throw new CannotCreateTransactionException(&quot;Could not open JDBC Connection for transaction&quot;, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果xml文件配置了readonly，这里会把事物设置成只读事物</span><br><span class="line">protected void prepareTransactionalConnection(Connection con, TransactionDefinition definition)</span><br><span class="line">    throws SQLException &#123;</span><br><span class="line"></span><br><span class="line">  if (isEnforceReadOnly() &amp;&amp; definition.isReadOnly()) &#123;</span><br><span class="line">    try (Statement stmt = con.createStatement()) &#123;</span><br><span class="line">      stmt.executeUpdate(&quot;SET TRANSACTION READ ONLY&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们回到TransactionAspectSupport的invokeWithinTransaction方法，得到TransactionInfo之后，会调用InvocationCallback的proceedWithInvocation方法，这个方法会执行拦截器链，如果没有拦截器链会执行目标方法。<br>proceedWithInvocation的实现上文已经介绍过：<br>org.springframework.aop.framework.ReflectiveMethodInvocation：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object proceed() throws Throwable &#123;</span><br><span class="line">  // We start with an index of -1 and increment early.</span><br><span class="line">  if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) &#123;</span><br><span class="line">    //进入invokeJoinpoint方法</span><br><span class="line">    return invokeJoinpoint();</span><br><span class="line">  &#125;</span><br><span class="line">  ......略</span><br><span class="line">&#125;</span><br><span class="line">//使用反射调用连接点</span><br><span class="line">protected Object invokeJoinpoint() throws Throwable &#123;</span><br><span class="line">  //target是目标对象，method是目标对象的方法，arguments是目标方法的参数</span><br><span class="line">  return AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>invokeJoinpointUsingReflection方法实现：<br>org.springframework.aop.support.AopUtils</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static Object invokeJoinpointUsingReflection(@Nullable Object target, Method method, Object[] args)</span><br><span class="line">    throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">  // Use reflection to invoke the method.</span><br><span class="line">  try &#123;</span><br><span class="line">    //突破访问限制</span><br><span class="line">    ReflectionUtils.makeAccessible(method);</span><br><span class="line">    //调用目标方法，即StudentServiceImpl.saveStudent()</span><br><span class="line">    return method.invoke(target, args);</span><br><span class="line">  &#125;</span><br><span class="line">  catch (InvocationTargetException ex) &#123;</span><br><span class="line">    // Invoked method threw a checked exception.</span><br><span class="line">    // We must rethrow it. The client won&#x27;t see the interceptor.</span><br><span class="line">    throw ex.getTargetException();</span><br><span class="line">  &#125;</span><br><span class="line">  catch (IllegalArgumentException ex) &#123;</span><br><span class="line">    throw new AopInvocationException(&quot;AOP configuration seems to be invalid: tried calling method [&quot; +</span><br><span class="line">        method + &quot;] on target [&quot; + target + &quot;]&quot;, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  catch (IllegalAccessException ex) &#123;</span><br><span class="line">    throw new AopInvocationException(&quot;Could not access method [&quot; + method + &quot;]&quot;, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="执行逻辑-事物的提交-x2F-回滚"><a href="#执行逻辑-事物的提交-x2F-回滚" class="headerlink" title="执行逻辑-事物的提交&#x2F;回滚"></a>执行逻辑-事物的提交&#x2F;回滚</h4><p>我们回到TransactionAspectSupport的invokeWithinTransaction方法，环绕事物InvocationCallback.proceedWithInvocation()<br>执行完毕之后，紧接着执行commitTransactionAfterReturning()方法对事物进行提交：<br>org.springframework.transaction.interceptor.TransactionAspectSupport</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void commitTransactionAfterReturning(@Nullable TransactionInfo txInfo) &#123;</span><br><span class="line">  if (txInfo != null &amp;&amp; txInfo.getTransactionStatus() != null) &#123;</span><br><span class="line">    if (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(&quot;Completing transaction for [&quot; + txInfo.getJoinpointIdentification() + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>commit方法的实现：<br>org.springframework.transaction.support.AbstractPlatformTransactionManager</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final void commit(TransactionStatus status) throws TransactionException &#123;</span><br><span class="line">  ......略</span><br><span class="line">  //事物处理逻辑</span><br><span class="line">  processCommit(defStatus);</span><br><span class="line">&#125;</span><br><span class="line">//处理一个实际的提交</span><br><span class="line">private void processCommit(DefaultTransactionStatus status) throws TransactionException &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    boolean beforeCompletionInvoked = false;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      boolean unexpectedRollback = false;</span><br><span class="line">      prepareForCommit(status);</span><br><span class="line">      triggerBeforeCommit(status);</span><br><span class="line">      triggerBeforeCompletion(status);</span><br><span class="line">      beforeCompletionInvoked = true;</span><br><span class="line"></span><br><span class="line">      if (status.hasSavepoint()) &#123;</span><br><span class="line">        if (status.isDebug()) &#123;</span><br><span class="line">          logger.debug(&quot;Releasing transaction savepoint&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">        status.releaseHeldSavepoint();</span><br><span class="line">      &#125;</span><br><span class="line">      else if (status.isNewTransaction()) &#123;</span><br><span class="line">        if (status.isDebug()) &#123;</span><br><span class="line">          logger.debug(&quot;Initiating transaction commit&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">        //事物提交</span><br><span class="line">        doCommit(status);</span><br><span class="line">      &#125;</span><br><span class="line">      else if (isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">        unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Throw UnexpectedRollbackException if we have a global rollback-only</span><br><span class="line">      // marker but still didn&#x27;t get a corresponding exception from commit.</span><br><span class="line">      if (unexpectedRollback) &#123;</span><br><span class="line">        throw new UnexpectedRollbackException(</span><br><span class="line">            &quot;Transaction silently rolled back because it has been marked as rollback-only&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (UnexpectedRollbackException ex) &#123;</span><br><span class="line">      // can only be caused by doCommit</span><br><span class="line">      triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</span><br><span class="line">      throw ex;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (TransactionException ex) &#123;</span><br><span class="line">      // can only be caused by doCommit</span><br><span class="line">      if (isRollbackOnCommitFailure()) &#123;</span><br><span class="line">        doRollbackOnCommitException(status, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">        triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line">      &#125;</span><br><span class="line">      throw ex;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (RuntimeException | Error ex) &#123;</span><br><span class="line">      if (!beforeCompletionInvoked) &#123;</span><br><span class="line">        triggerBeforeCompletion(status);</span><br><span class="line">      &#125;</span><br><span class="line">      doRollbackOnCommitException(status, ex);</span><br><span class="line">      throw ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Trigger afterCommit callbacks, with an exception thrown there</span><br><span class="line">    // propagated to callers but the transaction still considered as committed.</span><br><span class="line">    try &#123;</span><br><span class="line">      triggerAfterCommit(status);</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">      triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  finally &#123;</span><br><span class="line">    cleanupAfterCompletion(status);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行提交</span><br><span class="line">protected void doCommit(DefaultTransactionStatus status) &#123;</span><br><span class="line">  //事物对象，每一次事物都会存在一个事物对象</span><br><span class="line">  DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();</span><br><span class="line">  //得到一个数据库连接，ConnectionHolder持有当前数据库的连接</span><br><span class="line">  Connection con = txObject.getConnectionHolder().getConnection();</span><br><span class="line">  if (status.isDebug()) &#123;</span><br><span class="line">    logger.debug(&quot;Committing JDBC transaction on Connection [&quot; + con + &quot;]&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    //使用数据库连接执行事物的提交</span><br><span class="line">    con.commit();</span><br><span class="line">  &#125;</span><br><span class="line">  catch (SQLException ex) &#123;</span><br><span class="line">    throw new TransactionSystemException(&quot;Could not commit JDBC transaction&quot;, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此事物执行结束。</p>
<h5 id="针对于数据库事物的操作"><a href="#针对于数据库事物的操作" class="headerlink" title="针对于数据库事物的操作"></a>针对于数据库事物的操作</h5><p>setAutoCommit();</p>
<p>target.methods();</p>
<p>conn.commit();<br>or<br>conn.rollback();</p>
<h5 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h5><p>org.springframework.transaction.interceptor.TransactionAspectSupport</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Object invokeWithinTransaction(Method method, @Nullable Class&lt;?&gt; targetClass,</span><br><span class="line">    final InvocationCallback invocation) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">      Object retVal;</span><br><span class="line">			try &#123;</span><br><span class="line">				// This is an around advice: Invoke the next interceptor in the chain.</span><br><span class="line">				// This will normally result in a target object being invoked.</span><br><span class="line">        //环绕通知，调用拦截器链中的下一个拦截器，如果没有拦截器会调用目标对象的方法</span><br><span class="line">				retVal = invocation.proceedWithInvocation();</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Throwable ex) &#123;</span><br><span class="line">				// target invocation exception</span><br><span class="line">        //如果目标方法出现异常，completeTransactionAfterThrowing执行回滚</span><br><span class="line">				completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">				throw ex;</span><br><span class="line">			&#125;</span><br><span class="line">			finally &#123;</span><br><span class="line">				cleanupTransactionInfo(txInfo);</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void completeTransactionAfterThrowing(@Nullable TransactionInfo txInfo, Throwable ex) &#123;</span><br><span class="line">  ......略</span><br><span class="line">        txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());</span><br><span class="line">          ......略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>org.springframework.transaction.support.AbstractPlatformTransactionManager</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final void rollback(TransactionStatus status) throws TransactionException &#123;</span><br><span class="line">  if (status.isCompleted()) &#123;</span><br><span class="line">    throw new IllegalTransactionStateException(</span><br><span class="line">        &quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;</span><br><span class="line">  //处理回滚</span><br><span class="line">  processRollback(defStatus, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void processRollback(DefaultTransactionStatus status, boolean unexpected) &#123;</span><br><span class="line">            ......略</span><br><span class="line">	doRollback(status);</span><br><span class="line">            ......略</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void doRollback(DefaultTransactionStatus status) &#123;</span><br><span class="line">  DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();</span><br><span class="line">  Connection con = txObject.getConnectionHolder().getConnection();</span><br><span class="line">  if (status.isDebug()) &#123;</span><br><span class="line">    logger.debug(&quot;Rolling back JDBC transaction on Connection [&quot; + con + &quot;]&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    //使用数据库连接执行回滚</span><br><span class="line">    con.rollback();</span><br><span class="line">  &#125;</span><br><span class="line">  catch (SQLException ex) &#123;</span><br><span class="line">    throw new TransactionSystemException(&quot;Could not roll back JDBC transaction&quot;, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【本章代码位置：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzExNTY3MjE4NzQvc3ByaW5nLWtlcm5lbC1sZWN0dXJlJUUzJTgwJTkx">https://github.com/1156721874/spring-kernel-lecture】<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>spring_core</category>
      </categories>
      <tags>
        <tag>spring aop transaction</tag>
      </tags>
  </entry>
  <entry>
    <title>spring_boot_cloud(1)微服务宏观把控与深入剖析</title>
    <url>/2019/05/19/spring_boot_and_cloud/spring_boot_cloud(1)%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%8F%E8%A7%82%E6%8A%8A%E6%8E%A7%E4%B8%8E%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<h3 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h3><ul>
<li>Martin Fowler:简而言之，微服务架构风格这种开发方法，是以开发一组小型服务的方式来开发一个独立的应用系统。其中每个小型服务都运行在自己的进程中，并经常采用http资源api这样轻量级的机制来互相通信。这些服务围绕业务功能进行构建，并能通过全量自动的部署机制来进行独立部署。这些微服务可以使用不同的语言来编写，并且可以使用不同的数据存储技术。对于这些微服务我们仅做最低限度的集中管理。<span id="more"></span></li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly9tYXJ0aW5mb3dsZXIuY29tL2FydGljbGVzL21pY3Jvc2VydmljZXMuaHRtbA==">Martin Fowler关于微服务的解读<i class="fa fa-external-link-alt"></i></span><br>此处为了读者理解和阅读，引用二龙湖 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0JsYWRlQ29kZQ==">@Jerry xu<i class="fa fa-external-link-alt"></i></span>对此文的翻译给各位吃瓜群众，<span class="exturl" data-url="aHR0cHM6Ly9pbmNvZGVyLm9yZy8yMDE5LzA2LzAxL21pY3Jvc2VydmljZXMv">【译】• 微服务<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li><p>微服务是一种架构模式，她提倡将单一应用程序划分成一组小的服务，服务之间相互协调、相互配合，为用户提供最终价值。<br>每个服务运行在其独立的进程中，服务于服务间采用轻量级的通信机制相互通信（通常是基于http的restfull api）每个服务都围绕着具体业务构建、并且能够独立的部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中式的服务器管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。</p>
</li>
<li><p>微服务是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成，系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅关注于完成一件任务并很好的完成该任务，在所有情况下，每个任务代表着一个小的业务能力。</p>
</li>
<li><p>微服务的优点</p>
<ul>
<li>易于开发和维护</li>
<li>启动较快</li>
<li>局部修改容易部署</li>
<li>技术栈不受限</li>
<li>按需伸缩</li>
<li>DevOps</li>
</ul>
</li>
<li><p>微服务带来的挑战</p>
<ul>
<li>运维要求较高</li>
<li>分布式的复杂性</li>
<li>接口调整成本高</li>
<li>重复劳动</li>
</ul>
</li>
<li><p>微服务设计原则</p>
<ul>
<li>单一职责原则</li>
<li>服务自治原则</li>
<li>轻量级通信原则</li>
<li>接口明确原则</li>
</ul>
</li>
</ul>
<h3 id="什么是SOA"><a href="#什么是SOA" class="headerlink" title="什么是SOA"></a>什么是SOA</h3><ul>
<li>soa的概念和介绍<br><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2VydmljZS1vcmllbnRlZF9hcmNoaXRlY3R1cmU=">Service-oriented_architecture<i class="fa fa-external-link-alt"></i></span><br>此处为了读者理解和阅读，引用二龙湖 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0JsYWRlQ29kZQ==">@Jerry xu<i class="fa fa-external-link-alt"></i></span>对此文的翻译给各位吃瓜群众，<span class="exturl" data-url="aHR0cHM6Ly9pbmNvZGVyLm9yZy8yMDE5LzA2LzE5L3NvYS8=">【译】• 面向服务的架构<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="SOA和microservices的区别"><a href="#SOA和microservices的区别" class="headerlink" title="SOA和microservices的区别"></a>SOA和microservices的区别</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9ibG9ncy9jbG91ZC1jb21wdXRpbmcvMjAxOC8wOS8wNi9zb2EtdmVyc3VzLW1pY3Jvc2VydmljZXMv">soa-versus-microservices<i class="fa fa-external-link-alt"></i></span><br>这篇文章主要的点时soa是在应用(application)上的架构模式，而微服务是在服务(service)上的架构模式</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kem9uZS5jb20vYXJ0aWNsZXMvbWljcm9zZXJ2aWNlcy12cy1zb2EtaXMtdGhlcmUtYW55LWRpZmZlcmVuY2UtYXQtYWw=">microservices-vs-soa-is-there-any-difference-at-al<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>spring_boot_cloud</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>spring_core(5)注解的注入配置</title>
    <url>/2020/07/16/spring_core/spring_core(5)Annotation-config/</url>
    <content><![CDATA[<p>本节讲解使用注解的方式加载bean到工厂的过程，其流程和使用xml的方式大同小异。</p>
<span id="more"></span>
<h3 id="事例"><a href="#事例" class="headerlink" title="事例"></a>事例</h3><p>定义一个bean：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private  String name;</span><br><span class="line"></span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个bean的配置类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class PersonConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(name=&quot;person&quot;)</span><br><span class="line">    public Person getPerson()&#123;</span><br><span class="line">        Person  person =  new Person();</span><br><span class="line">        person.setId(222);</span><br><span class="line">        person.setName(&quot;kkkk&quot;);</span><br><span class="line">        return person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建一个启动类:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line">public class SpringClient &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //相当于xml方式的工厂，内置了reader和scanner</span><br><span class="line">        AnnotationConfigApplicationContext annotationConfigApplicationContext =</span><br><span class="line">                new AnnotationConfigApplicationContext();</span><br><span class="line">        //相当于xml的读取器要读取的位置</span><br><span class="line">        annotationConfigApplicationContext.register(PersonConfiguration.class);</span><br><span class="line">        //刷新工厂</span><br><span class="line">        annotationConfigApplicationContext.refresh();</span><br><span class="line">        Person person = (Person)annotationConfigApplicationContext.getBean(&quot;person&quot;);</span><br><span class="line">        System.out.println(person.getId());</span><br><span class="line">        System.out.println(person.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br>222<br>kkkk</p>
<h3 id="bean对象创建时机"><a href="#bean对象创建时机" class="headerlink" title="bean对象创建时机"></a>bean对象创建时机</h3><p>AnnotationConfigApplicationContext的构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private final AnnotatedBeanDefinitionReader reader;</span><br><span class="line"></span><br><span class="line">private final ClassPathBeanDefinitionScanner scanner;</span><br><span class="line">public AnnotationConfigApplicationContext() &#123;</span><br><span class="line">  //读取器</span><br><span class="line">  this.reader = new AnnotatedBeanDefinitionReader(this);</span><br><span class="line">  //扫描器</span><br><span class="line">  this.scanner = new ClassPathBeanDefinitionScanner(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AnnotatedBeanDefinitionReader"><a href="#AnnotatedBeanDefinitionReader" class="headerlink" title="AnnotatedBeanDefinitionReader"></a>AnnotatedBeanDefinitionReader</h4><p>AnnotatedBeanDefinitionReader构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">  this(registry, getOrCreateEnvironment(registry));</span><br><span class="line">&#125;</span><br><span class="line">//Environment封装了properties和profile</span><br><span class="line">public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) &#123;</span><br><span class="line">  Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;);</span><br><span class="line">  Assert.notNull(environment, &quot;Environment must not be null&quot;);</span><br><span class="line">  this.registry = registry;</span><br><span class="line">  this.conditionEvaluator = new ConditionEvaluator(registry, environment, null);</span><br><span class="line">  AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>org.springframework.context.annotation.AnnotationConfigUtils完成注解配置处理器的注册过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void registerAnnotationConfigProcessors(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">  registerAnnotationConfigProcessors(registry, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors(</span><br><span class="line">    BeanDefinitionRegistry registry, @Nullable Object source) &#123;</span><br><span class="line">  //得到工厂</span><br><span class="line">  DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">  if (beanFactory != null) &#123;</span><br><span class="line">    if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) &#123;</span><br><span class="line">      beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line">      beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;&gt;(8);</span><br><span class="line">  //各种注册处理器的注册</span><br><span class="line">  if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">    RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);</span><br><span class="line">    def.setSource(source);</span><br><span class="line">    beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">    RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">    def.setSource(source);</span><br><span class="line">    beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span><br><span class="line">  if (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">    RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">    def.setSource(source);</span><br><span class="line">    beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span><br><span class="line">  if (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">    RootBeanDefinition def = new RootBeanDefinition();</span><br><span class="line">    try &#123;</span><br><span class="line">      def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,</span><br><span class="line">          AnnotationConfigUtils.class.getClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ClassNotFoundException ex) &#123;</span><br><span class="line">      throw new IllegalStateException(</span><br><span class="line">          &quot;Cannot load optional framework class: &quot; + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    def.setSource(source);</span><br><span class="line">    beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">    RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);</span><br><span class="line">    def.setSource(source);</span><br><span class="line">    beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;</span><br><span class="line">    RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);</span><br><span class="line">    def.setSource(source);</span><br><span class="line">    beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class="line">  &#125;</span><br><span class="line">  //beanDefs里边有如下5个注解处理器：</span><br><span class="line">  //org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">  //org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">  //org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">  //org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">  //org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">  return beanDefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ClassPathBeanDefinitionScanner"><a href="#ClassPathBeanDefinitionScanner" class="headerlink" title="ClassPathBeanDefinitionScanner"></a>ClassPathBeanDefinitionScanner</h4><p>即，从什么地方去扫描我么注解的类或者方法之类的。<br>ClassPathBeanDefinitionScanner的构造器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">  this(registry, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters) &#123;</span><br><span class="line">  this(registry, useDefaultFilters, getOrCreateEnvironment(registry));</span><br><span class="line">&#125;</span><br><span class="line">public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters,</span><br><span class="line">    Environment environment) &#123;</span><br><span class="line"></span><br><span class="line">  this(registry, useDefaultFilters, environment,</span><br><span class="line">      (registry instanceof ResourceLoader ? (ResourceLoader) registry : null));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters,</span><br><span class="line">    Environment environment, @Nullable ResourceLoader resourceLoader) &#123;</span><br><span class="line"></span><br><span class="line">  Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;);</span><br><span class="line">  this.registry = registry;</span><br><span class="line"></span><br><span class="line">  if (useDefaultFilters) &#123;</span><br><span class="line">    registerDefaultFilters();</span><br><span class="line">  &#125;</span><br><span class="line">  setEnvironment(environment);</span><br><span class="line">  setResourceLoader(resourceLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样也是对环境以及资源加载器的设置。</p>
<h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>接下来回到main函数的【annotationConfigApplicationContext.register(PersonConfiguration.class);】<br>将需要读取的bean，放入到工厂里边，读取入口是PersonConfiguration。<br>org.springframework.context.annotation.AnnotationConfigApplicationContext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//注册一个或多个组件到读取器上，注册完毕之后要调用一下refresh方法</span><br><span class="line">public void register(Class&lt;?&gt;... componentClasses) &#123;</span><br><span class="line">  Assert.notEmpty(componentClasses, &quot;At least one component class must be specified&quot;);</span><br><span class="line">  this.reader.register(componentClasses);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取器的注册方法：<br>org.springframework.context.annotation.AnnotatedBeanDefinitionReader</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void register(Class&lt;?&gt;... componentClasses) &#123;</span><br><span class="line">  for (Class&lt;?&gt; componentClass : componentClasses) &#123;</span><br><span class="line">    registerBean(componentClass);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void registerBean(Class&lt;?&gt; beanClass) &#123;</span><br><span class="line">  doRegisterBean(beanClass, null, null, null, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private &lt;T&gt; void doRegisterBean(Class&lt;T&gt; beanClass, @Nullable String name,</span><br><span class="line">    @Nullable Class&lt;? extends Annotation&gt;[] qualifiers, @Nullable Supplier&lt;T&gt; supplier,</span><br><span class="line">    @Nullable BeanDefinitionCustomizer[] customizers) &#123;</span><br><span class="line">      //bean的定义</span><br><span class="line">  AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(beanClass);</span><br><span class="line">  if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  abd.setInstanceSupplier(supplier);</span><br><span class="line">  ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">  abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">  //生成bean的名字：personConfiguration</span><br><span class="line">  String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));</span><br><span class="line"></span><br><span class="line">  AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">  if (qualifiers != null) &#123;</span><br><span class="line">    for (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">      if (Primary.class == qualifier) &#123;</span><br><span class="line">        abd.setPrimary(true);</span><br><span class="line">      &#125;</span><br><span class="line">      else if (Lazy.class == qualifier) &#123;</span><br><span class="line">        abd.setLazyInit(true);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">        abd.addQualifier(new AutowireCandidateQualifier(qualifier));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (customizers != null) &#123;</span><br><span class="line">    for (BeanDefinitionCustomizer customizer : customizers) &#123;</span><br><span class="line">      customizer.customize(abd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //持有bean定义的持有者，bean的名字，bean的定义，还有bean的别名</span><br><span class="line">  BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);</span><br><span class="line">  definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);</span><br><span class="line">  //执行注册</span><br><span class="line">  BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册逻辑：<br>org.springframework.beans.factory.support.BeanDefinitionReaderUtils</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void registerBeanDefinition(</span><br><span class="line">    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span><br><span class="line">    throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">  // Register bean definition under primary name.</span><br><span class="line">  String beanName = definitionHolder.getBeanName();</span><br><span class="line">  //将bean的名字作为key，bean的定义作为value，注册到工厂，注意BeanDefinitionRegistry就是工厂</span><br><span class="line">  registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">  // Register aliases for bean name, if any.</span><br><span class="line">  String[] aliases = definitionHolder.getAliases();</span><br><span class="line">  if (aliases != null) &#123;</span><br><span class="line">    for (String alias : aliases) &#123;</span><br><span class="line">      registry.registerAlias(beanName, alias);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="refresh刷新"><a href="#refresh刷新" class="headerlink" title="refresh刷新"></a>refresh刷新</h4><p>【annotationConfigApplicationContext.refresh();】的执行会触发PersonConfiguration.getPerson()方法的执行。<br>xml的方式创建bean的时机是在getBean的时候(首次从工厂获取bean的时候)创建，但是注解的方式是在refresh的时候会创建bean的实例，<br>基于注解的配置方式，bean对象的创建是在注解处理器解析相应的@Bean注解时调用了该注解所修饰的方法，当该方法执行后，相应的对象自然就已经被创建出来了，这时，spring就会将该对象纳入到工厂的管理范围之内，当我们首次尝试从工厂获取到该bean对象时，该bean对象实际上已经完成了创建并已经被纳入到工厂的管理范围之内——-<strong>这个是xml的方式和注解的方式的唯一的不同</strong>。</p>
<p>运行程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SpringClient &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //相当于xml方式的工厂，内置了reader和scanner</span><br><span class="line">        AnnotationConfigApplicationContext annotationConfigApplicationContext =</span><br><span class="line">                new AnnotationConfigApplicationContext();</span><br><span class="line">        //相当于xml的读取器</span><br><span class="line">        annotationConfigApplicationContext.register(PersonConfiguration.class);</span><br><span class="line">        //刷新工厂</span><br><span class="line">        annotationConfigApplicationContext.refresh();</span><br><span class="line">        PersonConfiguration personConfiguration = (PersonConfiguration)annotationConfigApplicationContext.getBean(&quot;personConfiguration&quot;);</span><br><span class="line">        Person person = (Person)annotationConfigApplicationContext.getBean(&quot;person&quot;);</span><br><span class="line">        System.out.println(personConfiguration.getClass());</span><br><span class="line">        System.out.println(person.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印：<br>class com.tdl.spring.anotation.PersonConfiguration$$EnhancerBySpringCGLIB$$8455c0b9<br>class com.tdl.spring.anotation.Person<br>由此可以看到得到的personConfiguration是一个PersonConfiguration的子类，是在运行的时候生成的一个子类（代理类），并且将这个子类放在spring的工厂里边。<br>refresh方法实现：<br>org.springframework.context.support.AbstractApplicationContext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//</span><br><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">  synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">    // Prepare this context for refreshing.</span><br><span class="line">      //注册监听器、环境的校验、占位符</span><br><span class="line">    prepareRefresh();</span><br><span class="line"></span><br><span class="line">    // Tell the subclass to refresh the internal bean factory.</span><br><span class="line">    //返回一个bean工厂，DefaultListableBeanFactory(和xml的方式殊途同归)</span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">    // Prepare the bean factory for use in this context.</span><br><span class="line">    //配置上下文、bean的类加载器之类的(appClassLoader),一些处理器等</span><br><span class="line">    prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      // Allows post-processing of the bean factory in context subclasses.</span><br><span class="line">      //bean工厂创建的后置处理器</span><br><span class="line">      postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      // Invoke factory processors registered as beans in the context.</span><br><span class="line">      //自定义bean的BeanDefinationn被注入(但是没有实例化)</span><br><span class="line">      invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">      // Register bean processors that intercept bean creation.</span><br><span class="line">      //bean的后置处理器</span><br><span class="line">      registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">      // Initialize message source for this context.</span><br><span class="line">      //初始化消息源</span><br><span class="line">      initMessageSource();</span><br><span class="line"></span><br><span class="line">      // Initialize event multicaster for this context.</span><br><span class="line">      initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">      // Initialize other special beans in specific context subclasses.</span><br><span class="line">      onRefresh();</span><br><span class="line"></span><br><span class="line">      // Check for listener beans and register them.</span><br><span class="line">      registerListeners();</span><br><span class="line"></span><br><span class="line">      // Instantiate all remaining (non-lazy-init) singletons.</span><br><span class="line">      //bean的实例初始化和创建。对应PersonConfiguration.getPerson()方法会执行</span><br><span class="line">      finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">      // Last step: publish corresponding event.</span><br><span class="line">      finishRefresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    catch (BeansException ex) &#123;</span><br><span class="line">      if (logger.isWarnEnabled()) &#123;</span><br><span class="line">        logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">            &quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Destroy already created singletons to avoid dangling resources.</span><br><span class="line">      destroyBeans();</span><br><span class="line"></span><br><span class="line">      // Reset &#x27;active&#x27; flag.</span><br><span class="line">      cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">      // Propagate exception to caller.</span><br><span class="line">      throw ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    finally &#123;</span><br><span class="line">      // Reset common introspection caches in Spring&#x27;s core, since we</span><br><span class="line">      // might not ever need metadata for singleton beans anymore...</span><br><span class="line">      resetCommonCaches();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">  PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">  // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span><br><span class="line">  // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span><br><span class="line">  if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">    beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//完成bean工厂的初始化，初始化所有的单例的bean</span><br><span class="line">protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">  // Initialize conversion service for this context.</span><br><span class="line">  if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">      beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">    beanFactory.setConversionService(</span><br><span class="line">        beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Register a default embedded value resolver if no bean post-processor</span><br><span class="line">  // (such as a PropertyPlaceholderConfigurer bean) registered any before:</span><br><span class="line">  // at this point, primarily for resolution in annotation attribute values.</span><br><span class="line">  if (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">    beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span><br><span class="line">  String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);</span><br><span class="line">  for (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">    getBean(weaverAwareName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Stop using the temporary ClassLoader for type matching.</span><br><span class="line">  beanFactory.setTempClassLoader(null);</span><br><span class="line"></span><br><span class="line">  // Allow for caching all bean definition metadata, not expecting further changes.</span><br><span class="line">  beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">  // Instantiate all remaining (non-lazy-init) singletons.</span><br><span class="line">  //初始化单例bean</span><br><span class="line">  beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void invokeBeanFactoryPostProcessors(</span><br><span class="line">    ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) &#123;</span><br><span class="line">    ......略</span><br><span class="line">  List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">  BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">  //注册bean定义</span><br><span class="line">	invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">  ......略</span><br><span class="line">&#125;</span><br><span class="line">private static void invokeBeanDefinitionRegistryPostProcessors(</span><br><span class="line">    Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry) &#123;</span><br><span class="line"></span><br><span class="line">  for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">    postProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">    ......略</span><br><span class="line">  processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">  List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;();</span><br><span class="line">  String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">  for (String beanName : candidateNames) &#123;</span><br><span class="line">    //registry是DefaultListableBeanFactory，其持有</span><br><span class="line">    //【	private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);】</span><br><span class="line">    //用来存放bean的定义</span><br><span class="line">    BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line">    if (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) &#123;</span><br><span class="line">      if (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(&quot;Bean definition has already been processed as a configuration class: &quot; + beanDef);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) &#123;</span><br><span class="line">      configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">      ......略</span><br><span class="line">  //读取被@Bean修饰的方法代表的Bean，加载bean的定义</span><br><span class="line">  /*</span><br><span class="line">  *for (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;</span><br><span class="line">  *  loadBeanDefinitionsForBeanMethod(beanMethod);</span><br><span class="line">  *&#125;  </span><br><span class="line">  this.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">    ......略</span><br></pre></td></tr></table></figure>
<p>preInstantiateSingletons的实现：<br>org.springframework.beans.factory.support.DefaultListableBeanFactory</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void preInstantiateSingletons() throws BeansException &#123;</span><br><span class="line">  if (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(&quot;Pre-instantiating singletons in &quot; + this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Iterate over a copy to allow for init methods which in turn register new bean definitions.</span><br><span class="line">  // While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span><br><span class="line">  List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">  // Trigger initialization of all non-lazy singleton beans...</span><br><span class="line">  //beanNames：</span><br><span class="line">  //0 = &quot;org.springframework.context.annotation.internalConfigurationAnnotationProcessor&quot;</span><br><span class="line">  //1 = &quot;org.springframework.context.annotation.internalAutowiredAnnotationProcessor&quot;</span><br><span class="line">  //2 = &quot;org.springframework.context.annotation.internalCommonAnnotationProcessor&quot;</span><br><span class="line">  //3 = &quot;org.springframework.context.event.internalEventListenerProcessor&quot;</span><br><span class="line">  //4 = &quot;org.springframework.context.event.internalEventListenerFactory&quot;</span><br><span class="line">  //5 = &quot;personConfiguration&quot;</span><br><span class="line">  //6 = &quot;person&quot;</span><br><span class="line">  for (String beanName : beanNames) &#123;</span><br><span class="line">    //bean的元数据信息</span><br><span class="line">    RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">      //是不是一个工厂bean</span><br><span class="line">      if (isFactoryBean(beanName)) &#123;</span><br><span class="line">        //getBean和xml的方式的实现是一样的。</span><br><span class="line">        Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">        if (bean instanceof FactoryBean) &#123;</span><br><span class="line">          final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">          boolean isEagerInit;</span><br><span class="line">          if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;</span><br><span class="line">            isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">                    ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                getAccessControlContext());</span><br><span class="line">          &#125;</span><br><span class="line">          else &#123;</span><br><span class="line">            isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;</span><br><span class="line">                ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">          &#125;</span><br><span class="line">          if (isEagerInit) &#123;</span><br><span class="line">            getBean(beanName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">        getBean(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">......略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终注解的方式也是使用工厂来获取bean的实例，单例的也会缓存到工厂里边。</p>
<h4 id="bean的创建和缓存流程"><a href="#bean的创建和缓存流程" class="headerlink" title="bean的创建和缓存流程"></a>bean的创建和缓存流程</h4><p>接上次的代码位置。进入getBean方法。<br>和xml的方式一样，只不过获取bean的流程进行到如下的分支(得到beanWraper)的时候出现了区别：<br>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) &#123;</span><br><span class="line">  // Make sure bean class is actually resolved at this point.</span><br><span class="line">  Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">  if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">    throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">        &quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot; + beanClass.getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">  if (instanceSupplier != null) &#123;</span><br><span class="line">    return obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">  &#125;</span><br><span class="line">  //注解定义的时候会进入这个分支</span><br><span class="line">  if (mbd.getFactoryMethodName() != null) &#123;</span><br><span class="line">    //使用工厂方法(PersonConfiguration.getPerson)</span><br><span class="line">    return instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">  &#125;</span><br><span class="line">  ......略</span><br><span class="line">&#125;</span><br><span class="line">//使用工厂方法实例化bean</span><br><span class="line">protected BeanWrapper instantiateUsingFactoryMethod(</span><br><span class="line">    String beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs) &#123;</span><br><span class="line"></span><br><span class="line">  return new ConstructorResolver(this).instantiateUsingFactoryMethod(beanName, mbd, explicitArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>org.springframework.beans.factory.support.ConstructorResolver实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public BeanWrapper instantiateUsingFactoryMethod(</span><br><span class="line">    String beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs) &#123;</span><br><span class="line">      //bean的包装器</span><br><span class="line">      BeanWrapperImpl bw = new BeanWrapperImpl();</span><br><span class="line">  		this.beanFactory.initBeanWrapper(bw);</span><br><span class="line"></span><br><span class="line">  		Object factoryBean;</span><br><span class="line">  		Class&lt;?&gt; factoryClass;</span><br><span class="line">  		boolean isStatic;</span><br><span class="line">      //bean的工厂的名字(personConfiguration)</span><br><span class="line">  		String factoryBeanName = mbd.getFactoryBeanName();</span><br><span class="line">      //设置bean的实例</span><br><span class="line">      bw.setBeanInstance(instantiate(beanName, mbd, factoryBean, uniqueCandidate, EMPTY_ARGS));</span><br><span class="line">      .....略</span><br><span class="line">&#125;</span><br><span class="line">//instantiate实现，即创建bean实例</span><br><span class="line">private Object instantiate(String beanName, RootBeanDefinition mbd,</span><br><span class="line">    @Nullable Object factoryBean, Method factoryMethod, Object[] args) &#123;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    if (System.getSecurityManager() != null) &#123;</span><br><span class="line">      return AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;</span><br><span class="line">          this.beanFactory.getInstantiationStrategy().instantiate(</span><br><span class="line">              mbd, beanName, this.beanFactory, factoryBean, factoryMethod, args),</span><br><span class="line">          this.beanFactory.getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      //使用工厂的创建实例的策略创建bean</span><br><span class="line">      return this.beanFactory.getInstantiationStrategy().instantiate(</span><br><span class="line">          mbd, beanName, this.beanFactory, factoryBean, factoryMethod, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  catch (Throwable ex) &#123;</span><br><span class="line">    throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">        &quot;Bean instantiation via factory method failed&quot;, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>this.beanFactory.getInstantiationStrategy().instantiate的实现是<br>org.springframework.beans.factory.support.SimpleInstantiationStrategy：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//使用反射获取bean的实例</span><br><span class="line">public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,</span><br><span class="line">			@Nullable Object factoryBean, final Method factoryMethod, Object... args) &#123;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			if (System.getSecurityManager() != null) &#123;</span><br><span class="line">				AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">					ReflectionUtils.makeAccessible(factoryMethod);</span><br><span class="line">					return null;</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				ReflectionUtils.makeAccessible(factoryMethod);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Method priorInvokedFactoryMethod = currentlyInvokedFactoryMethod.get();</span><br><span class="line">			try &#123;</span><br><span class="line">				currentlyInvokedFactoryMethod.set(factoryMethod);</span><br><span class="line">        //factoryMethod: getPerson,</span><br><span class="line">        //factoryBean: com.tdl.spring.anotation.PersonConfiguration$$EnhancerBySpringCGLIB$$8455c0b9,</span><br><span class="line">        //args: getPerson方法的参数</span><br><span class="line">				Object result = factoryMethod.invoke(factoryBean, args);</span><br><span class="line">				if (result == null) &#123;</span><br><span class="line">					result = new NullBean();</span><br><span class="line">				&#125;</span><br><span class="line">				return result;</span><br><span class="line">			&#125;</span><br><span class="line">			finally &#123;</span><br><span class="line">				if (priorInvokedFactoryMethod != null) &#123;</span><br><span class="line">					currentlyInvokedFactoryMethod.set(priorInvokedFactoryMethod);</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					currentlyInvokedFactoryMethod.remove();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (IllegalArgumentException ex) &#123;</span><br><span class="line">			throw new BeanInstantiationException(factoryMethod,</span><br><span class="line">					&quot;Illegal arguments to factory method &#x27;&quot; + factoryMethod.getName() + &quot;&#x27;; &quot; +</span><br><span class="line">					&quot;args: &quot; + StringUtils.arrayToCommaDelimitedString(args), ex);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (IllegalAccessException ex) &#123;</span><br><span class="line">			throw new BeanInstantiationException(factoryMethod,</span><br><span class="line">					&quot;Cannot access factory method &#x27;&quot; + factoryMethod.getName() + &quot;&#x27;; is it public?&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (InvocationTargetException ex) &#123;</span><br><span class="line">			String msg = &quot;Factory method &#x27;&quot; + factoryMethod.getName() + &quot;&#x27; threw exception&quot;;</span><br><span class="line">			if (bd.getFactoryBeanName() != null &amp;&amp; owner instanceof ConfigurableBeanFactory &amp;&amp;</span><br><span class="line">					((ConfigurableBeanFactory) owner).isCurrentlyInCreation(bd.getFactoryBeanName())) &#123;</span><br><span class="line">				msg = &quot;Circular reference involving containing bean &#x27;&quot; + bd.getFactoryBeanName() + &quot;&#x27; - consider &quot; +</span><br><span class="line">						&quot;declaring the factory method as static for independence from its containing instance. &quot; + msg;</span><br><span class="line">			&#125;</span><br><span class="line">			throw new BeanInstantiationException(factoryMethod, msg, ex.getTargetException());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>PersonConfiguration会被当做getPerson的工厂。<br>【本章代码位置：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzExNTY3MjE4NzQvc3ByaW5nLWtlcm5lbC1sZWN0dXJlJUUzJTgwJTkx">https://github.com/1156721874/spring-kernel-lecture】<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>spring_core</category>
      </categories>
      <tags>
        <tag>spring annotation</tag>
      </tags>
  </entry>
  <entry>
    <title>spring_boot_cloud(10)Apache-Kafka相关介绍</title>
    <url>/2019/07/28/spring_boot_and_cloud/spring_boot_cloud(10)Apache-Kafka%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>本片不对kafak原理做过多解释，只是介绍一下kafka和spring boot耦合的方式。</p>
<span id="more"></span>
<h3 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h3><p>在gradle依赖配置当中引入以下依赖:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;org.springframework.kafka:spring-kafka&quot;,</span><br><span class="line">&quot;com.google.code.gson:gson:2.8.5&quot;</span><br></pre></td></tr></table></figure>

<h3 id="编写生产者"><a href="#编写生产者" class="headerlink" title="编写生产者"></a>编写生产者</h3><p>生产者代码第一要使用<code>@Component</code>注册到spring容器当中:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class KafkaProducer &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private KafkaTemplate&lt;String,String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    public void sendKafkaMessage(KafkaMessage kafkaMessage)&#123;</span><br><span class="line">        this.kafkaTemplate.send(&quot;myTopic&quot;, new Gson().toJson(kafkaMessage));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写消费者"><a href="#编写消费者" class="headerlink" title="编写消费者"></a>编写消费者</h3><p>和生产者一样，消费者也需要注册到spring 容器当中,并且要用<code>KafkaListener</code>表示监听的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class KafkaConsumer &#123;</span><br><span class="line"></span><br><span class="line">    @KafkaListener(topics = &quot;myTopic&quot;,groupId = &quot;myGroup&quot;)</span><br><span class="line">    public void obtainMessage(ConsumerRecord&lt;String, String&gt; consumerRecord)&#123;</span><br><span class="line">        System.out.println(&quot;ontainMessage invoked!&quot;);</span><br><span class="line">        String topic =consumerRecord.topic();</span><br><span class="line">        String key = consumerRecord.key();</span><br><span class="line">        String value = consumerRecord.value();</span><br><span class="line">        int partition = consumerRecord.partition();</span><br><span class="line">        long timeStamp = consumerRecord.timestamp();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;topic: &quot; + topic);</span><br><span class="line">        System.out.println(&quot;key: &quot; + key);</span><br><span class="line">        System.out.println(&quot;value: &quot; + value);</span><br><span class="line">        System.out.println(&quot;partition: &quot; + partition);</span><br><span class="line">        System.out.println(&quot;timeStamp: &quot; + timeStamp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="kafka配置信息"><a href="#kafka配置信息" class="headerlink" title="kafka配置信息"></a>kafka配置信息</h3><p>在application.yml文件当中配置相应的broker地址、序列化方式等信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kafka:</span><br><span class="line">  producer:</span><br><span class="line">    bootstrap-servers: localhost:9092</span><br><span class="line">    key-serializer: org.apache.kafka.common.serialization.StringSerializer</span><br><span class="line">    value-serializer: org.apache.kafka.common.serialization.StringSerializer</span><br><span class="line">  consumer:</span><br><span class="line">    bootstrap-servers: localhost:9092</span><br><span class="line">    key-deserializer: org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="line">    value-deserializer: org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="对外提供webapi"><a href="#对外提供webapi" class="headerlink" title="对外提供webapi"></a>对外提供webapi</h3><p>新建一个controller，实现在web端发送消息的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(value = &quot;/kafka&quot;, produces =  MediaType.APPLICATION_JSON_UTF8_VALUE)</span><br><span class="line">public class KafkaController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private KafkaProducer kafkaProducer;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;message&quot;, method = RequestMethod.GET)</span><br><span class="line">    public KafkaMessage sendKafkaMessages(@RequestParam(name = &quot;id&quot;) long id,</span><br><span class="line">                                          @RequestParam(name = &quot;username&quot;) String username,</span><br><span class="line">                                          @RequestParam(name = &quot;password&quot;) String password)&#123;</span><br><span class="line">        System.out.println(&quot;send kafka message invoked!&quot;);</span><br><span class="line">        KafkaMessage kafkaMessage = new KafkaMessage();</span><br><span class="line">        kafkaMessage.setId(id);;</span><br><span class="line">        kafkaMessage.setUsername(username);</span><br><span class="line">        kafkaMessage.setPasseord(password);</span><br><span class="line">        kafkaMessage.setDate(new Date());</span><br><span class="line">        kafkaProducer.sendKafkaMessage(kafkaMessage);</span><br><span class="line">        return kafkaMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;sendMessage2&quot;, method = RequestMethod.POST)</span><br><span class="line">    public KafkaMessage sendMessage2(@RequestBody KafkaMessage kafkaMessage)&#123;</span><br><span class="line">        System.out.println(&quot;send kafka message2 invoked!&quot;);</span><br><span class="line">        kafkaMessage.setDate(new Date());</span><br><span class="line">        this.kafkaProducer.sendKafkaMessage(kafkaMessage);</span><br><span class="line">        return kafkaMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>spring_boot_cloud</category>
      </categories>
      <tags>
        <tag>Apache Kafka SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>spring_boot_cloud(11)Spring_Boot对于Spring_MVC的整合原理深度解析</title>
    <url>/2019/08/10/spring_boot_and_cloud/spring_boot_cloud(11)Spring_Boot%E5%AF%B9%E4%BA%8ESpring_MVC%E7%9A%84%E6%95%B4%E5%90%88%E5%8E%9F%E7%90%86%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>现在我们使用spring boot搭建的工程和之前spring mvc的方式有一个很大的不同点就是：web.xml已经不需要配置，而之前的spring mvc需要配置web.xml，在里边配置DsipatcherServlet，spring boot之所以不需要这个配置是一位servlet的升级，之前用的是servlet2.5的标准，现在boot的方式是servlet3.0，而servlet3.0允许以spi的方式去实现servlet的初始化。</p>
<span id="more"></span>

<h3 id="ServletContainerInitializer"><a href="#ServletContainerInitializer" class="headerlink" title="ServletContainerInitializer"></a>ServletContainerInitializer</h3><p>我们打开我们项目依赖的jar包：<br><img src="/servletContainerInitializer.png" alt="servletContainerInitializer.png"><br>这个文件里边 只有一个类：<br>org.springframework.web.SpringServletContainerInitializer<br>它实现了ServletContainerInitializer，看一下ServletContainerInitializer的doc：</p>
<p>ServletContainerInitializer是通过META-INF&#x2F;service&#x2F;javax.servlet.ServletConotainerInitializer注册的，它的实现必须包含在一个jar文件中。<br>ServletContainerInitializer可以通过javax.servlet.annotation.handlesTypes注解来注册感兴趣的注解，比如class,method,field等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface ServletContainerInitializer &#123;</span><br><span class="line">    void onStartup(Set&lt;Class&lt;?&gt;&gt; var1, ServletContext var2) throws ServletException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>onStartup方法有一个参数ServletContext，即上下文，web应用启动的时候会收到一些通知，onStartup得到调用，通知来源就是javax.servlet.annotation.handlesTypes标记的。</p>
<h3 id="SpringServletContainerInitializer"><a href="#SpringServletContainerInitializer" class="headerlink" title="SpringServletContainerInitializer"></a>SpringServletContainerInitializer</h3><p> ServletContainerInitializer是一个Servlet 3.0的，他的设计目的是基于代码servlet容器的配置。而且会使用到WebApplicationInitializer SPI 搭配使用支撑web.xml的实现方式。</p>
<p>这个类会被加载和实例化，它的onStartup方法会被任意一个servlet3.0兼容的容器(比如tomcat)在启动的时候被调用，并且假设spring-web的jar包出现在classpath下边。 这个过程发生在通过jar包服务api ServiceLoader.load(Class) 方法探测spring-web模块的META-INF&#x2F;services&#x2F;javax.servlet.ServletContainerInitializer服务提供配置文件。</p>
<h4 id="与web-xml搭配使用"><a href="#与web-xml搭配使用" class="headerlink" title="与web.xml搭配使用"></a>与web.xml搭配使用</h4><p>一个应用在启动的时候可以选择限制classpath扫描的servlet容器的数量，或者通过 web.xml当中的 metadata-complete 属性，它会控制servlet注解的扫描机制，或者通过web.xml中的<absolute-ordering> 标签，它会控制那些web片段允许去被执行ServletContainerInitializer的扫描，当使用在这种特性的时候，SpringServletContainerInitializer可以添加”spring_web”到web.xml的片段列表里边去，形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;absolute-ordering&gt;</span><br><span class="line">  &lt;name&gt;some_web_fragment&lt;/name&gt;</span><br><span class="line">  &lt;name&gt;spring_web&lt;/name&gt;</span><br><span class="line">&lt;/absolute-ordering&gt;</span><br></pre></td></tr></table></figure>
<h4 id="与WebApplicationInitializer的关系"><a href="#与WebApplicationInitializer的关系" class="headerlink" title="与WebApplicationInitializer的关系"></a>与WebApplicationInitializer的关系</h4><p>WebApplicationInitializer是一个spi，只有一个方法WebApplicationInitializer.onStartup(ServletContext).这个签名和 ServletContainerInitializer.onStartup(Set, ServletContext)很像，简单来说SpringServletContainerInitializer负责实例化和将ServletContext委托给任何WebApplicationInitializer的实现，接下来是由WebApplicationInitializer接管，完成ServletContext的初始化，具体的委托处理过程描述在onStartup的doc里面。</p>
<p>SpringServletContainerInitializer应该被看成是一种支撑的基础设施，目的是为了更加重要的用户面对的WebApplicationInitializer的spi所服务的，使用这个容器的初始化器是可选的，如果WebApplicationInitializer的实现没有出现在classpath下面，容器的初始化器不不会受到影响的。<br>WebApplicationInitializer并没有绑定到spring mvc上边，任何的servlet，filter，listener都可以使用WebApplicationInitializer注册，并不仅仅针对于spring mvc。</p>
<p>用户不用去使用SpringServletContainerInitializer，用户应该去使用WebApplicationInitializer的具体实现。</p>
<h4 id="SpringServletContainerInitializer的onStartup方法"><a href="#SpringServletContainerInitializer的onStartup方法" class="headerlink" title="SpringServletContainerInitializer的onStartup方法"></a>SpringServletContainerInitializer的onStartup方法</h4><p>将ServletContext委托任何一个WebApplicationInitializer的实现，这个实现要以jar包的形式出现在classpath里边。<br>由于这个类声明了 @HandlesTypes(WebApplicationInitializer.class)这个注解，servlet3.0容器会自动扫描WebApplicationInitializer接口的实现，并且把所有实现类组成的set集合作为onStartup方法的webAppInitializerClasses参数。<br>如果在classpath里边没有WebApplicationInitializer的实现，这个方法相当于什么都不做，系统只是打印日志，提示SpringServletContainerInitializer被调用了，但是并没有找到WebApplicationInitializer的实现，假设有多个WebApplicationInitializer实现被检测到，他们都会被实例化，如果加上<code>@Order</code>直接还会被排序，接下来每个实例的 WebApplicationInitializer.onStartup(ServletContext)方法都会被调用，将ServletContext进行委托，这样每一个实例都会被注册，比如说 Spring的 DispatcherServlet。监听器，比如ContextLoaderListener，或者其他servlet 挨批，比如过滤器之类的，等等。</p>
<h4 id="HandlesTypes注解"><a href="#HandlesTypes注解" class="headerlink" title="@HandlesTypes注解"></a>@HandlesTypes注解</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface HandlesTypes &#123;</span><br><span class="line">    Class&lt;?&gt;[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringServletContainerInitializer类上声明了@HandlesTypes注解，@HandlesTypes注解的class是WebApplicationInitializer，那么在SpringServletContainerInitializer的onStartup方法的webAppInitializerClasses参数就是从classpath扫描出来的WebApplicationInitializer实现的集合。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@HandlesTypes(WebApplicationInitializer.class)</span><br><span class="line">public class SpringServletContainerInitializer implements ServletContainerInitializer &#123;</span><br><span class="line"></span><br><span class="line">  public void onStartup(@Nullable Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)</span><br><span class="line">			throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">		List&lt;WebApplicationInitializer&gt; initializers = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		if (webAppInitializerClasses != null) &#123;</span><br><span class="line">			for (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123;</span><br><span class="line">				// Be defensive: Some servlet containers provide us with invalid classes,</span><br><span class="line">				// no matter what @HandlesTypes says...</span><br><span class="line">        //首先不是接口，不是抽象类，并且实现了WebApplicationInitializer接口</span><br><span class="line">				if (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;</span><br><span class="line">						WebApplicationInitializer.class.isAssignableFrom(waiClass)) &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">            //使用反射实例化，加入到initializers集合</span><br><span class="line">						initializers.add((WebApplicationInitializer)</span><br><span class="line">								ReflectionUtils.accessibleConstructor(waiClass).newInstance());</span><br><span class="line">					&#125;</span><br><span class="line">					catch (Throwable ex) &#123;</span><br><span class="line">						throw new ServletException(&quot;Failed to instantiate WebApplicationInitializer class&quot;, ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    //如果在classpath下没有找到任何WebApplicationInitializer的实现，打印info日志。</span><br><span class="line">		if (initializers.isEmpty()) &#123;</span><br><span class="line">			servletContext.log(&quot;No Spring WebApplicationInitializer types detected on classpath&quot;);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		servletContext.log(initializers.size() + &quot; Spring WebApplicationInitializers detected on classpath&quot;);</span><br><span class="line">    //排序</span><br><span class="line">		AnnotationAwareOrderComparator.sort(initializers);</span><br><span class="line">    //将servlet上下文servletContext委托给每一个WebApplicationInitializer的实现。</span><br><span class="line">		for (WebApplicationInitializer initializer : initializers) &#123;</span><br><span class="line">			initializer.onStartup(servletContext);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>spring_boot_cloud</category>
      </categories>
      <tags>
        <tag>springmvc SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>spring_boot_cloud(12)Spring_Boot集成内嵌服务器原理揭秘</title>
    <url>/2019/11/10/spring_boot_and_cloud/spring_boot_cloud(12)Spring_Boot%E9%9B%86%E6%88%90%E5%86%85%E5%B5%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8E%9F%E7%90%86%E6%8F%AD%E7%A7%98/</url>
    <content><![CDATA[<h3 id="断点SpringServletContainerInitializer"><a href="#断点SpringServletContainerInitializer" class="headerlink" title="断点SpringServletContainerInitializer"></a>断点SpringServletContainerInitializer</h3><p>我们在SpringServletContainerInitializer的onStartup方法里边加一个断点，然后debug应用，让我们感到奇怪的是断点并不会进入到onStartup方法，那么我们看一下顶层接口ServletContainerInitializer的实现类有哪些：</p>
<span id="more"></span>
<p><img src="/ServletContainerInitializer.png" alt="ServletContainerInitializer.png"><br>会看到有TomcatStarter和还有我们的SpringServletContainerInitializer，这里不会进入断点的原因是如果我们是以jar包或者main方法的方式启动应用的时候会使用springboot内嵌的tomcat容器，如果我们使用传统的spring mvc或者war包的方式那么SpringServletContainerInitializer就会初始化，如果我们现在在TomcatStarter的onStartup方法加一个断点，那么断点一定会进入。</p>
<h4 id="传统的Spring-mvc的容器初始化过程；"><a href="#传统的Spring-mvc的容器初始化过程；" class="headerlink" title="传统的Spring mvc的容器初始化过程；"></a>传统的Spring mvc的容器初始化过程；</h4><ol>
<li>通过SpringServletContainerInitializer来负责对容器启动时的相关组件的初始化。</li>
<li>到底要初始化那些组件则是通过Servlet规范中所提供的注解HandlesTypes来指定的。</li>
<li>在SpringServletContainerInitializer中，其HandlesTypes注解则明确指定为了WebApplicationInitializer.class类型。</li>
<li>在SpringServletContainerInitializer的onStartup方法中，这主要完成了一些验证与组件装配的工作。</li>
<li>在SpringServletContainerInitializer的onStartup方法中，由于某些容器并未遵循servlet规范，导致虽然明确指定了HandlesTypes注解的类型为WebApplicationInitializer.class类型，但还是可能会存在将一些非法类型传递过来的情况；所以，该方法还对传递进来的具体类型进行了细致的判断，只有符合条件的类型才会被纳入到List<WebApplicationInitializer>集合中。</li>
<li>当以上判断完成以后，List<WebApplicationInitializer>就是接下来要进行初始化的组件了。</li>
<li>最后，通过遍历List<WebApplicationInitializer>列表，取出其中的每一个WebApplicationInitializer对象，调用这些对象的onStartup方法，完成组件的启动初始化工作。</li>
</ol>
<p>总结一下：<br>SpringServletContainerInitializer在整个初始过程中，其扮演的角色实际上是委托或是代理的角色，真正完成初始化工作的依旧是一个个WebApplicationInitializer实现类。</p>
<h4 id="现代的Spring-Boot应用的容器初始化过程："><a href="#现代的Spring-Boot应用的容器初始化过程：" class="headerlink" title="现代的Spring Boot应用的容器初始化过程："></a>现代的Spring Boot应用的容器初始化过程：</h4><ol>
<li>对于Spring Boot应用来说，他并未使用SpringServletContainerInitializer来进行容器的初始化，而是使用了TomcatStarter进行的。</li>
<li>TomcatStarter存在三点因素使得它无法通过SPI机制进行初始化，它没有不带参数的构造方法；它的声明并非public；其所在jar包并没有META-INF.services目录，当然也就不存在javax.servlet.ServletContainerInitializer的文件了。</li>
<li>综上，TomcaStarter并非通过SPI机制进行的查找与实例化。</li>
<li>本质上，TomcatStarter是通过Spring Boot框架new出来的。</li>
<li>与SpringServletContainerInitializer类似，TomcatStarter在容器的初始化过程中扮演着一个委托或是代理的角色，真正执行的初始化动作实际上是由所持有的ServletContextInitializer的onStartup方法来完成。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class TomcatStarter implements ServletContainerInitializer &#123;</span><br><span class="line"></span><br><span class="line">	private static final Log logger = LogFactory.getLog(TomcatStarter.class);</span><br><span class="line"></span><br><span class="line">	private final ServletContextInitializer[] initializers;</span><br><span class="line"></span><br><span class="line">	private volatile Exception startUpException;</span><br><span class="line"></span><br><span class="line">	TomcatStarter(ServletContextInitializer[] initializers) &#123;</span><br><span class="line">		this.initializers = initializers;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void onStartup(Set&lt;Class&lt;?&gt;&gt; classes, ServletContext servletContext)</span><br><span class="line">			throws ServletException &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			for (ServletContextInitializer initializer : this.initializers) &#123;</span><br><span class="line">				initializer.onStartup(servletContext);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Exception ex) &#123;</span><br><span class="line">			this.startUpException = ex;</span><br><span class="line">			// Prevent Tomcat from logging and re-throwing when we know we can</span><br><span class="line">			// deal with it in the main thread, but log for information here.</span><br><span class="line">			if (logger.isErrorEnabled()) &#123;</span><br><span class="line">				logger.error(&quot;Error starting Tomcat context. Exception: &quot;</span><br><span class="line">						+ ex.getClass().getName() + &quot;. Message: &quot; + ex.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Exception getStartUpException() &#123;</span><br><span class="line">		return this.startUpException;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TomcatStarter是ServletContainerInitializer的实现，并且记录ServletContextInitializer初始过程中的错误。<br>我们看一下ServletContextInitializer的doc:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface ServletContextInitializer &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Configure the given &#123;@link ServletContext&#125; with any servlets, filters, listeners</span><br><span class="line">	 * context-params and attributes necessary for initialization.</span><br><span class="line">	 * @param servletContext the &#123;@code ServletContext&#125; to initialize</span><br><span class="line">	 * @throws ServletException if any call against the given &#123;@code ServletContext&#125;</span><br><span class="line">	 * throws a &#123;@code ServletException&#125;</span><br><span class="line">	 */</span><br><span class="line">	void onStartup(ServletContext servletContext) throws ServletException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Interface used to configure a Servlet 3.0+ context programmatically. Unlike WebApplicationInitializer, classes that implement this interface (and do not implement WebApplicationInitializer) will not be detected by SpringServletContainerInitializer and hence will not be automatically bootstrapped by the Servlet container.<br>This interface is primarily designed to allow ServletContextInitializers to be managed by Spring and not the Servlet container.<br>For configuration examples see WebApplicationInitializer.</p>
<p>这是一个接口，以编程的方式配置Servlet 3.0+的上下文，与WebApplicationInitializer不同的是，实现了这是一个接口，以编程的方式配置Servlet 3.0+的上下文，与WebApplicationInitializer不同的是，实现了ServletContextInitializer接口的类（没有实现WebApplicationInitializer）将不会被SpringServletContainerInitializer检测到，因此它不会被servlet容器自动的进行启动。<br>这个接口的主要的设计目的是允许ServletContextInitializers被spring管理，而不是Servlet容器管理。</p>
<h3 id="Servlet-3-0-的一些重要特性："><a href="#Servlet-3-0-的一些重要特性：" class="headerlink" title="Servlet 3.0 的一些重要特性："></a>Servlet 3.0 的一些重要特性：</h3><p>ServletRegistration:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface ServletRegistration extends Registration &#123;</span><br><span class="line">    Set&lt;String&gt; addMapping(String... var1);</span><br><span class="line"></span><br><span class="line">    Collection&lt;String&gt; getMappings();</span><br><span class="line"></span><br><span class="line">    String getRunAsRole();</span><br><span class="line"></span><br><span class="line">    public interface Dynamic extends ServletRegistration, javax.servlet.Registration.Dynamic &#123;</span><br><span class="line">        void setLoadOnStartup(int var1);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; setServletSecurity(ServletSecurityElement var1);</span><br><span class="line"></span><br><span class="line">        void setMultipartConfig(MultipartConfigElement var1);</span><br><span class="line"></span><br><span class="line">        void setRunAsRole(String var1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ServletContext:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface ServletContext &#123;</span><br><span class="line">    String TEMPDIR = &quot;javax.servlet.context.tempdir&quot;;</span><br><span class="line">    String ORDERED_LIBS = &quot;javax.servlet.context.orderedLibs&quot;;</span><br><span class="line"></span><br><span class="line">    String getContextPath();</span><br><span class="line"></span><br><span class="line">    ServletContext getContext(String var1);</span><br><span class="line"></span><br><span class="line">    int getMajorVersion();</span><br><span class="line"></span><br><span class="line">    int getMinorVersion();</span><br><span class="line"></span><br><span class="line">    int getEffectiveMajorVersion();</span><br><span class="line"></span><br><span class="line">    int getEffectiveMinorVersion();</span><br><span class="line"></span><br><span class="line">    String getMimeType(String var1);</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; getResourcePaths(String var1);</span><br><span class="line"></span><br><span class="line">    URL getResource(String var1) throws MalformedURLException;</span><br><span class="line"></span><br><span class="line">    InputStream getResourceAsStream(String var1);</span><br><span class="line"></span><br><span class="line">    RequestDispatcher getRequestDispatcher(String var1);</span><br><span class="line"></span><br><span class="line">    RequestDispatcher getNamedDispatcher(String var1);</span><br><span class="line"></span><br><span class="line">    /** @deprecated */</span><br><span class="line">    @Deprecated</span><br><span class="line">    Servlet getServlet(String var1) throws ServletException;</span><br><span class="line"></span><br><span class="line">    /** @deprecated */</span><br><span class="line">    @Deprecated</span><br><span class="line">    Enumeration&lt;Servlet&gt; getServlets();</span><br><span class="line"></span><br><span class="line">    /** @deprecated */</span><br><span class="line">    @Deprecated</span><br><span class="line">    Enumeration&lt;String&gt; getServletNames();</span><br><span class="line"></span><br><span class="line">    void log(String var1);</span><br><span class="line"></span><br><span class="line">    /** @deprecated */</span><br><span class="line">    @Deprecated</span><br><span class="line">    void log(Exception var1, String var2);</span><br><span class="line"></span><br><span class="line">    void log(String var1, Throwable var2);</span><br><span class="line"></span><br><span class="line">    String getRealPath(String var1);</span><br><span class="line"></span><br><span class="line">    String getServerInfo();</span><br><span class="line"></span><br><span class="line">    String getInitParameter(String var1);</span><br><span class="line"></span><br><span class="line">    Enumeration&lt;String&gt; getInitParameterNames();</span><br><span class="line"></span><br><span class="line">    boolean setInitParameter(String var1, String var2);</span><br><span class="line"></span><br><span class="line">    Object getAttribute(String var1);</span><br><span class="line"></span><br><span class="line">    Enumeration&lt;String&gt; getAttributeNames();</span><br><span class="line"></span><br><span class="line">    void setAttribute(String var1, Object var2);</span><br><span class="line"></span><br><span class="line">    void removeAttribute(String var1);</span><br><span class="line"></span><br><span class="line">    String getServletContextName();</span><br><span class="line"></span><br><span class="line">    Dynamic addServlet(String var1, String var2);</span><br><span class="line"></span><br><span class="line">    Dynamic addServlet(String var1, Servlet var2);</span><br><span class="line"></span><br><span class="line">    Dynamic addServlet(String var1, Class&lt;? extends Servlet&gt; var2);</span><br><span class="line"></span><br><span class="line">    Dynamic addJspFile(String var1, String var2);</span><br><span class="line"></span><br><span class="line">    &lt;T extends Servlet&gt; T createServlet(Class&lt;T&gt; var1) throws ServletException;</span><br><span class="line"></span><br><span class="line">    ServletRegistration getServletRegistration(String var1);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, ? extends ServletRegistration&gt; getServletRegistrations();</span><br><span class="line"></span><br><span class="line">    javax.servlet.FilterRegistration.Dynamic addFilter(String var1, String var2);</span><br><span class="line"></span><br><span class="line">    javax.servlet.FilterRegistration.Dynamic addFilter(String var1, Filter var2);</span><br><span class="line"></span><br><span class="line">    javax.servlet.FilterRegistration.Dynamic addFilter(String var1, Class&lt;? extends Filter&gt; var2);</span><br><span class="line"></span><br><span class="line">    &lt;T extends Filter&gt; T createFilter(Class&lt;T&gt; var1) throws ServletException;</span><br><span class="line"></span><br><span class="line">    FilterRegistration getFilterRegistration(String var1);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, ? extends FilterRegistration&gt; getFilterRegistrations();</span><br><span class="line"></span><br><span class="line">    SessionCookieConfig getSessionCookieConfig();</span><br><span class="line"></span><br><span class="line">    void setSessionTrackingModes(Set&lt;SessionTrackingMode&gt; var1);</span><br><span class="line"></span><br><span class="line">    Set&lt;SessionTrackingMode&gt; getDefaultSessionTrackingModes();</span><br><span class="line"></span><br><span class="line">    Set&lt;SessionTrackingMode&gt; getEffectiveSessionTrackingModes();</span><br><span class="line"></span><br><span class="line">    void addListener(String var1);</span><br><span class="line"></span><br><span class="line">    &lt;T extends EventListener&gt; void addListener(T var1);</span><br><span class="line"></span><br><span class="line">    void addListener(Class&lt;? extends EventListener&gt; var1);</span><br><span class="line"></span><br><span class="line">    &lt;T extends EventListener&gt; T createListener(Class&lt;T&gt; var1) throws ServletException;</span><br><span class="line"></span><br><span class="line">    JspConfigDescriptor getJspConfigDescriptor();</span><br><span class="line"></span><br><span class="line">    ClassLoader getClassLoader();</span><br><span class="line"></span><br><span class="line">    void declareRoles(String... var1);</span><br><span class="line"></span><br><span class="line">    String getVirtualServerName();</span><br><span class="line"></span><br><span class="line">    int getSessionTimeout();</span><br><span class="line"></span><br><span class="line">    void setSessionTimeout(int var1);</span><br><span class="line"></span><br><span class="line">    String getRequestCharacterEncoding();</span><br><span class="line"></span><br><span class="line">    void setRequestCharacterEncoding(String var1);</span><br><span class="line"></span><br><span class="line">    String getResponseCharacterEncoding();</span><br><span class="line"></span><br><span class="line">    void setResponseCharacterEncoding(String var1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Servlet 3.0可以使用注解的方式增加filter、Servlet等，可以使用编程式的api，也可以使用web.xml的方式。</p>
<ol>
<li>ServletRegistration.Dynamic servlet &#x3D; servletContext.addServlet(MyServlet.class..getSimpleName(),MuServlet.class);<br> servlet.addMapping(“&#x2F;myServlet”);</li>
</ol>
<h3 id="WebApplicationInitializer与ServletContextInitializer的关系详解"><a href="#WebApplicationInitializer与ServletContextInitializer的关系详解" class="headerlink" title="WebApplicationInitializer与ServletContextInitializer的关系详解"></a>WebApplicationInitializer与ServletContextInitializer的关系详解</h3><p>WebApplicationInitializer接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface WebApplicationInitializer &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Configure the given &#123;@link ServletContext&#125; with any servlets, filters, listeners</span><br><span class="line">	 * context-params and attributes necessary for initializing this web application. See</span><br><span class="line">	 * examples &#123;@linkplain WebApplicationInitializer above&#125;.</span><br><span class="line">	 * @param servletContext the &#123;@code ServletContext&#125; to initialize</span><br><span class="line">	 * @throws ServletException if any call against the given &#123;@code ServletContext&#125;</span><br><span class="line">	 * throws a &#123;@code ServletException&#125;</span><br><span class="line">	 */</span><br><span class="line">	void onStartup(ServletContext servletContext) throws ServletException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先看一下WebApplicationInitializer的doc：</p>
<p>Interface to be implemented in Servlet 3.0+ environments in order to configure the ServletContext programmatically – as opposed to (or possibly in conjunction with) the traditional web.xml-based approach.<br>Implementations of this SPI will be detected automatically by SpringServletContainerInitializer, which itself is bootstrapped automatically by any Servlet 3.0 container. See its Javadoc for details on this bootstrapping mechanism.</p>
<h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><h5 id="The-traditional-XML-based-approach"><a href="#The-traditional-XML-based-approach" class="headerlink" title="The traditional, XML-based approach"></a>The traditional, XML-based approach</h5><p>Most Spring users building a web application will need to register Spring’s DispatcherServlet. For reference, in WEB-INF&#x2F;web.xml, this would typically be done as follows:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">  &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;</span><br><span class="line">  &lt;servlet-class&gt;</span><br><span class="line">    org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">  &lt;/servlet-class&gt;</span><br><span class="line">  &lt;init-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">    &lt;param-value&gt;/WEB-INF/spring/dispatcher-config.xml&lt;/param-value&gt;</span><br><span class="line">  &lt;/init-param&gt;</span><br><span class="line">  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">  &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<h5 id="The-code-based-approach-with-WebApplicationInitializer"><a href="#The-code-based-approach-with-WebApplicationInitializer" class="headerlink" title="The code-based approach with WebApplicationInitializer"></a>The code-based approach with WebApplicationInitializer</h5><p>Here is the equivalent DispatcherServlet registration logic, WebApplicationInitializer-style:<br>   public class MyWebAppInitializer implements WebApplicationInitializer {</p>
<pre><code>  @Override
  public void onStartup(ServletContext container) &#123;
    XmlWebApplicationContext appContext = new XmlWebApplicationContext();
    appContext.setConfigLocation(&quot;/WEB-INF/spring/dispatcher-config.xml&quot;);

    ServletRegistration.Dynamic dispatcher =
      container.addServlet(&quot;dispatcher&quot;, new DispatcherServlet(appContext));
    dispatcher.setLoadOnStartup(1);
    dispatcher.addMapping(&quot;/&quot;);
  &#125;
</code></pre>
<p>   }<br>As an alternative to the above, you can also extend from org.springframework.web.servlet.support.AbstractDispatcherServletInitializer. As you can see, thanks to Servlet 3.0’s new ServletContext.addServlet method we’re actually registering an instance of the DispatcherServlet, and this means that the DispatcherServlet can now be treated like any other object – receiving constructor injection of its application context in this case.<br>This style is both simpler and more concise. There is no concern for dealing with init-params, etc, just normal JavaBean-style properties and constructor arguments. You are free to create and work with your Spring application contexts as necessary before injecting them into the DispatcherServlet.<br>Most major Spring Web components have been updated to support this style of registration. You’ll find that DispatcherServlet, FrameworkServlet, ContextLoaderListener and DelegatingFilterProxy all now support constructor arguments. Even if a component (e.g. non-Spring, other third party) has not been specifically updated for use within WebApplicationInitializers, they still may be used in any case. The Servlet 3.0 ServletContext API allows for setting init-params, context-params, etc programmatically.</p>
<h5 id="A-100-code-based-approach-to-configuration"><a href="#A-100-code-based-approach-to-configuration" class="headerlink" title="A 100% code-based approach to configuration"></a>A 100% code-based approach to configuration</h5><p>In the example above, WEB-INF&#x2F;web.xml was successfully replaced with code in the form of a WebApplicationInitializer, but the actual dispatcher-config.xml Spring configuration remained XML-based. WebApplicationInitializer is a perfect fit for use with Spring’s code-based @Configuration classes. See @Configuration Javadoc for complete details, but the following example demonstrates refactoring to use Spring’s AnnotationConfigWebApplicationContext in lieu of XmlWebApplicationContext, and user-defined @Configuration classes AppConfig and DispatcherConfig instead of Spring XML files. This example also goes a bit beyond those above to demonstrate typical configuration of the ‘root’ application context and registration of the ContextLoaderListener:<br>   public class MyWebAppInitializer implements WebApplicationInitializer {</p>
<pre><code>  @Override
  public void onStartup(ServletContext container) &#123;
    // Create the &#39;root&#39; Spring application context
    AnnotationConfigWebApplicationContext rootContext =
      new AnnotationConfigWebApplicationContext();
    rootContext.register(AppConfig.class);

    // Manage the lifecycle of the root application context
    container.addListener(new ContextLoaderListener(rootContext));

    // Create the dispatcher servlet&#39;s Spring application context
    AnnotationConfigWebApplicationContext dispatcherContext =
      new AnnotationConfigWebApplicationContext();
    dispatcherContext.register(DispatcherConfig.class);

    // Register and map the dispatcher servlet
    ServletRegistration.Dynamic dispatcher =
      container.addServlet(&quot;dispatcher&quot;, new DispatcherServlet(dispatcherContext));
    dispatcher.setLoadOnStartup(1);
    dispatcher.addMapping(&quot;/&quot;);
  &#125;
</code></pre>
<p>   }<br>As an alternative to the above, you can also extend from org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer. Remember that WebApplicationInitializer implementations are detected automatically – so you are free to package them within your application as you see fit.</p>
<p>这是一个在servlet3.0+环境下实现的一个接口，用来以编程的方式配置ServletContext，这种方式是和传统的web.xml相反的，或者也是可以和传统的方式搭配使用的。</p>
<p>这个SPI的实现可以被SpringServletContainerInitializer自动的探测到，SpringServletContainerInitializer本身又是可以被servlet3.0容器启动的。详细可以看文档。</p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><h5 id="传统的web-xml方式是怎么做的"><a href="#传统的web-xml方式是怎么做的" class="headerlink" title="传统的web.xml方式是怎么做的"></a>传统的web.xml方式是怎么做的</h5><p>大多数的用户构建一个web应用将需要注册一个spring的DispatcherServlet，下面列出了一个引用，是一个经典的web.xml的使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">	&lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;</span><br><span class="line">	&lt;servlet-class&gt;</span><br><span class="line">		org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">	&lt;/servlet-class&gt;</span><br><span class="line">	&lt;init-param&gt;</span><br><span class="line">		&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">		&lt;param-value&gt;/WEB-INF/spring/dispatcher-config.xml&lt;/param-value&gt;</span><br><span class="line">	&lt;/init-param&gt;</span><br><span class="line">	&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">	&lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;</span><br><span class="line">	&lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<h5 id="基于WebApplicationInitializer使用编程式"><a href="#基于WebApplicationInitializer使用编程式" class="headerlink" title="基于WebApplicationInitializer使用编程式"></a>基于WebApplicationInitializer使用编程式</h5><p>下面是一个和web.xml等价的写法来注册DispatcherServlet的逻辑，WebApplicationInitializer的风格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyWebAppInitializer implements WebApplicationInitializer &#123;</span><br><span class="line"></span><br><span class="line">	 @Override</span><br><span class="line">	 public void onStartup(ServletContext container) &#123;</span><br><span class="line">		 XmlWebApplicationContext appContext = new XmlWebApplicationContext();</span><br><span class="line">		 appContext.setConfigLocation(&quot;/WEB-INF/spring/dispatcher-config.xml&quot;);</span><br><span class="line"></span><br><span class="line">		 ServletRegistration.Dynamic dispatcher =</span><br><span class="line">			 container.addServlet(&quot;dispatcher&quot;, new DispatcherServlet(appContext));</span><br><span class="line">		 dispatcher.setLoadOnStartup(1);</span><br><span class="line">		 dispatcher.addMapping(&quot;/&quot;);</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为上述实现方式的另外一种实现手段，你也可以继承org.springframework.web.servlet.support.AbstractDispatcherServletInitializer:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractDispatcherServletInitializer extends AbstractContextLoaderInitializer &#123;</span><br><span class="line">	---- 略 ----</span><br><span class="line">	@Override</span><br><span class="line">	public void onStartup(ServletContext servletContext) throws ServletException &#123;</span><br><span class="line">		super.onStartup(servletContext);</span><br><span class="line">		registerDispatcherServlet(servletContext);</span><br><span class="line">	&#125;</span><br><span class="line">	protected void registerDispatcherServlet(ServletContext servletContext) &#123;</span><br><span class="line">		String servletName = getServletName();</span><br><span class="line">		Assert.hasLength(servletName, &quot;getServletName() must not return null or empty&quot;);</span><br><span class="line"></span><br><span class="line">		WebApplicationContext servletAppContext = createServletApplicationContext();</span><br><span class="line">		Assert.notNull(servletAppContext, &quot;createServletApplicationContext() must not return null&quot;);</span><br><span class="line"></span><br><span class="line">		FrameworkServlet dispatcherServlet = createDispatcherServlet(servletAppContext);</span><br><span class="line">		Assert.notNull(dispatcherServlet, &quot;createDispatcherServlet(WebApplicationContext) must not return null&quot;);</span><br><span class="line">		dispatcherServlet.setContextInitializers(getServletApplicationContextInitializers());</span><br><span class="line">		// 设置到servletContext</span><br><span class="line">		ServletRegistration.Dynamic registration = servletContext.addServlet(servletName, dispatcherServlet);</span><br><span class="line">		if (registration == null) &#123;</span><br><span class="line">			throw new IllegalStateException(&quot;Failed to register servlet with name &#x27;&quot; + servletName + &quot;&#x27;. &quot; +</span><br><span class="line">					&quot;Check if there is another servlet registered under the same name.&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		//设置启动顺序</span><br><span class="line">		registration.setLoadOnStartup(1);</span><br><span class="line">		//设置映射</span><br><span class="line">		registration.addMapping(getServletMappings());</span><br><span class="line">		registration.setAsyncSupported(isAsyncSupported());</span><br><span class="line">		// 过滤器设置</span><br><span class="line">		Filter[] filters = getServletFilters();</span><br><span class="line">		if (!ObjectUtils.isEmpty(filters)) &#123;</span><br><span class="line">			for (Filter filter : filters) &#123;</span><br><span class="line">				registerServletFilter(servletContext, filter);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		customizeRegistration(registration);</span><br><span class="line"> &#125;</span><br><span class="line">	---- 略 ----</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是servlet3.0+使用编程式api配置dispatcherServlet。<br>记住WebApplicationInitializer的所有实现都可以被自动探测到。<br>Ordering WebApplicationInitializer execution<br>WebApplicationInitializer implementations may optionally be annotated at the class level with Spring’s @Order annotation or may implement Spring’s Ordered interface. If so, the initializers will be ordered prior to invocation. This provides a mechanism for users to ensure the order in which servlet container initialization occurs. Use of this feature is expected to be rare, as typical applications will likely centralize all container initialization within a single WebApplicationInitializer.<br>WebApplicationInitializer执行的排序，WebApplicationInitializer可以被@Order注解在class级别进行标注，也可以实现spring的排序接口，如果是这样，初始化器在调用之前会进行一个排序，略。。。</p>
<p>Caveats<br>警告<br>web.xml versioning<br>web.xml 的版本化<br>WEB-INF&#x2F;web.xml and WebApplicationInitializer use are not mutually exclusive; for example, web.xml can register one servlet, and a WebApplicationInitializer can register another. An initializer can even modify registrations performed in web.xml through methods such as ServletContext.getServletRegistration(String). However, if WEB-INF&#x2F;web.xml is present in the application, its version attribute must be set to “3.0” or greater, otherwise ServletContainerInitializer bootstrapping will be ignored by the servlet container.<br>Mapping to ‘&#x2F;‘ under Tomcat<br>Apache Tomcat maps its internal DefaultServlet to “&#x2F;“, and on Tomcat versions &lt;&#x3D; 7.0.14, this servlet mapping cannot be overridden programmatically. 7.0.15 fixes this issue. Overriding the “&#x2F;“ servlet mapping has also been tested successfully under GlassFish 3.1.<br>WEB-INF&#x2F;web.xml和WebApplicationInitializer在使用上并不是互斥的，比如说web.xml 可以注册为一个servlet，WebApplicationInitializer也可以注册另外一个servlet，初始化器甚至可以通过ServletContext.getServletRegistration(String)方法修改在web.xml当中的注册，当然如果web.xml在应用中出现，那么其版本的属性应该设置成3.0或者更大，否则ServletContainerInitializer的启动将会被servlet容器忽略掉。<br>略。。。</p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>以往的web.xml到了3.0可以使用WebApplicationInitializer的方式替换，而WebApplicationInitializer使用的是spi的机制，可以被自动探测到，并且去执行；对于dispatcherServlet是一个非常重要的组件，所以spring干脆就提供了一个AbstractDispatcherServletInitializer抽象类以及它的实现类AbstractAnnotationConfigDispatcherServletInitializer帮助我们更为轻松的实例化dispatcherServlet。<br>关于传统的spring mvc和现代的spring boot应用组件之间的对应关系：</p>
<ol>
<li>SpringServletContainerInitializer对应TomcatStarter；<br> SpringServletContainerInitializer是通过spi机制，使用servlet 容器加载；TomcatStarter是spring容器new出来的。</li>
<li>WebApplicationInitializer对应TomcatStarter里边的ServletContextInitializer；</li>
</ol>
<h4 id="为什么TomcatStarter不使用SpringServletContainerInitializer的方式加载？"><a href="#为什么TomcatStarter不使用SpringServletContainerInitializer的方式加载？" class="headerlink" title="为什么TomcatStarter不使用SpringServletContainerInitializer的方式加载？"></a>为什么TomcatStarter不使用SpringServletContainerInitializer的方式加载？</h4><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NwcmluZy1wcm9qZWN0cy9zcHJpbmctYm9vdC9pc3N1ZXMvMzIx">https://github.com/spring-projects/spring-boot/issues/321<i class="fa fa-external-link-alt"></i></span><br>简而言之，当我们使用WAR包的时候，会有javax.servlet.ServletContainerInitializer自动加载，而当我们使用spring boot搞成jar包的时候，javax.servlet.ServletContainerInitializer的方式就不会生效，所以spring做了一个SpringServletContainerInitializer用来支持jar的方式运行app的支持。</p>
<p>当使用spring boot时，我们所编写的Servlet、Filter、Listener都是如何被检测的，加载和执行的呢？</p>
<ol>
<li>使用Servlet3.0+的注解，配合@ServletComponentScan。<br>定义一个Servlet class：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@WebServlet(&quot;myServlet&quot;)</span><br><span class="line">public class MyServlet extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;MyServlet Invoked&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在启动类上加上@ServletComponentScan：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@ServletComponentScan</span><br><span class="line">public class MyApplication  &#123;</span><br><span class="line">    private static  final Logger logger = LoggerFactory.getLogger(MyApplication.class);</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
@ServletComponentScan 说明：<br>Enables scanning for Servlet components (filters, servlets, and listeners). Scanning is only performed when using an embedded web server.<br>Typically, one of value, basePackages, or basePackageClasses should be specified to control the packages to be scanned for components. In their absence, scanning will be performed from the package of the class with the annotation.<br>能够扫描Servlet组件（filters、servlets、listeners）。扫描只对嵌入式的web 服务器作起用。<br>一般来说需要指定basePackages，basePackageClasses中的一个用来控制可以被扫描到组件的package。<br>如果没有指定，那么就会从使用@ServletComponentScan注解的类所在的包开始扫描。</li>
<li>使用RegistrationBean（在spring boot内部得到了大量的应用）<br>定义Servlet：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyServlet2 extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;MyServlet2 Invoked&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
定义Filter：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        System.out.println(&quot;MyFilter Invoked&quot;);</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意在之前版本的servlet里边，Filter的三个方法init、doFilter、destroy都是必须要实现的，但是到了jdk1.8的时候提供了default method，我们可以不用强制去实现init和destroy，因为这两个方法变成default method了。<br>定义配置类ServletRegistrationConfig：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ServletRegistrationConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public ServletRegistrationBean  myServletRegistrationBean()&#123;</span><br><span class="line">        ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean();</span><br><span class="line">        servletRegistrationBean.addUrlMappings(&quot;/myServlet2&quot;);</span><br><span class="line">        servletRegistrationBean.setServlet(new MyServlet2());</span><br><span class="line">        return servletRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">		@Bean</span><br><span class="line">		public FilterRegistrationBean myFilterRegistrationBean()&#123;</span><br><span class="line">				FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();</span><br><span class="line">				filterRegistrationBean.addUrlPatterns(&quot;/mServlet/*&quot;);</span><br><span class="line">				filterRegistrationBean.setFilter(new MyFilter());</span><br><span class="line">				return  filterRegistrationBean;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
以下ServletRegistrationBean和FilterRegistrationBean的继承结构，<br><img src="/ServletRegistrationBean.png" alt="ServletRegistrationBean.png"><br><img src="/FilterRegistrationBean.png" alt="FilterRegistrationBean.png"><br>找到最后的入口还是ServletContextInitializer，而ServletContextInitializer是内嵌服务的初始化入口。</li>
</ol>
<h4 id="TomcatStarter启动过程"><a href="#TomcatStarter启动过程" class="headerlink" title="TomcatStarter启动过程"></a>TomcatStarter启动过程</h4><p>首先我们在TomcatStarter的onStartup方法里边的for循环打一个断点：<br><img src="/tomcatStarter.png" alt="tomcatStarter.png"><br>可以看到TomcatStarter的成员变量initializers里边有三个元素，那么这三个元素是在什么时候初始化的呢？<br>然后在【initializer.onStartup(servletContext);】f7进入到onStartup的实现类里边，这个时候会进入到AbstractServletWebServerFactory的mergeInitializers方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final ServletContextInitializer[] mergeInitializers(</span><br><span class="line">		ServletContextInitializer... initializers) &#123;</span><br><span class="line">	List&lt;ServletContextInitializer&gt; mergedInitializers = new ArrayList&lt;&gt;();</span><br><span class="line">	// 这个lambda表达式就是代表一个ServletContextInitializer</span><br><span class="line">	mergedInitializers.add((servletContext) -&gt; this.initParameters.forEach(servletContext::setInitParameter));</span><br><span class="line">	mergedInitializers.add(new SessionConfiguringInitializer(this.session));</span><br><span class="line">	mergedInitializers.addAll(Arrays.asList(initializers));</span><br><span class="line">	mergedInitializers.addAll(this.initializers);</span><br><span class="line">	return mergedInitializers.toArray(new ServletContextInitializer[0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/tomcatStarter1.png" alt="tomcatStarter1.png"><br>此时mergedInitializers的三个元素和TomcatStarter里边的三个元素是一样的，那么我们就可以猜想TomcatStarter的成员变量initializers是由AbstractServletWebServerFactory初始化的，我们看一下AbstractServletWebServerFactory的层次结构，AbstractServletWebServerFactory看名字是抽象的web服务器工厂，就是生产web 服务的：<br><img src="/AbstractServletWebServerFactory.png" alt="AbstractServletWebServerFactory.png"><br>AbstractServletWebServerFactory下边有三个实现类，其中有一个是TomcatServletWebServerFactory，我们在TomcatServletWebServerFactory搜索TomcatStarter，找到了configureContext方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void configureContext(Context context,ServletContextInitializer[] initializers) &#123;</span><br><span class="line">	TomcatStarter starter = new TomcatStarter(initializers);</span><br><span class="line">	if (context instanceof TomcatEmbeddedContext) &#123;</span><br><span class="line">		TomcatEmbeddedContext embeddedContext = (TomcatEmbeddedContext) context;</span><br><span class="line">		embeddedContext.setStarter(starter);</span><br><span class="line">		embeddedContext.setFailCtxIfServletStartFails(true);</span><br><span class="line">	&#125;</span><br><span class="line">	context.addServletContainerInitializer(starter, NO_CLASSES);</span><br><span class="line">	for (LifecycleListener lifecycleListener : this.contextLifecycleListeners) &#123;</span><br><span class="line">		context.addLifecycleListener(lifecycleListener);</span><br><span class="line">	&#125;</span><br><span class="line">	for (Valve valve : this.contextValves) &#123;</span><br><span class="line">		context.getPipeline().addValve(valve);</span><br><span class="line">	&#125;</span><br><span class="line">	for (ErrorPage errorPage : getErrorPages()) &#123;</span><br><span class="line">		new TomcatErrorPage(errorPage).addToContext(context);</span><br><span class="line">	&#125;</span><br><span class="line">	for (MimeMappings.Mapping mapping : getMimeMappings()) &#123;</span><br><span class="line">		context.addMimeMapping(mapping.getExtension(), mapping.getMimeType());</span><br><span class="line">	&#125;</span><br><span class="line">	configureSession(context);</span><br><span class="line">	new DisableReferenceClearingContextCustomizer().customize(context);</span><br><span class="line">	for (TomcatContextCustomizer customizer : this.tomcatContextCustomizers) &#123;</span><br><span class="line">		customizer.customize(context);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>configureContext会被prepareContext方法调用，在prepareContext里边会首先调用mergeInitializers，提前完成初始化TomactStarter里边需要的的ServletContextInitializer[]数组，上边提到的。<br>在这个方法里边，，调用了【	TomcatStarter starter &#x3D; new TomcatStarter(initializers);】构造了TomcatStarter。<br><img src="/TomcatStarterPackage.png" alt="TomcatStarterPackage.png"><br>TomcatStarter没有使用public的原因就是因为TomcatStarter和TomcatServletWebServerFactory属于同一个package，不需要修饰为public，他不希望TomcatStarter被其他的包的类去使用，这是一种保护设计。</p>
]]></content>
      <categories>
        <category>spring_boot_cloud</category>
      </categories>
      <tags>
        <tag>tomcat SpringBoot 容器</tag>
      </tags>
  </entry>
  <entry>
    <title>spring_boot_cloud(14)Condition条件注解</title>
    <url>/2020/05/16/spring_boot_and_cloud/spring_boot_cloud(14)Condition%E6%9D%A1%E4%BB%B6%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>A single condition that must be matched in order for a component to be registered.<br>用来标示一个组件是否可以被注册。</p>
<span id="more"></span>
<h4 id="Conditional"><a href="#Conditional" class="headerlink" title="Conditional"></a>Conditional</h4><p>Condition和Conditional成对出现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Conditional &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * All &#123;@link Condition Conditions&#125; that must &#123;@linkplain Condition#matches match&#125;</span><br><span class="line">	 * in order for the component to be registered.</span><br><span class="line">	 */</span><br><span class="line">   //所有Condition都匹配才可以被注册进来</span><br><span class="line">	Class&lt;? extends Condition&gt;[] value();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>我们在application.yml里边添加一个配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">person:</span><br><span class="line">  address:</span><br><span class="line">    city: dalian</span><br><span class="line">````</span><br><span class="line">创建一个实现了Condition的类：</span><br></pre></td></tr></table></figure>
<p>public class TestCondition implements Condition {<br>    @Override<br>    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {<br>        String city &#x3D; context.getEnvironment().getProperty(“person.address.city”);<br>        if(“tianjin”.equals(city)){<br>            return true;<br>        }<br>        return false;<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果城市是天津就返回true，表示加载。</span><br><span class="line">接着创建一个Config:</span><br></pre></td></tr></table></figure>
<p>@Configuration<br>public class TestConditionConfig {</p>
<pre><code>//Conditional的参数TestCondition规定了是否可以加载这个bean，中间会调TestCondition的matches方法
@Bean
@Conditional(TestCondition.class)
public String getConfig()&#123;
    return &quot;hello&quot;;
&#125;

//没有配置Conditional条件加载
@Bean
public String getConfig2()&#123;
    return &quot;world&quot;;
&#125;


@Bean
@Conditional(TestCondition.class)
public String getConfig3()&#123;
    return &quot;welcome&quot;;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">最后在MyApplication里边启动测试：</span><br></pre></td></tr></table></figure>
<p>@SpringBootApplication<br>public class MyApplication {<br>  private static  final Logger logger &#x3D; LoggerFactory.getLogger(MyApplication.class);<br>  public static void main(String[] args) {<br>    ConfigurableApplicationContext configurableApplicationContext &#x3D;  SpringApplication.run(MyApplication.class,args);<br>    String [] names &#x3D;  configurableApplicationContext.getBeanNamesForType(String.class);<br>    System.out.println(names);<br>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出：</span><br><span class="line">[getConfig2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">因为我们配置的大连，所以getConfig和getConfig3不会被加载。</span><br><span class="line"></span><br><span class="line">修改application.yml为:</span><br></pre></td></tr></table></figure>
<p>person:<br>  address:<br>    city: dalian<br>  name:<br>    firstNamme: zhangsan</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建新的Condition：</span><br></pre></td></tr></table></figure>
<p>public class TestCondition2 implements Condition {<br>    @Override<br>    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {<br>        String city &#x3D; context.getEnvironment().getProperty(“person.name.firstNamme”);<br>        if (“lisi”.equals(city)) {<br>            return true;<br>        }<br>        return false;<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改TestConditionConfig的getConfig3</span><br></pre></td></tr></table></figure>
<p>@Bean<br>@Conditional({TestCondition.class, TestCondition2.class})<br>public String getConfig3(){<br>    return “welcome”;<br>}</p>
<pre><code>运行MyApplication输出：
[getConfig, getConfig2]

#### 小结
Conditional要求Conditional.value()返回的值都返回true，才会加载。

#### Conditional在spring框架内部的使用
ConditionalOnBean Bean存在的条件加载
ConditionalOnClass Class存在的条件加载
ConditionalOnCloudPlatform
ConditionalOnExpression
ConditionalOnJava
ConditionalOnJndi
ConditionalOnMissingBean  当Bean不存在的条件加载
ConditionalOnMissingClass 当Class不存在的条件加载
ConditionalOnNotWebApplication
ConditionalOnProperty
ConditionalOnResource
ConditionalOnSingleCandidate
ConditionalOnWebApplication
ConditionEvaluationReport

这些注解实现了springboot的按需加载。
</code></pre>
]]></content>
      <categories>
        <category>spring_boot_cloud</category>
      </categories>
      <tags>
        <tag>Condition</tag>
      </tags>
  </entry>
  <entry>
    <title>spring_boot_cloud(15)eureka架构剖析与服务注册详解</title>
    <url>/2020/05/16/spring_boot_and_cloud/spring_boot_cloud(15)eureka%E6%9E%B6%E6%9E%84%E5%89%96%E6%9E%90%E4%B8%8E%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="eureka架构"><a href="#eureka架构" class="headerlink" title="eureka架构"></a>eureka架构</h3><p><img src="/eureka-construct.png" alt="eureka-construct.png"></p>
<h3 id="DiscoveryClient"><a href="#DiscoveryClient" class="headerlink" title="DiscoveryClient"></a>DiscoveryClient</h3><p>The class that is instrumental for interactions with Eureka Server.<br>Eureka Client is responsible for a) Registering the instance with Eureka Server b) Renewalof the lease with Eureka Server c) Cancellation of the lease from Eureka Server during shutdown<br>d) Querying the list of services&#x2F;instances registered with Eureka Server<br>DiscoveryClient是和Eureka服务通信的类的实现<br>a)注册到Eureka server<br>b)租约，续约<br>c)服务下线<br>d)拉取服务列表</p>
<span id="more"></span>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>DiscoveryClient的主要方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Initializes all scheduled tasks.</span><br><span class="line"> * 初始化所有的调度任务</span><br><span class="line"> */</span><br><span class="line">private void initScheduledTasks() &#123;</span><br><span class="line">  //返回true拉取所有的信息</span><br><span class="line">    if (clientConfig.shouldFetchRegistry()) &#123;</span><br><span class="line">        // registry cache refresh timer</span><br><span class="line">        int registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();</span><br><span class="line">        int expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();</span><br><span class="line">        //启动定时服务</span><br><span class="line">        cacheRefreshTask = new TimedSupervisorTask(</span><br><span class="line">                &quot;cacheRefresh&quot;,</span><br><span class="line">                scheduler,</span><br><span class="line">                cacheRefreshExecutor,</span><br><span class="line">                registryFetchIntervalSeconds,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                expBackOffBound,</span><br><span class="line">                new CacheRefreshThread()</span><br><span class="line">        );</span><br><span class="line">        scheduler.schedule(</span><br><span class="line">                cacheRefreshTask,</span><br><span class="line">                registryFetchIntervalSeconds, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    //需要注册到Eureka server</span><br><span class="line">    if (clientConfig.shouldRegisterWithEureka()) &#123;</span><br><span class="line">        int renewalIntervalInSecs = instanceInfo.getLeaseInfo().getRenewalIntervalInSecs();</span><br><span class="line">        int expBackOffBound = clientConfig.getHeartbeatExecutorExponentialBackOffBound();</span><br><span class="line">        logger.info(&quot;Starting heartbeat executor: &quot; + &quot;renew interval is: &#123;&#125;&quot;, renewalIntervalInSecs);</span><br><span class="line"></span><br><span class="line">        // Heartbeat timer</span><br><span class="line">        heartbeatTask = new TimedSupervisorTask(</span><br><span class="line">                &quot;heartbeat&quot;,</span><br><span class="line">                scheduler,</span><br><span class="line">                heartbeatExecutor,</span><br><span class="line">                renewalIntervalInSecs,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                expBackOffBound,</span><br><span class="line">                new HeartbeatThread()</span><br><span class="line">        );</span><br><span class="line">        scheduler.schedule(</span><br><span class="line">                heartbeatTask,</span><br><span class="line">                renewalIntervalInSecs, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        // InstanceInfo replicator</span><br><span class="line">        instanceInfoReplicator = new InstanceInfoReplicator(</span><br><span class="line">                this,</span><br><span class="line">                instanceInfo,</span><br><span class="line">                clientConfig.getInstanceInfoReplicationIntervalSeconds(),</span><br><span class="line">                2); // burstSize</span><br><span class="line"></span><br><span class="line">        statusChangeListener = new ApplicationInfoManager.StatusChangeListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String getId() &#123;</span><br><span class="line">                return &quot;statusChangeListener&quot;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void notify(StatusChangeEvent statusChangeEvent) &#123;</span><br><span class="line">                if (InstanceStatus.DOWN == statusChangeEvent.getStatus() ||</span><br><span class="line">                        InstanceStatus.DOWN == statusChangeEvent.getPreviousStatus()) &#123;</span><br><span class="line">                    // log at warn level if DOWN was involved</span><br><span class="line">                    logger.warn(&quot;Saw local status change event &#123;&#125;&quot;, statusChangeEvent);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    logger.info(&quot;Saw local status change event &#123;&#125;&quot;, statusChangeEvent);</span><br><span class="line">                &#125;</span><br><span class="line">                instanceInfoReplicator.onDemandUpdate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        if (clientConfig.shouldOnDemandUpdateStatusChange()) &#123;</span><br><span class="line">            applicationInfoManager.registerStatusChangeListener(statusChangeListener);</span><br><span class="line">        &#125;</span><br><span class="line">        // 主要的注册实现在 instanceInfoReplicator的run方法里边实现的</span><br><span class="line">        instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        logger.info(&quot;Not registering with Eureka server per configuration&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 注册</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>instanceInfoReplicator的run方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        discoveryClient.refreshInstanceInfo();</span><br><span class="line"></span><br><span class="line">        Long dirtyTimestamp = instanceInfo.isDirtyWithTime();</span><br><span class="line">        if (dirtyTimestamp != null) &#123;</span><br><span class="line">          // 注册的核心实现</span><br><span class="line">            discoveryClient.register();</span><br><span class="line">            instanceInfo.unsetIsDirty(dirtyTimestamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        logger.warn(&quot;There was a problem with the instance info replicator&quot;, t);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Future next = scheduler.schedule(this, replicationIntervalSeconds, TimeUnit.SECONDS);</span><br><span class="line">        scheduledPeriodicRef.set(next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>discoveryClient.register()的实现:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Register with the eureka service by making the appropriate REST call.</span><br><span class="line"> */</span><br><span class="line">boolean register() throws Throwable &#123;</span><br><span class="line">    logger.info(PREFIX + &quot;&#123;&#125;: registering service...&quot;, appPathIdentifier);</span><br><span class="line">    EurekaHttpResponse&lt;Void&gt; httpResponse;</span><br><span class="line">    try &#123;</span><br><span class="line">      //使用http的方式去注册</span><br><span class="line">        httpResponse = eurekaTransport.registrationClient.register(instanceInfo);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        logger.warn(PREFIX + &quot;&#123;&#125; - registration failed &#123;&#125;&quot;, appPathIdentifier, e.getMessage(), e);</span><br><span class="line">        throw e;</span><br><span class="line">    &#125;</span><br><span class="line">    if (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(PREFIX + &quot;&#123;&#125; - registration status: &#123;&#125;&quot;, appPathIdentifier, httpResponse.getStatusCode());</span><br><span class="line">    &#125;</span><br><span class="line">    return httpResponse.getStatusCode() == Status.NO_CONTENT.getStatusCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>eurekaTransport.registrationClient.register的实现:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public EurekaHttpResponse&lt;Void&gt; register(InstanceInfo info) &#123;</span><br><span class="line">  String urlPath = serviceUrl + &quot;apps/&quot; + info.getAppName();</span><br><span class="line">  //组装http的header</span><br><span class="line">  HttpHeaders headers = new HttpHeaders();</span><br><span class="line">  headers.add(HttpHeaders.ACCEPT_ENCODING, &quot;gzip&quot;);</span><br><span class="line">  headers.add(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line"></span><br><span class="line">  ResponseEntity&lt;Void&gt; response = restTemplate.exchange(urlPath, HttpMethod.POST,</span><br><span class="line">      new HttpEntity&lt;&gt;(info, headers), Void.class);</span><br><span class="line"></span><br><span class="line">  return anEurekaHttpResponse(response.getStatusCodeValue())</span><br><span class="line">      .headers(headersOf(response)).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>eureka最终是http的方式去注册的。</p>
<h4 id="续约"><a href="#续约" class="headerlink" title="续约"></a>续约</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Renew with the eureka service by making the appropriate REST call</span><br><span class="line"> */</span><br><span class="line"> 续约到eureka servver，通过REST的方式</span><br><span class="line">boolean renew() &#123;</span><br><span class="line">    EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse;</span><br><span class="line">    try &#123;</span><br><span class="line">      //发送心跳</span><br><span class="line">        httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, null);</span><br><span class="line">        logger.debug(PREFIX + &quot;&#123;&#125; - Heartbeat status: &#123;&#125;&quot;, appPathIdentifier, httpResponse.getStatusCode());</span><br><span class="line">        if (httpResponse.getStatusCode() == Status.NOT_FOUND.getStatusCode()) &#123;</span><br><span class="line">            REREGISTER_COUNTER.increment();</span><br><span class="line">            logger.info(PREFIX + &quot;&#123;&#125; - Re-registering apps/&#123;&#125;&quot;, appPathIdentifier, instanceInfo.getAppName());</span><br><span class="line">            long timestamp = instanceInfo.setIsDirtyWithTime();</span><br><span class="line">            boolean success = register();</span><br><span class="line">            if (success) &#123;</span><br><span class="line">                instanceInfo.unsetIsDirty(timestamp);</span><br><span class="line">            &#125;</span><br><span class="line">            return success;</span><br><span class="line">        &#125;</span><br><span class="line">        return httpResponse.getStatusCode() == Status.OK.getStatusCode();</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        logger.error(PREFIX + &quot;&#123;&#125; - was unable to send heartbeat!&quot;, appPathIdentifier, e);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sendHeartBeat的主要实现:<br>org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public EurekaHttpResponse&lt;InstanceInfo&gt; sendHeartBeat(String appName, String id,</span><br><span class="line">    InstanceInfo info, InstanceStatus overriddenStatus) &#123;</span><br><span class="line">  String urlPath = serviceUrl + &quot;apps/&quot; + appName + &#x27;/&#x27; + id + &quot;?status=&quot;</span><br><span class="line">      + info.getStatus().toString() + &quot;&amp;lastDirtyTimestamp=&quot;</span><br><span class="line">      + info.getLastDirtyTimestamp().toString() + (overriddenStatus != null</span><br><span class="line">          ? &quot;&amp;overriddenstatus=&quot; + overriddenStatus.name() : &quot;&quot;);</span><br><span class="line"></span><br><span class="line">  ResponseEntity&lt;InstanceInfo&gt; response = restTemplate.exchange(urlPath,</span><br><span class="line">      HttpMethod.PUT, null, InstanceInfo.class);</span><br><span class="line"></span><br><span class="line">  EurekaHttpResponseBuilder&lt;InstanceInfo&gt; eurekaResponseBuilder = anEurekaHttpResponse(</span><br><span class="line">      response.getStatusCodeValue(), InstanceInfo.class)</span><br><span class="line">          .headers(headersOf(response));</span><br><span class="line"></span><br><span class="line">  if (response.hasBody()) &#123;</span><br><span class="line">    eurekaResponseBuilder.entity(response.getBody());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return eurekaResponseBuilder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即续约也是使用http的方式.</p>
<h3 id="EurekaClientConfigBean"><a href="#EurekaClientConfigBean" class="headerlink" title="EurekaClientConfigBean"></a>EurekaClientConfigBean</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    registerWithEureka: true</span><br><span class="line">    fetchRegistry: true</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://node1:10097/eureka/,http://node2:10098/eureka/,http://node3:10099/eureka/</span><br></pre></td></tr></table></figure>
<p>这个eureka配置主要的实现类是EurekaClientConfigBean,service-url的获取:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static final String DEFAULT_ZONE = &quot;defaultZone&quot;;</span><br><span class="line"> public static final String DEFAULT_URL = &quot;http://localhost:8761&quot; + DEFAULT_PREFIX+ &quot;/&quot;;</span><br><span class="line"> private Map&lt;String, String&gt; serviceUrl = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> &#123;</span><br><span class="line">   this.serviceUrl.put(DEFAULT_ZONE, DEFAULT_URL);</span><br><span class="line"> &#125;	private Map&lt;String, String&gt; serviceUrl = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> 	&#123;</span><br><span class="line"> 		this.serviceUrl.put(DEFAULT_ZONE, DEFAULT_URL);</span><br><span class="line"> 	&#125;</span><br></pre></td></tr></table></figure>

<p>【本期代码：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzExNTY3MjE4NzQvc3ByaW5nX2Nsb3VkX3Byb2plY3RzJUUzJTgwJTkx">https://github.com/1156721874/spring_cloud_projects】<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>spring_boot_cloud</category>
      </categories>
      <tags>
        <tag>eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>spring_boot_cloud(13)Value注解与BeanPostProcessor作用与分析</title>
    <url>/2019/11/21/spring_boot_and_cloud/spring_boot_cloud(13)Value%E6%B3%A8%E8%A7%A3%E4%B8%8EBeanPostProcessor%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="Value注解的使用方式"><a href="#Value注解的使用方式" class="headerlink" title="@Value注解的使用方式"></a>@Value注解的使用方式</h3><span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(value = &quot;/person&quot;, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)</span><br><span class="line">public class MyController &#123;</span><br><span class="line">    @Value(&quot;$&#123;myConfig.myObject.myName&#125;&quot;)</span><br><span class="line">    private  String myName;</span><br><span class="line">    @Value(&quot;$&#123;myConfig.myObject.myAge&#125;&quot;)</span><br><span class="line">    private int myAge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>myConfig.myObject.myName和myConfig.myObject.myAge都是配置里边的属性。</p>
<p>那么 <code>@Value</code>注解是怎样把其表达式的值赋值给它所作用的变量的呢？<br>接下来看一下它的doc说明：<br>Annotation at the field or method&#x2F;constructor parameter level that indicates a default value expression for the affected argument.<br>Typically used for expression-driven dependency injection. Also supported for dynamic resolution of handler method parameters, e.g. in Spring MVC.<br>A common use case is to assign default field values using #{systemProperties.myProp} style expressions.<br>Note that actual processing of the @Value annotation is performed by a BeanPostProcessor which in turn means that you cannot use @Value within BeanPostProcessor or BeanFactoryPostProcessor types. Please consult the javadoc for the AutowiredAnnotationBeanPostProcessor class (which, by default, checks for the presence of this annotation).</p>
<p>作用在方法&#x2F;构造方法&#x2F;字段等上面，用于受影响的参数一个值表达式。<br>通常用于表达式驱动依赖注入的场景上边，此外还支持处理器方法的动态解析，比如spring mvc得到了大量使用。<br>一种常用的使用场景是使用#{systemProperties.myProp}风格的表达式赋值一个字段的值。<br>注意，对于<code>@Value</code>注解的处理是使用BeanPostProcessor来去完成的，表示不能在BeanPostProcessor或者BeanFactoryPostProcessor类型上使用注解，请参考AutowiredAnnotationBeanPostProcessor类（默认情况下会检查<code>@Value</code>这个注解是否存在）</p>
<h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Factory hook that allows for custom modification of new bean instances, e.g. checking for marker interfaces or wrapping them with proxies.</span><br><span class="line">ApplicationContexts can autodetect BeanPostProcessor beans in their bean definitions and apply them to any beans subsequently created. Plain bean factories allow for programmatic registration of post-processors, applying to all beans created through this factory.</span><br><span class="line">Typically, post-processors that populate beans via marker interfaces or the like will implement postProcessBeforeInitialization, while post-processors that wrap beans with proxies will normally implement postProcessAfterInitialization.</span><br><span class="line">BeanPostProcessor是一个工厂的钩子，对于新的bean的实例进行一种定制化的修改，比如，会检查marker interface或者将其包装成一个代理。</span><br><span class="line">ApplicationContexts可以在bean的定义当中自动探测到BeanPostProcessor，然后将BeanPostProcessor应用到随后创建出来的bean上面，</span><br><span class="line">普通的bean工厂允许post-processors进行一种编程式注册，将其应用到经过这个工厂创建的所有的bean上面。</span><br><span class="line">典型的，post-processors 或者类似的bean，通过marker interfaces或者类型的组件，都会实现postProcessBeforeInitialization，其他的包装了post-processors的代理通常实现postProcessAfterInitialization。</span><br><span class="line">public interface BeanPostProcessor &#123;</span><br><span class="line">  /**</span><br><span class="line">    Apply this BeanPostProcessor to the given new bean instance before any bean initialization callbacks (like InitializingBean&#x27;s afterPropertiesSet or a custom init-method). The bean will already be populated with property values. The returned bean instance may be a wrapper around the original.</span><br><span class="line">    The default implementation returns the given bean as-is.</span><br><span class="line">    在任何的bean实例初始化回调(比如说InitializingBean的afterPropertiesSet，或者自定义的初始化方法)之前应用这个BeanPostProcessor，这些bean已经使用给定的属性值进行了装配，返回的bean的实例可能是一个原始实例的一个包装，</span><br><span class="line">    默认的实现是返回给定的bean的自身。</span><br><span class="line">  **/</span><br><span class="line">  default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">    return bean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">    Apply this BeanPostProcessor to the given new bean instance after any bean initialization callbacks (like InitializingBean&#x27;s afterPropertiesSet or a custom init-method). The bean will already be populated with property values. The returned bean instance may be a wrapper around the original.</span><br><span class="line">    In case of a FactoryBean, this callback will be invoked for both the FactoryBean instance and the objects created by the FactoryBean (as of Spring 2.0). The post-processor can decide whether to apply to either the FactoryBean or created objects or both through corresponding bean instanceof FactoryBean checks.</span><br><span class="line">    This callback will also be invoked after a short-circuiting triggered by a InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation method, in contrast to all other BeanPostProcessor callbacks.</span><br><span class="line">    The default implementation returns the given bean as-is.</span><br><span class="line">    在任何的bean实例初始化回调(比如说InitializingBean的afterPropertiesSet，或者自定义的初始化方法)之后应用这个BeanPostProcessor，这些bean已经使用给定的属性值进行了装配，返回的bean的实例可能是一个原始实例的一个包装，</span><br><span class="line">    默认的实现是返回给定的bean的自身。</span><br><span class="line">    对于FactoryBean来说，针对于FactoryBean实例和通过FactoryBean创建的对象都会得到回调，post-processor可以决定是否应用到FactoryBean上边，或者说FactoryBean创建的对象上边，或者2者之上，都是可以通过FactoryBean的检查来决定。</span><br><span class="line">    当一个短路操作被触发对的时候，这个方法也会被调用，通过InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation方法的调用触发，这和其他的BeanPostProcessor回调是相反的。</span><br><span class="line">    默认的实现是返回给定的bean的自身。</span><br><span class="line">  **/</span><br><span class="line">  default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">    return bean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>postProcessBeforeInitialization和postProcessAfterInitialization为什么到了jdk1.8改成默认方法了，是因为在1.7里边如果实现一个接口，就必须去实现它的所有方法，有些时候我们只需要实现其中的一个方法，只不过另一个方法返回原来的bean，而使用default method可以不去实现所有的方法，用到那个就重写那个即可。<br><img src="/desc.png" alt="desc.png"></p>
<p>上面说到 <code>@Value</code>不能在BeanPostProcessor或者BeanFactoryPostProcessor上使用，那么BeanFactoryPostProcessor是做啥的呢？</p>
<h3 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">Allows for custom modification of an application context&#x27;s bean definitions, adapting the bean property values of the context&#x27;s underlying bean factory.</span><br><span class="line">Application contexts can auto-detect BeanFactoryPostProcessor beans in their bean definitions and apply them before any other beans get created.</span><br><span class="line">Useful for custom config files targeted at system administrators that override bean properties configured in the application context.</span><br><span class="line">See PropertyResourceConfigurer and its concrete implementations for out-of-the-box solutions that address such configuration needs.</span><br><span class="line">A BeanFactoryPostProcessor may interact with and modify bean definitions, but never bean instances. Doing so may cause premature bean instantiation, violating the container and causing unintended side-effects. If bean instance interaction is required, consider implementing BeanPostProcessor instead.</span><br><span class="line">允许对于应用上下文的bean定义进行定制化修改，适配上下文底层bean工厂的属性值。</span><br><span class="line">在其他任何的bean创建之前，应用上下文可以在bean的定义当中自动检测BeanFactoryPostProcessor，</span><br><span class="line">主要作用于定制化的配置文件，目标是系统管理员，用于覆盖应用上下文当中的属性。</span><br><span class="line">参考PropertyResourceConfigurer和具体的实现，针对于这种配置需要的开箱即用的解决方案。</span><br><span class="line">一个BeanFactoryPostProcessor可能和修改bean的定义或者和bean的定义进行交互相关，但是从来不会和 bean的实例进行交互和修改，如果是面向bean的实例，会导致一个不成熟的bean的实例化，违背了容器的一些约定，并且会导致一些意想不到的副作用，如果需要和bean的实例进行交互，可以考虑使用BeanPostProcessor的实现代替。</span><br><span class="line">*/</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface BeanFactoryPostProcessor &#123;</span><br><span class="line">  /**</span><br><span class="line">  Modify the application context&#x27;s internal bean factory after its standard initialization. All bean definitions will have been loaded, but no beans will have been instantiated yet. This allows for overriding or adding properties even to eager-initializing beans.</span><br><span class="line">  在bean工厂初始化完毕之后，修改应用上下文里边的bean工厂，所有的bean的定义将会被加载，但是还没有bean的实例，这样就允许我们覆盖甚至添加一些属性，甚至于对于非延迟初始化的bean的属性进行覆盖。</span><br><span class="line">  **/</span><br><span class="line">  void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BeanFactoryPostProcessor是在bena的定义已经加载，但是bean的实例还没有初始化这个间隙，加入一些逻辑。</p>
<p>上面提到检查<code>Value</code>是否存在，用的是AutowiredAnnotationBeanPostProcessor，那么看一下这个类的介绍：</p>
<h3 id="AutowiredAnnotationBeanPostProcessor"><a href="#AutowiredAnnotationBeanPostProcessor" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a>AutowiredAnnotationBeanPostProcessor</h3><p>org.springframework.beans.factory.config.BeanPostProcessor implementation that autowires annotated fields, setter methods and arbitrary config methods. Such members to be injected are detected through a Java 5 annotation: by default, Spring’s <code>@Autowired</code> and <code>@Value</code> annotations.<br>Also supports JSR-330’s <code>@Inject</code> annotation, if available, as a direct alternative to Spring’s own <code>@Autowired</code>.<br>Only one constructor (at max) of any given bean class may declare this annotation with the ‘required’ parameter set to true, indicating the constructor to autowire when used as a Spring bean. If multiple non-required constructors declare the annotation, they will be considered as candidates for autowiring. The constructor with the greatest number of dependencies that can be satisfied by matching beans in the Spring container will be chosen. If none of the candidates can be satisfied, then a primary&#x2F;default constructor (if present) will be used. If a class only declares a single constructor to begin with, it will always be used, even if not annotated. An annotated constructor does not have to be public.<br>Fields are injected right after construction of a bean, before any config methods are invoked. Such a config field does not have to be public.<br>Config methods may have an arbitrary name and any number of arguments; each of those arguments will be autowired with a matching bean in the Spring container. Bean property setter methods are effectively just a special case of such a general config method. Config methods do not have to be public.<br>Note: A default AutowiredAnnotationBeanPostProcessor will be registered by the “context:annotation-config” and “context:component-scan” XML tags. Remove or turn off the default annotation configuration there if you intend to specify a custom AutowiredAnnotationBeanPostProcessor bean definition.<br>NOTE: Annotation injection will be performed before XML injection; thus the latter configuration will override the former for properties wired through both approaches.<br>In addition to regular injection points as discussed above, this post-processor also handles Spring’s <code>@Lookup</code> annotation which identifies lookup methods to be replaced by the container at runtime. This is essentially a type-safe version of getBean(Class, args) and getBean(String, args), See <code>@Lookup&#39;s</code> javadoc for details.<br>AutowiredAnnotationBeanPostProcessor是BeanPostProcessor的实现（AutowiredAnnotationBeanPostProcessor面向bena的实例），她会自动装配被注解的fields，setter方法，被配置好的方法，这些被用于注入的方法，是通过java 5的一个注解进行检测，默认是通过 <code>@Autowired</code> and <code>@Value</code> 注解。<br>当然也支持JSR-330标准的 <code>@Inject</code>注解，如果有的话可以作为spring  <code>@Autowired</code>的替代方案，给定的bean的class只有一个构造器(最多一个)，并且声明了<code>@Autowired</code>这个注解的参数required是true，这个构造方法会自动的进行装配，当用做一个spring bean的时候，<br>如果有多个没有声明require的<code>@Autowired</code>注解的构造器，他们会被认为是自动注入的备选，如果一个拥有最多依赖的构造器将会作为满足spring容器的选择，如果没有候选的依赖，那么主构造器或者默认构造器，如果有的话，将会被使用，如果一个class只有一个单个构造器，那么这个构造器将会永远被使用，一个构造器不必是一个public的构造器，既是她没有被<code>@Autowired</code>注解。<br> 成员变量的注入是在bean的构造之后进行的，在所有的配置方法执行之前，这样的成员变量没有必要是public的。<br>配置方法拥有一些自由的名称和一些参数；每个方法的参数都会自动匹配一个spring容器里边的一个bean，bean的属性的setter方法就是一个配置方法，配置方法没有必要是public的。<br>注意：默认的AutowiredAnnotationBeanPostProcessor将会被”context:annotation-config” 和 “context:component-scan” XML 标签注册，如果你倾向于移除或者关闭默认注解配置，那么可以使用定制化的AutowiredAnnotationBeanPostProcessor 的bean定义。<br>注意：注解的注入比xml的注入的优先级比较高，如果使用这两种方式，这样后来的配置将会覆盖之前的属性配置。<br>除了常规的注入点之外，post-processor后置处理器可以处理spring的lookup注解，lookup注解是用来标示或者指定一个lookup方法，可以被容器在 运行时的时候别替换，这本质上是一个类替换的安全的getBean的版本，有兴趣参考<code>@Lookup</code>java 文档。<br>AutowiredAnnotationBeanPostProcessor的构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AutowiredAnnotationBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter</span><br><span class="line">		implements MergedBeanDefinitionPostProcessor, PriorityOrdered, BeanFactoryAware&#123;</span><br><span class="line">        public AutowiredAnnotationBeanPostProcessor() &#123;</span><br><span class="line">            this.autowiredAnnotationTypes.add(Autowired.class);</span><br><span class="line">            this.autowiredAnnotationTypes.add(Value.class);</span><br><span class="line">            //try catch的作用是检测JSR-330的Inject注解的防御性设计。</span><br><span class="line">            try &#123;</span><br><span class="line">              this.autowiredAnnotationTypes.add((Class&lt;? extends Annotation&gt;)</span><br><span class="line">                  ClassUtils.forName(&quot;javax.inject.Inject&quot;, AutowiredAnnotationBeanPostProcessor.class.getClassLoader()));</span><br><span class="line">              logger.trace(&quot;JSR-330 &#x27;javax.inject.Inject&#x27; annotation found and supported for autowiring&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (ClassNotFoundException ex) &#123;</span><br><span class="line">              // JSR-330 API not available - simply skip.</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Autowired注解"><a href="#Autowired注解" class="headerlink" title="Autowired注解"></a>Autowired注解</h3><p>Marks a constructor, field, setter method or config method as to be autowired by Spring’s dependency injection facilities. This is an alternative to the JSR-330 javax.inject.Inject annotation, adding required-vs-optional semantics.<br>Only one constructor (at max) of any given bean class may declare this annotation with the ‘required’ parameter set to true, indicating the constructor to autowire when used as a Spring bean. If multiple non-required constructors declare the annotation, they will be considered as candidates for autowiring. The constructor with the greatest number of dependencies that can be satisfied by matching beans in the Spring container will be chosen. If none of the candidates can be satisfied, then a primary&#x2F;default constructor (if present) will be used. If a class only declares a single constructor to begin with, it will always be used, even if not annotated. An annotated constructor does not have to be public.<br>Fields are injected right after construction of a bean, before any config methods are invoked. Such a config field does not have to be public.<br>Config methods may have an arbitrary name and any number of arguments; each of those arguments will be autowired with a matching bean in the Spring container. Bean property setter methods are effectively just a special case of such a general config method. Such config methods do not have to be public.<br>In the case of a multi-arg constructor or method, the ‘required’ parameter is applicable to all arguments. Individual parameters may be declared as Java-8-style java.util.Optional or, as of Spring Framework 5.0, also as @Nullable or a not-null parameter type in Kotlin, overriding the base required semantics.<br>In case of a java.util.Collection or java.util.Map dependency type, the container autowires all beans matching the declared value type. For such purposes, the map keys must be declared as type String which will be resolved to the corresponding bean names. Such a container-provided collection will be ordered, taking into account org.springframework.core.Ordered&#x2F;org.springframework.core.annotation.Order values of the target components, otherwise following their registration order in the container. Alternatively, a single matching target bean may also be a generally typed Collection or Map itself, getting injected as such.<br>Note that actual injection is performed through a BeanPostProcessor which in turn means that you cannot use @Autowired to inject references into BeanPostProcessor or BeanFactoryPostProcessor types. Please consult the javadoc for the AutowiredAnnotationBeanPostProcessor class (which, by default, checks for the presence of this annotation).<br>标记一个构造器，成员变量，setter方法，配置方法，作为spring依赖管理自动注入的标示。 是JSR-330的javax.inject.Inject的替代方案，添加了require和optional的语义。<br>给定的类只有一个构造器可能声明这个注解，并且声明了require参数为true，标示这个构造去器会进行自动装配，如果有多个没有require参数的构造器被注解，他们都会被作为注入的候选者，拥有最多的依赖的构造会被spring容器作为满足注入的依赖最佳选择，如果没有一个候选，会使用默认的构造器，如果一个class只有一个构造器，那么这个构造器会被永远使用，甚至是没有被注解的构造器，一个被注解的构造器没有必要是public的。<br>成员变量的注入是在bean的构造之后进行的，在所有的配置方法执行之前，这样的成员变量没有必要是public的。<br>配置方法拥有一些自由的名称和一些参数；每个方法的参数都会自动匹配一个spring容器里边的一个bean，bean的属性的setter方法就是一个配置方法，配置方法没有必要是public的。<br>有多个参数的构造器或者方法，require参数是针对于所有的方法参数。单个参数的可以声明为java8风格的java.util.Optional 或者是说从spring5.0开始作为一个@Nullable，或者kotlin当中一个非空参数，可以覆盖一些基础的语义。<br>对于java.util.Collection和java.util.Map依赖的类型，spring容器可以匹配与其值类型匹配的所有的bean，假设一下，如果是map的key是String类型，它会被解析成与之对应的bean的名字，这样容器提供的集合将会被排序，，，，<br>略。。。</p>
<h3 id="Configuration注解"><a href="#Configuration注解" class="headerlink" title="Configuration注解"></a>Configuration注解</h3><p>Indicates that a class declares one or more @Bean methods and may be processed by the Spring container to generate bean definitions and service requests for those beans at runtime, for example:<br>   @Configuration<br>   public class AppConfig {</p>
<pre><code>   @Bean
   public MyBean myBean() &#123;
       // instantiate, configure and return bean ...
   &#125;
</code></pre>
<p>   }<br>Bootstrapping @Configuration classes<br>  Via AnnotationConfigApplicationContext<br>   @Configuration classes are typically bootstrapped using either AnnotationConfigApplicationContext or its web-capable variant, AnnotationConfigWebApplicationContext. A simple example with the former follows:<br>      AnnotationConfigApplicationContext ctx &#x3D; new AnnotationConfigApplicationContext();<br>      ctx.register(AppConfig.class);<br>      ctx.refresh();<br>      MyBean myBean &#x3D; ctx.getBean(MyBean.class);<br>      &#x2F;&#x2F; use myBean …</p>
<p>   See the AnnotationConfigApplicationContext javadocs for further details, and see AnnotationConfigWebApplicationContext for web configuration instructions in a Servlet container.<br> Via Spring <beans> XML<br>   As an alternative to registering @Configuration classes directly against an AnnotationConfigApplicationContext, @Configuration classes may be declared as normal <bean> definitions within Spring XML files:<br>      <beans><br>         <span class="exturl" data-url="Y29udGV4dDphbm5vdGF0aW9uLWNvbmZpZy8=">context:annotation-config/<i class="fa fa-external-link-alt"></i></span><br>         <bean class="com.acme.AppConfig"/><br>      </beans></p>
<p>   In the example above, <span class="exturl" data-url="Y29udGV4dDphbm5vdGF0aW9uLWNvbmZpZy8=">context:annotation-config/<i class="fa fa-external-link-alt"></i></span> is required in order to enable ConfigurationClassPostProcessor and other annotation-related post processors that facilitate handling @Configuration classes.<br> Via component scanning<br>   @Configuration is meta-annotated with @Component, therefore @Configuration classes are candidates for component scanning (typically using Spring XML’s <span class="exturl" data-url="Y29udGV4dDpjb21wb25lbnQtc2Nhbi8=">context:component-scan/<i class="fa fa-external-link-alt"></i></span> element) and therefore may also take advantage of @Autowired&#x2F;@Inject like any regular @Component. In particular, if a single constructor is present autowiring semantics will be applied transparently for that constructor:<br>      @Configuration<br>      public class AppConfig {</p>
<pre><code>      private final SomeBean someBean;

      public AppConfig(SomeBean someBean) &#123;
          this.someBean = someBean;
      &#125;

      // @Bean definition using &quot;SomeBean&quot;

  &#125;
</code></pre>
<p>   @Configuration classes may not only be bootstrapped using component scanning, but may also themselves configure component scanning using the @ComponentScan annotation:<br>      @Configuration<br>      @ComponentScan(“com.acme.app.services”)<br>      public class AppConfig {<br>          &#x2F;&#x2F; various @Bean definitions …<br>      }<br>   See the @ComponentScan javadocs for details.</p>
<p> Working with externalized values<br>   Using the Environment API<br>   Externalized values may be looked up by injecting the Spring org.springframework.core.env.Environment into a @Configuration class — for example, using the @Autowired annotation:<br>      @Configuration<br>      public class AppConfig {</p>
<pre><code>      @Autowired Environment env;

      @Bean
      public MyBean myBean() &#123;
          MyBean myBean = new MyBean();
          myBean.setName(env.getProperty(&quot;bean.name&quot;));
          return myBean;
      &#125;
  &#125;
</code></pre>
<p>   Properties resolved through the Environment reside in one or more “property source” objects, and @Configuration classes may contribute property sources to the Environment object using the @PropertySource annotation:<br>      @Configuration<br>      @PropertySource(“classpath:&#x2F;com&#x2F;acme&#x2F;app.properties”)<br>      public class AppConfig {</p>
<pre><code>      @Inject Environment env;

      @Bean
      public MyBean myBean() &#123;
          return new MyBean(env.getProperty(&quot;bean.name&quot;));
      &#125;
  &#125;
</code></pre>
<p>   See the Environment and @PropertySource javadocs for further details.<br> Using the @Value annotation</p>
<p>Composing @Configuration classes<br>With the @Import annotation<br>@Configuration classes may be composed using the @Import annotation, similar to the way that <import> works in Spring XML. Because @Configuration objects are managed as Spring beans within the container, imported configurations may be injected — for example, via constructor injection:<br>   @Configuration<br>   public class DatabaseConfig {</p>
<pre><code>   @Bean
   public DataSource dataSource() &#123;
       // instantiate, configure and return DataSource
   &#125;
</code></pre>
<p>   }</p>
<p>   @Configuration<br>   @Import(DatabaseConfig.class)<br>   public class AppConfig {</p>
<pre><code>   private final DatabaseConfig dataConfig;

   public AppConfig(DatabaseConfig dataConfig) &#123;
       this.dataConfig = dataConfig;
   &#125;

   @Bean
   public MyBean myBean() &#123;
       // reference the dataSource() bean method
       return new MyBean(dataConfig.dataSource());
   &#125;
</code></pre>
<p>   }<br>Now both AppConfig and the imported DatabaseConfig can be bootstrapped by registering only AppConfig against the Spring context:<br>   new AnnotationConfigApplicationContext(AppConfig.class);<br>With the @Profile annotation<br>@Configuration classes may be marked with the @Profile annotation to indicate they should be processed only if a given profile or profiles are active:<br>   @Profile(“development”)<br>   @Configuration<br>   public class EmbeddedDatabaseConfig {</p>
<pre><code>   @Bean
   public DataSource dataSource() &#123;
       // instantiate, configure and return embedded DataSource
   &#125;
</code></pre>
<p>   }</p>
<p>   @Profile(“production”)<br>   @Configuration<br>   public class ProductionDatabaseConfig {</p>
<pre><code>   @Bean
   public DataSource dataSource() &#123;
       // instantiate, configure and return production DataSource
   &#125;
</code></pre>
<p>   }<br>Alternatively, you may also declare profile conditions at the @Bean method level — for example, for alternative bean variants within the same configuration class:<br>   @Configuration<br>   public class ProfileDatabaseConfig {</p>
<pre><code>   @Bean(&quot;dataSource&quot;)
   @Profile(&quot;development&quot;)
   public DataSource embeddedDatabase() &#123; ... &#125;

   @Bean(&quot;dataSource&quot;)
   @Profile(&quot;production&quot;)
   public DataSource productionDatabase() &#123; ... &#125;
</code></pre>
<p>   }<br>See the @Profile and org.springframework.core.env.Environment javadocs for further details.<br>With Spring XML using the @ImportResource annotation<br>As mentioned above, @Configuration classes may be declared as regular Spring <bean> definitions within Spring XML files. It is also possible to import Spring XML configuration files into @Configuration classes using the @ImportResource annotation. Bean definitions imported from XML can be injected — for example, using the @Inject annotation:<br>   @Configuration<br>   @ImportResource(“classpath:&#x2F;com&#x2F;acme&#x2F;database-config.xml”)<br>   public class AppConfig {</p>
<pre><code>   @Inject DataSource dataSource; // from XML

   @Bean
   public MyBean myBean() &#123;
       // inject the XML-defined dataSource bean
       return new MyBean(this.dataSource);
   &#125;
</code></pre>
<p>   }<br>With nested @Configuration classes<br>@Configuration classes may be nested within one another as follows:<br>   @Configuration<br>   public class AppConfig {</p>
<pre><code>   @Inject DataSource dataSource;

   @Bean
   public MyBean myBean() &#123;
       return new MyBean(dataSource);
   &#125;

   @Configuration
   static class DatabaseConfig &#123;
       @Bean
       DataSource dataSource() &#123;
           return new EmbeddedDatabaseBuilder().build();
       &#125;
   &#125;
</code></pre>
<p>   }<br>When bootstrapping such an arrangement, only AppConfig need be registered against the application context. By virtue of being a nested @Configuration class, DatabaseConfig will be registered automatically. This avoids the need to use an @Import annotation when the relationship between AppConfig and DatabaseConfig is already implicitly clear.<br>Note also that nested @Configuration classes can be used to good effect with the @Profile annotation to provide two options of the same bean to the enclosing @Configuration class.<br>Configuring lazy initialization<br>By default, @Bean methods will be eagerly instantiated at container bootstrap time. To avoid this, @Configuration may be used in conjunction with the @Lazy annotation to indicate that all @Bean methods declared within the class are by default lazily initialized. Note that @Lazy may be used on individual @Bean methods as well.</p>
<p>标示声明有多个@Bean的方法的类，可以被spring的容器处理，用来生成bean的定义和针对于bean在运行期间你的服务请求，举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        // instantiate, configure and return bean ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="启动Configuration"><a href="#启动Configuration" class="headerlink" title="启动Configuration"></a>启动Configuration</h4><h5 id="通过-AnnotationConfigApplicationContext"><a href="#通过-AnnotationConfigApplicationContext" class="headerlink" title="通过 AnnotationConfigApplicationContext"></a>通过 AnnotationConfigApplicationContext</h5><p>@Configuration的启动通常有AnnotationConfigApplicationContext和 web-capable的变种AnnotationConfigWebApplicationContext，举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();</span><br><span class="line">ctx.register(AppConfig.class);</span><br><span class="line">ctx.refresh();</span><br><span class="line">MyBean myBean = ctx.getBean(MyBean.class);</span><br><span class="line">// use myBean ...</span><br></pre></td></tr></table></figure>
<p>参考AnnotationConfigApplicationContext 文档和AnnotationConfigWebApplicationContext 了解详情。</p>
<h5 id="通过Spring-XML方式"><a href="#通过Spring-XML方式" class="headerlink" title="通过Spring XML方式"></a>通过Spring XML方式</h5><p>作为Configuration注解的替代方案，直接使用AnnotationConfigApplicationContext的方式注册，@Configuration可以声明成spring xml的方式定义bean。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">   &lt;context:annotation-config/&gt;</span><br><span class="line">   &lt;bean class=&quot;com.acme.AppConfig&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>在上面的实例当中呢，<span class="exturl" data-url="Y29udGV4dDphbm5vdGF0aW9uLWNvbmZpZy8=">context:annotation-config/<i class="fa fa-external-link-alt"></i></span>是被要求的，用来启用ConfigurationClassPostProcessor和其他的和注解相关的后置处理器，处理@Configuration。</p>
<h5 id="组件扫描的方式"><a href="#组件扫描的方式" class="headerlink" title="组件扫描的方式"></a>组件扫描的方式</h5><p>@Configuration是由元注解@Component修饰的，所以@Configuration也是可以被认为是组件（通常使用<span class="exturl" data-url="Y29udGV4dDpjb21wb25lbnQtc2Nhbi8=">context:component-scan/<i class="fa fa-external-link-alt"></i></span>的元素），因此可以使用@Autowired&#x2F;@Inject 就像常规的组件一样，如果出现单个的构造方法，那么自动装配的语义会被透明的应用到这个构造方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    private final SomeBean someBean;</span><br><span class="line"></span><br><span class="line">    public AppConfig(SomeBean someBean) &#123;</span><br><span class="line">        this.someBean = someBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // @Bean definition using &quot;SomeBean&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Configuration不仅可以使用组件扫描启动，他自己也可以配置组件扫描使用 @ComponentScan注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.acme.app.services&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    // various @Bean definitions ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="以外部的值去工作"><a href="#以外部的值去工作" class="headerlink" title="以外部的值去工作"></a>以外部的值去工作</h4><h5 id="使用环境变量"><a href="#使用环境变量" class="headerlink" title="使用环境变量"></a>使用环境变量</h5><p>外部的值可以通过spring的 org.springframework.core.env.Environment 注入到被@Configuration接的类里边， 举例，使用 @Autowired 注解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired Environment env;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        MyBean myBean = new MyBean();</span><br><span class="line">        myBean.setName(env.getProperty(&quot;bean.name&quot;));</span><br><span class="line">        return myBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过Environment可以解析属性源对象，并且 @Configuration 可以通过@PropertySource 注解给Environment提供属性源。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@PropertySource(&quot;classpath:/com/acme/app.properties&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;bean.name&#125;&quot;) String beanName;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        return new MyBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="通过-Value注解"><a href="#通过-Value注解" class="headerlink" title="通过@Value注解"></a>通过@Value注解</h5><p>外部的值的注入到@Configuration 注解的class，可以通过@Value 注解。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@PropertySource(&quot;classpath:/com/acme/app.properties&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;bean.name&#125;&quot;) String beanName;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        return new MyBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="组合-Configuration-类"><a href="#组合-Configuration-类" class="headerlink" title="组合 @Configuration 类"></a>组合 @Configuration 类</h4><h5 id="使用-Import-注解"><a href="#使用-Import-注解" class="headerlink" title="使用 @Import 注解"></a>使用 @Import 注解</h5><p>@Configuration注解可以使用 @Import 注解进行组合，有点像xml方式里边的 <import> 标签，因为被 @Configuration 注解的对象是作为spring 容器的bean被管理的，导入配置可以被注入的，举例，使用构造器注入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DatabaseConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        // instantiate, configure and return DataSource</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@Import(DatabaseConfig.class)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    private final DatabaseConfig dataConfig;</span><br><span class="line"></span><br><span class="line">    public AppConfig(DatabaseConfig dataConfig) &#123;</span><br><span class="line">        this.dataConfig = dataConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        // reference the dataSource() bean method</span><br><span class="line">        return new MyBean(dataConfig.dataSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，可以通过仅在Spring上下文中注册AppConfig来引导AppConfig和导入的DatabaseConfig：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new AnnotationConfigApplicationContext(AppConfig.class);</span><br></pre></td></tr></table></figure>
<h5 id="通过-Profile-注解"><a href="#通过-Profile-注解" class="headerlink" title="通过@Profile 注解"></a>通过@Profile 注解</h5><p>@Configuration注解可以被@Profile 注解标记，暗示它们在指定的profile或者活动profile需要被处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Profile(&quot;development&quot;)</span><br><span class="line">@Configuration</span><br><span class="line">public class EmbeddedDatabaseConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        // instantiate, configure and return embedded DataSource</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Profile(&quot;production&quot;)</span><br><span class="line">@Configuration</span><br><span class="line">public class ProductionDatabaseConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        // instantiate, configure and return production DataSource</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以在 @Bean 方法层面声明profile条件，举例，以下方式可以替代上面的@Profile的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ProfileDatabaseConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(&quot;dataSource&quot;)</span><br><span class="line">    @Profile(&quot;development&quot;)</span><br><span class="line">    public DataSource embeddedDatabase() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(&quot;dataSource&quot;)</span><br><span class="line">    @Profile(&quot;production&quot;)</span><br><span class="line">    public DataSource productionDatabase() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="和spring-xml配合使用-ImportResource-注解"><a href="#和spring-xml配合使用-ImportResource-注解" class="headerlink" title="和spring xml配合使用@ImportResource 注解"></a>和spring xml配合使用@ImportResource 注解</h4><p>前边提过，@Configuration 类可以在spring的 xml里边按照spring的bean定义声明，同样可以使用@ImportResource 注解导入 Spring XML配置到 @Configuration 的类里边。bean的xml定义被注入—举例，使用 @Inject注解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ImportResource(&quot;classpath:/com/acme/database-config.xml&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Inject DataSource dataSource; // from XML</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        // inject the XML-defined dataSource bean</span><br><span class="line">        return new MyBean(this.dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用嵌套的-Configuration-类"><a href="#使用嵌套的-Configuration-类" class="headerlink" title="使用嵌套的 @Configuration 类"></a>使用嵌套的 @Configuration 类</h4><p> @Configuration可以被嵌套到其他的 @Configuration类里边:<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Inject DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        return new MyBean(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Configuration</span><br><span class="line">    static class DatabaseConfig &#123;</span><br><span class="line">        @Bean</span><br><span class="line">        DataSource dataSource() &#123;</span><br><span class="line">            return new EmbeddedDatabaseBuilder().build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 这种写法启动的时候，只需要将AppConfig注册到spring的上下文，通过虚拟的嵌套的@Configuration类，DatabaseConfig将会被自动注册，避免了在AppConfig和DatabaseConfig存在联系的时候使用 @Import 注解，这样比较清晰。</p>
<h3 id="AnnotationConfigApplicationContext"><a href="#AnnotationConfigApplicationContext" class="headerlink" title="AnnotationConfigApplicationContext"></a>AnnotationConfigApplicationContext</h3><p>Standalone application context, accepting annotated classes as input - in particular @Configuration-annotated classes, but also plain @Component types and JSR-330 compliant classes using javax.inject annotations. Allows for registering classes one by one using register(Class…) as well as for classpath scanning using scan(String…).<br>In case of multiple @Configuration classes,@Bean  methods defined in later classes will override those defined in earlier classes. This can be leveraged to deliberately override certain bean definitions via an extra @Configuration class.<br>See @Configuration’s javadoc for usage examples.<br>独立应用上下文，以被注解的类作为参数输入，特别是 @Configuration注解的类，同时也是一个@Component组件类型，兼容JSR-330的javax.inject注解。允许通过register(Class…)方法一个一个的注册class，或者使用 scan(String…)方法扫描classPath下的，<br>当存在多个 @Configuration 的时候，后面的类的 @Bean注解的方法的定义将会覆盖前边的定义，这个可以用来故意覆盖一些bena的定义，通过外部的@Configuration 类。</p>
<h3 id="AnnotationConfigWebApplicationContext"><a href="#AnnotationConfigWebApplicationContext" class="headerlink" title="AnnotationConfigWebApplicationContext"></a>AnnotationConfigWebApplicationContext</h3><p>是AnnotationConfigApplicationContext在web环境下的实现</p>
<h3 id="注解解析的流程"><a href="#注解解析的流程" class="headerlink" title="注解解析的流程"></a>注解解析的流程</h3><p>我们打开AutowiredAnnotationBeanPostProcessor，这里面有AutowiredMethodElement、AutowiredFieldElement看上去分别是为了解析被注解的方法和字段的，我们拿AutowiredFieldElement的inject方法进行断点调试，启动我们的app。<br><img src="/debug1.png" alt="debug1.png"><br>断点到了inject方法里边，可以看到inject的beanname参数是我们的controller，controller的结构：<br><img src="/debug2.png" alt="debug2.png"><br>最终到了关键性的代码：<br><img src="/debug3.png" alt="debug3.png"><br>makeAccessible是为了打开访问设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void makeAccessible(Field field) &#123;</span><br><span class="line">    if ((!Modifier.isPublic(field.getModifiers()) || !Modifier.isPublic(field.getDeclaringClass().getModifiers()) || Modifier.isFinal(field.getModifiers())) &amp;&amp; !field.isAccessible()) &#123;</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>field.set(bean, value);<br>是java的反射appi，field是controller的myName字段，bean是MyController对象，value是从yml里边读取的值。<br>PS：其实MyController里边的getter和setter是无需提供的，而是spring通过反射设置的。</p>
]]></content>
      <categories>
        <category>spring_boot_cloud</category>
      </categories>
      <tags>
        <tag>Value注解 SpringBoot BeanPostProcessor</tag>
      </tags>
  </entry>
  <entry>
    <title>spring_boot_cloud(16)ribbon负载均衡与底层源码流程剖析</title>
    <url>/2020/05/18/spring_boot_and_cloud/spring_boot_cloud(16)ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B8%8E%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E6%B5%81%E7%A8%8B%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<h3 id="ribbon"><a href="#ribbon" class="headerlink" title="ribbon"></a>ribbon</h3><ul>
<li>负载均衡的框架</li>
<li>支持多种协议，如http、tcp等</li>
<li>提供负载均衡客户端</li>
</ul>
<h4 id="jar包"><a href="#jar包" class="headerlink" title="jar包"></a>jar包</h4><p>Gradle: com.netflix.ribbon:ribbon:2.3.0 外壳<br>Gradle: com.netflix.ribbon:ribbon-core:2.3.0 核心包<br>Gradle: com.netflix.ribbon:ribbon-eureka:2.3.0 和eureka的继承<br>Gradle: com.netflix.ribbon:ribbon-httpclient:2.3.0 http客户端<br>Gradle: com.netflix.ribbon:ribbon-loadbalancer:2.3.0 负载均衡器<br>Gradle: com.netflix.ribbon:ribbon-transport:2.3.0  其他协议的支持</p>
<span id="more"></span>
<h4 id="负载均衡器组件"><a href="#负载均衡器组件" class="headerlink" title="负载均衡器组件"></a>负载均衡器组件</h4><ul>
<li>一个负载均衡器，至少提供以下功能<ul>
<li>要维护各个服务器的ip等信息</li>
<li>根据特定逻辑选取服务器</li>
</ul>
</li>
<li>为了实现基本的负载均衡功能，ribbon的负载均衡有三大子模块<ul>
<li>rule</li>
<li>ping（心跳）</li>
<li>serverList</li>
</ul>
</li>
</ul>
<h4 id="内置负载均衡规则"><a href="#内置负载均衡规则" class="headerlink" title="内置负载均衡规则"></a>内置负载均衡规则</h4><ul>
<li>RoundRobinRule</li>
<li>AvailabilityFilterRule</li>
<li>WeightResponseTimeRule</li>
<li>ZoneAvoidanceRule</li>
<li>BestAvailableRule</li>
<li>RandomRule</li>
<li>RetryRule</li>
</ul>
<h4 id="ribbon的两种使用方式"><a href="#ribbon的两种使用方式" class="headerlink" title="ribbon的两种使用方式"></a>ribbon的两种使用方式</h4><ul>
<li>与RestTemplate结合使用</li>
<li>与Feign结合使用</li>
</ul>
<h4 id="LoadBalanceerClient"><a href="#LoadBalanceerClient" class="headerlink" title="LoadBalanceerClient"></a>LoadBalanceerClient</h4><ul>
<li>LoadBalanceClient是负载均衡器的核心类，他可以通过eureka-client获取到负载 均衡服务提供者的实例信息，，并将服务注册列表信息缓存一份，从而实现了客户端的负载均衡。</li>
</ul>
<h4 id="Ribbon实现负载均衡原理"><a href="#Ribbon实现负载均衡原理" class="headerlink" title="Ribbon实现负载均衡原理"></a>Ribbon实现负载均衡原理</h4><p> Ribbon的负载均衡主要是通过LoadBalanceClient来实现的，而LoadBalanceClient具体交给了ILoadBalance来处理，IloadBalance通过配置IRule，IPing等，想Eureka Client获取注册列表信息，默认每秒想Eureka Client发送一次【ping】，进而检查是否需要更新服务的注册列表信息。最后，在得到服务注册列表信息后，ILoadBalance根据IRULE的策略进行负载均衡。</p>
<h4 id="Ribbon实现负载均衡的原理"><a href="#Ribbon实现负载均衡的原理" class="headerlink" title="Ribbon实现负载均衡的原理"></a>Ribbon实现负载均衡的原理</h4><ul>
<li>RestTemplate增加@LoadBalance注解后，再进行远程调度时能够做到负载均衡，主要是维护了一个被@LoadBalance注解的RestTemplate列表，并给该列表中的RestTemplate对象添加了拦截器，在拦截器方法中，将远程调度方法教给了Ribbon的负载均衡器LoadBalanceClient去处理。从而实现了负载均衡的目的。</li>
</ul>
<h4 id="LoadBalanced注解"><a href="#LoadBalanced注解" class="headerlink" title="LoadBalanced注解"></a>LoadBalanced注解</h4><p>Annotation to mark a RestTemplate or WebClient bean to be configured to use a LoadBalancerClient.<br>标示RestTemplate或者WebClient可以被配置，以被LoadBalancerClient使用</p>
<h4 id="LoadBalancerAutoConfiguration"><a href="#LoadBalancerAutoConfiguration" class="headerlink" title="LoadBalancerAutoConfiguration"></a>LoadBalancerAutoConfiguration</h4><p>Auto-configuration for Ribbon (client-side load balancing).<br>为Ribbon自动配置使用，负载均衡的装配</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration(proxyBeanMethods = false)</span><br><span class="line">@ConditionalOnClass(RestTemplate.class)</span><br><span class="line">@ConditionalOnBean(LoadBalancerClient.class)</span><br><span class="line">@EnableConfigurationProperties(LoadBalancerRetryProperties.class)</span><br><span class="line">public class LoadBalancerAutoConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConditionalOnClass和ConditionalOnBean完成LoadBalancerAutoConfiguration的加载，即RestTemplate在classpath下边能找到，<br>并且LoadBalancerClient实例存在才会加载LoadBalancerAutoConfiguration。</p>
<h4 id="LoadBalancerInterceptor拦截器"><a href="#LoadBalancerInterceptor拦截器" class="headerlink" title="LoadBalancerInterceptor拦截器"></a>LoadBalancerInterceptor拦截器</h4><p>LoadBalancerInterceptor存在LoadBalancerAutoConfiguration当中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class LoadBalancerInterceptor implements ClientHttpRequestInterceptor &#123;</span><br><span class="line"></span><br><span class="line">	private LoadBalancerClient loadBalancer;</span><br><span class="line"></span><br><span class="line">	private LoadBalancerRequestFactory requestFactory;</span><br><span class="line"></span><br><span class="line">	public LoadBalancerInterceptor(LoadBalancerClient loadBalancer,</span><br><span class="line">			LoadBalancerRequestFactory requestFactory) &#123;</span><br><span class="line">		this.loadBalancer = loadBalancer;</span><br><span class="line">		this.requestFactory = requestFactory;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public LoadBalancerInterceptor(LoadBalancerClient loadBalancer) &#123;</span><br><span class="line">		// for backwards compatibility</span><br><span class="line">		this(loadBalancer, new LoadBalancerRequestFactory(loadBalancer));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public ClientHttpResponse intercept(final HttpRequest request, final byte[] body,</span><br><span class="line">			final ClientHttpRequestExecution execution) throws IOException &#123;</span><br><span class="line">		final URI originalUri = request.getURI();</span><br><span class="line">		String serviceName = originalUri.getHost();</span><br><span class="line">		Assert.state(serviceName != null,</span><br><span class="line">				&quot;Request URI does not contain a valid hostname: &quot; + originalUri);</span><br><span class="line">		return this.loadBalancer.execute(serviceName,</span><br><span class="line">				this.requestFactory.createRequest(request, body, execution));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> this.loadBalancer.execute调用了LoadBalancerClient的execute方法:<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> public interface LoadBalancerClient extends ServiceInstanceChooser &#123;</span><br><span class="line"></span><br><span class="line"> 	/**</span><br><span class="line"> 	 * Executes request using a ServiceInstance from the LoadBalancer for the specified</span><br><span class="line"> 	 * service.</span><br><span class="line"> 	 * @param serviceId The service ID to look up the LoadBalancer.</span><br><span class="line"> 	 * @param request Allows implementations to execute pre and post actions, such as</span><br><span class="line"> 	 * incrementing metrics.</span><br><span class="line"> 	 * @param &lt;T&gt; type of the response</span><br><span class="line"> 	 * @throws IOException in case of IO issues.</span><br><span class="line"> 	 * @return The result of the LoadBalancerRequest callback on the selected</span><br><span class="line"> 	 * ServiceInstance.</span><br><span class="line"> 	 */</span><br><span class="line">   主要完成具体请求的执行</span><br><span class="line"> 	&lt;T&gt; T execute(String serviceId, LoadBalancerRequest&lt;T&gt; request) throws IOException;</span><br><span class="line"></span><br><span class="line">  &lt;T&gt; T execute(String serviceId, ServiceInstance serviceInstance,	LoadBalancerRequest&lt;T&gt; request) throws IOException;</span><br><span class="line">  // 重新构建uri</span><br><span class="line">  /*</span><br><span class="line">  * Creates a proper URI with a real host and port for systems to utilize. Some systems use a URI with the logical</span><br><span class="line">  * service name as the host, such as http://myservice/path/to/service. This will replace the service name with the *</span><br><span class="line">  * host:port from the ServiceInstance</span><br><span class="line">  */</span><br><span class="line">  URI reconstructURI(ServiceInstance instance, URI original);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> LoadBalancerClient实继承了ServiceInstanceChooser，ServiceInstanceChooser只有一个方法，就是选择一个实例，然后封装为ServiceInstance返回。<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface ServiceInstanceChooser &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Chooses a ServiceInstance from the LoadBalancer for the specified service.</span><br><span class="line">	 * @param serviceId The service ID to look up the LoadBalancer.</span><br><span class="line">	 * @return A ServiceInstance that matches the serviceId.</span><br><span class="line">	 */</span><br><span class="line">	ServiceInstance choose(String serviceId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="RibbonLoadBalancerClient"><a href="#RibbonLoadBalancerClient" class="headerlink" title="RibbonLoadBalancerClient"></a>RibbonLoadBalancerClient</h4><p>RibbonLoadBalancerClient是具体的执行execute方法的实现类。</p>
<h4 id="bubug-LoadBalancerInterceptor"><a href="#bubug-LoadBalancerInterceptor" class="headerlink" title="bubug LoadBalancerInterceptor"></a>bubug LoadBalancerInterceptor</h4><p>我们在LoadBalancerInterceptor的intercept方法加一个断点，然后做一个请求:<br><img src="/debug-LoadBalancerInterceptor-01.png" alt="debug-LoadBalancerInterceptor-01.png"><br>进入RibbonLoadBalancerClient的execute如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public &lt;T&gt; T execute(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span><br><span class="line">    throws IOException &#123;</span><br><span class="line">  return execute(serviceId, request, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续往下走：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//使用一个负载均衡规则选择一个ip</span><br><span class="line">protected Server getServer(ILoadBalancer loadBalancer, Object hint) &#123;</span><br><span class="line">  if (loadBalancer == null) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  // Use &#x27;default&#x27; on a null hint, or just pass it on?</span><br><span class="line">  return loadBalancer.chooseServer(hint != null ? hint : &quot;default&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后返回的Server：<br><img src="/debug-LoadBalancerInterceptor-02.png" alt="debug-LoadBalancerInterceptor-02.png"><br>应用的名称转换为ip+端口的形式。<br>然后得到要调用的主机的一些元数据，以及是否是安全的等等数据。<br><img src="/debug-LoadBalancerInterceptor-03.png" alt="debug-LoadBalancerInterceptor-03.png"><br>最后执行真正的http调用返回结果：<br><img src="/debug-LoadBalancerInterceptor-04.png" alt="debug-LoadBalancerInterceptor-04.png"></p>
<h3 id="IRule"><a href="#IRule" class="headerlink" title="IRule"></a>IRule</h3><p>Interface that defines a “Rule” for a LoadBalancer. A Rule can be thought of as a Strategy for loadbalacing. Well known loadbalancing strategies include Round Robin, Response Time based etc.<br>接口定义了负载均衡的规则。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface IRule&#123;</span><br><span class="line">    /*</span><br><span class="line">     * choose one alive server from lb.allServers or</span><br><span class="line">     * lb.upServers according to key</span><br><span class="line">     *</span><br><span class="line">     * @return choosen Server object. NULL is returned if none</span><br><span class="line">     *  server is available</span><br><span class="line">     */</span><br><span class="line">     // 选择一个server</span><br><span class="line">    public Server choose(Object key);</span><br><span class="line">    //设置负载均衡器</span><br><span class="line">    public void setLoadBalancer(ILoadBalancer lb);</span><br><span class="line"></span><br><span class="line">    public ILoadBalancer getLoadBalancer();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h4><p><img src="/IRule.png" alt="IRule.png"><br>如果我们想指定使用某一个规则 怎么定义呢?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RibbonConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @LoadBalanced</span><br><span class="line">    public RestTemplate restTemplate() &#123;</span><br><span class="line">        return new RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public IRule getRule()&#123;</span><br><span class="line">        return new RoundRobinRule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样配置就会全局生效。</p>
<p>【本期代码：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzExNTY3MjE4NzQvc3ByaW5nX2Nsb3VkX3Byb2plY3RzJUUzJTgwJTkx">https://github.com/1156721874/spring_cloud_projects】<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>spring_boot_cloud</category>
      </categories>
      <tags>
        <tag>ribbon</tag>
      </tags>
  </entry>
  <entry>
    <title>spring_boot_cloud(17)feign</title>
    <url>/2020/06/20/spring_boot_and_cloud/spring_boot_cloud(17)feign/</url>
    <content><![CDATA[<h3 id="feign"><a href="#feign" class="headerlink" title="feign"></a>feign</h3><p>feign是一个声明式的伪http客户端，它使得编写http客户端变的简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用Feign注解和JAX_RS注解。Feign支持可插拔的编码器和解码器。Feign整合了Ribbon与Hystrix，并和Eureka结合，能够实现负载均衡和断路器等效果。<br>简而言之:</p>
<ul>
<li>feign采用的基于接口的注解</li>
<li>feign整合Ribbon、Hystrix<span id="more"></span>
####feign提供的主要功能</li>
<li>可插拔的http客户端实现</li>
<li>可插拔的编解码器</li>
<li>可对http请求与响应进行gzip压缩</li>
<li>可设定压缩的阈值</li>
<li>自带负载均衡实现</li>
<li>自带熔断器</li>
<li>请求日志详细信息展示</li>
<li>自带重试处理器</li>
</ul>
<h4 id="Feign的实现流程"><a href="#Feign的实现流程" class="headerlink" title="Feign的实现流程"></a>Feign的实现流程</h4><ul>
<li>首先通过@EnableFeignClients注解开启FeignClient的功能，只有这个注解存在，才会在程序启动时开启对@FeignClient注解的包扫描</li>
<li>根据Feign的规则实现接口，并在接口上加上@FeignClient注解</li>
<li>程序启动后，会进行包扫描，扫描所有的@FeignClient注解的类，并将这些信息注入到IOC容器中。</li>
<li>当接口中的方法被调用时，通过JDK的动态代理生成具体的RequestTemplate模板对象</li>
<li>根据RequestTemplate再生成Http的request对象</li>
<li>Request对象交给Client处理，其中Client网络请求框架可以是HttpURLConnection，HttpClient与OkHttp（主要看依赖什么）</li>
<li>最后，client被封装到LoadBalanceClient类，该类结合Ribbon做到了负载均衡。</li>
</ul>
<h4 id="重拾器"><a href="#重拾器" class="headerlink" title="重拾器"></a>重拾器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//针对于所有Feign客户端生效</span><br><span class="line">@Configuration</span><br><span class="line">public class FeignClientConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Retryer feignClientRetryer() &#123;</span><br><span class="line">        return new Retryer.Default(50, SECONDS.toMillis(2), 6);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Logger.Level feignClientLogLevel() &#123;</span><br><span class="line">        return Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Retryer.Default(50, SECONDS.toMillis(2), 6):<br>50: 间隔50秒重试一次。<br>SECONDS.toMillis(2): 最大重试间隔时间。<br>6：重试次数</p>
<p>充实逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long nextMaxInterval() &#123;</span><br><span class="line">  long interval = (long) (period * Math.pow(1.5, attempt - 1));</span><br><span class="line">  return interval &gt; maxPeriod ? maxPeriod : interval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次的重试间隔是10秒，那么距离第二次的时间间隔是10<em>1.5，距离第三次的时间间隔是10</em>1.5*1.5。</p>
<p>如果重试器要想针对某一个客户端生效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FeignClient(value = &quot;eureka-client&quot;, configuration = &#123;FeignClientConfig.class&#125;)</span><br><span class="line">public interface EurekaClientFeign &#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class FeignClientConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Retryer feignClientRetryer() &#123;</span><br><span class="line">        return new Retryer.Default(50, SECONDS.toMillis(2), 6);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Logger.Level feignClientLogLevel() &#123;</span><br><span class="line">      //配置http访问日志级别</span><br><span class="line">        return Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>http日志级别，枚举：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Controls the level of logging.</span><br><span class="line"> */</span><br><span class="line">public enum Level &#123;</span><br><span class="line">  /**</span><br><span class="line">   * No logging.</span><br><span class="line">   */</span><br><span class="line">  NONE,</span><br><span class="line">  /**</span><br><span class="line">   * Log only the request method and URL and the response status code and execution time.</span><br><span class="line">   */</span><br><span class="line">  BASIC,</span><br><span class="line">  /**</span><br><span class="line">   * Log the basic information along with request and response headers.</span><br><span class="line">   */</span><br><span class="line">  HEADERS,</span><br><span class="line">  /**</span><br><span class="line">   * Log the headers, body, and metadata for both requests and responses.</span><br><span class="line">   */</span><br><span class="line">  FULL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外需要配置application.yml:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    com.shengsiyuan.feign.client.EurekaClientFeign: debug</span><br></pre></td></tr></table></figure>

<p>其他使用方式参考github的实例代码。</p>
<h3 id="Feign的底层实现逻辑分析"><a href="#Feign的底层实现逻辑分析" class="headerlink" title="Feign的底层实现逻辑分析"></a>Feign的底层实现逻辑分析</h3><p>先从app的启动开始：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">@EnableFeignClients</span><br><span class="line">public class EurekaFeignClientApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(EurekaFeignClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="EnableFeignClients注解"><a href="#EnableFeignClients注解" class="headerlink" title="EnableFeignClients注解"></a>EnableFeignClients注解</h4><p>EnableFeignClients主要是用来表示扫描Feign的一些组件的注册</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Documented</span><br><span class="line">@Import(FeignClientsRegistrar.class)</span><br><span class="line">public @interface EnableFeignClients &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册的实现在FeignClientsRegistrar里边：<br>FeignClientsRegistrar实现了spring的一些接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class FeignClientsRegistrar 	implements ImportBeanDefinitionRegistrar, ResourceLoaderAware, EnvironmentAware &#123;</span><br><span class="line">  //主要方法</span><br><span class="line">  public void registerBeanDefinitions(AnnotationMetadata metadata,BeanDefinitionRegistry registry) &#123;</span><br><span class="line">    //注册默认的配置信息</span><br><span class="line">    registerDefaultConfiguration(metadata, registry);</span><br><span class="line">    //注册客户端接口</span><br><span class="line">    registerFeignClients(metadata, registry);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进registerFeignClients(),最后来到registerFeignClient()方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void registerFeignClient(BeanDefinitionRegistry registry,</span><br><span class="line">    AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes) &#123;</span><br><span class="line">  String className = annotationMetadata.getClassName();</span><br><span class="line">  BeanDefinitionBuilder definition = BeanDefinitionBuilder</span><br><span class="line">      .genericBeanDefinition(FeignClientFactoryBean.class);</span><br><span class="line">  validate(attributes);</span><br><span class="line">  definition.addPropertyValue(&quot;url&quot;, getUrl(attributes));</span><br><span class="line">  definition.addPropertyValue(&quot;path&quot;, getPath(attributes));</span><br><span class="line">  String name = getName(attributes);</span><br><span class="line">  definition.addPropertyValue(&quot;name&quot;, name);</span><br><span class="line">  String contextId = getContextId(attributes);</span><br><span class="line">  definition.addPropertyValue(&quot;contextId&quot;, contextId);</span><br><span class="line">  definition.addPropertyValue(&quot;type&quot;, className);</span><br><span class="line">  definition.addPropertyValue(&quot;decode404&quot;, attributes.get(&quot;decode404&quot;));</span><br><span class="line">  definition.addPropertyValue(&quot;fallback&quot;, attributes.get(&quot;fallback&quot;));</span><br><span class="line">  definition.addPropertyValue(&quot;fallbackFactory&quot;, attributes.get(&quot;fallbackFactory&quot;));</span><br><span class="line">  definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">  ....</span><br></pre></td></tr></table></figure>
<p>这里一个重要的工厂类FeignClientFactoryBean:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class FeignClientFactoryBean implements FactoryBean&lt;Object&gt;, InitializingBean, ApplicationContextAware &#123;</span><br><span class="line">      ...</span><br><span class="line">      protected &lt;T&gt; T loadBalance(Feign.Builder builder, FeignContext context,HardCodedTarget&lt;T&gt; target) &#123;</span><br><span class="line">        Client client = getOptional(context, Client.class);</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">          builder.client(client);</span><br><span class="line">          Targeter targeter = get(context, Targeter.class);</span><br><span class="line">          return targeter.target(this, builder, context, target);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        throw new IllegalStateException(</span><br><span class="line">            &quot;No Feign Client for loadBalancing defined. Did you forget to include spring-cloud-starter-netflix-ribbon?&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点看loadBalance方法,方法的功能是得到客户端的代理对象<br><img src="/jdk-feign-proxy.png" alt="jdk-feign-proxy.png"></p>
<h4 id="debug验证"><a href="#debug验证" class="headerlink" title="debug验证"></a>debug验证</h4><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><p>我们首选在生成动态代理的地方加一个断点，然后debug启动:<br><img src="/jdk-feign-proxy-app-start.png" alt="jdk-feign-proxy-app-start.png"></p>
<h5 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h5><p>我们在ReflectiveFeign的invoke处打一个断点：<br>浏览器访问<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4ODg5L2dldFN0dWRlbnRCeUZlaWdu">http://localhost:8889/getStudentByFeign<i class="fa fa-external-link-alt"></i></span><br><img src="/jdk-feign-proxy-app-invoke.png" alt="jdk-feign-proxy-app-invoke.png"></p>
<p>【本期代码：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzExNTY3MjE4NzQvc3ByaW5nX2Nsb3VkX3Byb2plY3RzJUUzJTgwJTkx">https://github.com/1156721874/spring_cloud_projects】<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>spring_boot_cloud</category>
      </categories>
      <tags>
        <tag>feign</tag>
      </tags>
  </entry>
  <entry>
    <title>spring_boot_cloud(18)Hystrix</title>
    <url>/2020/06/20/spring_boot_and_cloud/spring_boot_cloud(18)Hystrix/</url>
    <content><![CDATA[<h3 id="hystrix"><a href="#hystrix" class="headerlink" title="hystrix"></a>hystrix</h3><ul>
<li>hystrix监控和断路器，我们只需要在服务接口上添加Hystrix标签，就可以实现对这个接口的监控和断路器功能</li>
<li>Hystrix dashboard控制面板，提供了一个界面，可以监控各个服务上的服务调用所消耗的时间等等。</li>
<li>Hystrix Turbine监控聚合，使用Hystrix监控，我们需要打开每一个服务实例的监控来查看，而Turbine可以帮助我们把所有的服务实例的监控信息聚合到一个地方统一查看，这样就不需要挨个打开一个个的页面一个个查看。<span id="more"></span>
<h4 id="为什么需要断路器功能"><a href="#为什么需要断路器功能" class="headerlink" title="为什么需要断路器功能"></a>为什么需要断路器功能</h4>在微服务架构中，我们呢将业务拆分成一个个的服务，服务于服务之间可以相互调用。为了保证其高可用，单个服务又必须集群部署，由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现网络延迟，此时若有大量的网络请求涌入，会形成任务积累，导致服务瘫痪，甚至导致服务“雪崩”，为了解决这个问题，就出现断路器模型。</li>
</ul>
<h4 id="Hystrix作用"><a href="#Hystrix作用" class="headerlink" title="Hystrix作用"></a>Hystrix作用</h4><p>断路器机制：当Hystrix command请求后端服务失败数量超过一定比例(50%)，断路器会切换到开路状态(open)，这时所有请求会直接失败而不会发送 到后端服务，断流器保持在开路状态一段时间后(默认5秒)，自动切换到半开路状态(half-open)，这时会判断下一次请求返回情况，如果请求成功，断路器切回闭路状态(closed)，否则重新切换到开鲁状态(open)，Hystrix的断路器就像我们家庭电路中的保险丝，一旦后端服务不可用，断路器会直接切断请求链，避免发送大量无效请求影响系统吞吐量，并且断路器有自我检测并恢复的能力。</p>
<p>fallBack: Fallback相当于是降级操作，对于查询操作，我们可以实现一个fallback方法，当请求后端服务出现异常的时候，可以使用fallback方法返回的值，fallback方法的返回值一般是设置的默认值或者来自缓存。</p>
<p>资源隔离： 在Hystrix中，主要通过线程池来实现资源隔离，通常在使用的时候我们会根据调用的远程服务划分出多个线程池，例如调用产品服务的command放入A线程池，调用账户服务的Command放入B线程池，这样做的主要优点是运行环境被隔离开了，这样就算调用服务的代码存在bug或者其他原因导致自己所在线程池被耗尽时，不会对系统的其他服务造成影响，但是带来的代价就是维护多个线程池会对系统带来额外的性能开销。</p>
<h4 id="feign继承Hystrix"><a href="#feign继承Hystrix" class="headerlink" title="feign继承Hystrix"></a>feign继承Hystrix</h4><ul>
<li>如果请求失败，断路器检测到超时，那么feign会做重试。</li>
</ul>
<h4 id="Hystrix的监控"><a href="#Hystrix的监控" class="headerlink" title="Hystrix的监控"></a>Hystrix的监控</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableEurekaClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableHystrix</span><br><span class="line">@EnableHystrixDashboard</span><br><span class="line">public class EurekaRibbonClientApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(EurekaRibbonClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ServletRegistrationBean getServlet() &#123;</span><br><span class="line">        HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet();</span><br><span class="line">        ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet);</span><br><span class="line"></span><br><span class="line">        registrationBean.setLoadOnStartup(1);</span><br><span class="line">        registrationBean.addUrlMappings(&quot;/hystrix.stream&quot;);</span><br><span class="line">        registrationBean.setName(&quot;HystrixMetricsStreamServlet&quot;);</span><br><span class="line"></span><br><span class="line">        return registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4ODg4L2h5c3RyaXguc3RyZWFt">http://localhost:8888/hystrix.stream<i class="fa fa-external-link-alt"></i></span><br>会看到都是ping的打印，这是因为我们还没有进行任何访问，访问<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4ODg4L2luZm8=">http://localhost:8888/info<i class="fa fa-external-link-alt"></i></span> 再去看就会发现不会打印ping了。</p>
<h5 id="Hystrix-Dashboard"><a href="#Hystrix-Dashboard" class="headerlink" title="Hystrix Dashboard"></a>Hystrix Dashboard</h5><p>@EnableHystrixDashboard 注解表示开启可视化监控。<br>访问路径：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4ODg4L2h5c3RyaXg=">http://localhost:8888/hystrix<i class="fa fa-external-link-alt"></i></span><br><img src="/hystrix-dashboard.png" alt="hystrix-dashboard.png"><br>监控指标：<br><img src="/hystrix-dashboard2.png" alt="hystrix-dashboard2.png"></p>
<p>【本期代码：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzExNTY3MjE4NzQvc3ByaW5nX2Nsb3VkX3Byb2plY3RzJUUzJTgwJTkx">https://github.com/1156721874/spring_cloud_projects】<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>spring_boot_cloud</category>
      </categories>
      <tags>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title>spring_boot_cloud(19)zuul</title>
    <url>/2020/06/21/spring_boot_and_cloud/spring_boot_cloud(19)zuul/</url>
    <content><![CDATA[<h3 id="zuul"><a href="#zuul" class="headerlink" title="zuul"></a>zuul</h3><p>api网关 所有的客户端请求通过这个网关访问后台的服务，他可以使用一定的路由配置来判断某一个url由那个服务来处理，并从eureka获取注册的服务来转发请求。<br><img src="/zuul1.png" alt="zuul1.png"></p>
<span id="more"></span>

<h4 id="微服务网关应该具备的要素"><a href="#微服务网关应该具备的要素" class="headerlink" title="微服务网关应该具备的要素"></a>微服务网关应该具备的要素</h4><ul>
<li>稳定性、高可用：网关是所有请求的入口，如果这里出现问题就会导致所有的服务不能对外提供服务了，可见其重要性</li>
<li>性能、并发性：既然是所有请求的入口，那就意味着并发量大，这对其性能就有很高的要求。</li>
<li>安全性：确保服务的安全，防止外部恶意访问，就像金融行业一般会对数据进行加密传输。</li>
<li>拓展性：因为各种请求都经过网关服务，所以网关上大有文章可做，是处理所有非业务功能的绝佳场所，比如流控，协议转发，日志，防刷等等。</li>
</ul>
<h4 id="zuul的主要功能"><a href="#zuul的主要功能" class="headerlink" title="zuul的主要功能"></a>zuul的主要功能</h4><ul>
<li>认证和安全， 对每一个resource进行身份认证</li>
<li>追踪和监控，实时观察后端微服务的tps，响应时间，失败数量等准确的信息。</li>
<li>日志 记录所有请求的访问日志数据，可以为日志分析和查询提供统一支持</li>
<li>动态路由 动态的将request路由到后端的服务上去。</li>
<li>压力测试 逐渐的增加访问集群的压力，来测试集群的性能</li>
<li>限流，根据一定的策略对流量进行限定</li>
<li>静态响应 直接在网关返回一些响应，而不是通过内部的服务返回响应。</li>
</ul>
<h4 id="zuul的优势"><a href="#zuul的优势" class="headerlink" title="zuul的优势"></a>zuul的优势</h4><ul>
<li>易于监控，可在微服务网关收集监控数据并将其推送到外部系统进行分析。</li>
<li>易于认证，可以在微服务网关上进行认证，然后再将其请求转发到后端的微服务，而无须在每个微服务上进行认证</li>
<li>减少了客户端与各个微服务之间的交互次数。</li>
</ul>
<h4 id="zuul介绍"><a href="#zuul介绍" class="headerlink" title="zuul介绍"></a>zuul介绍</h4><ul>
<li>zuul的主要功能是路由转发和过滤器，路由功能是微服务的一部分，比如&#x2F;api&#x2F;user转发到user服务，&#x2F;api&#x2F;shop转发到shop服务，zuul默认和ribbon结合实现了负载均衡的功能，类似于nginx转发</li>
<li>提供代理、过滤、路由等功能</li>
</ul>
<h4 id="zuul：hystrix和ribbon支持"><a href="#zuul：hystrix和ribbon支持" class="headerlink" title="zuul：hystrix和ribbon支持"></a>zuul：hystrix和ribbon支持</h4><p>zuul天生就拥有线程隔离和断路器的自我保护功能，以及对服务调用的客户端负载均衡的功能，但是需要注意，当使用path与url的映射关系来配置路由规则的时候，对于路由转发的请求不会采用hystrix command来包装，所以这类路由请求没有线程隔离和断路器的保护，并且也不会有负载均衡的能力。因此，我们在使用zuul的时候尽量使用path和serviceid的组合来进行配置，这样不仅可以保证api的网关的健壮和稳定，也能用到ribbon的客户端负载均衡功能。</p>
<h4 id="zuul的4种过滤器"><a href="#zuul的4种过滤器" class="headerlink" title="zuul的4种过滤器"></a>zuul的4种过滤器</h4><ul>
<li>zuul通过servlet来实现<ul>
<li>pre 过滤器</li>
<li>routing过滤器</li>
<li>post过滤器</li>
<li>error过滤器</li>
</ul>
</li>
</ul>
<h5 id="zuul的4种过滤器-1"><a href="#zuul的4种过滤器-1" class="headerlink" title="zuul的4种过滤器"></a>zuul的4种过滤器</h5><ul>
<li>前置(pre)：首先到达的是这里，注意这里是指Pre这种类型的过滤器，实际上不止一个过滤器，队请求路由前置加工，比如参数校验限流、鉴权</li>
<li>路由(route)：这里的是将请求转发到具体的original server（具体的微服务）上，可以在这里重写http请求</li>
<li>后置(post):这里是已经拿到的请求结果了，如果想对结果再加工一下，可以在这里，比如统计、日志。</li>
<li>错误(error)：pre或者route、post出现异常就会来到error，这里了可以统一处理异常。</li>
</ul>
<p><img src="/zuul-filter.png" alt="zuul-filter.png"></p>
<h4 id="zuul和cluster的模式"><a href="#zuul和cluster的模式" class="headerlink" title="zuul和cluster的模式"></a>zuul和cluster的模式</h4><p><img src="/zuul-cluster.png" alt="zuul-cluster.png"><br>看图说话，计算机软件世界任何问题都可以通过抽象一层的方式把问题解决，zuul就是抽象的那一层。</p>
<h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>依赖： org.springframework.cloud:spring-cloud-starter-netflix-zuul<br>引入依赖之后会默认引入eureka、ribbon、histrix的支持。</p>
<h4 id="配置路由规则"><a href="#配置路由规则" class="headerlink" title="配置路由规则"></a>配置路由规则</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zuul:</span><br><span class="line">  routes:</span><br><span class="line">    eureka-client-api:</span><br><span class="line">      path: /eureka-client-api/**</span><br><span class="line">      serviceId: eureka-client</span><br><span class="line"></span><br><span class="line">    feign-client-api:</span><br><span class="line">      path: /feign-client-api/**</span><br><span class="line">      serviceId: feign-client</span><br></pre></td></tr></table></figure>

<p>启动类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">@EnableZuulProxy</span><br><span class="line">public class EurekaZuulClientApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(EurekaZuulClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo1MDAwL2V1cmVrYS1jbGllbnQtYXBpL2luZm8=">http://localhost:5000/eureka-client-api/info<i class="fa fa-external-link-alt"></i></span><br>输出：welcome: zhangsan, your address is shanghai<br>zuul正常运行。<br>这个访问自带了 负载均衡、熔断的支持。</p>
<p>feign的访问：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo1MDAwL2ZlaWduLWNsaWVudC1hcGkvaW5mb0J5RmVpZ24=">http://localhost:5000/feign-client-api/infoByFeign<i class="fa fa-external-link-alt"></i></span><br>输出：welcome: zhangsan, your address is shanghai<br>zuul正常运行。</p>
<h4 id="直接访问微服务的问题"><a href="#直接访问微服务的问题" class="headerlink" title="直接访问微服务的问题"></a>直接访问微服务的问题</h4><p>我们配置了zuul，但是可以直接通过<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4ODg4L2luZm8lRTclOUElODQlRTYlOTYlQjklRTUlQkMlOEYlRTclOUIlQjQlRTYlOEUlQTUlRTglQUUlQkYlRTklOTclQUUlRTUlQkUlQUUlRTYlOUMlOEQlRTUlOEElQTElRUYlQkMlOEMlRTglQjYlOEElRTglQkYlODclRTQlQkElODZ6dXVsJUUzJTgwJTgy">http://localhost:8888/info的方式直接访问微服务，越过了zuul。<i class="fa fa-external-link-alt"></i></span><br>zuul想到了这一点，只需要加一个配置项即可：</p>
<h4 id="端点信息开启"><a href="#端点信息开启" class="headerlink" title="端点信息开启"></a>端点信息开启</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &#x27;*&#x27;</span><br><span class="line">  endpoint:</span><br><span class="line">    shutdown:</span><br><span class="line">      enabled: true</span><br></pre></td></tr></table></figure>
<p>shutdown可以通过url的方式关闭app，不需要Linux的命令操作。</p>
<h5 id="routes端点"><a href="#routes端点" class="headerlink" title="routes端点"></a>routes端点</h5><p>访问：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo1MDAwL2FjdHVhdG9yL3JvdXRlcw==">http://localhost:5000/actuator/routes<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  /eureka-client-api/**: &quot;eureka-client&quot;,</span><br><span class="line">  /feign-client-api/**: &quot;feign-client&quot;,</span><br><span class="line">  /feign-client/**: &quot;feign-client&quot;,</span><br><span class="line">  /eureka-ribbon-client/**: &quot;eureka-ribbon-client&quot;,</span><br><span class="line">  /eureka-client/**: &quot;eureka-client&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>罗列是当前已经好的端点的信息。【<code>/feign-client/**: &quot;feign-client&quot;</code>】【<code>/eureka-client/**: &quot;eureka-client&quot;</code>】是默认的映射，<br>可以通过[<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo1MDAwL2V1cmVrYS1jbGllbnQvaW5mb10lRTglQkYlOUIlRTglQTElOEMlRTglQUUlQkYlRTklOTclQUUlRTMlODAlODI=">http://localhost:5000/eureka-client/info]进行访问。<i class="fa fa-external-link-alt"></i></span><br>即默认的微服务的名字会做默认映射。我们可以忽略掉这种配置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zuul:</span><br><span class="line">  routes:</span><br><span class="line">    eureka-client-api:</span><br><span class="line">      path: /eureka-client-api/**</span><br><span class="line">      serviceId: eureka-client</span><br><span class="line"></span><br><span class="line">    feign-client-api:</span><br><span class="line">      path: /feign-client-api/**</span><br><span class="line">      serviceId: feign-client</span><br><span class="line"></span><br><span class="line">  ignored-patterns: /eureka-client/**, /feign-client/**</span><br></pre></td></tr></table></figure>
<p>ignored-patterns过滤掉不想映射的路径形式。<br>此时访问[<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo1MDAwL2V1cmVrYS1jbGllbnQvaW5mb10lRTUlQjAlQjElRTQlQkMlOUE0MDQlRUYlQkMlOEMlRTglQUYlODElRTYlOTglOEUlRTklODUlOEQlRTclQkQlQUUlRTYlOUMlODklRTYlOTUlODglRTMlODAlODI=">http://localhost:5000/eureka-client/info]就会404，证明配置有效。<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    com.netflix: debug</span><br></pre></td></tr></table></figure>
<p>这样请求的路由转发日志就会打印出来。</p>
<h4 id="ignored-headers"><a href="#ignored-headers" class="headerlink" title="ignored-headers"></a>ignored-headers</h4><p>访问：<br>curl -H ‘authKey:authKey’ -H ‘authKey2:authKey2’ ‘<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo1MDAwL2V1cmVrYS1jbGllbnQtYXBpL2dldFN0dWRlbnQ/bmFtZT16aGFuc2FuJmFkZHJlc3M9dGlhbmppbic=">http://localhost:5000/eureka-client-api/getStudent?name=zhansan&amp;address=tianjin&#39;<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  id: 20,</span><br><span class="line">  name: &quot;zhangsan&quot;,</span><br><span class="line">  address: &quot;guangzhou&quot;,</span><br><span class="line">  parent: &#123;</span><br><span class="line">    id: 10,</span><br><span class="line">    name: &quot;parentName&quot;,</span><br><span class="line">    address: &quot;parentAddress&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候我们在eureka-client的提供者查看日志 是能够看到header都能接受到的，证明zuul会把header的信息也会转发下去。</p>
<p>那么我们是否可以忽略掉一些header呢，答案是可以的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zuul:</span><br><span class="line">  routes:</span><br><span class="line">    eureka-client-api:</span><br><span class="line">      path: /eureka-client-api/**</span><br><span class="line">      serviceId: eureka-client</span><br><span class="line">    feign-client-api:</span><br><span class="line">      path: /feign-client-api/**</span><br><span class="line">      serviceId: feign-client</span><br><span class="line"></span><br><span class="line">  ignored-patterns: /eureka-client/**, /feign-client/**</span><br><span class="line">  ignored-headers: authKey</span><br></pre></td></tr></table></figure>
<p>配置【ignored-headers: authKey】就可以访问eureka-client-api的时候忽略掉header的配置的key【authKey】。<br>再次访问：<br>访问：<br>curl -H ‘authKey:authKey’ -H ‘authKey2:authKey2’ ‘<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo1MDAwL2V1cmVrYS1jbGllbnQtYXBpL2dldFN0dWRlbnQ/bmFtZT16aGFuc2FuJmFkZHJlc3M9dGlhbmppbic=">http://localhost:5000/eureka-client-api/getStudent?name=zhansan&amp;address=tianjin&#39;<i class="fa fa-external-link-alt"></i></span><br>在eureka-client的提供者查看日志，这个时候就不会打印authKey，zuul的规则是不配置过滤，都会传递，配置的话才会生效过滤。</p>
<h4 id="ZuulFilter"><a href="#ZuulFilter" class="headerlink" title="ZuulFilter"></a>ZuulFilter</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.netflix.zuul.ZuulFilter;</span><br><span class="line">import com.netflix.zuul.context.RequestContext;</span><br><span class="line">import com.netflix.zuul.exception.ZuulException;</span><br><span class="line">import org.springframework.cloud.netflix.zuul.filters.support.FilterConstants;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line">    public class MyZuulFilter extends ZuulFilter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String filterType() &#123;</span><br><span class="line">        return FilterConstants.PRE_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int filterOrder() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean shouldFilter() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object run() throws ZuulException &#123;</span><br><span class="line">        System.out.println(&quot;Entered MyZuulFilter run Method&quot;);</span><br><span class="line">        //获取当前请求上下文</span><br><span class="line">        RequestContext requestContext = RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request = requestContext.getRequest();</span><br><span class="line">        String method = request.getMethod();</span><br><span class="line">        String url = request.getRequestURL().toString();</span><br><span class="line">        System.out.println(&quot;method: &quot; + method + &quot;, url: &quot; + url);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import com.netflix.zuul.ZuulFilter;</span><br><span class="line">import com.shengsiyuan.zuul.filter.MyZuulFilter;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class MyZuulConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ZuulFilter myZuulFilter() &#123;</span><br><span class="line">        return new MyZuulFilter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="zuul自动装配的源码解读"><a href="#zuul自动装配的源码解读" class="headerlink" title="zuul自动装配的源码解读"></a>zuul自动装配的源码解读</h3><p>我们打开 启动的入口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">@EnableZuulProxy</span><br><span class="line">public class EurekaZuulClientApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(EurekaZuulClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>zuul的装配要从EnableZuulProxy注解开始，我们看一下EnableZuulProxy的逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableCircuitBreaker</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Import(ZuulProxyMarkerConfiguration.class)</span><br><span class="line">public @interface EnableZuulProxy &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引入了ZuulProxyMarkerConfiguration.class</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration(proxyBeanMethods = false)</span><br><span class="line">public class ZuulProxyMarkerConfiguration &#123;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	public Marker zuulProxyMarkerBean() &#123;</span><br><span class="line">		return new Marker();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	class Marker &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>alt + f7 看一下ZuulProxyMarkerConfiguration在哪里被引用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class</span><br><span class="line">    ZuulProxyMarkerConfiguration</span><br><span class="line">Found usages  (2 usages found)</span><br><span class="line">    Nested class access  (1 usage found)</span><br><span class="line">        Gradle: org.springframework.cloud:spring-cloud-netflix-zuul:2.2.2.RELEASE  (1 usage found)</span><br><span class="line">            org.springframework.cloud.netflix.zuul  (1 usage found)</span><br><span class="line">                ZuulProxyAutoConfiguration  (1 usage found)</span><br><span class="line">                    65 @ConditionalOnBean(ZuulProxyMarkerConfiguration.Marker.class)</span><br><span class="line">    Usage in .class  (1 usage found)</span><br><span class="line">        Gradle: org.springframework.cloud:spring-cloud-netflix-zuul:2.2.2.RELEASE  (1 usage found)</span><br><span class="line">            org.springframework.cloud.netflix.zuul  (1 usage found)</span><br><span class="line">                EnableZuulProxy  (1 usage found)</span><br><span class="line">                    41 @Import(ZuulProxyMarkerConfiguration.class)</span><br></pre></td></tr></table></figure>
<p>关键点： @ConditionalOnBean(ZuulProxyMarkerConfiguration.Marker.class)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration(proxyBeanMethods = false)</span><br><span class="line">@Import(&#123; RibbonCommandFactoryConfiguration.RestClientRibbonConfiguration.class,</span><br><span class="line">		RibbonCommandFactoryConfiguration.OkHttpRibbonConfiguration.class,</span><br><span class="line">		RibbonCommandFactoryConfiguration.HttpClientRibbonConfiguration.class,</span><br><span class="line">		HttpClientConfiguration.class &#125;)</span><br><span class="line">@ConditionalOnBean(ZuulProxyMarkerConfiguration.Marker.class)</span><br><span class="line">public class ZuulProxyAutoConfiguration extends ZuulServerAutoConfiguration &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ZuulProxyAutoConfiguration就是自动装配的逻辑.<br>我们打开jar包看一下：<br><img src="/zuul-autoconfigation.png" alt="zuul-autoconfigation.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.cloud.netflix.zuul.ZuulServerAutoConfiguration,\</span><br><span class="line">org.springframework.cloud.netflix.zuul.ZuulProxyAutoConfiguration</span><br></pre></td></tr></table></figure>
<p>都是自动转配的类。</p>
<h3 id="过滤器讲解"><a href="#过滤器讲解" class="headerlink" title="过滤器讲解"></a>过滤器讲解</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.cloud.netflix.zuul.filters.post</span><br><span class="line">  org.springframework.cloud.netflix.zuul.filters.post.LocationRewriteFilter</span><br><span class="line">  org.springframework.cloud.netflix.zuul.filters.post.SendErrorFilter</span><br><span class="line">  org.springframework.cloud.netflix.zuul.filters.post.SendResponseFilter</span><br><span class="line">org.springframework.cloud.netflix.zuul.filters.pre</span><br><span class="line">  org.springframework.cloud.netflix.zuul.filters.pre.DebugFilter</span><br><span class="line">  org.springframework.cloud.netflix.zuul.filters.pre.FormBodyWrapperFilter</span><br><span class="line">  org.springframework.cloud.netflix.zuul.filters.pre.PreDecorationFilter</span><br><span class="line">  org.springframework.cloud.netflix.zuul.filters.pre.Servlet30RequestWrapper</span><br><span class="line">  org.springframework.cloud.netflix.zuul.filters.pre.Servlet30WrapperFilter</span><br><span class="line">  org.springframework.cloud.netflix.zuul.filters.pre.ServletDetectionFilter</span><br><span class="line">org.springframework.cloud.netflix.zuul.filters.route</span><br><span class="line">  org.springframework.cloud.netflix.zuul.filters.route.apache</span><br><span class="line">  org.springframework.cloud.netflix.zuul.filters.route.okhttp</span><br><span class="line">  org.springframework.cloud.netflix.zuul.filters.route.support</span><br><span class="line">  org.springframework.cloud.netflix.zuul.filters.route.FallbackProvider</span><br><span class="line">  org.springframework.cloud.netflix.zuul.filters.route.RestClientRibbonCommand</span><br><span class="line">  org.springframework.cloud.netflix.zuul.filters.route.RestClientRibbonCommandFactory</span><br><span class="line">  org.springframework.cloud.netflix.zuul.filters.route.RibbonCommand</span><br><span class="line">  org.springframework.cloud.netflix.zuul.filters.route.RibbonCommandFactory</span><br><span class="line">  org.springframework.cloud.netflix.zuul.filters.route.RibbonRoutingFilter</span><br><span class="line">  org.springframework.cloud.netflix.zuul.filters.route.SendForwardFilter</span><br><span class="line">  org.springframework.cloud.netflix.zuul.filters.route.SimpleHostRoutingFilter</span><br></pre></td></tr></table></figure>

<h4 id="ServletDetectionFilter-filterOrder"><a href="#ServletDetectionFilter-filterOrder" class="headerlink" title="ServletDetectionFilter.filterOrder()"></a>ServletDetectionFilter.filterOrder()</h4><p>ServletDetectionFilter是用来探测请求是spring mvc的DispatcherServlet还是ZuulServlet的形式执行的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Must run before other filters that rely on the difference between DispatcherServlet</span><br><span class="line"> * and ZuulServlet.</span><br><span class="line"> 必须要在DispatcherServlet和ZuulServlet之前执行</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public int filterOrder() &#123;</span><br><span class="line">  return SERVLET_DETECTION_FILTER_ORDER;//-3 最先执行的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Object run() &#123;</span><br><span class="line">  RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">  HttpServletRequest request = ctx.getRequest();</span><br><span class="line">  //是否是DispatcherServlet</span><br><span class="line">  if (!(request instanceof HttpServletRequestWrapper)</span><br><span class="line">      &amp;&amp; isDispatcherServletRequest(request)) &#123;</span><br><span class="line">    ctx.set(IS_DISPATCHER_SERVLET_REQUEST_KEY, true);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    ctx.set(IS_DISPATCHER_SERVLET_REQUEST_KEY, false);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Servlet30WrapperFilter"><a href="#Servlet30WrapperFilter" class="headerlink" title="Servlet30WrapperFilter"></a>Servlet30WrapperFilter</h4><p>包装了servlet3.0规范的顾虑器，在ZuulFilter之前执行，顺序-2.</p>
<h4 id="FormBodyWrapperFilter"><a href="#FormBodyWrapperFilter" class="headerlink" title="FormBodyWrapperFilter"></a>FormBodyWrapperFilter</h4><p>在ZuulFilter之前执行，解析消息体的作用，顺序-1.</p>
<h4 id="SendErrorFilter"><a href="#SendErrorFilter" class="headerlink" title="SendErrorFilter"></a>SendErrorFilter</h4><p>异常的处理</p>
<h4 id="SendResponseFilter"><a href="#SendResponseFilter" class="headerlink" title="SendResponseFilter"></a>SendResponseFilter</h4><p>正常的响应处理</p>
<h4 id="filter的串联FilterProcessor"><a href="#filter的串联FilterProcessor" class="headerlink" title="filter的串联FilterProcessor"></a>filter的串联FilterProcessor</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * runs all filters of the filterType sType/ Use this method within filters to run custom filters by type</span><br><span class="line"> * 根据filterType执行过滤器</span><br><span class="line"> * @param sType the filterType.</span><br><span class="line"> * @return</span><br><span class="line"> * @throws Throwable throws up an arbitrary exception</span><br><span class="line"> */</span><br><span class="line">public Object runFilters(String sType) throws Throwable &#123;</span><br><span class="line">    if (RequestContext.getCurrentContext().debugRouting()) &#123;</span><br><span class="line">        Debug.addRoutingDebug(&quot;Invoking &#123;&quot; + sType + &quot;&#125; type filters&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    boolean bResult = false;</span><br><span class="line">    List&lt;ZuulFilter&gt; list = FilterLoader.getInstance().getFiltersByType(sType);</span><br><span class="line">    if (list != null) &#123;</span><br><span class="line">        for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">            ZuulFilter zuulFilter = list.get(i);</span><br><span class="line">            Object result = processZuulFilter(zuulFilter);</span><br><span class="line">            if (result != null &amp;&amp; result instanceof Boolean) &#123;</span><br><span class="line">                bResult |= ((Boolean) result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return bResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>【本期代码：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzExNTY3MjE4NzQvc3ByaW5nX2Nsb3VkX3Byb2plY3RzJUUzJTgwJTkx">https://github.com/1156721874/spring_cloud_projects】<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>spring_boot_cloud</category>
      </categories>
      <tags>
        <tag>zuul</tag>
      </tags>
  </entry>
  <entry>
    <title>spring_boot_cloud(2)Spring_Boot打包文件结构深入分析源码讲解</title>
    <url>/2019/06/07/spring_boot_and_cloud/spring_boot_cloud(2)Spring_Boot%E6%89%93%E5%8C%85%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E6%BA%90%E7%A0%81%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="gradle-的打包task"><a href="#gradle-的打包task" class="headerlink" title="gradle 的打包task"></a>gradle 的打包task</h3><p>在使用gradle构建springboot的项目时，可以查看当前项目由那些gradle的任务，我们在<span class="exturl" data-url="aHR0cHM6Ly9zdGFydC5zcHJpbmcuaW8v">springboot的初始化页面<i class="fa fa-external-link-alt"></i></span> 构建一个简单的springboot项目，然后在本地我们用vscode打开，执行.&#x2F;gradlew task得到如下输出：</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; Task :tasks</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Tasks runnable from root project</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Application tasks</span><br><span class="line">-----------------</span><br><span class="line">bootRun - Runs this project as a Spring Boot application.</span><br><span class="line"></span><br><span class="line">Build tasks</span><br><span class="line">-----------</span><br><span class="line">assemble - Assembles the outputs of this project.</span><br><span class="line">bootJar - Assembles an executable jar archive containing the main classes and their dependencies.</span><br><span class="line">build - Assembles and tests this project.</span><br><span class="line">buildDependents - Assembles and tests this project and all projects that depend on it.</span><br><span class="line">buildNeeded - Assembles and tests this project and all projects it depends on.</span><br><span class="line">classes - Assembles main classes.</span><br><span class="line">clean - Deletes the build directory.</span><br><span class="line">jar - Assembles a jar archive containing the main classes.</span><br><span class="line">testClasses - Assembles test classes.</span><br><span class="line"></span><br><span class="line">Build Setup tasks</span><br><span class="line">-----------------</span><br><span class="line">init - Initializes a new Gradle build.</span><br><span class="line">wrapper - Generates Gradle wrapper files.</span><br><span class="line"></span><br><span class="line">Documentation tasks</span><br><span class="line">-------------------</span><br><span class="line">javadoc - Generates Javadoc API documentation for the main source code.</span><br><span class="line"></span><br><span class="line">Help tasks</span><br><span class="line">----------</span><br><span class="line">buildEnvironment - Displays all buildscript dependencies declared in root project &#x27;spring-lecture&#x27;.</span><br><span class="line">components - Displays the components produced by root project &#x27;spring-lecture&#x27;. [incubating]</span><br><span class="line">dependencies - Displays all dependencies declared in root project &#x27;spring-lecture&#x27;.</span><br><span class="line">dependencyInsight - Displays the insight into a specific dependency in root project &#x27;spring-lecture&#x27;.</span><br><span class="line">dependencyManagement - Displays the dependency management declared in root project &#x27;spring-lecture&#x27;.</span><br><span class="line">dependentComponents - Displays the dependent components of components in root project &#x27;spring-lecture&#x27;. [incubating]</span><br><span class="line">help - Displays a help message.</span><br><span class="line">model - Displays the configuration model of root project &#x27;spring-lecture&#x27;. [incubating]</span><br><span class="line">projects - Displays the sub-projects of root project &#x27;spring-lecture&#x27;.</span><br><span class="line">properties - Displays the properties of root project &#x27;spring-lecture&#x27;.</span><br><span class="line">tasks - Displays the tasks runnable from root project &#x27;spring-lecture&#x27;.</span><br><span class="line"></span><br><span class="line">Verification tasks</span><br><span class="line">------------------</span><br><span class="line">check - Runs all checks.</span><br><span class="line">test - Runs the unit tests.</span><br><span class="line"></span><br><span class="line">Rules</span><br><span class="line">-----</span><br><span class="line">Pattern: clean&lt;TaskName&gt;: Cleans the output files of a task.</span><br><span class="line">Pattern: build&lt;ConfigurationName&gt;: Assembles the artifacts of a configuration.</span><br><span class="line">Pattern: upload&lt;ConfigurationName&gt;: Assembles and uploads the artifacts belonging to a configuration.</span><br><span class="line"></span><br><span class="line">To see all tasks and more detail, run gradlew tasks --all</span><br><span class="line"></span><br><span class="line">To see more detail about a task, run gradlew help --task &lt;task&gt;</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL in 2s</span><br><span class="line">1 actionable task: 1 executed</span><br></pre></td></tr></table></figure>
<p>【bootJar - Assembles an executable jar archive containing the main classes and their dependencies.】<br>这里就是将整个工程打包，生成一个自包含的jar包。<br>我们可以将当前工程下的build&#x2F;libs下的jar包删除，然后执行： .&#x2F;gradlew  bootJar<br>就会重新生成jar包。jar包名字：工程名字-版本号.jar,这个jar包我们可以直接用java运行：<br><img src="/bootjar.png" alt="bootjar.png"></p>
<p>这个jar是一个自包含的，里边包含了运行的所有依赖，使用jar命令对其解压，查看内部有哪些内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jar -xvf spring-lecture-0.0.1-SNAPSHOT.jar</span><br><span class="line"> BOOT-INF</span><br><span class="line"> META-INF</span><br><span class="line"> org</span><br></pre></td></tr></table></figure>

<h3 id="jar包目录结构"><a href="#jar包目录结构" class="headerlink" title="jar包目录结构"></a>jar包目录结构</h3><p>解压后有三个目录： BOOT-INF、 META-INF、org</p>
<p> BOOT-INF&#x2F;classes里边是我们自己的工程的代码以及配置文件， BOOT-INF&#x2F;lib里边是所有的依赖：<br> <img src="/bootjar1.png" alt="bootjar1.png"><br>META-INF下面有一个MANIFEST.MF文件，里边的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Start-Class: com.tdl.springlecture.SpringLectureApplication</span><br><span class="line">Spring-Boot-Classes: BOOT-INF/classes/</span><br><span class="line">Spring-Boot-Lib: BOOT-INF/lib/</span><br><span class="line">Spring-Boot-Version: 2.1.5.RELEASE</span><br><span class="line">Main-Class: org.springframework.boot.loader.JarLauncher</span><br></pre></td></tr></table></figure>

<p>此文件指定了入口文件，Main-Class是开始启动的类，Start-Class是我们自己写的包含main方法的全称。<br>库依赖路径，class文件路径，Spring-Boot的版本，Manifest的版本。Main-Class和Start-Class之间的关系后续介绍。<br>PS：Main-Class: org.springframework.boot.loader.JarLauncher在文件的结尾处又要换行，不然无法启动。</p>
<p>org目录是spring提供的一些class文件。<br> <img src="/bootjar2.png" alt="bootjar2.png"><br>其中就有Main-Class: org.springframework.boot.loader.JarLauncher。</p>
<p>这里有个疑问，就是org目录下JarLauncher这些class文件是从哪里来的，我们在工程里边搜索压根搜索不到，如果想看这些类的源码其实可以引入相关的依赖【org.springframework.boot:spring-boot-loader】<br> <img src="/bootjar3.png" alt="bootjar3.png"></p>
<p>在JarLauncher的源码中我们看到了BOOT-INF&#x2F;classes&#x2F;、BOOT-INF&#x2F;lib&#x2F;这些熟悉的路径，源码面前无虚假。</p>
<p>Launcher for JAR based archives. This launcher assumes that dependency jars are included inside a &#x2F;BOOT-INF&#x2F;lib directory and that application classes are included inside a &#x2F;BOOT-INF&#x2F;classes directory.</p>
<p>基于jar的启动器，启动器假设jar包的依赖在 &#x2F;BOOT-INF&#x2F;lib目录下，应用的class在&#x2F;BOOT-INF&#x2F;classes目录内。</p>
<h3 id="JarLauncher的继承体系结构与源码分析："><a href="#JarLauncher的继承体系结构与源码分析：" class="headerlink" title="JarLauncher的继承体系结构与源码分析："></a>JarLauncher的继承体系结构与源码分析：</h3><p> <img src="/bootjar4.png" alt="bootjar4.png"><br>ExecutableArchiveLauncher下面有JarLauncher和WarLauncher，我们只看JarLauncher。<br>JarLauncher由于是启动类，肯定有main方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">  new JarLauncher().launch(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里记事本实例化了一个JarLauncher的实例，然后调了父类 Launcher 的launch方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Launch the application. This method is the initial entry point that should be</span><br><span class="line"> * called by a subclass &#123;@code public static void main(String[] args)&#125; method.</span><br><span class="line"> * @param args the incoming arguments</span><br><span class="line"> * @throws Exception if the application fails to launch</span><br><span class="line"> */</span><br><span class="line"> 启动一个应用，这个方法应该被初始的入口点，这个入口点应该是一个Launcher的子类的 public static void main(String[] args)这样的方法调用</span><br><span class="line">protected void launch(String[] args) throws Exception &#123;</span><br><span class="line">  JarFile.registerUrlProtocolHandler();//不重要略过，只是注册一些关于url的属性</span><br><span class="line">  //构建一个类加载器，我么先看一下getClassPathArchives方法做了什么</span><br><span class="line">  ClassLoader classLoader = createClassLoader(getClassPathArchives());</span><br><span class="line">  launch(args, getMainClass(), classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getClassPathArchives()：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns the archives that will be used to construct the class path.</span><br><span class="line"> * @return the class path archives</span><br><span class="line"> * @throws Exception if the class path archives cannot be obtained</span><br><span class="line"> */</span><br><span class="line"> Launcher的一个抽象方法，返回用来构建class path的归档文件</span><br><span class="line">protected abstract List&lt;Archive&gt; getClassPathArchives() throws Exception;</span><br></pre></td></tr></table></figure>

<p>getClassPathArchives的子类实现位于ExecutableArchiveLauncher：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected List&lt;Archive&gt; getClassPathArchives() throws Exception &#123;</span><br><span class="line">	List&lt;Archive&gt; archives = new ArrayList&lt;&gt;(</span><br><span class="line">			this.archive.getNestedArchives(this::isNestedArchive));</span><br><span class="line">	postProcessClassPathArchives(archives);</span><br><span class="line">	return archives;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>this.archive位于ExecutableArchiveLauncher的构造器当中：
</code></pre>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  public ExecutableArchiveLauncher() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			this.archive = createArchive();</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Exception ex) &#123;</span><br><span class="line">			throw new IllegalStateException(ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  //createArchive方法的作用是返回我们要执行的jar文件的绝对路径(java -jar xxx.jar中 xxx.jar的绝对路径)：</span><br><span class="line">  protected final Archive createArchive() throws Exception &#123;</span><br><span class="line">  ProtectionDomain protectionDomain = getClass().getProtectionDomain();</span><br><span class="line">  CodeSource codeSource = protectionDomain.getCodeSource();</span><br><span class="line">  URI location = (codeSource != null) ? codeSource.getLocation().toURI() : null;</span><br><span class="line">  String path = (location != null) ? location.getSchemeSpecificPart() : null;</span><br><span class="line">  if (path == null) &#123;</span><br><span class="line">    throw new IllegalStateException(&quot;Unable to determine code source archive&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  File root = new File(path);</span><br><span class="line">  if (!root.exists()) &#123;</span><br><span class="line">    throw new IllegalStateException(</span><br><span class="line">        &quot;Unable to determine code source archive from &quot; + root);</span><br><span class="line">  &#125;</span><br><span class="line">  return (root.isDirectory() ? new ExplodedArchive(root)</span><br><span class="line">      : new JarFileArchive(root));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后【this.archive.getNestedArchives】是做的什么事情呢？<br>它Archive类里边</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns nested &#123;@link Archive&#125;s for entries that match the specified filter.</span><br><span class="line"> * @param filter the filter used to limit entries</span><br><span class="line"> * @return nested archives</span><br><span class="line"> * @throws IOException if nested archives cannot be read</span><br><span class="line"> */</span><br><span class="line"> 根据过滤器filter返回嵌套的归档文件</span><br><span class="line">List&lt;Archive&gt; getNestedArchives(EntryFilter filter) throws IOException;</span><br></pre></td></tr></table></figure>
<p>getNestedArchives实现类JarFileArchive：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">	public List&lt;Archive&gt; getNestedArchives(EntryFilter filter) throws IOException &#123;</span><br><span class="line">		List&lt;Archive&gt; nestedArchives = new ArrayList&lt;&gt;();</span><br><span class="line">    // JarFileArchive实现了 Iterable&lt;Archive.Entry&gt;</span><br><span class="line">		for (Entry entry : this) &#123;</span><br><span class="line">			if (filter.matches(entry)) &#123;</span><br><span class="line">				nestedArchives.add(getNestedArchive(entry));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return Collections.unmodifiableList(nestedArchives);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们就要看一下过滤器是过滤的那些归档，切到ExecutableArchiveLauncher的isNestedArchive：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExecutableArchiveLauncher的对isNestedArchive的抽象：</span><br><span class="line">/**</span><br><span class="line"> * Determine if the specified &#123;@link JarEntry&#125; is a nested item that should be added</span><br><span class="line"> * to the classpath. The method is called once for each entry.</span><br><span class="line"> * @param entry the jar entry</span><br><span class="line"> * @return &#123;@code true&#125; if the entry is a nested item (jar or folder)</span><br><span class="line"> */</span><br><span class="line"> 判断指定的JarEntry是不是一个嵌套的，如果是嵌套的需要添加到classpath下边，这个方法对于每个entry只被调用一次。</span><br><span class="line">protected abstract boolean isNestedArchive(Archive.Entry entry);</span><br><span class="line"></span><br><span class="line">JarLauncher的实现：</span><br><span class="line">@Override</span><br><span class="line">protected boolean isNestedArchive(Archive.Entry entry) &#123;</span><br><span class="line">  //如果是目录判断是不是BOOT-INF/classes/目录</span><br><span class="line">  if (entry.isDirectory()) &#123;</span><br><span class="line">    return entry.getName().equals(BOOT_INF_CLASSES);</span><br><span class="line">  &#125;</span><br><span class="line">  //如果是文件判断文件的前缀是不是BOOT-INF/lib/开头</span><br><span class="line">  return entry.getName().startsWith(BOOT_INF_LIB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里做一下补充：规范要求，jar文件的里边的启动类，必须是位于目录的顶层结构中，启动类不能位于嵌套的jar里边。<br>我们看到jar包的org目录下边的JarLauncher是在顶层目录的结构里边，是可以被加载的，而BOOT-INF&#x2F;lib&#x2F;里边的jar属于嵌套的（FatJar），同样BOOT-INF&#x2F;classes&#x2F;里边的类<br>没有在jar目录的顶层结构同样无法加载执行，spring要想加载执行他们需要做一些工作，后续我们会介绍，其实是spring自定义了自己的类加载器去加载。<br>回到Launcher的launch方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void launch(String[] args) throws Exception &#123;</span><br><span class="line">		JarFile.registerUrlProtocolHandler();</span><br><span class="line">		ClassLoader classLoader = createClassLoader(getClassPathArchives());</span><br><span class="line">		launch(args, getMainClass(), classLoader);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>getClassPathArchives()得到集合要么是BOOT-INF&#x2F;classes&#x2F;或者BOOT-INF&#x2F;lib&#x2F;的目录或者是他们下边的class文件或者jar依赖文件，<br>紧接着我们进入createClassLoader方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Create a classloader for the specified archives.</span><br><span class="line"> * @param archives the archives</span><br><span class="line"> * @return the classloader</span><br><span class="line"> * @throws Exception if the classloader cannot be created</span><br><span class="line"> */</span><br><span class="line">// 为指定为归档文件创建类加载器，archives是我们拿到的所有的要加载的归档，返回一个spring定义的一个自定义加载器</span><br><span class="line">protected ClassLoader createClassLoader(List&lt;Archive&gt; archives) throws Exception &#123;</span><br><span class="line">  List&lt;URL&gt; urls = new ArrayList&lt;&gt;(archives.size());</span><br><span class="line">  for (Archive archive : archives) &#123;</span><br><span class="line">    urls.add(archive.getUrl());</span><br><span class="line">  &#125;</span><br><span class="line">  //将所有归档文件的url统一放在一个集合里边</span><br><span class="line">  return createClassLoader(urls.toArray(new URL[0]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">	 * Create a classloader for the specified URLs.</span><br><span class="line">	 * @param urls the URLs</span><br><span class="line">	 * @return the classloader</span><br><span class="line">	 * @throws Exception if the classloader cannot be created</span><br><span class="line">	 */</span><br><span class="line">   //为指定的url创建一个类加载器</span><br><span class="line">	protected ClassLoader createClassLoader(URL[] urls) throws Exception &#123;</span><br><span class="line">    //自定义类加载器需要指定父加载器，getClass()是Launcher.clas 得到Launcher类的类加载器，即appClassLoader，系统类加载器</span><br><span class="line">		return new LaunchedURLClassLoader(urls, getClass().getClassLoader());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>LaunchedURLClassLoader继承了URLClassLoader：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Create a new &#123;@link LaunchedURLClassLoader&#125; instance.</span><br><span class="line"> * @param urls the URLs from which to load classes and resources</span><br><span class="line"> * @param parent the parent class loader for delegation</span><br><span class="line"> */</span><br><span class="line">public LaunchedURLClassLoader(URL[] urls, ClassLoader parent) &#123;</span><br><span class="line">   //直接调用了URLClassLoader的构造器</span><br><span class="line">	super(urls, parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>URLClassLoader的说明：<br>This class loader is used to load classes and resources from a search path of URLs referring to both JAR files and directories. Any URL that ends with a ‘&#x2F;‘ is assumed to refer to a directory. Otherwise, the URL is assumed to refer to a JAR file which will be opened as needed.<br>The AccessControlContext of the thread that created the instance of URLClassLoader will be used when subsequently loading classes and resources.<br>The classes that are loaded are by default granted permission only to access the URLs specified when the URLClassLoader was created.<br>这个类加载器用来加载类和资源，这些资源是通过搜索一个jar文件或者一个目录，任何一个以“&#x2F;”结尾的会认为是一个目录，否则会认为是一个jar文件。</p>
<p>到现在【	ClassLoader classLoader &#x3D; createClassLoader(getClassPathArchives());】得到了自定义的类加载器，接下来的【launch(args, getMainClass(), classLoader);】<br>进行加载，getMainClass()是用来找到我们自定义的含有main方法的class的名字，即com.twodragonlake.boot.MyApplication<br>我们看一下在ExecutableArchiveLauncher里边的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected String getMainClass() throws Exception &#123;</span><br><span class="line">  //得到Manifest的封装</span><br><span class="line">  Manifest manifest = this.archive.getManifest();</span><br><span class="line">  String mainClass = null;</span><br><span class="line">  if (manifest != null) &#123;</span><br><span class="line">    //我们知道，在我们解压的bootJar出来的jar包里边有一个目录里是/META-INF/下边的文件是MANIFEST.MF，里边是key-value对，</span><br><span class="line">    // manifest.getMainAttributes()就是拿到所有的key-value对，这里取的是Start-Class，即“com.twodragonlake.boot.MyApplication”这个字符串</span><br><span class="line">    mainClass = manifest.getMainAttributes().getValue(&quot;Start-Class&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  if (mainClass == null) &#123;</span><br><span class="line">    throw new IllegalStateException(</span><br><span class="line">        &quot;No &#x27;Start-Class&#x27; manifest entry specified in &quot; + this);</span><br><span class="line">  &#125;</span><br><span class="line">  return mainClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回到我们的主流承诺，进入到Launcher.launch()方法的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Launch the application given the archive file and a fully configured classloader.</span><br><span class="line"> * @param args the incoming arguments</span><br><span class="line"> * @param mainClass the main class to run</span><br><span class="line"> * @param classLoader the classloader</span><br><span class="line"> * @throws Exception if the launch fails</span><br><span class="line"> */</span><br><span class="line">protected void launch(String[] args, String mainClass, ClassLoader classLoader)</span><br><span class="line">    throws Exception &#123;</span><br><span class="line">      //当前线程的上下文类加载器模式是系统类加载器，此处将线程山下文类加载器设置为spring自定义的LaunchedURLClassLoader</span><br><span class="line">      //此处是set了LaunchedURLClassLoader，后边在某个时刻一定会get出来使用，去加载类，惯用套路</span><br><span class="line">  Thread.currentThread().setContextClassLoader(classLoader);</span><br><span class="line">  createMainMethodRunner(mainClass, args, classLoader).run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Create the &#123;@code MainMethodRunner&#125; used to launch the application.</span><br><span class="line"> * @param mainClass the main class</span><br><span class="line"> * @param args the incoming arguments</span><br><span class="line"> * @param classLoader the classloader</span><br><span class="line"> * @return the main method runner</span><br><span class="line"> */</span><br><span class="line"> //创建一个MainMethodRunner用来驱动运用</span><br><span class="line">protected MainMethodRunner createMainMethodRunner(String mainClass, String[] args,</span><br><span class="line">    ClassLoader classLoader) &#123;</span><br><span class="line">  return new MainMethodRunner(mainClass, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>MainMethodRunner的doc：<br>  Utility class that is used by Launchers to call a main method. The class containing the main method is loaded using the thread context class loader.<br>  工具类，用来执行一个main方法，包含main方法的类是由线程上下文类加载器加载（线程山下文类加载器是LaunchedURLClassLoader）</p>
<p>构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public MainMethodRunner(String mainClass, String[] args) &#123;</span><br><span class="line">  //我们应用的含有main方法的启动类的权限定名，即，com.twodragonlake.boot.MyApplication</span><br><span class="line">  this.mainClassName = mainClass;</span><br><span class="line">  //参数</span><br><span class="line">  this.args = (args != null) ? args.clone() : null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是重点，我们创建了一个MainMethodRunner，之后执行的是它的run方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public void run() throws Exception &#123;</span><br><span class="line">   //获取线程上下文类加载（LaunchedURLClassLoader），然后执行LaunchedURLClassLoader的loadClass方法，参数this.mainClassName是com.twodragonlake.boot.MyApplication</span><br><span class="line">   //即有自定义的类加载器LaunchedURLClassLoader加载我们自定义的启动类com.twodragonlake.boot.MyApplication。</span><br><span class="line">	Class&lt;?&gt; mainClass = Thread.currentThread().getContextClassLoader()</span><br><span class="line">			.loadClass(this.mainClassName);</span><br><span class="line">       //得到com.twodragonlake.boot.MyApplication的main方法</span><br><span class="line">	Method mainMethod = mainClass.getDeclaredMethod(&quot;main&quot;, String[].class);</span><br><span class="line">   //执行com.twodragonlake.boot.MyApplication的main方法。invoke方法之所以传递的第一个参数是null，是因为main方法是一个static的，不属于某个对象。</span><br><span class="line">	mainMethod.invoke(null, new Object[] &#123; this.args &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个点就是 其实我们的com.twodragonlake.boot.MyApplication的main方法，不用非得名字是main，只不过是spring规定的是main，因为spring的代码里边写死是main，spring之所以规定方法名字必须是main的原因<br>是我们可能使用idea直接右单击运行我们的应用，，所以2者结合进行兼容，规定名字必须是main。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>我们修改MyApplication的main方法加入一行打印MyApplication的加载器的代码；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class MyApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      //打印MyApplication的类加载器</span><br><span class="line">        System.out.println(&quot;MyApplication classloader: &quot;+MyApplication.class.getClassLoader());</span><br><span class="line">        SpringApplication.run(MyApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用如下两种方式运行：</p>
<ul>
<li>直接用idea右单击运行main方法</li>
<li>使用gradle bootJar打成jar包，然后使用 java -jar spring_lecture-1.0-SNAPSHOT.jar 运行</li>
</ul>
<p>他们打印的结果是一样的吗？<br>使用idea打印的结果是：<br>MyApplication classloader: sun.misc.Launcher$AppClassLoader@18b4aac2<br>即使用应用类加载器加载的。<br>使用java -jar spring_lecture-1.0-SNAPSHOT.jar运行的结果是:<br>MyApplication classloader: org.springframework.boot.loader.LaunchedURLClassLoader@5197848c<br>使用LaunchedURLClassLoader加载的。</p>
<p>辅助同类理解：<span class="exturl" data-url="aHR0cHM6Ly9pbmNvZGVyLm9yZy8yMDE5LzA3LzA1L3NwcmluZ2Jvb3QyLyMuWFNJRUtCMjU5Y1Eud2VjaGF0">https://incoder.org/2019/07/05/springboot2/#.XSIEKB259cQ.wechat<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>spring_boot_cloud</category>
      </categories>
      <tags>
        <tag>打包文件</tag>
      </tags>
  </entry>
  <entry>
    <title>spring_boot_cloud(19)config</title>
    <url>/2020/06/21/spring_boot_and_cloud/spring_boot_cloud(20)config/</url>
    <content><![CDATA[<h3 id="spring-cloud-config"><a href="#spring-cloud-config" class="headerlink" title="spring cloud config"></a>spring cloud config</h3><ul>
<li><p>用来为分布式系统中的基础设置和微服务应用提供集中化的外部配置支持，它分为服务端与客户端两个部分，其中服务端也称为分布式配置中心，他是一个独立的微服务应用，用来连接配置仓库并为客户端提供获取配置信息，加密&#x2F;解密信息等访问接口；而客户端则是微服务架构中的各个微服务应用或基础设施，他们通过指定的配置中心来管理应用资源与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。</p>
<span id="more"></span>
<p><img src="/config1.png" alt="config1.png"></p>
</li>
<li><p>spring cloud config实现了对服务端和客户端中环境变量和属性配置的抽象映射，他是除了适用于spring构建的应用程序之外，也可以在任何其他语言运行的应用程序中使用，由于spring cloud config实现的配置中心默认采用git来存储配置信息，所以使用spring cloud config构建的配置服务器，天然就支持对微服务应用配置信息的版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容。当然他也提供了对其他存储方式的支持，比如svn仓库，本地化文件系统。</p>
</li>
</ul>
<p>spring cloud config 文件与访问方式剖析</p>
<ul>
<li>仓库中的配置文件会被转换为web接口，访问请参考以下的规则<ul>
<li>{application}&#x2F;{profile}&#x2F;{label}</li>
<li>{application}-{profile}.yml</li>
<li>{label}&#x2F;{application}-{profile}.yml</li>
<li>{application}&#x2F;{profile}.preperties</li>
<li>{label}&#x2F;{application}-{profile}.properties</li>
</ul>
</li>
<li>以config-client-dev为例，它的application是config-client（这里的application是存储配置的应用程序名字），profile是dev。<br>client会根据填写的参数来选择读取对应的配置。</li>
</ul>
<p>spring cloud config的高可用<br><img src="/config2.png" alt="config2.png"></p>
<h4 id="加密解密操作"><a href="#加密解密操作" class="headerlink" title="加密解密操作"></a>加密解密操作</h4><ol>
<li>涉及到的改动点：spring-cloud-config-server、github仓库</li>
<li>oracle官方加密、解密的支持：<span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS9qYXZhL3RlY2hub2xvZ2llcy9qYXZhc2UtamNlOC1kb3dubG9hZHMuaHRtbA==">https://www.oracle.com/java/technologies/javase-jce8-downloads.html<i class="fa fa-external-link-alt"></i></span></li>
<li>下载：<span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS93ZWJhcHBzL3JlZGlyZWN0L3NpZ25vbj9uZXh0dXJsPWh0dHA6Ly9kb3dubG9hZC5vcmFjbGUuY29tL290bi1wdWIvamF2YS9qY2UvOC9qY2VfcG9saWN5LTguemlw">https://www.oracle.com/webapps/redirect/signon?nexturl=http://download.oracle.com/otn-pub/java/jce/8/jce_policy-8.zip<i class="fa fa-external-link-alt"></i></span><br>解压之后的local_policy.jar、US_export_policy.jar替换jdk目录C:\Program Files\Java\jdk1.8.0_111\jre\lib\security下的文件。</li>
<li>生成密钥对:在E:\Study\intelIde\spring_cloud_projects\spring-cloud-config-server\src\main\resources&gt;下执行：<br> keytool -genkeypair -alias config-server -keyalg RSA -keystore config-server.keystore -validity 400<br> alias:密钥对的别名<br> keyalg：生成算法<br> keystore：秘钥对文件名<br> validity：有效期400天<br> <img src="/keytool.png" alt="keytool.png"><br> config-server.keystore是一个二进制文件</li>
<li>配置: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">encrypt:</span><br><span class="line">  key-store:</span><br><span class="line">    location: config-server.keystore # 这个文件的存储位置在真实的线上环境一般是使用一个环境变量制定，不会直接写一个地址，为了安全考虑</span><br><span class="line">    alias: config-server # keytool生成秘钥的时候指定的alias</span><br><span class="line">    password: 123456</span><br><span class="line">    secret: 123456   </span><br></pre></td></tr></table></figure></li>
<li>执行加密<br>curl -X POST -d ‘<span class="exturl" data-url="aHR0cDovL3JlZGlzLWRldmVsb3AuaG9zdCYvIzM5Ow==">http://redis-develop.host&#39;<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo3MDAwL2VuY3J5cHQ=">http://localhost:7000/encrypt<i class="fa fa-external-link-alt"></i></span><br>会生成一个加密的字符串A,此时修改<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzExNTY3MjE4NzQvY29uZmlnLXRlc3QvYmxvYi9tYXN0ZXIvY29uZmlnL2NvbmZpZy1kZXZlbG9wLnByb3BlcnRpZXM=">https://github.com/1156721874/config-test/blob/master/config/config-develop.properties<i class="fa fa-external-link-alt"></i></span> 的<br>redis.host值为:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis.host=&#123;cipher&#125;加密后的字符串A</span><br></pre></td></tr></table></figure></li>
<li>解密测试<br>curl -X POST -d ‘加密后的字符串A’  <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo3MDAwL2RlY3J5cHQ=">http://localhost:7000/decrypt<i class="fa fa-external-link-alt"></i></span><br>解密之后的值会解密出来</li>
<li>浏览器访问spring-cloud-config-client的地址:<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDAwL2hvc3Rz">http://localhost:8000/hosts<i class="fa fa-external-link-alt"></i></span><br>加载出来的数据都是自动解密的。</li>
</ol>
<h4 id="动态配置生效"><a href="#动态配置生效" class="headerlink" title="动态配置生效"></a>动态配置生效</h4><p>spring-cloud-config-client配置端点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &#x27;*&#x27;</span><br><span class="line">  endpoint:</span><br><span class="line">    shutdown:</span><br><span class="line">      enabled: true</span><br></pre></td></tr></table></figure>
<p>会多出来一个refresh的端点.<br>spring-cloud-config-client属性的动态加载配置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@RefreshScope</span><br><span class="line">public class ConfigClientConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;redis.host&#125;&quot;)</span><br><span class="line">    private String redisHost;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;mysql.host&#125;&quot;)</span><br><span class="line">    private String mysqlHost;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;mongo.host&#125;&quot;)</span><br><span class="line">    private String mongoHost;</span><br><span class="line"></span><br><span class="line">    public String getRedisHost() &#123;</span><br><span class="line">        return redisHost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMysqlHost() &#123;</span><br><span class="line">        return mysqlHost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMongoHost() &#123;</span><br><span class="line">        return mongoHost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即加入一个@RefreshScope注解。<br>此时修改github的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzExNTY3MjE4NzQvY29uZmlnLXRlc3QvYmxvYi9tYXN0ZXIvY29uZmlnL2NvbmZpZy1kZXZlbG9wLnByb3BlcnRpZXMlRTklODUlOEQlRTclQkQlQUUlRUYlQkMlOEMlRTclODQlQjYlRTUlOTAlOEUlRTYlQjUlOEYlRTglQTclODglRTUlOTklQTglRTglQUUlQkYlRTklOTclQUVzcHJpbmctY2xvdWQtY29uZmlnLWNsaWVudCVFNyU5QSU4NCVFNSU5QyVCMCVFNSU5RCU4MDpodHRwOi8vbG9jYWxob3N0OjgwMDAvaG9zdHM=">https://github.com/1156721874/config-test/blob/master/config/config-develop.properties配置，然后浏览器访问spring-cloud-config-client的地址:http://localhost:8000/hosts<i class="fa fa-external-link-alt"></i></span><br>得到的数据依然没有更新。<br>为了让修改生效 我们访问：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDAwL2FjdHVhdG9yL3JlZnJlc2g=">http://localhost:8000/actuator/refresh<i class="fa fa-external-link-alt"></i></span><br>刷新一下本地的配置信息，这个时候spring-cloud-config-client和spring-cloud-config-server都会有刷新的动作，确切的说是client远程通知server更新。<br>再次访问spring-cloud-config-client的地址:<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDAwL2hvc3Rz">http://localhost:8000/hosts<i class="fa fa-external-link-alt"></i></span><br>得到的信息已经得到更新！实现了动态加载。<br>这里可以使用github的webhoke.</p>
<h4 id="客户端发现服务端的方式"><a href="#客户端发现服务端的方式" class="headerlink" title="客户端发现服务端的方式"></a>客户端发现服务端的方式</h4><p>客户端配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: config</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">#     uri: http://localhost:7000 #注释掉，使用注册中心的方式，即下边的discovery的配置方式</span><br><span class="line">      label: master</span><br><span class="line">      profile: develop</span><br><span class="line">      discovery:</span><br><span class="line">        enabled: true</span><br><span class="line">        service-id: config-server</span><br></pre></td></tr></table></figure>

<h3 id="bus消息总线实现配置自动刷新"><a href="#bus消息总线实现配置自动刷新" class="headerlink" title="bus消息总线实现配置自动刷新"></a>bus消息总线实现配置自动刷新</h3><h4 id="客户端和服务端同时加入rabbitmq的依赖："><a href="#客户端和服务端同时加入rabbitmq的依赖：" class="headerlink" title="客户端和服务端同时加入rabbitmq的依赖："></a>客户端和服务端同时加入rabbitmq的依赖：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile(</span><br><span class="line">            &quot;org.springframework.boot:spring-boot-starter-web&quot;,</span><br><span class="line">            &quot;org.springframework.cloud:spring-cloud-starter-netflix-eureka-server&quot;,</span><br><span class="line">            &quot;org.springframework.boot:spring-boot-starter-actuator&quot;,</span><br><span class="line">            &quot;org.springframework.boot:spring-boot-starter-undertow&quot;,</span><br><span class="line">            &quot;org.springframework.cloud:spring-cloud-config-server&quot;,</span><br><span class="line">            &quot;org.springframework.cloud:spring-cloud-starter-bus-amqp&quot;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    configurations &#123;</span><br><span class="line">        all*.exclude group: &#x27;org.springframework.boot&#x27;, module: &#x27;spring-boot-starter-tomcat&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="客户端和服务端的配置"><a href="#客户端和服务端的配置" class="headerlink" title="客户端和服务端的配置"></a>客户端和服务端的配置</h4><p>客户端和服务端同时配置端点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &#x27;*&#x27;</span><br><span class="line">  endpoint:</span><br><span class="line">    shutdown:</span><br><span class="line">      enabled: true</span><br></pre></td></tr></table></figure>
<p>配置端点是为了打开刷新的能力</p>
<h4 id="rabbitmq的配置"><a href="#rabbitmq的配置" class="headerlink" title="rabbitmq的配置"></a>rabbitmq的配置</h4><p>客户端和服务端同时配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmq:</span><br><span class="line">  host: localhost</span><br><span class="line">  port: 5672</span><br><span class="line">  username: config-server</span><br><span class="line">  password: config-server</span><br></pre></td></tr></table></figure>

<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ul>
<li>启动服务端、客户端，在服务端会看到一个[&#x2F;actuator&#x2F;bus-refresh]</li>
<li>改变github的一个配置</li>
<li>刷新server: curl -X POST <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo3MDAwL2FjdHVhdG9yL2J1cy1yZWZyZXNo">http://localhost:7000/actuator/bus-refresh<i class="fa fa-external-link-alt"></i></span></li>
<li>服务端刷新完之后，会通过bus总线通知所有注册的客户端，所有的客户端也会得到这样一个通知，使得配置在所有的客户端生效</li>
<li>访问其中一个客户端：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDAwL2hvc3Rz">http://localhost:8000/hosts<i class="fa fa-external-link-alt"></i></span> 会发现配置生效了。</li>
</ul>
<p>和之前说的刷新客户端的方式，这种bus的方式是刷新的服务端，然后通知到所有的客户端。但是也是离不开webhoke的帮助</p>
<h4 id="本期代码："><a href="#本期代码：" class="headerlink" title="本期代码："></a>本期代码：</h4><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzExNTY3MjE4NzQvc3ByaW5nX2Nsb3VkX3Byb2plY3RzL3RyZWUvbWFzdGVyL3NwcmluZy1jbG91ZC1jb25maWctc2VydmVy">https://github.com/1156721874/spring_cloud_projects/tree/master/spring-cloud-config-server<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzExNTY3MjE4NzQvc3ByaW5nX2Nsb3VkX3Byb2plY3RzL3RyZWUvbWFzdGVyL3NwcmluZy1jbG91ZC1jb25maWctY2xpZW50">https://github.com/1156721874/spring_cloud_projects/tree/master/spring-cloud-config-client<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzExNTY3MjE4NzQvY29uZmlnLXRlc3Q=">https://github.com/1156721874/config-test<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>spring_boot_cloud</category>
      </categories>
      <tags>
        <tag>config</tag>
      </tags>
  </entry>
  <entry>
    <title>spring_boot_cloud(20)sleuth</title>
    <url>/2020/06/25/spring_boot_and_cloud/spring_boot_cloud(20)sleuth/</url>
    <content><![CDATA[<h3 id="sleuth"><a href="#sleuth" class="headerlink" title="sleuth"></a>sleuth</h3><ul>
<li><p>警犬、监视、追踪的意思</p>
</li>
<li><p>服务链路分布式追踪</p>
</li>
<li><p>微服务架构是一个分布式架构 ，他按业务划分服务单元，一个分布式系统往往有很多个服务单元，由于服务单元数量众多，业务的复杂性，如果出现了错误和异常，很难去定位。主要体现在一个请求可能需要调用很多个服务，而内部服务的调用复杂性决定了问题难以定位，所以微服务架构中，必须实现分布式链路追踪，去跟进一个请求到底有哪些服务参与，参与的顺序又是怎样的，从而达到每个请求的步骤清晰可见，除了问题很快定位。</p>
</li>
<li><p>举个例子，在服务系统中，一个来自用户的请求，想达到前端A（如前端界面），然后通过远程调用，到达系统的中间件B、C（如负载均衡、网关），最后到达后端服务D、E，后端经过一系列的业务逻辑计算后将数据返回给用户，对于这样一个请求，经历了这么多服务，怎样将它的请求过程的数据记录下来呢？这就需要用到服务链路追踪。</p>
</li>
<li><p>目前，链路追踪组件有google的Dapper，Twitter的ziplin等，他们都是非常优秀的链路追踪开源组件。</p>
</li>
<li><p>spring cloud sleuth采用的是google的开源项目Dapper的专业术语。</p>
<span id="more"></span>
<h4 id="sleuth重要概念"><a href="#sleuth重要概念" class="headerlink" title="sleuth重要概念"></a>sleuth重要概念</h4></li>
<li><p>span：基本工作单元，发送一个远程调度任务就会产生一个span，span是一个64位id唯一标示的，，trace是用另一个64位id唯一标示的，span还有其他数据信息，比如摘要、时间戳时间、span的id、以及进度id。</p>
</li>
<li><p>trace：一系列span组成的一个树状结构，请求一个微服务系统的api接口，这个api接口需要调用多个微服务，调用每个微服务都会产生一个新的span，所有由这个请求产生的span组成了这个trace</p>
</li>
<li><p>annotation：用来及时记录一个事件，一些核心注解用来定义一个请求的开始和结束<br>Annotation: is used to record existence of an event in time. Some of the core annotations used to define the start and stop of a request are:</p>
<ul>
<li><p>cs - Client Sent - The client has made a request. This annotation depicts the start of the span.</p>
</li>
<li><p>sr - Server Received - The server side got the request and will start processing it. If one subtracts the cs timestamp from this timestamp one will receive the network latency.</p>
</li>
<li><p>ss - Server Sent - Annotated upon completion of request processing (when the response got sent back to the client). If one subtracts the sr timestamp from this timestamp one will receive the time needed by the server side to process the request.</p>
</li>
<li><p>cr - Client Received - Signifies the end of the span. The client has successfully received the response from the server side. If one subtracts the cs timestamp from this timestamp one will receive the whole time needed by the client to receive the response from the server.</p>
</li>
</ul>
</li>
</ul>
<h4 id="配置依赖"><a href="#配置依赖" class="headerlink" title="配置依赖"></a>配置依赖</h4><p>spring-cloud-eureka-client\spring-cloud-feign 增加依赖<br>org.springframework.cloud:spring-cloud-starter-sleuth</p>
<h4 id="spring-cloud-eureka-client配置日志级别"><a href="#spring-cloud-eureka-client配置日志级别" class="headerlink" title="spring-cloud-eureka-client配置日志级别"></a>spring-cloud-eureka-client配置日志级别</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    root: trace</span><br></pre></td></tr></table></figure>

<p>启动spring-cloud-eureka、spring-cloud-eureka-client、spring-cloud-feign<br>在spring-cloud-feign查看日志：<br>2020-06-25 14:27:48.041 DEBUG [feign-client,e095ccf4d53b7992,e095ccf4d53b7992,true] 87068 — [  XNIO-1 task-1] c.s.feign.client.EurekaClientFeign       : [EurekaClientFeign#infoByFeign] —&gt; GET <span class="exturl" data-url="aHR0cDovL2V1cmVrYS1jbGllbnQvaW5mbw==">http://eureka-client/info<i class="fa fa-external-link-alt"></i></span> HTTP&#x2F;1.1<br>feign-client是客户端id。<br>e095ccf4d53b7992是traceid。<br>e095ccf4d53b7992是spanid<br>true 指的是生成的请求日志是否是转发到日志服务器上。</p>
<h3 id="采样器"><a href="#采样器" class="headerlink" title="采样器"></a>采样器</h3><h4 id="RateLimitingSampler"><a href="#RateLimitingSampler" class="headerlink" title="RateLimitingSampler"></a>RateLimitingSampler</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class RateLimitingSampler extends Sampler &#123;</span><br><span class="line"></span><br><span class="line">	private final Sampler sampler;</span><br><span class="line"></span><br><span class="line">	RateLimitingSampler(SamplerProperties configuration) &#123;</span><br><span class="line">		this.sampler = brave.sampler.RateLimitingSampler.create(rateLimit(configuration));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Integer rateLimit(SamplerProperties configuration) &#123;</span><br><span class="line">		return configuration.getRate() != null ? configuration.getRate() : 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public boolean isSampled(long traceId) &#123;</span><br><span class="line">		return this.sampler.isSampled(traceId);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RateLimitingSampler是默认的采样器，继承了Sampler:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public abstract class Sampler &#123;</span><br><span class="line"></span><br><span class="line">  //永远采样</span><br><span class="line">  public static final Sampler ALWAYS_SAMPLE = new Sampler() &#123;</span><br><span class="line">    @Override public boolean isSampled(long traceId) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public String toString() &#123;</span><br><span class="line">      return &quot;AlwaysSample&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // 永远不采样</span><br><span class="line">  public static final Sampler NEVER_SAMPLE = new Sampler() &#123;</span><br><span class="line">    @Override public boolean isSampled(long traceId) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public String toString() &#123;</span><br><span class="line">      return &quot;NeverSample&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  public abstract boolean isSampled(long traceId);</span><br><span class="line"></span><br><span class="line">  public static Sampler create(float probability) &#123;</span><br><span class="line">    return CountingSampler.create(probability);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Sampler属于brave.sampler包下边是org.springframework.cloud:spring-cloud-starter-zipkin依赖里边的。</p>
<h5 id="自定义采样器"><a href="#自定义采样器" class="headerlink" title="自定义采样器:"></a>自定义采样器:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class FeignClientConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Retryer feignClientRetryer() &#123;</span><br><span class="line">        return new Retryer.Default(50, SECONDS.toMillis(2), 6);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Logger.Level feignClientLogLevel() &#123;</span><br><span class="line">        return Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">    //配置采样器</span><br><span class="line">    @Bean</span><br><span class="line">    public Sampler mySampler() &#123;</span><br><span class="line">        return Sampler.NEVER_SAMPLE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="配置采样率"><a href="#配置采样率" class="headerlink" title="配置采样率"></a>配置采样率</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: feign-client</span><br><span class="line">  sleuth:</span><br><span class="line">    sampler:</span><br><span class="line">      rate: 10</span><br></pre></td></tr></table></figure>

<h3 id="日志存储"><a href="#日志存储" class="headerlink" title="日志存储"></a>日志存储</h3><ul>
<li>目前。链路追踪组件有google的Dapper，Twitter的zipkin等，他们都是非常优秀的链路追踪开源组件。</li>
<li>spring cloud sleuth采用的是google的开源项目Dapper的专业术语</li>
</ul>
<h4 id="zipKin"><a href="#zipKin" class="headerlink" title="zipKin"></a>zipKin</h4><ul>
<li>下载zipkin.jar：<span class="exturl" data-url="aHR0cHM6Ly9zZWFyY2gubWF2ZW4ub3JnL3JlbW90ZV9jb250ZW50P2c9aW8uemlwa2luJmE9emlwa2luLXNlcnZlciZ2PUxBVEVTVCZjPWV4ZWM=">https://search.maven.org/remote_content?g=io.zipkin&amp;a=zipkin-server&amp;v=LATEST&amp;c=exec<i class="fa fa-external-link-alt"></i></span></li>
<li>运行 java -jar zipkin.jar</li>
<li>访问: <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo5NDExLw==">http://localhost:9411<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h4 id="配置并将日志推到zipkin"><a href="#配置并将日志推到zipkin" class="headerlink" title="配置并将日志推到zipkin"></a>配置并将日志推到zipkin</h4><p>spring-cloud-feign工程配置gradle依赖：org.springframework.cloud:spring-cloud-starter-zipkin<br>spring-cloud-eureka-client工程配置gradle依赖：org.springframework.cloud:spring-cloud-starter-zipkin<br>spring-cloud-feign、spring-cloud-eureka-client工程配置resources&#x2F;application.yml:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zipkin:</span><br><span class="line">  enabled: true</span><br><span class="line">  base-url: http://localhost:9411</span><br></pre></td></tr></table></figure>
<p>然后再次做一下请求<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4ODg5L2luZm9CeUZlaWduJUVGJUJDJThDJUU0JUJBJUE3JUU3JTk0JTlGJUU0JUI4JTgwJUU0JUI4JThCJUU2JTk3JUE1JUU1JUJGJTk3JUUzJTgwJTgy">http://localhost:8889/infoByFeign，产生一下日志。<i class="fa fa-external-link-alt"></i></span><br>默认zipkin是存储在内存里边的，当zipkin重启之后，日志会消息。</p>
<h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29wZW56aXBraW4vemlwa2luL3RyZWUvbWFzdGVyL3ppcGtpbi1zdG9yYWdl">https://github.com/openzipkin/zipkin/tree/master/zipkin-storage<i class="fa fa-external-link-alt"></i></span><br>使用mysql存储：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29wZW56aXBraW4vemlwa2luL3RyZWUvbWFzdGVyL3ppcGtpbi1zdG9yYWdlL215c3FsLXYx">https://github.com/openzipkin/zipkin/tree/master/zipkin-storage/mysql-v1<i class="fa fa-external-link-alt"></i></span><br>需要建立zipkin数据库，然后执行提供的建表语句</p>
<p>重启zipkin，指定数据库：java -jar zipkin.jar –STORAGE_TYPE&#x3D;mysql –MYSQL_HOST&#x3D;localhost,–MYSQL_TCP_PORT&#x3D;3306 –MYSQL_USER&#x3D;root –MYSQL_PASS&#x3D;root<br>然后再次做一下请求<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4ODg5L2luZm9CeUZlaWduJUVGJUJDJThDJUU0JUJBJUE3JUU3JTk0JTlGJUU0JUI4JTgwJUU0JUI4JThCJUU2JTk3JUE1JUU1JUJGJTk3JUVGJUJDJThDJUU4JUJGJTk5JUU2JUFDJUExJUU3JTk0JTlGJUU2JTg4JTkwJUU3JTlBJTg0JUU2JTk3JUE1JUU1JUJGJTk3JUU5JTgzJUJEJUU0JUJDJTlBJUU1JUFEJTk4JUU1JTgyJUE4JUU1JTlDJUE4bXlzcWwlRTklODclOEMlRTglQkUlQjklRUYlQkMlOENlcyVFRiVCQyU4Q2Nhc3NhbmRyYSVFOSU4MyVCRCVFNiU5OCVBRiVFNSU5MCU4QyVFNiVBMCVCNyVFNyU5QSU4NCVFOSU4MSU5MyVFNyU5MCU4NiVFMyU4MCU4Mg==">http://localhost:8889/infoByFeign，产生一下日志，这次生成的日志都会存储在mysql里边，es，cassandra都是同样的道理。<i class="fa fa-external-link-alt"></i></span></p>
<p>本章需要的代码：<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzExNTY3MjE4NzQvc3ByaW5nX2Nsb3VkX3Byb2plY3RzL3RyZWUvbWFzdGVyL3NwcmluZy1jbG91ZC1ldXJla2E=">https://github.com/1156721874/spring_cloud_projects/tree/master/spring-cloud-eureka<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzExNTY3MjE4NzQvc3ByaW5nX2Nsb3VkX3Byb2plY3RzL3RyZWUvbWFzdGVyL3NwcmluZy1jbG91ZC1ldXJla2EtY2xpZW50">https://github.com/1156721874/spring_cloud_projects/tree/master/spring-cloud-eureka-client<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzExNTY3MjE4NzQvc3ByaW5nX2Nsb3VkX3Byb2plY3RzL3RyZWUvbWFzdGVyL3NwcmluZy1jbG91ZC1mZWlnbg==">https://github.com/1156721874/spring_cloud_projects/tree/master/spring-cloud-feign<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>spring_boot_cloud</category>
      </categories>
      <tags>
        <tag>config</tag>
      </tags>
  </entry>
  <entry>
    <title>spring_boot_cloud(21)distribute_transaction</title>
    <url>/2020/06/25/spring_boot_and_cloud/spring_boot_cloud(21)distribute_transaction/</url>
    <content><![CDATA[<h3 id="分布式事物"><a href="#分布式事物" class="headerlink" title="分布式事物"></a>分布式事物</h3><ul>
<li>2pc</li>
<li>3pc</li>
<li>tcc</li>
<li>事物的最终一致性<span id="more"></span>
<h4 id="2pc-2阶段提交"><a href="#2pc-2阶段提交" class="headerlink" title="2pc 2阶段提交"></a>2pc 2阶段提交</h4><img src="/2pc.png" alt="2pc.png"></li>
<li>角色：Transaction Manager、Resource Manager</li>
<li>预提交阶段<br>Transaction Manager给Resource Manager发信息，进行预提交，然后Resource Manager会把预提交的结果反馈给Transaction Manager</li>
<li>提交阶段<br>如果预提交阶段所有的Resource Manager都是返回OK，那么进行真正的提交，Transaction Manager给所有的Resource Manager发信息，全部提交，然后所有的Resource Manager都会给Transaction Manager返回提交结果。</li>
<li>异常处理，如果预提交阶段其中任何一个Resource Manager返回失败，那么Transaction Manager都会给所有Resource Manager发送回滚。<br>同样的道理如果是提交阶段任何一个Resource Manager返回失败，那么Transaction Manager也会给所有Resource Manager发送回滚信息。</li>
<li>Resource Manager里边是一个jvm实例，可以使用spring的事物管理器管理提交和回滚。</li>
<li>不完美处：在预提交处会对所有涉及的资源资源进行锁定，第二是Transaction Manager存在单点故障，导致整个轮子不可用</li>
</ul>
<h4 id="3pc三阶段提交"><a href="#3pc三阶段提交" class="headerlink" title="3pc三阶段提交"></a>3pc三阶段提交</h4><p> 3pc其实是对2pc的第一阶段 一分为二。同时针对Transaction Manager、Resource Manager都设置里的超时，如果超时了不会进行提交。</p>
<ul>
<li>can commit<br>  我能提交吗</li>
<li>预提交</li>
<li>提交</li>
</ul>
<h4 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h4><p>try confirm cancel<br><img src="/tcc.png" alt="tcc.png"></p>
<ul>
<li>try<br>main发起者对每个依赖的服务ABCD执行try，try的内容是，比如：下单，对A减100，对B加100，对C减库存，对D积分加20.<br>ABCD每个服务在try阶段都是对自己业务表的一个备用字段进行加减，不是对真正的业务字段进行操作，只是尝试，try一下。</li>
<li>confirm<br>  如果try阶段都是返回成功，那么执行confirm阶段，这个阶段main会给ABCD发送真正提交的命令，然后ABCD收到命令之后执行真正的业务字段的加减操作和提交。</li>
<li>cancel<br>如果在try或者confirm阶段，ABCD任何一个返回失败，那么main会给ABCD发送cancel的命令，撤销操作。</li>
</ul>
<p>tcc是同步的模式。</p>
<h4 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h4><p>异步的事物一致性</p>
]]></content>
      <categories>
        <category>spring_boot_cloud</category>
      </categories>
      <tags>
        <tag>distribute_transaction</tag>
      </tags>
  </entry>
  <entry>
    <title>spring_boot_cloud(3)JDWP远程调试详解以及调试spring-boot-loader的启动与加载全流程</title>
    <url>/2019/06/08/spring_boot_and_cloud/spring_boot_cloud(3)JDWP%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E8%B0%83%E8%AF%95spring-boot-loader%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E5%8A%A0%E8%BD%BD%E5%85%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="JDWP"><a href="#JDWP" class="headerlink" title="JDWP"></a>JDWP</h1><p>Java Debug Wire Protocol, Java调试协议</p>
<span id="more"></span>

<p>命令： java -agentlib:jdwp&#x3D;help</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java Debugger JDWP Agent Library</span><br><span class="line">--------------------------------</span><br><span class="line"></span><br><span class="line">(see http://java.sun.com/products/jpda for more information)</span><br><span class="line"></span><br><span class="line">jdwp usage: java -agentlib:jdwp=[help]|[&lt;option&gt;=&lt;value&gt;, ...]</span><br><span class="line"></span><br><span class="line">Option Name and Value            Description                       Default  </span><br><span class="line">---------------------            -----------                       -------</span><br><span class="line">suspend=y|n                      wait on startup?                  y          启动的时候是否等待建立远程的调试的socket连接</span><br><span class="line">transport=&lt;name&gt;                 transport spec                    none       传输协议</span><br><span class="line">address=&lt;listen/attach address&gt;  transport spec                    &quot;&quot;         监听地址</span><br><span class="line">server=y|n                       listen for debugger?              n          是否监听调试</span><br><span class="line">launch=&lt;command line&gt;            run debugger on event             none       时间发生的时候进入调试</span><br><span class="line">onthrow=&lt;exception name&gt;         debug on throw                    none       </span><br><span class="line">onuncaught=y|n                   debug on any uncaught?            n</span><br><span class="line">timeout=&lt;timeout value&gt;          for listen/attach in milliseconds n</span><br><span class="line">mutf8=y|n                        output modified utf-8             n</span><br><span class="line">quiet=y|n</span><br><span class="line"></span><br><span class="line">examples</span><br><span class="line"></span><br><span class="line">Using socket connect to a debugger at a specific address[客户端]:</span><br><span class="line">java -agentlib:jdwp=transport=dt_socket,address=localhost:8080</span><br><span class="line"></span><br><span class="line">Using sockets listen for a debugger t attach[服务器]:</span><br><span class="line">java -agentlib:jdwp=transport=dt_socket,server=y,suspend=y</span><br></pre></td></tr></table></figure>

<p>接下来我们使用监听的方式启动我们的应用:<br>运行命令：java -agentlib:jdwp&#x3D;transport&#x3D;dt_socket,server&#x3D;y,suspend&#x3D;y,address&#x3D;5050  -jar spring_lecture-1.0-SNAPSHOT.jar<br>服务端打印：Listening for transport dt_socket at address: 5050<br>idea的设置：<br><img src="/jdwp1.png" alt="jdwp1.png"><br>然后debug此设置，此时在JarLaunche（gradle要导入io.spring.gradle:dependency-management-plugin:1.0.7.RELEASE）r的main方法的断点就会进入debug模式。<br><img src="/jdwp2.png" alt="jdwp2.png"></p>
<p>我们debug到加载archives的地方可以看到spring的加载器加载的是那些东西，就是archives里边的jar包<br><img src="/jdwp3.png" alt="jdwp3.png"></p>
]]></content>
      <categories>
        <category>spring_boot_cloud</category>
      </categories>
      <tags>
        <tag>JDWP远程调试，调试spring-boot-loader</tag>
      </tags>
  </entry>
  <entry>
    <title>spring_boot_cloud(4)SpringBootApplication与Configuration注解深度解析</title>
    <url>/2019/06/23/spring_boot_and_cloud/spring_boot_cloud(4)SpringBootApplication%E4%B8%8EConfiguration%E6%B3%A8%E8%A7%A3%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>有三个注解组成：</p>
<span id="more"></span>
<p>@SpringBootConfiguration<br>@EnableAutoConfiguration<br>@ComponentScan</p>
<h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Configuration</span><br><span class="line">public @interface SpringBootConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先@SpringBootConfiguration是一个@Configuration，@SpringBootConfiguration可以作为@Configuration的替换方法，应用的配置会自动找到并且配置，应用的项目应该只使用一次在@SpringBootApplication里边。<br><code>@Configuration</code>是 context 包里边，表示一个类声明了多个bean和方法，用来生成bean。<br>使用事例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">   public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">       @Bean</span><br><span class="line">       public MyBean myBean() &#123;</span><br><span class="line">           // instantiate, configure and return bean ...</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="引导-Configuration-类："><a href="#引导-Configuration-类：" class="headerlink" title="引导 @Configuration 类："></a>引导 @Configuration 类：</h3><p>@Configuration通常通过AnnotationConfigApplicationContext 或者 具有web功能的contextAnnotationConfigWebApplicationContext引导，下面是一个实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();</span><br><span class="line"> ctx.register(AppConfig.class);</span><br><span class="line"> ctx.refresh();</span><br><span class="line"> MyBean myBean = ctx.getBean(MyBean.class);</span><br><span class="line"> // use myBean ...</span><br></pre></td></tr></table></figure>

<p>查看AnnotationConfigApplicationContext、AnnotationConfigWebApplicationContext的官方文档获得更多信息。</p>
<h4 id="通过XML的方式："><a href="#通过XML的方式：" class="headerlink" title="通过XML的方式："></a>通过XML的方式：</h4><beans>
     <context:annotation-config/>
     <bean class="com.acme.AppConfig"/>
</beans>



<h4 id="通过组件扫描的方式："><a href="#通过组件扫描的方式：" class="headerlink" title="通过组件扫描的方式："></a>通过组件扫描的方式：</h4><p> @Configuration是一种元注解，可以通过组件扫描。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">       private final SomeBean someBean;</span><br><span class="line"></span><br><span class="line">       public AppConfig(SomeBean someBean) &#123;</span><br><span class="line">           this.someBean = someBean;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // @Bean definition using &quot;SomeBean&quot;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过ComponentScan的方式："><a href="#通过ComponentScan的方式：" class="headerlink" title="通过ComponentScan的方式："></a>通过ComponentScan的方式：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.acme.app.services&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    // various @Bean definitions ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="通过环境API："><a href="#通过环境API：" class="headerlink" title="通过环境API："></a>通过环境API：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@PropertySource(&quot;classpath:/com/acme/app.properties&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Inject Environment env;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        return new MyBean(env.getProperty(&quot;bean.name&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过-Value-annotation"><a href="#通过-Value-annotation" class="headerlink" title="通过 @Value annotation"></a>通过 @Value annotation</h4><p>Externalized values may be injected into <code>@Configuration</code> classes using the <code>@Value</code> annotation:<br>   @Configuration<br>   @PropertySource(“classpath:&#x2F;com&#x2F;acme&#x2F;app.properties”)<br>   public class AppConfig {</p>
<pre><code>   @Value(&quot;$&#123;bean.name&#125;&quot;) String beanName;

   @Bean
   public MyBean myBean() &#123;
       return new MyBean(beanName);
   &#125;
</code></pre>
<p>   }</p>
<h4 id="组合Configuration"><a href="#组合Configuration" class="headerlink" title="组合Configuration"></a>组合Configuration</h4><p>使用@import对配置类进行组合。相当于<import>标签，@Configuration是被spring容器进行管理的，@Configuration类也会被注入(通过构造器)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DatabaseConfig &#123;</span><br><span class="line"></span><br><span class="line">       @Bean</span><br><span class="line">       public DataSource dataSource() &#123;</span><br><span class="line">           // instantiate, configure and return DataSource</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Configuration</span><br><span class="line">   @Import(DatabaseConfig.class)</span><br><span class="line">   public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">       private final DatabaseConfig dataConfig;</span><br><span class="line"></span><br><span class="line">       public AppConfig(DatabaseConfig dataConfig) &#123;</span><br><span class="line">           this.dataConfig = dataConfig;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       @Bean</span><br><span class="line">       public MyBean myBean() &#123;</span><br><span class="line">           // reference the dataSource() bean method</span><br><span class="line">           return new MyBean(dataConfig.dataSource());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这样不管是AppConfig还是被注入的DatabaseConfig都可以注册的AppConfig来从spring context引导启动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new AnnotationConfigApplicationContext(AppConfig.class);</span><br></pre></td></tr></table></figure>

<h4 id="使用-Profile-注解"><a href="#使用-Profile-注解" class="headerlink" title="使用@Profile 注解"></a>使用@Profile 注解</h4><p><code>@Configuration</code> 可以被@Profile 注解标记</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Profile(&quot;development&quot;)</span><br><span class="line">@Configuration</span><br><span class="line">public class EmbeddedDatabaseConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        // instantiate, configure and return embedded DataSource</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Profile(&quot;production&quot;)</span><br><span class="line">@Configuration</span><br><span class="line">public class ProductionDatabaseConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        // instantiate, configure and return production DataSource</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ProfileDatabaseConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(&quot;dataSource&quot;)</span><br><span class="line">    @Profile(&quot;development&quot;)</span><br><span class="line">    public DataSource embeddedDatabase() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(&quot;dataSource&quot;)</span><br><span class="line">    @Profile(&quot;production&quot;)</span><br><span class="line">    public DataSource productionDatabase() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式如果用apollo的中心化，Profile是用不上的，如果是spring cloud可能还能用到。</p>
<h4 id="使用-ImportResource-annotation-加载spring-xml配置文件"><a href="#使用-ImportResource-annotation-加载spring-xml配置文件" class="headerlink" title="使用 @ImportResource annotation 加载spring xml配置文件"></a>使用 @ImportResource annotation 加载spring xml配置文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line"> @ImportResource(&quot;classpath:/com/acme/database-config.xml&quot;)</span><br><span class="line"> public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">     @Inject DataSource dataSource; // from XML</span><br><span class="line"></span><br><span class="line">     @Bean</span><br><span class="line">     public MyBean myBean() &#123;</span><br><span class="line">         // inject the XML-defined dataSource bean</span><br><span class="line">         return new MyBean(this.dataSource);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="嵌套的-Configuration-classes"><a href="#嵌套的-Configuration-classes" class="headerlink" title="嵌套的@Configuration classes"></a>嵌套的@Configuration classes</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">   public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">       @Inject DataSource dataSource;</span><br><span class="line"></span><br><span class="line">       @Bean</span><br><span class="line">       public MyBean myBean() &#123;</span><br><span class="line">           return new MyBean(dataSource);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       @Configuration</span><br><span class="line">       static class DatabaseConfig &#123;</span><br><span class="line">           @Bean</span><br><span class="line">           DataSource dataSource() &#123;</span><br><span class="line">               return new EmbeddedDatabaseBuilder().build();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这种方式避免了使用@Import ，当使用dataSource的时候 就会去寻找DataSource的配置。</p>
<h4 id="配置延迟加载"><a href="#配置延迟加载" class="headerlink" title="配置延迟加载"></a>配置延迟加载</h4><p>被 @Bean修饰的方法，会在容器启动的时候就会实例化。@Configuration 也可以和 @Lazy搭配使用，而且单个的bean也可以和 @Lazy 搭配使用，表示@Configuration修饰的类里边所有被 @Bean 修饰的方法都会被延迟加载。</p>
<h4 id="Configuration对测试支持"><a href="#Configuration对测试支持" class="headerlink" title="@Configuration对测试支持"></a>@Configuration对测试支持</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@ContextConfiguration(classes = &#123;AppConfig.class, DatabaseConfig.class&#125;)</span><br><span class="line">public class MyTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired MyBean myBean;</span><br><span class="line"></span><br><span class="line">    @Autowired DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        // assertions against myBean ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Configuratione的一些约束"><a href="#Configuratione的一些约束" class="headerlink" title="@Configuratione的一些约束"></a>@Configuratione的一些约束</h4><ul>
<li>@Configuratione必须被提供作为一个类（可以子类增强）</li>
<li>@Configuratione 修饰的类 不能是final的</li>
<li>@Configuratione 不能声明在一个方法的内部</li>
<li>嵌套的 @Configuratione 必须是静态的 static</li>
</ul>
<h3 id="EnableAutoConfiguration-作用和分析"><a href="#EnableAutoConfiguration-作用和分析" class="headerlink" title="@EnableAutoConfiguration 作用和分析"></a>@EnableAutoConfiguration 作用和分析</h3><p>我们知道 @Configuration是对配置的一种抽象，而SpringBootConfiguration又是的 @Configuration一种实现，那SpringBootConfiguration肯定是对spring boot配置的特殊的抽象实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Configuration</span><br><span class="line">public @interface SpringBootConfiguration &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们看一下SpringBootApplication的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(excludeFilters = &#123;</span><br><span class="line">		@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line">public @interface SpringBootApplication &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前边的四个是jdk的注解，第五个是@SpringBootConfiguration，刚刚提到了，是SpringBoot的特化配置的实现，最后是个@EnableAutoConfiguration我们看一下doc：</p>
<p>org.springframework.boot.autoconfigure @Target(ElementType.TYPE)<br>@Retention(RetentionPolicy.RUNTIME)<br><code>@Documented</code><br><code>@Inherited</code><br><code>@AutoConfigurationPackage</code><br>@Import(AutoConfigurationImportSelector.class)<br>public interface EnableAutoConfiguration<br>extends annotation.Annotation<br>Enable auto-configuration of the Spring Application Context, attempting to guess and configure beans that you are likely to need. Auto-configuration classes are usually applied based on your classpath and what beans you have defined. For example, if you have tomcat-embedded.jar on your classpath you are likely to want a TomcatServletWebServerFactory (unless you have defined your own ServletWebServerFactory bean).<br>When using SpringBootApplication, the auto-configuration of the context is automatically enabled and adding this annotation has therefore no additional effect.<br>Auto-configuration tries to be as intelligent as possible and will back-away as you define more of your own configuration. You can always manually exclude() any configuration that you never want to apply (use excludeName() if you don’t have access to them). You can also exclude them via the spring.autoconfigure.exclude property. Auto-configuration is always applied after user-defined beans have been registered.<br>The package of the class that is annotated with <code>@EnableAutoConfiguration</code>, usually via <code>@SpringBootApplication</code>, has specific significance and is often used as a ‘default’. For example, it will be used when scanning for @Entity classes. It is generally recommended that you place <code>@EnableAutoConfiguration</code> (if you’re not using <code>@SpringBootApplication</code>) in a root package so that all sub-packages and classes can be searched.<br>Auto-configuration classes are regular Spring Configuration beans. They are located using the SpringFactoriesLoader mechanism (keyed against this class). Generally auto-configuration beans are <code>@Conditional</code> beans (most often using <code>@ConditionalOnClass</code> and <code>@ConditionalOnMissingBean</code> annotations).<br>See Also:<br>ConditionalOnBean, ConditionalOnMissingBean, ConditionalOnClass, AutoConfigureAfter, SpringBootApplication</p>
<p><code>@EnableAutoConfiguration让spring</code> 的上下文的自动配置成为 可能，尝试或者猜测去配置你可能需要的bean。自动化配置往往基于classpath和你已经定义的bean去加载。<br>比如你有一个tomcat-embedded.jar在你的classpath下边，你可能想要TomcatServletWebServerFactory这个bean（除非已经定义了你自己的ServletWebServerFactory bean）。<br>当使用SpringBootApplication 自动化配置就已经开启了，再去添加<code>@EnableAutoConfiguration让spring</code>也不会有影响。<br>自动阿虎配置尽可能智能的，也可以使用 exclude()排除掉你不想加载的配置，也可以以使用spring.autoconfigure.exclude property（yml里边配置）排除掉不想加载的配置。自动化配置总是在用户已经注册好了自定义的bean才能去应用上。</p>
<p>被 <code>@EnableAutoConfiguration</code>修饰的类所在的路径，通常通过 <code>@SpringBootApplication</code>，其指定了一个签名，通常是一个默认值，通常我们将 <code>@EnableAutoConfiguration</code>修饰的类放在根路径root package下（没有使用<code>@SpringBootApplication</code>的情况下）,这样所有的包和子包都会扫描到。</p>
<p>自动配置类就是一个普通的spring 配置bean，通过SpringFactoriesLoader的机制定位的，通常自动化配置bean是一个 <code>@Conditional</code> bean<br>（大部分都是<code>@ConditionalOnClass</code> and <code>@ConditionalOnMissingBean</code>注解）</p>
<p>总之：<code>@EnableAutoConfiguration让spring</code>会完成自动化的注入。最佳实践是将<code>@EnableAutoConfiguration让spring</code>修饰的类放在root package下，对应的实现就是 <code>@SpringBootApplication</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(AutoConfigurationImportSelector.class)</span><br><span class="line">public @interface EnableAutoConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="AutoConfigurationPackage"></a>AutoConfigurationPackage</h4><p>修饰EnableAutoConfiguration当中有一个AutoConfigurationPackage，意味着被AutoConfigurationPackage注解的类所在的包应该注册到AutoConfigurationPackages里边去。</p>
<h4 id="ComponentScan-组件扫描"><a href="#ComponentScan-组件扫描" class="headerlink" title="@ComponentScan 组件扫描"></a>@ComponentScan 组件扫描</h4><p>修饰SpringBootApplication的最后一个注解ComponentScan；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Documented</span><br><span class="line">@Repeatable(ComponentScans.class)</span><br><span class="line">public @interface ComponentScan</span><br></pre></td></tr></table></figure>
<p>配置组件扫描的指令，通常用于Configuration类，提供了使用 Spring XML（<span class="exturl" data-url="Y29udGV4dDpjb21wb25lbnQtc2Nhbg==">context:component-scan<i class="fa fa-external-link-alt"></i></span>）也可以通过basePackageClasses或者basePackages指定特定的包去扫描。如果定义的package不存在，默认就会从@ComponentScan注解的类所在的package去扫描。</p>
<p>注意<span class="exturl" data-url="Y29udGV4dDpjb21wb25lbnQtc2Nhbg==">context:component-scan<i class="fa fa-external-link-alt"></i></span>有一个annotation-config属性，但是@ComponentScan注解没有</p>
<h3 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a>SpringApplication</h3><p>SpringApplicatio用来在main方法里边启动和引导spring 应用，默认会执行一下的步骤：</p>
<ul>
<li>创建一个合适的SpringApplication实例(在classpath下面)</li>
<li>注册CommandLinePropertySource来暴露命令行参数作为 Spring properties</li>
<li>刷新application context，加载所有单利的bean</li>
<li>触发CommandLineRunner bean</li>
</ul>
<p>默认静态的main方法里边启动应用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">public class MyApplication  &#123;</span><br><span class="line"></span><br><span class="line">  // ... Bean definitions</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    SpringApplication.run(MyApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>对于更加高级的配置，SpringApplication实例可以在启动之前做一些定制化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  SpringApplication application = new SpringApplication(MyApplication.class);</span><br><span class="line">  // ... customize application settings here</span><br><span class="line">  application.run(args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringApplication可以从不同的源读取bean，通常推荐一个单个的 @Configuration 用于启动你的应用，然后你可以设置源从以下方面：</p>
<ul>
<li>完全限定的类名通过 AnnotatedBeanDefinitionReader加载。</li>
<li>本地的xml资源，通过 XmlBeanDefinitionReader加载 或者通过groovy 脚本，通过GroovyBeanDefinitionReader加载。</li>
<li>包名扫描通过 ClassPathBeanDefinitionScanner</li>
</ul>
]]></content>
      <categories>
        <category>spring_boot_cloud</category>
      </categories>
      <tags>
        <tag>SpringBootApplication</tag>
      </tags>
  </entry>
  <entry>
    <title>spring_boot_cloud(5)SpringApplication源码分析与作用详解</title>
    <url>/2019/06/30/spring_boot_and_cloud/spring_boot_cloud(5)SpringApplication%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%8E%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="SpringApplication的初始化流程源码分析"><a href="#SpringApplication的初始化流程源码分析" class="headerlink" title="SpringApplication的初始化流程源码分析"></a>SpringApplication的初始化流程源码分析</h3><span id="more"></span>

<h4 id="SpringApplication入口"><a href="#SpringApplication入口" class="headerlink" title="SpringApplication入口"></a>SpringApplication入口</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class MyApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的spring boot的启动都是从这个main方法开始的，，那么这个方法的主要的一行代码就是SpringApplication.run(MyApplication.class,args);我们本次要看一下他的执行流程。<br>run方法点进去之后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) &#123;</span><br><span class="line">  return run(new Class&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConfigurableApplicationContext是一个即使不是所有应用上下文 也是大部分的应用上下文实现的spi接口，提供了一些设施用来配置应用上下文，配置和生命周期方法封装在这里，避免他们出现在应用上下文的客户端代码里边，ConfigurableApplicationContext罗列的方法用来启动和关闭的代码里边。<br>run方法的入参是一个Class类型的参数，然后掉了另一个重载的run方法，这个run方法的第一个入参是Class类型的数组，第二个参数是传进来的args，这种变成风格很常见，一般一个方法是通用的，接受数组类型的，一个方法是只接受一个参数的，一个参数的方法是接受数组参数方法的特例，那么接受一个参数的方法会调用通用的那个方法。跟进去：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources,</span><br><span class="line">    String[] args) &#123;</span><br><span class="line">  return new SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法new 了一个SpringApplication的实例执行了SpringApplication实例的run方法，返回值就是SpringApplication的run方法的返回值。<br>接着往里走：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public SpringApplication(Class&lt;?&gt;... primarySources) &#123;</span><br><span class="line">  this(null, primarySources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SpringApplication构造器的主流程"><a href="#SpringApplication构造器的主流程" class="headerlink" title="SpringApplication构造器的主流程"></a>SpringApplication构造器的主流程</h4><p>最终来到了这个构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">Create a new SpringApplication instance. The application context will load beans from the specified primary sources (see class-level documentation for details. The instance can be customized before calling run(String...).</span><br><span class="line">创建一个应用上下文，应用 上下文会从指定的primarySources加载，这个实例可以在调用run方法之前进行一个定制化。</span><br><span class="line">*/</span><br><span class="line">public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123;</span><br><span class="line">  this.resourceLoader = resourceLoader;//为null</span><br><span class="line">  Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);</span><br><span class="line">  this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));//com.twodragonlake.boot.MyApplication.class</span><br><span class="line">  this.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">  setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">  setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">  this.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h4><p>  ResourceLoader：用来加载资源的策略接口（class path，类路劲，文件资源），org.springframework.context.ApplicationContext被要求提供这个功能，再加上org.springframework.core.io.support.ResourcePatternResolver这样一个支持。DefaultResourceLoader是一个独立的实现，他被用在ApplicationContext之外，也是被资源编辑器ResourceEditor所使用。<br>  ResourceLoader结构：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ResourceLoader</span><br><span class="line">  //加载资源都离不开类加载器</span><br><span class="line">  getClassLoader</span><br><span class="line">  getResource</span><br><span class="line">  CLASSPATH_URL_PREFIX</span><br></pre></td></tr></table></figure></p>
<h4 id="WebApplicationType探测应用类型逻辑"><a href="#WebApplicationType探测应用类型逻辑" class="headerlink" title="WebApplicationType探测应用类型逻辑"></a>WebApplicationType探测应用类型逻辑</h4><p>  this.webApplicationType &#x3D; WebApplicationType.deduceFromClasspath();这一行是确定应用类型，进到枚举WebApplicationType看一下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum WebApplicationType &#123;</span><br><span class="line"></span><br><span class="line">  	/**</span><br><span class="line">  	 * The application should not run as a web application and should not start an</span><br><span class="line">  	 * embedded web server.</span><br><span class="line">  	 */</span><br><span class="line">     什么类型也不是</span><br><span class="line">  	NONE,</span><br><span class="line"></span><br><span class="line">  	/**</span><br><span class="line">  	 * The application should run as a servlet-based web application and should start an</span><br><span class="line">  	 * embedded servlet web server.</span><br><span class="line">  	 */</span><br><span class="line">     servlet应用类型</span><br><span class="line">  	SERVLET,</span><br><span class="line"></span><br><span class="line">  	/**</span><br><span class="line">  	 * The application should run as a reactive web application and should start an</span><br><span class="line">  	 * embedded reactive web server.</span><br><span class="line">  	 */</span><br><span class="line">     反应式应用类型</span><br><span class="line">  	REACTIVE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    	private static final String[] SERVLET_INDICATOR_CLASSES = &#123; &quot;javax.servlet.Servlet&quot;,</span><br><span class="line">    			&quot;org.springframework.web.context.ConfigurableWebApplicationContext&quot; &#125;;</span><br><span class="line"></span><br><span class="line">    	private static final String WEBMVC_INDICATOR_CLASS = &quot;org.springframework.&quot;</span><br><span class="line">    			+ &quot;web.servlet.DispatcherServlet&quot;;</span><br><span class="line"></span><br><span class="line">    	private static final String WEBFLUX_INDICATOR_CLASS = &quot;org.&quot;</span><br><span class="line">    			+ &quot;springframework.web.reactive.DispatcherHandler&quot;;</span><br><span class="line"></span><br><span class="line">    	private static final String JERSEY_INDICATOR_CLASS = &quot;org.glassfish.jersey.servlet.ServletContainer&quot;;</span><br><span class="line"></span><br><span class="line">    	private static final String SERVLET_APPLICATION_CONTEXT_CLASS = &quot;org.springframework.web.context.WebApplicationContext&quot;;</span><br><span class="line"></span><br><span class="line">    	private static final String REACTIVE_APPLICATION_CONTEXT_CLASS = &quot;org.springframework.boot.web.reactive.context.ReactiveWebApplicationContext&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //推断应用类型</span><br><span class="line">    	static WebApplicationType deduceFromClasspath() &#123;</span><br><span class="line">        //反应式应用的推荐条件</span><br><span class="line">    		if (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null)</span><br><span class="line">    				&amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null)</span><br><span class="line">    				&amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) &#123;</span><br><span class="line">    			return WebApplicationType.REACTIVE;</span><br><span class="line">    		&#125;</span><br><span class="line">        //SERVLET_INDICATOR_CLASSES里边的都没有出现就是什么类型都不是的应用</span><br><span class="line">        //因为工程里边引入了tomcat的jar包所有javax.servlet.Servlet肯定存在classpath下，而ConfigurableWebApplicationContext</span><br><span class="line">        //是spring里边的类，也会出现在classpath里边。</span><br><span class="line">    		for (String className : SERVLET_INDICATOR_CLASSES) &#123;</span><br><span class="line">    			if (!ClassUtils.isPresent(className, null)) &#123;</span><br><span class="line">    				return WebApplicationType.NONE;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">        //其他的都是servlet应用[当前的demo会返回这个值，即，当前demo是一个servlet类型的应用]</span><br><span class="line">    		return WebApplicationType.SERVLET;</span><br><span class="line">    	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ApplicationContextInitializer的加载和初始化逻辑"><a href="#ApplicationContextInitializer的加载和初始化逻辑" class="headerlink" title="ApplicationContextInitializer的加载和初始化逻辑"></a>ApplicationContextInitializer的加载和初始化逻辑</h4><h5 id="ApplicationContextInitializer介绍"><a href="#ApplicationContextInitializer介绍" class="headerlink" title="ApplicationContextInitializer介绍"></a>ApplicationContextInitializer介绍</h5><p>接下来是 setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));<br>getSpringFactoriesInstances的作用就是加载实现了ApplicationContextInitializer接口的这些工厂的实例。<br>首先看一下getSpringFactoriesInstances的参数ApplicationContextInitializer.class<br>看一下doc:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Callback interface for initializing a Spring ConfigurableApplicationContext prior to being refreshed.</span><br><span class="line">Typically used within web applications that require some programmatic initialization of the application context. For example, registering property sources or activating profiles against the context&#x27;s environment. See ContextLoader and FrameworkServlet support for declaring a &quot;contextInitializerClasses&quot; context-param and init-param, respectively.</span><br><span class="line">ApplicationContextInitializer processors are encouraged to detect whether Spring&#x27;s Ordered interface has been implemented or if the @Order annotation is present and to sort instances accordingly if so prior to invocation.</span><br></pre></td></tr></table></figure>
<p>在bean刷新之前初始化 Spring ConfigurableApplicationContext的一个回调接口。<br>通常用于在web应用当中，需要编程的方式初始化应用的上下文。<br>比如我们注册 一个属性源，激活profile这对于上下文的环境。<br>ApplicationContextInitializer被鼓励探测spring排序接口是不是被实现或者<code>@Order</code>注解是不是存在，存在的话用来排序。<br>ApplicationContextInitializer主要用来完成初始化工作。</p>
<h5 id="加载所有工厂并缓存"><a href="#加载所有工厂并缓存" class="headerlink" title="加载所有工厂并缓存"></a>加载所有工厂并缓存</h5><p>那为什么getSpringFactoriesInstances方法要传入初始化器呢，跟进去看一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type) &#123;</span><br><span class="line">  return getSpringFactoriesInstances(type, new Class&lt;?&gt;[] &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type,</span><br><span class="line">    Class&lt;?&gt;[] parameterTypes, Object... arg s) &#123;</span><br><span class="line">  ClassLoader classLoader = getClassLoader();//应用类加载器</span><br><span class="line">  // Use names and ensure unique to protect against duplicates</span><br><span class="line">  Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(</span><br><span class="line">      SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">  List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes,</span><br><span class="line">      classLoader, args, names);</span><br><span class="line">  AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">  return instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getClassLoader()方法是获取类的加载器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//如果resourceLoader不是空，就返回resourceLoader的类加载器，此处resourceLoader是空的，if语句不会执行</span><br><span class="line">public ClassLoader getClassLoader() &#123;</span><br><span class="line">  if (this.resourceLoader != null) &#123;</span><br><span class="line">    return this.resourceLoader.getClassLoader();</span><br><span class="line">  &#125;</span><br><span class="line">  return ClassUtils.getDefaultClassLoader();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后看一下ClassUtils.getDefaultClassLoader()：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">逻辑很简单，默认返回线程上下文类加载器</span><br><span class="line">public static ClassLoader getDefaultClassLoader() &#123;</span><br><span class="line">  ClassLoader cl = null;</span><br><span class="line">  try &#123;</span><br><span class="line">    cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">  &#125;</span><br><span class="line">  catch (Throwable ex) &#123;</span><br><span class="line">    // Cannot access thread context ClassLoader - falling back...</span><br><span class="line">  &#125;</span><br><span class="line">  //如果线程上下文类加载器是空的，就返回ClassUtils的类加载器</span><br><span class="line">  if (cl == null) &#123;</span><br><span class="line">    // No thread context class loader -&gt; use class loader of this class.</span><br><span class="line">    cl = ClassUtils.class.getClassLoader();</span><br><span class="line">    //如果ClassUtils的类加载器也是空的就返回系统类加载器</span><br><span class="line">    if (cl == null) &#123;</span><br><span class="line">      // getClassLoader() returning null indicates the bootstrap ClassLoader</span><br><span class="line">      try &#123;</span><br><span class="line">        cl = ClassLoader.getSystemClassLoader();</span><br><span class="line">      &#125;</span><br><span class="line">      catch (Throwable ex) &#123;</span><br><span class="line">        // Cannot access system ClassLoader - oh well, maybe the caller can live with null...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return cl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们的程序返回的是系统类加载器(线程上下文类加载器中的)<br>Set<String> names &#x3D; new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));<br>type是ApplicationContextInitializer.class，<br>这里SpringFactoriesLoader加载了工厂的名字：<br>SpringFactoriesLoader解析:<br>doc：<br>General purpose factory loading mechanism for internal use within the framework.<br>SpringFactoriesLoader loads and instantiates factories of a given type from “META-INF&#x2F;spring.factories” files which may be present in multiple JAR files in the classpath. The spring.factories file must be in Properties format, where the key is the fully qualified name of the interface or abstract class, and the value is a comma-separated list of implementation class names. For example:<br>example.MyService&#x3D;example.MyServiceImpl1,example.MyServiceImpl2<br>where example.MyService is the name of the interface, and MyServiceImpl1 and MyServiceImpl2 are two implementations.<br>在框架内部所使用的的一种通用工厂加载机制。<br>SpringFactoriesLoader从文件 “META-INF&#x2F;spring.factories” 里边指定的类型工厂进行加载和实例化。<br>这个文件可能位于classpath下多个jar文件当中。spring.factories文件必须要是Properties格式的，其中key就是接口或者抽象类的完全限定的名字，值是逗号分隔的实现类名字的列表。举例：<br>example.MyService&#x3D;example.MyServiceImpl1,example.MyServiceImpl2<br>其中example.MyService是接口的名字，example.MyServiceImpl1,example.MyServiceImpl2是2个实现类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123;</span><br><span class="line">  String factoryClassName = factoryClass.getName();//ApplicationContextInitializer.class的全限定名</span><br><span class="line">  return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="factoryClass-getName扩展"><a href="#factoryClass-getName扩展" class="headerlink" title="factoryClass.getName扩展"></a>factoryClass.getName扩展</h6><p> factoryClass.getName()：<br>这里做一下扩展结合之前jvm字节码的章节，我们看一下这个方法的doc：<br><img src="/getName.png" alt="getName.png"><br>返回调用getName的class对象的实体（类，接口，数组，原生类型，或者void）的名字。并且作为字符串的形式返回<br>如果class对象代表的是引用类新型，并且不是数组类型，就会返回这个类的二进制的名字，名字是java 语言规范规定的格式返回的。<br>如果class的对象代表的是原生类型或者是void，调用getName返回的名称就是原生类型的名字或者void。<br>如果class对象表示的是数组类，那么返回的名字的内部形式就会包含元素类型的名字，其中”[“代表的是数组的维度数量。</p>
<p>接下来回到主流程，进入到loadSpringFactories()：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//进入loadSpringFactories</span><br><span class="line">private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123;</span><br><span class="line">  //cache的结构：Map&lt;ClassLoader, MultiValueMap&lt;String, String&gt;&gt;</span><br><span class="line">  MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line">  //缓存加载出来的是null，继续往下走</span><br><span class="line">  if (result != null) &#123;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    /**</span><br><span class="line">    	 * The location to look for factories.</span><br><span class="line">    	 * &lt;p&gt;Can be present in multiple JAR files.</span><br><span class="line">       寻找工厂的位置，可以存在于多个jar文件当中</span><br><span class="line">       public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;;</span><br><span class="line">    */</span><br><span class="line">    Enumeration&lt;URL&gt; urls = (classLoader != null ?</span><br><span class="line">        classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">        ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">    result = new LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">    while (urls.hasMoreElements()) &#123;</span><br><span class="line">      //</span><br><span class="line">      URL url = urls.nextElement();</span><br><span class="line">      UrlResource resource = new UrlResource(url);</span><br><span class="line">      Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">      for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">        String factoryClassName = ((String) entry.getKey()).trim();</span><br><span class="line">        for (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">          result.add(factoryClassName, factoryName.trim());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cache.put(classLoader, result);</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">  catch (IOException ex) &#123;</span><br><span class="line">    throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; +</span><br><span class="line">        FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="classLoader-getResources扩展："><a href="#classLoader-getResources扩展：" class="headerlink" title="classLoader.getResources扩展："></a>classLoader.getResources扩展：</h6><p>classLoader.getResources(FACTORIES_RESOURCE_LOCATION) 解析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据名称得到资源（图片、音频、文本等），这些资源可以被class字节码访问，并且和字节码在位置上是独立存在的。</span><br><span class="line">name对应的资源路径是被&quot;/&quot;分隔的。</span><br><span class="line">返回值是一个枚举，如果资源找不到，枚举就是空的，如果资源没法访问，那么资源就不会出现在枚举里边。</span><br><span class="line">CompoundEnumeration是sun.misc包下的枚举的实现，它的结构如下：</span><br><span class="line">public class CompoundEnumeration&lt;E&gt; implements Enumeration&lt;E&gt; &#123;</span><br><span class="line">    private Enumeration&lt;E&gt;[] enums;</span><br><span class="line">    private int index = 0;</span><br><span class="line">&#125;    </span><br><span class="line">从代码结构来看它实现了Enumeration，就有Enumeration的一些特性，同时它有一个Enumeration数组，意味着它下面还可以存在Enumeration</span><br><span class="line">是一个多级的结构。</span><br><span class="line">public Enumeration&lt;URL&gt; getResources(String name) throws IOException &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    Enumeration&lt;URL&gt;[] tmp = (Enumeration&lt;URL&gt;[]) new Enumeration&lt;?&gt;[2];</span><br><span class="line">    if (parent != null) &#123;</span><br><span class="line">        tmp[0] = parent.getResources(name);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        tmp[0] = getBootstrapResources(name);</span><br><span class="line">    &#125;</span><br><span class="line">    tmp[1] = findResources(name);</span><br><span class="line"></span><br><span class="line">    return new CompoundEnumeration&lt;&gt;(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="加载三个spring-jar的工厂"><a href="#加载三个spring-jar的工厂" class="headerlink" title="加载三个spring jar的工厂"></a>加载三个spring jar的工厂</h5><p>我们debug可以看到url的位置<br>!(url.png)[url.png]<br>jar:file:&#x2F;D:&#x2F;gradlerepo&#x2F;caches&#x2F;modules-2&#x2F;files-2.1&#x2F;org.springframework.boot&#x2F;spring-boot-autoconfigure&#x2F;2.1.3.RELEASE&#x2F;58e07f69638a3ca13dffe8a2b68d284af376d105&#x2F;spring-boot-autoconfigure-2.1.3.RELEASE.jar!&#x2F;META-INF&#x2F;spring.factories<br><img src="/url.png" alt="url.png"><br>然后打开这个spring.factories<br><img src="/url1.png" alt="url1.png"><br>里边有七个主要的类(接口)：</p>
<ul>
<li>org.springframework.context.ApplicationContextInitializer</li>
<li>org.springframework.context.ApplicationListener</li>
<li>org.springframework.boot.autoconfigure.AutoConfigurationImportListener</li>
<li>org.springframework.boot.autoconfigure.AutoConfigurationImportFilter</li>
<li>org.springframework.boot.autoconfigure.EnableAutoConfiguration</li>
<li>org.springframework.boot.diagnostics.FailureAnalyzer</li>
<li>org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider<br>接下往下走就会看到这七个接口：<br><img src="/url2.png" alt="url2.png"><br>最后loadSpringFactories返回的result是一个map，key是接口的名称，value是接口的实现类：<br>比如刚才的spring.factories里边 org.springframework.boot.autoconfigure.EnableAutoConfiguration有118个实现，那么map的key就是 org.springframework.boot.autoconfigure.EnableAutoConfiguration，value是她的118个实现。</li>
</ul>
<p>然后再看一下第二个工厂的jar位置：<br>jar:file:&#x2F;D:&#x2F;gradlerepo&#x2F;caches&#x2F;modules-2&#x2F;files-2.1&#x2F;org.springframework.boot&#x2F;spring-boot&#x2F;2.1.3.RELEASE&#x2F;92bb92cd73212cefc1e5112e3bbf1f31c154c3fd&#x2F;spring-boot-2.1.3.RELEASE.jar!&#x2F;META-INF&#x2F;spring.factories<br>看一下它里边的结构：<br><img src="/url2.png" alt="url2.png"><br>主要接口如下：</p>
<ul>
<li>org.springframework.boot.diagnostics.FailureAnalysisReporter</li>
<li>org.springframework.boot.diagnostics.FailureAnalyzer</li>
<li>org.springframework.boot.env.EnvironmentPostProcessor</li>
<li>org.springframework.boot.env.PropertySourceLoader</li>
<li>org.springframework.boot.SpringApplicationRunListener</li>
<li>org.springframework.boot.SpringBootExceptionReporter</li>
<li>org.springframework.context.ApplicationContextInitializer</li>
<li>org.springframework.context.ApplicationListener</li>
</ul>
<p>我们看到有一个org.springframework.context.ApplicationListener但是在spring-boot-autoconfigure-2.1.3.RELEASE.jar里边也有一个org.springframework.context.ApplicationListener，这个时候就能看到MultiValueMap&lt;String, String&gt;所起的作用，相同key的value会进行合并。</p>
<p>继续放下看下一个工厂jar的位置：<br>jar:file:&#x2F;D:&#x2F;gradlerepo&#x2F;caches&#x2F;modules-2&#x2F;files-2.1&#x2F;org.springframework&#x2F;spring-beans&#x2F;5.1.5.RELEASE&#x2F;58b10c61f6bf2362909d884813c4049b657735f5&#x2F;spring-beans-5.1.5.RELEASE.jar!&#x2F;META-INF&#x2F;spring.factories</p>
<p>然后打开对应的spring.factories文件：<br>这里边只有一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.beans.BeanInfoFactory=org.springframework.beans.ExtendedBeanInfoFactory</span><br></pre></td></tr></table></figure>

<h5 id="所有工厂的合并结果"><a href="#所有工厂的合并结果" class="headerlink" title="所有工厂的合并结果"></a>所有工厂的合并结果</h5><p>由此我们可以得出结论spring boot启动的时候会初始化三个jar包的工厂。<br>得到的result是三个jar包所有的数据进行了合并，合并之后一共有13个工厂接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 = &#123;LinkedHashMap$Entry@1746&#125; &quot;org.springframework.boot.autoconfigure.AutoConfigurationImportFilter&quot; -&gt; &quot; size = 3&quot;</span><br><span class="line">1 = &#123;LinkedHashMap$Entry@1747&#125; &quot;org.springframework.boot.diagnostics.FailureAnalyzer&quot; -&gt; &quot; size = 17&quot;</span><br><span class="line">2 = &#123;LinkedHashMap$Entry@1748&#125; &quot;org.springframework.boot.autoconfigure.AutoConfigurationImportListener&quot; -&gt; &quot; size = 1&quot;</span><br><span class="line">3 = &#123;LinkedHashMap$Entry@1749&#125; &quot;org.springframework.context.ApplicationContextInitializer&quot; -&gt; &quot; size = 6&quot;</span><br><span class="line">4 = &#123;LinkedHashMap$Entry@1750&#125; &quot;org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider&quot; -&gt; &quot; size = 5&quot;</span><br><span class="line">5 = &#123;LinkedHashMap$Entry@1751&#125; &quot;org.springframework.context.ApplicationListener&quot; -&gt; &quot; size = 10&quot;</span><br><span class="line">6 = &#123;LinkedHashMap$Entry@1752&#125; &quot;org.springframework.boot.autoconfigure.EnableAutoConfiguration&quot; -&gt; &quot; size = 118&quot;</span><br><span class="line">7 = &#123;LinkedHashMap$Entry@1753&#125; &quot;org.springframework.boot.env.EnvironmentPostProcessor&quot; -&gt; &quot; size = 3&quot;</span><br><span class="line">8 = &#123;LinkedHashMap$Entry@1754&#125; &quot;org.springframework.boot.SpringApplicationRunListener&quot; -&gt; &quot; size = 1&quot;</span><br><span class="line">9 = &#123;LinkedHashMap$Entry@1755&#125; &quot;org.springframework.boot.env.PropertySourceLoader&quot; -&gt; &quot; size = 2&quot;</span><br><span class="line">10 = &#123;LinkedHashMap$Entry@1756&#125; &quot;org.springframework.boot.diagnostics.FailureAnalysisReporter&quot; -&gt; &quot; size = 1&quot;</span><br><span class="line">11 = &#123;LinkedHashMap$Entry@1757&#125; &quot;org.springframework.boot.SpringBootExceptionReporter&quot; -&gt; &quot; size = 1&quot;</span><br><span class="line">12 = &#123;LinkedHashMap$Entry@1758&#125; &quot;org.springframework.beans.BeanInfoFactory&quot; -&gt; &quot; size = 1&quot;</span><br></pre></td></tr></table></figure>

<h4 id="得到ApplicationContextInitializer的所有实现"><a href="#得到ApplicationContextInitializer的所有实现" class="headerlink" title="得到ApplicationContextInitializer的所有实现"></a>得到ApplicationContextInitializer的所有实现</h4><p>loadSpringFactories(classLoader)的结果就是上边的13个实例，然后loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());<br>里边getOrDefault方法的参数是factoryClassName是interface org.springframework.context.ApplicationContextInitializer，<br>意思是从13个接口里边找到ApplicationContextInitializer这个接口，是能找到的，一共有6个ApplicationContextInitializer的实现类:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 = &quot;org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer&quot;</span><br><span class="line">1 = &quot;org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener&quot;</span><br><span class="line">2 = &quot;org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer&quot;</span><br><span class="line">3 = &quot;org.springframework.boot.context.ContextIdApplicationContextInitializer&quot;</span><br><span class="line">4 = &quot;org.springframework.boot.context.config.DelegatingApplicationContextInitializer&quot;</span><br><span class="line">5 = &quot;org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer&quot;</span><br></pre></td></tr></table></figure>

<h4 id="创建ApplicationContextInitializer所有实现的实例"><a href="#创建ApplicationContextInitializer所有实现的实例" class="headerlink" title="创建ApplicationContextInitializer所有实现的实例"></a>创建ApplicationContextInitializer所有实现的实例</h4><p>接下来的逻辑是：<br>List<T> instances &#x3D; createSpringFactoriesInstances(type, parameterTypes,classLoader, args, names);<br>type：interface org.springframework.context.ApplicationContextInitializer<br>parameterTypes：是空数组。<br>classLoader：应用类加载器<br>args：空数组<br>names：即我们上边得到的有6个对象的数组。<br>逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private &lt;T&gt; List&lt;T&gt; createSpringFactoriesInstances(Class&lt;T&gt; type,  Class&lt;?&gt;[] parameterTypes,</span><br><span class="line">  ClassLoader classLoader,Object[] args,Set&lt;String&gt; names) &#123;</span><br><span class="line">  List&lt;T&gt; instances = new ArrayList&lt;&gt;(names.size());</span><br><span class="line">  for (String name : names) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      //先从ClassUtils内部的缓存加载，如果缓存不存在就会调用Class.forName(name, false, classLoader)这种原始的方式加载。</span><br><span class="line">      Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader);</span><br><span class="line">      Assert.isAssignable(type, instanceClass);</span><br><span class="line">      //得到构造器</span><br><span class="line">      Constructor&lt;?&gt; constructor = instanceClass</span><br><span class="line">          .getDeclaredConstructor(parameterTypes);</span><br><span class="line">      //创建实例，instantiateClass方法会尝试将不可访问（非public的）的改为可访问的，而且支持kotlin的类</span><br><span class="line">      T instance = (T) BeanUtils.instantiateClass(constructor, args);</span><br><span class="line">      instances.add(instance);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable ex) &#123;</span><br><span class="line">      throw new IllegalArgumentException(</span><br><span class="line">          &quot;Cannot instantiate &quot; + type + &quot; : &quot; + name, ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="BeanUtils-instantiateClass扩展"><a href="#BeanUtils-instantiateClass扩展" class="headerlink" title="BeanUtils.instantiateClass扩展"></a>BeanUtils.instantiateClass扩展</h5><p> BeanUtils.instantiateClass：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static &lt;T&gt; T instantiateClass(Constructor&lt;T&gt; ctor, Object... args) throws BeanInstantiationException &#123;</span><br><span class="line">    Assert.notNull(ctor, &quot;Constructor must not be null&quot;);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">       /**</span><br><span class="line">        ReflectionUtils.makeAccessible实现，即如果不可访问的改为可访问的。</span><br><span class="line">       public static void makeAccessible(Constructor&lt;?&gt; ctor) &#123;</span><br><span class="line">         if ((!Modifier.isPublic(ctor.getModifiers()) ||</span><br><span class="line">             !Modifier.isPublic(ctor.getDeclaringClass().getModifiers())) &amp;&amp; !ctor.isAccessible()) &#123;</span><br><span class="line">           ctor.setAccessible(true);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       **/</span><br><span class="line">        ReflectionUtils.makeAccessible(ctor);</span><br><span class="line">        //对java和kotlin类型的进行生成。</span><br><span class="line">        return KotlinDetector.isKotlinReflectPresent() &amp;&amp; KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ? BeanUtils.KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args);</span><br><span class="line">    &#125; catch (InstantiationException var3) &#123;</span><br><span class="line">        throw new BeanInstantiationException(ctor, &quot;Is it an abstract class?&quot;, var3);</span><br><span class="line">    &#125; catch (IllegalAccessException var4) &#123;</span><br><span class="line">        throw new BeanInstantiationException(ctor, &quot;Is the constructor accessible?&quot;, var4);</span><br><span class="line">    &#125; catch (IllegalArgumentException var5) &#123;</span><br><span class="line">        throw new BeanInstantiationException(ctor, &quot;Illegal arguments for constructor&quot;, var5);</span><br><span class="line">    &#125; catch (InvocationTargetException var6) &#123;</span><br><span class="line">        throw new BeanInstantiationException(ctor, &quot;Constructor threw exception&quot;, var6.getTargetException());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>创建出来的对象：<br><img src="/instance.png" alt="instance.png"></p>
<h4 id="setInitializers和排序"><a href="#setInitializers和排序" class="headerlink" title="setInitializers和排序"></a>setInitializers和排序</h4><p>回到getSpringFactoriesInstances，返回的map类型的result放到LinkedHashSet里边：<br>Set<String> names &#x3D; new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));<br>接下来是  List<T> instances &#x3D; createSpringFactoriesInstances(type, parameterTypes,classLoader, args, names);<br>创建工厂的实例。<br>AnnotationAwareOrderComparator.sort(instances);是进行排序，然后这个方法就返回了。</p>
<p>回到了SpringApplication的构造器，执行到了：<br>setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));<br>setInitializers的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void setInitializers(</span><br><span class="line">    Collection&lt;? extends ApplicationContextInitializer&lt;?&gt;&gt; initializers) &#123;</span><br><span class="line">  this.initializers = new ArrayList&lt;&gt;();</span><br><span class="line">  this.initializers.addAll(initializers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只是添加到集合当中。</p>
<p>注意：【setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));】和<br>【setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));】的执行流程是一模一样的。</p>
<h4 id="ApplicationListener"><a href="#ApplicationListener" class="headerlink" title="ApplicationListener"></a>ApplicationListener</h4><p>org.springframework.context @FunctionalInterface<br>public interface ApplicationListener<E extends ApplicationEvent><br>extends EventListener<br>Interface to be implemented by application event listeners. Based on the standard java.util.EventListener interface for the Observer design pattern.<br>As of Spring 3.0, an ApplicationListener can generically declare the event type that it is interested in. When registered with a Spring ApplicationContext, events will be filtered accordingly, with the listener getting invoked for matching event objects only.<br>一个用来被应用事件监听实现的接口，基于标准的java.util.EventListener接口，是一种观察者模式。<br>在Spring 3.0版本，一个应用监听器可以声明一个它感兴趣的事件类型，当注册到spring的应用上下文里边，事件将相应的过滤，当注册的事件发生的时候，监听器就会被触发。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ApplicationListener是一个函数式接口</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Handle an application event.</span><br><span class="line">	 * @param event the event to respond to</span><br><span class="line">	 */</span><br><span class="line">	void onApplicationEvent(E event);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它最终初始化的所有监听器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 = &#123;BackgroundPreinitializer@1931&#125;</span><br><span class="line">1 = &#123;ClearCachesApplicationListener@1966&#125;</span><br><span class="line">2 = &#123;ParentContextCloserApplicationListener@1967&#125;</span><br><span class="line">3 = &#123;FileEncodingApplicationListener@1968&#125;</span><br><span class="line">4 = &#123;AnsiOutputApplicationListener@1969&#125;</span><br><span class="line">5 = &#123;ConfigFileApplicationListener@1970&#125;</span><br><span class="line">6 = &#123;DelegatingApplicationListener@1971&#125;</span><br><span class="line">7 = &#123;ClasspathLoggingApplicationListener@1972&#125;</span><br><span class="line">8 = &#123;LoggingApplicationListener@1973&#125;</span><br><span class="line">9 = &#123;LiquibaseServiceLocatorApplicationListener@1974&#125;</span><br></pre></td></tr></table></figure>

<h4 id="主应用类获取deduceMainApplicationClass"><a href="#主应用类获取deduceMainApplicationClass" class="headerlink" title="主应用类获取deduceMainApplicationClass"></a>主应用类获取deduceMainApplicationClass</h4><p>SpringApplication的SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;… primarySources) 方法最后一行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.mainApplicationClass = deduceMainApplicationClass();</span><br></pre></td></tr></table></figure>
<p>即获取主应用类的逻辑，我们进去看一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Class&lt;?&gt; deduceMainApplicationClass() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    StackTraceElement[] stackTrace = new RuntimeException().getStackTrace();</span><br><span class="line">    for (StackTraceElement stackTraceElement : stackTrace) &#123;</span><br><span class="line">      if (&quot;main&quot;.equals(stackTraceElement.getMethodName())) &#123;</span><br><span class="line">        return Class.forName(stackTraceElement.getClassName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  catch (ClassNotFoundException ex) &#123;</span><br><span class="line">    // Swallow and continue</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br></pre></td></tr></table></figure>
<p>这种获取主应用类的凡是非常讨巧，首先new一个运行时异常，同时得到它的堆栈信息，然后遍历堆栈信息，当某一条的堆栈信息调用的方式是main方法的时候，得到main方法所在的类就是主应用类。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>到目前为止SpringApplication的【public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;… primarySources)】方法已经分析完毕，返回到上一层的逻辑：<br>SpringApplication(primarySources).run(args);<br>接下来会分析run方法的执行逻辑，，run方法逻辑分析完毕整个spring boot的启动流程也就完毕了。</p>
<h3 id="SpringApplication的run方法源码分析"><a href="#SpringApplication的run方法源码分析" class="headerlink" title="SpringApplication的run方法源码分析"></a>SpringApplication的run方法源码分析</h3><p>run方法逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">运行spring应用，创建并且刷新一个新的ApplicationContext</span><br><span class="line">args：main方法的参数</span><br><span class="line">*/</span><br><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">  //计时器</span><br><span class="line">  StopWatch stopWatch = new StopWatch();</span><br><span class="line">  //记录开始时间</span><br><span class="line">  stopWatch.start();</span><br><span class="line">  //配置上下文</span><br><span class="line">  ConfigurableApplicationContext context = null;</span><br><span class="line">  //异常构造器集合</span><br><span class="line">  Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();</span><br><span class="line">  //是一个服务器端应用</span><br><span class="line">  configureHeadlessProperty();</span><br><span class="line">  //加载所有SpringApplicationRunListener监听器</span><br><span class="line">  SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">  //启动所有监听器，发布Application启动事件。</span><br><span class="line">  listeners.starting();</span><br><span class="line">  try &#123;</span><br><span class="line">    //将参数封装为ApplicationArguments</span><br><span class="line">    ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);</span><br><span class="line">    //环境的准备</span><br><span class="line">    ConfigurableEnvironment environment = prepareEnvironment(listeners,applicationArguments);</span><br><span class="line">    //配置忽略的bean信息</span><br><span class="line">    configureIgnoreBeanInfo(environment);</span><br><span class="line">    //打印banner</span><br><span class="line">    Banner printedBanner = printBanner(environment);</span><br><span class="line">    //根据应用类型实例化上下文</span><br><span class="line">    context = createApplicationContext();</span><br><span class="line">    //之前介绍过的，加载接口的所有实现，context是它的实现类构造器的参数，这里会加载出一个异常报告器</span><br><span class="line">    exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line">        new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">    //准备上下文</span><br><span class="line">    prepareContext(context, environment, listeners, applicationArguments,printedBanner);</span><br><span class="line">    refreshContext(context);</span><br><span class="line">    afterRefresh(context, applicationArguments);</span><br><span class="line">    stopWatch.stop();</span><br><span class="line">    if (this.logStartupInfo) &#123;</span><br><span class="line">      new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">    &#125;</span><br><span class="line">    listeners.started(context);</span><br><span class="line">    callRunners(context, applicationArguments);</span><br><span class="line">  &#125;</span><br><span class="line">  catch (Throwable ex) &#123;</span><br><span class="line">    handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">    throw new IllegalStateException(ex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    listeners.running(context);</span><br><span class="line">  &#125;</span><br><span class="line">  catch (Throwable ex) &#123;</span><br><span class="line">    handleRunFailure(context, ex, exceptionReporters, null);</span><br><span class="line">    throw new IllegalStateException(ex);</span><br><span class="line">  &#125;</span><br><span class="line">  return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="StopWatch"><a href="#StopWatch" class="headerlink" title="StopWatch"></a>StopWatch</h4><p>看一下它的doc<br>Simple stop watch, allowing for timing of a number of tasks, exposing total running time and running time for each named task.<br>Conceals use of System.currentTimeMillis(), improving the readability of application code and reducing the likelihood of calculation errors.<br>Note that this object is not designed to be thread-safe and does not use synchronization.<br>This class is normally used to verify performance during proof-of-concepts and in development, rather than as part of production applications.<br>Since:<br>May 2, 2001</p>
<p>这个类的作者是Rod Johnson在20015月2号写的，时间飞逝，现在已经是2019年了，18年过去了，我也写了快5年的代码了，希望每个人技术爱好者能够坚持自己的初衷，也希望你们早日找到女朋友，闲言少叙看一下StopWatch的介绍。</p>
<p>一个简单的计数器，它支持一些列任务的计时工作，公开总的运行时间，还有具名任务的时间。<br>可以不去让我们使用 System.currentTimeMillis()得到系统时间，目的是为了应用代码的可读性以及可能的计算错误。</p>
<p>注意和这个对象没有设计为线程安全的，不能用于同步。<br>这个类通常用于在 proof-of-concepts阶段验证性能，并不是产品应用的一部分。<br>这里就用于统计我们应用的启动时间。</p>
<p>它的内部有一个private final List<TaskInfo> taskList &#x3D; new LinkedList&lt;&gt;(); 因为可以用于多个任务的统计工作。</p>
<h4 id="ConfigurableApplicationContext"><a href="#ConfigurableApplicationContext" class="headerlink" title="ConfigurableApplicationContext"></a>ConfigurableApplicationContext</h4><h5 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h5><p>ConfigurableApplicationContext继承了ApplicationContext，我们现在看到的应用启动过程都是围绕ApplicationContext进行的，有必要看一下ApplicationContext的doc：</p>
<p>org.springframework.context public interface ApplicationContext<br>extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver</p>
<p>Central interface to provide configuration for an application. This is read-only while the application is running, but may be reloaded if the implementation supports this.<br>An ApplicationContext provides:</p>
<ul>
<li>Bean factory methods for accessing application components. Inherited from ListableBeanFactory.</li>
<li>The ability to load file resources in a generic fashion. Inherited from the org.springframework.core.io.ResourceLoader interface.</li>
<li>The ability to publish events to registered listeners. Inherited from the ApplicationEventPublisher interface.</li>
<li>The ability to resolve messages, supporting internationalization. Inherited from the MessageSource interface.</li>
<li>Inheritance from a parent context. Definitions in a descendant context will always take priority. This means, for example, that a single parent context can be used by an entire web application, while each servlet has its own child context that is independent of that of any other servlet.</li>
</ul>
<p>In addition to standard org.springframework.beans.factory.BeanFactory lifecycle capabilities, ApplicationContext implementations detect and invoke ApplicationContextAware beans as well as ResourceLoaderAware, ApplicationEventPublisherAware and MessageSourceAware beans.<br>See Also:<br>ConfigurableApplicationContext,<br>org.springframework.beans.factory.BeanFactory,<br> org.springframework.core.io.ResourceLoader</p>
<p>一个用于提供应用配置的中心接口，当应用运行的时候是只读的，但是如果他的实现支持刷新，它也是会被刷新的。<br>一个应用上下文提供如下：</p>
<ul>
<li>bean工厂的方法，用于访问应用的组件，来自于ListableBeanFactory。</li>
<li>以一种通用的风格加载文件资源的能力，从org.springframework.core.io.ResourceLoader接口沿袭下来的能力</li>
<li>向注册的监听器发布事件的能力，来自于ApplicationEventPublisher接口</li>
<li>解析消息的能力，支持国际化，来自于MessageSource接口</li>
<li>可以从父的上下文继承能力，定义的后代的上下文拥有更高的优先级，这意味着，比如，一个单例的父上下文，可以被整个web应用使用，这样每个servlet的和其他的都是独立的。</li>
</ul>
<h4 id="ConfigurableApplicationContext-1"><a href="#ConfigurableApplicationContext-1" class="headerlink" title="ConfigurableApplicationContext"></a>ConfigurableApplicationContext</h4><p>org.springframework.context public interface ConfigurableApplicationContext<br>extends ApplicationContext, Lifecycle, Closeable<br>SPI interface to be implemented by most if not all application contexts. Provides facilities to configure an application context in addition to the application context client methods in the ApplicationContext interface.<br>Configuration and lifecycle methods are encapsulated here to avoid making them obvious to ApplicationContext client code. The present methods should only be used by startup and shutdown code.</p>
<p>被大部分，但不是全部的应用上下文实现的spi接口，在ApplicationContext接口的基础上通过附加的应用上下文客户端方法的形式提供了一些配置应用上下文的基础设施。<br>配置与生命周期方法被封装在这里，以避免显式的公开给客户端代码，只能被启动和关闭代码使用。</p>
<h4 id="SpringBootExceptionReporter"><a href="#SpringBootExceptionReporter" class="headerlink" title="SpringBootExceptionReporter"></a>SpringBootExceptionReporter</h4><p>SpringBootExceptionReporter是一个函数式接口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">Callback interface used to support custom reporting of SpringApplication startup errors. reporters are loaded via the SpringFactoriesLoader and must declare a public constructor with a single ConfigurableApplicationContext parameter.</span><br><span class="line">用来支持对于SpringApplication启动错误的自定义的报告的回调接口，reporters是通过SpringFactoriesLoader加载的，并且声明一个public的带有ConfigurableApplicationContext类型的参数的构造器。</span><br><span class="line">*/</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface SpringBootExceptionReporter &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Report a startup failure to the user.</span><br><span class="line">	 * @param failure the source failure 失败的源</span><br><span class="line">	 * @return &#123;@code true&#125; if the failure was reported or &#123;@code false&#125; if default</span><br><span class="line">	 * reporting should occur.</span><br><span class="line">   报告一个启动失败，</span><br><span class="line">	 */</span><br><span class="line">	boolean reportException(Throwable failure);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它有唯一一个实现类FailureAnalyzers，构造器如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FailureAnalyzers(ConfigurableApplicationContext context, ClassLoader classLoader) &#123;</span><br><span class="line">  Assert.notNull(context, &quot;Context must not be null&quot;);</span><br><span class="line">  this.classLoader = (classLoader != null) ? classLoader : context.getClassLoader();</span><br><span class="line">  this.analyzers = loadFailureAnalyzers(this.classLoader);</span><br><span class="line">  prepareFailureAnalyzers(this.analyzers, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="configureHeadlessProperty-方法"><a href="#configureHeadlessProperty-方法" class="headerlink" title="configureHeadlessProperty()方法"></a>configureHeadlessProperty()方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static final String SYSTEM_PROPERTY_JAVA_AWT_HEADLESS = &quot;java.awt.headless&quot;;</span><br><span class="line">private boolean headless = true;</span><br><span class="line">private void configureHeadlessProperty() &#123;</span><br><span class="line">  System.setProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, System.getProperty(</span><br><span class="line">      SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, Boolean.toString(this.headless)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SYSTEM_PROPERTY_JAVA_AWT_HEADLESS属性表达意图：这是一个服务器应用，没有显示器，没有键盘，没有鼠标的应用。</p>
<h4 id="getRunListeners-方法以及监听器模式的经典应用"><a href="#getRunListeners-方法以及监听器模式的经典应用" class="headerlink" title="getRunListeners()方法以及监听器模式的经典应用"></a>getRunListeners()方法以及监听器模式的经典应用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private SpringApplicationRunListeners getRunListeners(String[] args) &#123;</span><br><span class="line">  // SpringApplicationRunListener的构造器需要2个参数：SpringApplication和string数组。</span><br><span class="line">  Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">  return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances(</span><br><span class="line">      SpringApplicationRunListener.class, types, this, args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后返回的是SpringApplicationRunListeners，SpringApplicationRunListeners里边有一个集合【	private final List<SpringApplicationRunListener> listeners;】<br>因为有必要看那一下 SpringApplicationRunListener的doc</p>
<h5 id="SpringApplicationRunListener类"><a href="#SpringApplicationRunListener类" class="headerlink" title="SpringApplicationRunListener类"></a>SpringApplicationRunListener类</h5><p>org.springframework.boot public interface SpringApplicationRunListener<br>Listener for the SpringApplication run method. SpringApplicationRunListeners are loaded via the SpringFactoriesLoader and should declare a public constructor that accepts a SpringApplication instance and a String[] of arguments. A new SpringApplicationRunListener instance will be created for each run.</p>
<p>针对SpringApplication run方法的监听器，SpringApplicationRunListeners通过SpringFactoriesLoader加载的，而且声明一个public的构造器，并且接受一个SpringApplication类型的参数，和一个string类型的数组(这也是为什么上面介绍的getRunListeners方法携带【Class<?>[] types = new Class<?>[] { SpringApplication.class, String[].class };】参数的原因，SpringApplicationRunListener实例将会针对于运行一个新的SpringApplication的run被创建。<br>主要是对run方法的监听的作用。观察者模式的体现。<br>由于是一个监听器，它的方法接口都体现了声明周期的,SpringApplicationRunListener方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//ApplicationContext已经被加载，但是它还没有被刷新之前调用</span><br><span class="line">contextLoaded</span><br><span class="line">//ApplicationContext已经创建和准备好了，但是资源还没有被加载</span><br><span class="line">contextPrepared</span><br><span class="line">//环境准备完毕，但是ApplicationContext被创建之前调用</span><br><span class="line">environmentPrepared</span><br><span class="line">//应用启动失败的时候被调用</span><br><span class="line">failed</span><br><span class="line">//run方法已经完成，应用上下文已经被刷新，并且CommandLineRunners和ApplicationRunner也已经被调用，running才会被调用。</span><br><span class="line">running</span><br><span class="line">//ApplicationContext已经被刷新，应用也已经启动，但是CommandLineRunners和ApplicationRunner还没有被调用</span><br><span class="line">started</span><br><span class="line">//run方法已开始启动的时候就会被调用，常常用于非常早期的工作。</span><br><span class="line">starting</span><br></pre></td></tr></table></figure>

<h5 id="SpringApplicationRunListeners"><a href="#SpringApplicationRunListeners" class="headerlink" title="SpringApplicationRunListeners"></a>SpringApplicationRunListeners</h5><p>代码结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private final List&lt;SpringApplicationRunListener&gt; listeners;</span><br><span class="line"></span><br><span class="line">SpringApplicationRunListeners(Log log,</span><br><span class="line">    Collection&lt;? extends SpringApplicationRunListener&gt; listeners) &#123;</span><br><span class="line">  this.log = log;</span><br><span class="line">  this.listeners = new ArrayList&lt;&gt;(listeners);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其他的方法：</span><br><span class="line">callFailedListener</span><br><span class="line">contextLoaded</span><br><span class="line">contextPrepared</span><br><span class="line">environmentPrepared</span><br><span class="line">failed</span><br><span class="line">running</span><br><span class="line">started</span><br><span class="line">starting</span><br></pre></td></tr></table></figure>
<p>这些方法和SpringApplicationRunListener方法是一致的，SpringApplicationRunListeners对所有的SpringApplicationRunListener统一管理。</p>
<h5 id="EventPublishingRunListener"><a href="#EventPublishingRunListener" class="headerlink" title="EventPublishingRunListener"></a>EventPublishingRunListener</h5><p>我们断点一下看一下有几个监听器：<br><img src="/EventPublishingRunListener.png" alt="EventPublishingRunListener.png"><br>通过断点可以看到只有一个EventPublishingRunListener，用于发布SpringApplicationEvent，通过ApplicationEventMulticaster在上下文发布之前发布事件。</p>
<p>EventPublishingRunListener构造器如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private final SpringApplication application;</span><br><span class="line"></span><br><span class="line">private final String[] args;</span><br><span class="line"></span><br><span class="line">private final SimpleApplicationEventMulticaster initialMulticaster;</span><br><span class="line"></span><br><span class="line">public EventPublishingRunListener(SpringApplication application, String[] args) &#123;</span><br><span class="line">  this.application = application;</span><br><span class="line">  this.args = args;</span><br><span class="line">  this.initialMulticaster = new SimpleApplicationEventMulticaster();</span><br><span class="line">  for (ApplicationListener&lt;?&gt; listener : application.getListeners()) &#123;</span><br><span class="line">    this.initialMulticaster.addApplicationListener(listener);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="SimpleApplicationEventMulticaster"><a href="#SimpleApplicationEventMulticaster" class="headerlink" title="SimpleApplicationEventMulticaster"></a>SimpleApplicationEventMulticaster</h6><p>构造器里边初始化了一个SimpleApplicationEventMulticaster，看一下介绍：<br>org.springframework.context.event public class SimpleApplicationEventMulticaster<br>extends AbstractApplicationEventMulticaster<br>Simple implementation of the ApplicationEventMulticaster interface.<br>Multicasts all events to all registered listeners, leaving it up to the listeners to ignore events that they are not interested in. Listeners will usually perform corresponding instanceof checks on the passed-in event object.<br>By default, all listeners are invoked in the calling thread. This allows the danger of a rogue listener blocking the entire application, but adds minimal overhead. Specify an alternative task executor to have listeners executed in different threads, for example from a thread pool.<br>ApplicationEventMulticaster接口的简单实现。<br>广播所有的事件给所有注册的监听器，对于不感兴趣的事件的过滤的决定权留给每个监听器自己去处理。监听器对于传递过来的时间对象通常会进行instanceof检查，默认情况，所有的监听器都会在被调用的线程去执行，这样就会存在一种危险，某一些监听器会阻塞整个的应用，但确是最小的成本，用一个替代的任务执行器拥有这个监听器，这样在不同的线程去执行，比如在线程池里边。</p>
<p>看一下EventPublishingRunListener的starting方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void starting() &#123;</span><br><span class="line">  this.initialMulticaster.multicastEvent(</span><br><span class="line">      new ApplicationStartingEvent(this.application, this.args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里冒出来一个ApplicationStartingEvent。</p>
<h6 id="ApplicationStartingEvent"><a href="#ApplicationStartingEvent" class="headerlink" title="ApplicationStartingEvent"></a>ApplicationStartingEvent</h6><p>org.springframework.boot.context.event public class ApplicationStartingEvent<br>extends SpringApplicationEvent<br>Event published as early as conceivably possible as soon as a SpringApplication has been started - before the Environment or ApplicationContext is available, but after the ApplicationListeners have been registered. The source of the event is the SpringApplication itself, but beware of using its internal state too much at this early stage since it might be modified later in the lifecycle.</p>
<p>当spring应用已经启动的时候尽早的把事件发布出去，并且在Environment或者ApplicationContext可用之前，但是在ApplicationListeners已经被注册之后，时间的源是SpringApplication本身，但是请注意使用它的内部状态太多的话，会对后续的生命周期有一些影响。<br>它的父类是SpringApplicationEvent，父类的实现类有如下事件：<br>ApplicationContextInitializedEvent<br>ApplicationEnvironmentPreparedEvent<br>ApplicationFailedEvent<br>ApplicationPreparedEvent<br>ApplicationReadyEvent<br>ApplicationStartedEvent<br>ApplicationStartingEvent<br>诠释了Application的生命周期。</p>
<h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>应用在启动的时候，会在某一些时间点发布一些事件，发对对象是所有注册的事件监听器，事件监听器自己决定是否感兴趣和处理这个事件，这是一种监听器设计模式的体现，监听器都有一个源，就是监听器的主题，源是Application本身，SpringApplicationRunListeners在不同的时间点发布不同的事件对象。</p>
<h4 id="environment组件的重要作用详解"><a href="#environment组件的重要作用详解" class="headerlink" title="environment组件的重要作用详解"></a>environment组件的重要作用详解</h4><h5 id="Environment-doc解读"><a href="#Environment-doc解读" class="headerlink" title="Environment doc解读"></a>Environment doc解读</h5><p>我们走到了【ConfigurableEnvironment environment &#x3D; prepareEnvironment(listeners,applicationArguments);】这行代码，首先理解下ConfigurableEnvironment,它的父类是Environment，看下Environment的doc：</p>
<p>org.springframework.core.env<br>public interface Environment extends PropertyResolver</p>
<p>Interface representing the environment in which the current application is running. Models two key aspects of the application environment: profiles and properties. Methods related to property access are exposed via the PropertyResolver superinterface.<br>A profile is a named, logical group of bean definitions to be registered with the container only if the given profile is active. Beans may be assigned to a profile whether defined in XML or via annotations; see the spring-beans 3.1 schema or the <code>@Profile</code> annotation for syntax details. The role of the Environment object with relation to profiles is in determining which profiles (if any) are currently active, and which profiles (if any) should be active by default.<br>Properties play an important role in almost all applications, and may originate from a variety of sources: properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc Properties objects, Maps, and so on. The role of the environment object with relation to properties is to provide the user with a convenient service interface for configuring property sources and resolving properties from them.<br>Beans managed within an ApplicationContext may register to be EnvironmentAware or <code>@Inject</code> the Environment in order to query profile state or resolve properties directly.<br>In most cases, however, application-level beans should not need to interact with the Environment directly but instead may have to have ${…} property values replaced by a property placeholder configurer such as PropertySourcesPlaceholderConfigurer, which itself is EnvironmentAware and as of Spring 3.1 is registered by default when using <span class="exturl" data-url="Y29udGV4dDpwcm9wZXJ0eS1wbGFjZWhvbGRlci8=">context:property-placeholder/<i class="fa fa-external-link-alt"></i></span>.<br>Configuration of the environment object must be done through the ConfigurableEnvironment interface, returned from all AbstractApplicationContext subclass getEnvironment() methods. See ConfigurableEnvironment Javadoc for usage examples demonstrating manipulation of property sources prior to application context refresh().</p>
<p>代表了一种当前应用正在运行的环境，有两个很重要应用环境的方面：prifile和properties,访问属性的方法通过PropertyResolver父接口提供。<br>profile是被具名的，逻辑的bean的分组，当给定的profile是活动的状态时，这些bean定义会被被注册到容器当中，bean无论是xml定义或者annotation的形式，bean会被关联一个profile，请看 spring-beans 3.1的schema了解Profile注解的语法详情，环境的角色用来决定它关联的profiles，那些profile当前是活动的，并且这些profiles默认情况下是活动的。<br>在大多数的应用中，Properties扮演了一个重要的角色，它可能来自各种各样的来源，比如属性文件，jvm的系统属性，系统环境变量，jndi，servlet山下文参数，及时变更的属性对象，map，等等，关联属性的environment对象的这种角色，为用户提供了方便的属性配置属性解析的接口服务。<br>ApplicationContext里边注册的这些bean可以是EnvironmentAware或者是 <code>@Inject</code>的，这些可以用来查询profile状态和属性解析。<br>在大多数的情况下，应用级别的bean不需要直接和Environment交互，但是可以用一种 ${…}这种形式的占位符配置器的方式去配置，比如PropertySourcesPlaceholderConfigurer，他自己本身就是环境组件，在Spring 3.1当中，通过使用<span class="exturl" data-url="Y29udGV4dDpwcm9wZXJ0eS1wbGFjZWhvbGRlci8=">context:property-placeholder/<i class="fa fa-external-link-alt"></i></span>进行注册。<br>环境对象的配置必须通过ConfigurableEnvironment接口，从AbstractApplicationContext所有子类的getEnvironment方法返回。</p>
<h5 id="ConfigurableEnvironment-doc解读"><a href="#ConfigurableEnvironment-doc解读" class="headerlink" title="ConfigurableEnvironment doc解读"></a>ConfigurableEnvironment doc解读</h5><p>接下来是ConfigurableEnvironment，也就是Environment的子类，看一下doc：<br>org.springframework.core.env public interface ConfigurableEnvironment extends Environment, ConfigurablePropertyResolver</p>
<p>Configuration interface to be implemented by most if not all Environment types. Provides facilities for setting active and default profiles and manipulating underlying property sources. Allows clients to set and validate required properties, customize the conversion service and more through the ConfigurablePropertyResolver superinterface.<br>Manipulating property sources<br>Property sources may be removed, reordered, or replaced; and additional property sources may be added using the MutablePropertySources instance returned from getPropertySources(). The following examples are against the StandardEnvironment implementation of ConfigurableEnvironment, but are generally applicable to any implementation, though particular default property sources may differ.<br>Example: adding a new property source with highest search priority<br>   ConfigurableEnvironment environment &#x3D; new StandardEnvironment();<br>   MutablePropertySources propertySources &#x3D; environment.getPropertySources();<br>   Map&lt;String, String&gt; myMap &#x3D; new HashMap&lt;&gt;();<br>   myMap.put(“xyz”, “myValue”);<br>   propertySources.addFirst(new MapPropertySource(“MY_MAP”, myMap));</p>
<p>Example: removing the default system properties property source<br>   MutablePropertySources propertySources &#x3D; environment.getPropertySources();<br>   propertySources.remove(StandardEnvironment.SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME)</p>
<p>Example: mocking the system environment for testing purposes<br>   MutablePropertySources propertySources &#x3D; environment.getPropertySources();<br>   MockPropertySource mockEnvVars &#x3D; new MockPropertySource().withProperty(“xyz”, “myValue”);<br>   propertySources.replace(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, mockEnvVars);</p>
<p>When an Environment is being used by an ApplicationContext, it is important that any such PropertySource manipulations be performed before the context’s refresh() method is called. This ensures that all property sources are available during the container bootstrap process, including use by property placeholder configurers.<br>一个不是被所有也是被大多数Environment类型所实现的配置接口，提供了设置活动的默认的profiles，以及操作底层的属性元的基础设施，允许客户端设置和验证所要求的属性，定制转换服务，都是通过ConfigurablePropertyResolver这样的一个父接口进行的。<br>如何操纵属性源？<br>属性源可以被删除，重排序也可以被替换，并且额外的属性来源可以通过MutablePropertySources进行添加，通过getPropertySources方法进行获取，接下来的举例针对于ConfigurableEnvironment的标准环境的实现，不过和特定的默认的属性源有点不同。<br>例子：添加了一个高搜索优先级的属性源：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ConfigurableEnvironment environment = new StandardEnvironment();</span><br><span class="line">MutablePropertySources propertySources = environment.getPropertySources();</span><br><span class="line">Map&lt;String, String&gt; myMap = new HashMap&lt;&gt;();</span><br><span class="line">myMap.put(&quot;xyz&quot;, &quot;myValue&quot;);</span><br><span class="line">propertySources.addFirst(new MapPropertySource(&quot;MY_MAP&quot;, myMap));</span><br></pre></td></tr></table></figure>
<p>举例：删除默认系统属性源：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MutablePropertySources propertySources = environment.getPropertySources();</span><br><span class="line">propertySources.remove(StandardEnvironment.SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME)</span><br></pre></td></tr></table></figure>
<p>举例：针对测试的目的模拟系统的环境：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MutablePropertySources propertySources = environment.getPropertySources();</span><br><span class="line">MockPropertySource mockEnvVars = new MockPropertySource().withProperty(&quot;xyz&quot;, &quot;myValue&quot;);</span><br><span class="line">propertySources.replace(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, mockEnvVars);</span><br></pre></td></tr></table></figure>
<h5 id="prepareEnvironment方法"><a href="#prepareEnvironment方法" class="headerlink" title="prepareEnvironment方法"></a>prepareEnvironment方法</h5><p>它的逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners,  ApplicationArguments applicationArguments) &#123;</span><br><span class="line">  // Create and configure the environment</span><br><span class="line">  //存在环境就返回，不存在就创建</span><br><span class="line">  ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class="line">  configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line">  listeners.environmentPrepared(environment);</span><br><span class="line">  bindToSpringApplication(environment);</span><br><span class="line">  if (!this.isCustomEnvironment) &#123;</span><br><span class="line">    environment = new EnvironmentConverter(getClassLoader())</span><br><span class="line">        .convertEnvironmentIfNecessary(environment, deduceEnvironmentClass());</span><br><span class="line">  &#125;</span><br><span class="line">  ConfigurationPropertySources.attach(environment);</span><br><span class="line">  return environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="getOrCreateEnvironment-方法"><a href="#getOrCreateEnvironment-方法" class="headerlink" title="getOrCreateEnvironment()方法"></a>getOrCreateEnvironment()方法</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private ConfigurableEnvironment getOrCreateEnvironment() &#123;</span><br><span class="line">  //环境存在就返回</span><br><span class="line">  if (this.environment != null) &#123;</span><br><span class="line">    return this.environment;</span><br><span class="line">  &#125;</span><br><span class="line">  //根据应用类型返回对应应用类型的环境</span><br><span class="line">  switch (this.webApplicationType) &#123;</span><br><span class="line">  case SERVLET:</span><br><span class="line">    return new StandardServletEnvironment();</span><br><span class="line">  case REACTIVE:</span><br><span class="line">    return new StandardReactiveWebEnvironment();</span><br><span class="line">  default:</span><br><span class="line">    return new StandardEnvironment();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="configureEnvironment-方法"><a href="#configureEnvironment-方法" class="headerlink" title="configureEnvironment()方法"></a>configureEnvironment()方法</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void configureEnvironment(ConfigurableEnvironment environment,</span><br><span class="line">    String[] args) &#123;</span><br><span class="line">  if (this.addConversionService) &#123;</span><br><span class="line">    ConversionService conversionService = ApplicationConversionService</span><br><span class="line">        .getSharedInstance();</span><br><span class="line">    environment.setConversionService(</span><br><span class="line">        (ConfigurableConversionService) conversionService);</span><br><span class="line">  &#125;</span><br><span class="line">  configurePropertySources(environment, args);</span><br><span class="line">  configureProfiles(environment, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConversionService:一个用来进行类型转换的服务接口，装换系统的入口点，调用convert实现线程安全的转换。<br>ApplicationConversionService.getSharedInstance();用的单利模式，而且是线程安全的，这是经典的单利模式的使用，懒汉模式，注意配合volatile关键字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static volatile ApplicationConversionService sharedInstance;</span><br><span class="line">public static ConversionService getSharedInstance() &#123;</span><br><span class="line">  ApplicationConversionService sharedInstance = ApplicationConversionService.sharedInstance;</span><br><span class="line">  if (sharedInstance == null) &#123;</span><br><span class="line">    synchronized (ApplicationConversionService.class) &#123;</span><br><span class="line">      sharedInstance = ApplicationConversionService.sharedInstance;</span><br><span class="line">      if (sharedInstance == null) &#123;</span><br><span class="line">        sharedInstance = new ApplicationConversionService();</span><br><span class="line">        ApplicationConversionService.sharedInstance = sharedInstance;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【configurePropertySources(environment, args);】<br>添加，移除，重排序属性源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void configurePropertySources(ConfigurableEnvironment environment,</span><br><span class="line">    String[] args) &#123;</span><br><span class="line">  MutablePropertySources sources = environment.getPropertySources();</span><br><span class="line">  if (this.defaultProperties != null &amp;&amp; !this.defaultProperties.isEmpty()) &#123;</span><br><span class="line">    sources.addLast(</span><br><span class="line">        new MapPropertySource(&quot;defaultProperties&quot;, this.defaultProperties));</span><br><span class="line">  &#125;</span><br><span class="line">  if (this.addCommandLineProperties &amp;&amp; args.length &gt; 0) &#123;</span><br><span class="line">    String name = CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME;</span><br><span class="line">    if (sources.contains(name)) &#123;</span><br><span class="line">      PropertySource&lt;?&gt; source = sources.get(name);</span><br><span class="line">      CompositePropertySource composite = new CompositePropertySource(name);</span><br><span class="line">      composite.addPropertySource(new SimpleCommandLinePropertySource(</span><br><span class="line">          &quot;springApplicationCommandLineArgs&quot;, args));</span><br><span class="line">      composite.addPropertySource(source);</span><br><span class="line">      sources.replace(name, composite);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      sources.addFirst(new SimpleCommandLinePropertySource(args));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【configureProfiles(environment, args);】<br>针对于整个应用的环境，配置那些profile是活动的或者是默认的，其他额外的profile可以在配置文件处理过程中通过spring.profiles.active属性激活。</p>
<h6 id="listeners-environmentPrepared-environment"><a href="#listeners-environmentPrepared-environment" class="headerlink" title="listeners.environmentPrepared(environment)"></a>listeners.environmentPrepared(environment)</h6><p>触发了一个新的事件——环境准备好的事件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void environmentPrepared(ConfigurableEnvironment environment) &#123;</span><br><span class="line">  for (SpringApplicationRunListener listener : this.listeners) &#123;</span><br><span class="line">    listener.environmentPrepared(environment);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Banner"><a href="#Banner" class="headerlink" title="Banner"></a>Banner</h4><p>在进行往下进行之前，我们先对banner做一个实验，我们在resources目录下新建一个banner.txt文件，里边输入一段文字，然后启动应用，会看到打印了我们输入的信息，banner自定义生效：<br><img src="/banner.png" alt="banner.png"><br>Banner是一个函数式接口，里边有一个枚举，用于配置banner的模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Mode &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Disable printing of the banner.</span><br><span class="line">   */</span><br><span class="line">  OFF,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Print the banner to System.out.</span><br><span class="line">   */</span><br><span class="line">  CONSOLE,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Print the banner to the log file.</span><br><span class="line">   */</span><br><span class="line">  LOG</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主流程了printBanner()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Banner printBanner(ConfigurableEnvironment environment) &#123;</span><br><span class="line">  //默认是CONSOLE</span><br><span class="line">  if (this.bannerMode == Banner.Mode.OFF) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  //获取资源加载器</span><br><span class="line">  ResourceLoader resourceLoader = (this.resourceLoader != null)</span><br><span class="line">      ? this.resourceLoader : new DefaultResourceLoader(getClassLoader());</span><br><span class="line">  SpringApplicationBannerPrinter bannerPrinter = new SpringApplicationBannerPrinter(</span><br><span class="line">      resourceLoader, this.banner);</span><br><span class="line">  //当前程序不会走这个if</span><br><span class="line">  if (this.bannerMode == Mode.LOG) &#123;</span><br><span class="line">    return bannerPrinter.print(environment, this.mainApplicationClass, logger);</span><br><span class="line">  &#125;</span><br><span class="line">  //当前程序会执行这个</span><br><span class="line">  return bannerPrinter.print(environment, this.mainApplicationClass, System.out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="SpringApplicationBannerPrinter"><a href="#SpringApplicationBannerPrinter" class="headerlink" title="SpringApplicationBannerPrinter"></a>SpringApplicationBannerPrinter</h5><p>用来打印application的banner，其内部有一个成员变量【static final String DEFAULT_BANNER_LOCATION &#x3D; “banner.txt”;】<br>即默认的banner文件。<br>构造器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SpringApplicationBannerPrinter(ResourceLoader resourceLoader, Banner fallbackBanner) &#123;</span><br><span class="line">  //资源加载器，可能要使用resourceLoader加载banner文件</span><br><span class="line">  this.resourceLoader = resourceLoader;</span><br><span class="line">  //回退banner</span><br><span class="line">  this.fallbackBanner = fallbackBanner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下SpringApplicationBannerPrinter的print方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Banner print(Environment environment, Class&lt;?&gt; sourceClass, PrintStream out) &#123;</span><br><span class="line">  //获取banner</span><br><span class="line">  Banner banner = getBanner(environment);</span><br><span class="line">  //打印banner</span><br><span class="line">  banner.printBanner(environment, sourceClass, out);</span><br><span class="line">  return new PrintedBanner(banner, sourceClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getBanner根据环境得到banner。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Banner getBanner(Environment environment) &#123;</span><br><span class="line">  Banners banners = new Banners();</span><br><span class="line">  //图像banner存在就会加载</span><br><span class="line">  banners.addIfNotNull(getImageBanner(environment));</span><br><span class="line">  //文字banner存在就会加载</span><br><span class="line">  banners.addIfNotNull(getTextBanner(environment));</span><br><span class="line">  if (banners.hasAtLeastOneBanner()) &#123;</span><br><span class="line">    return banners;</span><br><span class="line">  &#125;</span><br><span class="line">  if (this.fallbackBanner != null) &#123;</span><br><span class="line">    return this.fallbackBanner;</span><br><span class="line">  &#125;</span><br><span class="line">  //没有找到banner就会使用spring默认的banner（SpringBootBanner）</span><br><span class="line">  return DEFAULT_BANNER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中看一下getTextBanner():</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final String DEFAULT_BANNER_LOCATION = &quot;banner.txt&quot;;</span><br><span class="line">private Banner getTextBanner(Environment environment) &#123;</span><br><span class="line">  String location = environment.getProperty(BANNER_LOCATION_PROPERTY,</span><br><span class="line">      DEFAULT_BANNER_LOCATION);</span><br><span class="line">  Resource resource = this.resourceLoader.getResource(location);</span><br><span class="line">  //如果文件banner.txt存在就会加载这个资源。</span><br><span class="line">  if (resource.exists()) &#123;</span><br><span class="line">    return new ResourceBanner(resource);</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们看一下SpringBootBanner的printBanner()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static final String[] BANNER = &#123; &quot;&quot;,</span><br><span class="line">    &quot;  .   ____          _            __ _ _&quot;,</span><br><span class="line">    &quot; /\\\\ / ___&#x27;_ __ _ _(_)_ __  __ _ \\ \\ \\ \\&quot;,</span><br><span class="line">    &quot;( ( )\\___ | &#x27;_ | &#x27;_| | &#x27;_ \\/ _` | \\ \\ \\ \\&quot;,</span><br><span class="line">    &quot; \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )&quot;,</span><br><span class="line">    &quot;  &#x27;  |____| .__|_| |_|_| |_\\__, | / / / /&quot;,</span><br><span class="line">    &quot; =========|_|==============|___/=/_/_/_/&quot; &#125;;</span><br><span class="line">public void printBanner(Environment environment, Class&lt;?&gt; sourceClass,PrintStream printStream) &#123;</span><br><span class="line">  for (String line : BANNER) &#123;</span><br><span class="line">    printStream.println(line);</span><br><span class="line">  &#125;</span><br><span class="line">  String version = SpringBootVersion.getVersion();</span><br><span class="line">  version = (version != null) ? &quot; (v&quot; + version + &quot;)&quot; : &quot;&quot;;</span><br><span class="line">  StringBuilder padding = new StringBuilder();</span><br><span class="line">  while (padding.length() &lt; STRAP_LINE_SIZE</span><br><span class="line">      - (version.length() + SPRING_BOOT.length())) &#123;</span><br><span class="line">    padding.append(&quot; &quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printStream.println(AnsiOutput.toString(AnsiColor.GREEN, SPRING_BOOT,</span><br><span class="line">      AnsiColor.DEFAULT, padding.toString(), AnsiStyle.FAINT, version));</span><br><span class="line">  printStream.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到之前我们没有配置banner.txt的时候打印就是这个”spring”输出，即输出了BANNER数组。</p>
<h4 id="createApplicationContext-方法"><a href="#createApplicationContext-方法" class="headerlink" title="createApplicationContext()方法"></a>createApplicationContext()方法</h4><p>一个用来创建上下文的策略方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected ConfigurableApplicationContext createApplicationContext() &#123;</span><br><span class="line">  //applicationContextClass默认是空的</span><br><span class="line">  Class&lt;?&gt; contextClass = this.applicationContextClass;</span><br><span class="line">  if (contextClass == null) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      switch (this.webApplicationType) &#123;</span><br><span class="line">        //我们的应用是SERVLET</span><br><span class="line">      case SERVLET:</span><br><span class="line">      /**</span><br><span class="line">      public static final String DEFAULT_SERVLET_WEB_CONTEXT_CLASS = &quot;org.springframework.boot.&quot;</span><br><span class="line">    			+ &quot;web.servlet.context.AnnotationConfigServletWebServerApplicationContext&quot;;</span><br><span class="line">      **/</span><br><span class="line">        contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line">        break;</span><br><span class="line">      case REACTIVE:</span><br><span class="line">        contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ClassNotFoundException ex) &#123;</span><br><span class="line">      throw new IllegalStateException(</span><br><span class="line">          &quot;Unable create a default ApplicationContext, &quot;</span><br><span class="line">              + &quot;please specify an ApplicationContextClass&quot;,</span><br><span class="line">          ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //通过反射创建contextClass</span><br><span class="line">  return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="prepareContext-context-environment-listeners-applicationArguments-printedBanner-方法"><a href="#prepareContext-context-environment-listeners-applicationArguments-printedBanner-方法" class="headerlink" title="prepareContext(context, environment, listeners, applicationArguments,printedBanner)方法"></a>prepareContext(context, environment, listeners, applicationArguments,printedBanner)方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void prepareContext(ConfigurableApplicationContext context,</span><br><span class="line">    ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span><br><span class="line">    ApplicationArguments applicationArguments, Banner printedBanner) &#123;</span><br><span class="line">  context.setEnvironment(environment);</span><br><span class="line">  //处理上下文</span><br><span class="line">  postProcessApplicationContext(context);</span><br><span class="line">  applyInitializers(context);</span><br><span class="line">  //触发事件，上下文已经创建和准备完毕，但是资源还没有加载</span><br><span class="line">  listeners.contextPrepared(context);</span><br><span class="line">  if (this.logStartupInfo) &#123;</span><br><span class="line">    logStartupInfo(context.getParent() == null);</span><br><span class="line">    //启动日志的处理</span><br><span class="line">    logStartupProfileInfo(context);</span><br><span class="line">  &#125;</span><br><span class="line">  // Add boot specific singleton beans</span><br><span class="line">  ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">  beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments);</span><br><span class="line">  if (printedBanner != null) &#123;</span><br><span class="line">    beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner);</span><br><span class="line">  &#125;</span><br><span class="line">  if (beanFactory instanceof DefaultListableBeanFactory) &#123;</span><br><span class="line">    ((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">        .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);</span><br><span class="line">  &#125;</span><br><span class="line">  // Load the sources 加载资源</span><br><span class="line">  Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">  Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);</span><br><span class="line">  load(context, sources.toArray(new Object[0]));</span><br><span class="line">  //触发事件，上下文已经被加载，但是还没有被刷新</span><br><span class="line">  listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="refreshContext-刷新上下文"><a href="#refreshContext-刷新上下文" class="headerlink" title="refreshContext()刷新上下文"></a>refreshContext()刷新上下文</h4><p>此方法按照规定的顺序执行， 这个方法做的事情非常多，不会过多介绍， 最终走到AbstractApplicationContext的refresh()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">  synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">    // Prepare this context for refreshing.</span><br><span class="line">    prepareRefresh();</span><br><span class="line"></span><br><span class="line">    // Tell the subclass to refresh the internal bean factory.</span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">    // Prepare the bean factory for use in this context.</span><br><span class="line">    prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      // Allows post-processing of the bean factory in context subclasses.</span><br><span class="line">      postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      // Invoke factory processors registered as beans in the context.</span><br><span class="line">      invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">      // Register bean processors that intercept bean creation.</span><br><span class="line">      registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">      // Initialize message source for this context.</span><br><span class="line">      initMessageSource();</span><br><span class="line"></span><br><span class="line">      // Initialize event multicaster for this context.</span><br><span class="line">      initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">      // Initialize other special beans in specific context subclasses.</span><br><span class="line">      onRefresh();</span><br><span class="line"></span><br><span class="line">      // Check for listener beans and register them.</span><br><span class="line">      registerListeners();</span><br><span class="line"></span><br><span class="line">      // Instantiate all remaining (non-lazy-init) singletons.</span><br><span class="line">      finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">      // Last step: publish corresponding event.</span><br><span class="line">      finishRefresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    catch (BeansException ex) &#123;</span><br><span class="line">      if (logger.isWarnEnabled()) &#123;</span><br><span class="line">        logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">            &quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Destroy already created singletons to avoid dangling resources.</span><br><span class="line">      destroyBeans();</span><br><span class="line"></span><br><span class="line">      // Reset &#x27;active&#x27; flag.</span><br><span class="line">      cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">      // Propagate exception to caller.</span><br><span class="line">      throw ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    finally &#123;</span><br><span class="line">      // Reset common introspection caches in Spring&#x27;s core, since we</span><br><span class="line">      // might not ever need metadata for singleton beans anymore...</span><br><span class="line">      resetCommonCaches();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="afterRefresh-context-applicationArguments-方法"><a href="#afterRefresh-context-applicationArguments-方法" class="headerlink" title="afterRefresh(context, applicationArguments)方法"></a>afterRefresh(context, applicationArguments)方法</h4><p>这个方法没有做任何事情，目的是为了留给子类继承的想象空间的。</p>
<h4 id="stopWatch-stop-秒表计时结束"><a href="#stopWatch-stop-秒表计时结束" class="headerlink" title="stopWatch.stop()秒表计时结束"></a>stopWatch.stop()秒表计时结束</h4><p>不做过多解释。</p>
<h4 id="打印启动信息"><a href="#打印启动信息" class="headerlink" title="打印启动信息"></a>打印启动信息</h4><p><img src="/stopwatch.png" alt="stopwatch.png"></p>
<h4 id="listeners-started-context"><a href="#listeners-started-context" class="headerlink" title="listeners.started(context)"></a>listeners.started(context)</h4><p>触发事件，上下文已经被刷新，应用已经启动，但是命令行运行器和应用运行器还没有被调用</p>
<h4 id="callRunners-方法"><a href="#callRunners-方法" class="headerlink" title="callRunners()方法"></a>callRunners()方法</h4><p>看一下它的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void callRunners(ApplicationContext context, ApplicationArguments args) &#123;</span><br><span class="line">  List&lt;Object&gt; runners = new ArrayList&lt;&gt;();</span><br><span class="line">  runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());</span><br><span class="line">  runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());</span><br><span class="line">  AnnotationAwareOrderComparator.sort(runners);</span><br><span class="line">  for (Object runner : new LinkedHashSet&lt;&gt;(runners)) &#123;</span><br><span class="line">    if (runner instanceof ApplicationRunner) &#123;</span><br><span class="line">      //启动应用运行器</span><br><span class="line">      callRunner((ApplicationRunner) runner, args);</span><br><span class="line">    &#125;</span><br><span class="line">    if (runner instanceof CommandLineRunner) &#123;</span><br><span class="line">      //启动命令行运行器</span><br><span class="line">      callRunner((CommandLineRunner) runner, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ApplicationRunner"><a href="#ApplicationRunner" class="headerlink" title="ApplicationRunner"></a>ApplicationRunner</h5><p>Interface used to indicate that a bean should run when it is contained within a SpringApplication. Multiple ApplicationRunner beans can be defined within the same application context and can be ordered using the Ordered interface or @Order annotation.</p>
<p>用于标示一个bean应该被运行，当它包含在一个SpringApplication当中，一个应用上下文可以有多个ApplicationRunner，可以使用Ordered接口或者<code>@Order</code>直接进行排序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface ApplicationRunner &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Callback used to run the bean.</span><br><span class="line">	 * @param args incoming application arguments</span><br><span class="line">	 * @throws Exception on error</span><br><span class="line">	 */</span><br><span class="line">	void run(ApplicationArguments args) throws Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="CommandLineRunner"><a href="#CommandLineRunner" class="headerlink" title="CommandLineRunner"></a>CommandLineRunner</h5><p>Interface used to indicate that a bean should run when it is contained within a SpringApplication. Multiple CommandLineRunner beans can be defined within the same application context and can be ordered using the Ordered interface or @Order annotation.<br>If you need access to ApplicationArguments instead of the raw String array consider using ApplicationRunner.</p>
<p>用于标示一个bean应该被运行，当它包含在一个SpringApplication当中，一个应用上下文可以有多个CommandLineRunner，可以使用Ordered接口或者<code>@Order</code>直接进行排序。<br>如果你想访问ApplicationArguments而不是原生的字符串数组，请使用ApplicationRunner。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface CommandLineRunner &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Callback used to run the bean.</span><br><span class="line">	 * @param args incoming main method arguments</span><br><span class="line">	 * @throws Exception on error</span><br><span class="line">	 */</span><br><span class="line">	void run(String... args) throws Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="listeners-running-context"><a href="#listeners-running-context" class="headerlink" title="listeners.running(context)"></a>listeners.running(context)</h4><p>run方法调用完毕之前立即会被触发和调用，应用上下文已经被刷新，CommandLineRunner和ApplicationRunner已经被调用。</p>
<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>当listeners.running(context)调用完毕之后run也就结束了，run方法返回一个ConfigurableApplicationContext，会返回到我们的main方法,到此应用的启动过程分析完毕。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class MyApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      ConfigurableApplicationContext configurableApplicationContext =   SpringApplication.run(MyApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>spring_boot_cloud</category>
      </categories>
      <tags>
        <tag>SpringBootApplication</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title>spring_boot_cloud(6)Spring_Boot日志处理详解</title>
    <url>/2019/07/28/spring_boot_and_cloud/spring_boot_cloud(6)Spring_Boot%E6%97%A5%E5%BF%97%E5%A4%84%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="spring-boot官方简介"><a href="#spring-boot官方简介" class="headerlink" title="spring-boot官方简介"></a>spring-boot官方简介</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NwcmluZy1wcm9qZWN0cy9zcHJpbmctYm9vdA==">https://github.com/spring-projects/spring-boot<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>

<h3 id="Spring-Boot日志处理详解"><a href="#Spring-Boot日志处理详解" class="headerlink" title="Spring Boot日志处理详解"></a>Spring Boot日志处理详解</h3><p>Spring Boot有一套自己的日志继承体系，我们在项目工程里边看到的logback-spring.xml文件就是它的体现，我们可以打开maven的依赖包下的<br>spring-boot-2.1.3.RELEASE.jar!&#x2F;org&#x2F;springframework&#x2F;boot&#x2F;logging&#x2F;logback&#x2F;base.xml文件，里边是一些基础的log配置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">Base logback configuration provided for compatibility with Spring Boot 1.1</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;included&gt;</span><br><span class="line">	&lt;include resource=&quot;org/springframework/boot/logging/logback/defaults.xml&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;LOG_FILE&quot; value=&quot;$&#123;LOG_FILE:-$&#123;LOG_PATH:-$&#123;LOG_TEMP:-$&#123;java.io.tmpdir:-/tmp&#125;&#125;&#125;/spring.log&#125;&quot;/&gt;</span><br><span class="line">	&lt;include resource=&quot;org/springframework/boot/logging/logback/console-appender.xml&quot; /&gt;</span><br><span class="line">	&lt;include resource=&quot;org/springframework/boot/logging/logback/file-appender.xml&quot; /&gt;</span><br><span class="line">	&lt;root level=&quot;INFO&quot;&gt;</span><br><span class="line">		&lt;appender-ref ref=&quot;CONSOLE&quot; /&gt;</span><br><span class="line">		&lt;appender-ref ref=&quot;FILE&quot; /&gt;</span><br><span class="line">	&lt;/root&gt;</span><br><span class="line">&lt;/included&gt;</span><br></pre></td></tr></table></figure>

<p>根据这个配置我们可以新建自己的logback-spring.xml：</p>
<ul>
<li><p>在工程的resources目录下边新建文件logback-spring.xml</p>
</li>
<li><p>内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration &gt;</span><br><span class="line">&lt;!-- 讲base.xml的日志配置引入 --&gt;</span><br><span class="line">    &lt;include resource=&quot;org/springframework/boot/logging/logback/base.xml&quot;/&gt;</span><br><span class="line">    &lt;!-- com.twodragonlake.boot包下的日志级别是DEBUG --&gt;</span><br><span class="line">    &lt;logger name=&quot;com.twodragonlake.boot&quot; level=&quot;DEBUG&quot;/&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>打印所有级别的日志<br>在MyApplication里边增加变量：<br>private static  final Logger logger &#x3D; LoggerFactory.getLogger(MyApplication.class);<br>增加方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//PostConstruct意味着当bean构建完毕的时候执行这个方法。</span><br><span class="line">@PostConstruct</span><br><span class="line">public void myLog()&#123;</span><br><span class="line">    logger.trace(&quot;Trace Message&quot;);</span><br><span class="line">    logger.debug(&quot;Debug Message&quot;);</span><br><span class="line">    logger.info(&quot;Info Message&quot;);</span><br><span class="line">    logger.warn(&quot;Warn Message&quot;);</span><br><span class="line">    logger.error(&quot;Error Message&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>打印结果<br>2019-07-28 10:13:49.343 DEBUG 2740 — [           main] com.twodragonlake.boot.MyApplication     : Debug Message<br>2019-07-28 10:13:49.343  INFO 2740 — [           main] com.twodragonlake.boot.MyApplication     : Info Message<br>2019-07-28 10:13:49.343  WARN 2740 — [           main] com.twodragonlake.boot.MyApplication     : Warn Message<br>2019-07-28 10:13:49.344 ERROR 2740 — [           main] com.twodragonlake.boot.MyApplication     : Error Message</p>
<p>Trace Message没有打印出来是因为我们的日志级别是【<logger name="com.twodragonlake.boot" level="DEBUG"/>】</p>
</li>
</ul>
<h3 id="springProfile"><a href="#springProfile" class="headerlink" title="springProfile"></a>springProfile</h3><p>有时候我们需要在开发环境、测试环境部、正式环境进行不同级别的日志打印。<br>为此就需要springProfile，我们在logback-spring.xml增加新的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;springProfile name=&quot;test&quot;&gt;</span><br><span class="line">    &lt;logger  name=&quot;com.twodragonlake.boot&quot;  level=&quot;INFO&quot; /&gt;</span><br><span class="line">&lt;/springProfile&gt;</span><br></pre></td></tr></table></figure>
<p>输出：<br>2019-07-28 10:20:42.747 DEBUG 14372 — [           main] com.twodragonlake.boot.MyApplication     : Debug Message<br>2019-07-28 10:20:42.747  INFO 14372 — [           main] com.twodragonlake.boot.MyApplication     : Info Message<br>2019-07-28 10:20:42.747  WARN 14372 — [           main] com.twodragonlake.boot.MyApplication     : Warn Message<br>2019-07-28 10:20:42.748 ERROR 14372 — [           main] com.twodragonlake.boot.MyApplication     : Error Message<br>我们可以看到日志打印没有发生变化，为什么呢，看一下启动日志有一句：<br>2019-07-28 10:20:41.489  INFO 14372 — [           main] com.twodragonlake.boot.MyApplication     : No active profile set, falling back to default profiles: default</p>
<p>当用户没有设置profile的时候，springboot就会使用默认的profiles，名字是“default”，<br>所以我们将springProfile的name改为default：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;springProfile name=&quot;default&quot;&gt;</span><br><span class="line">    &lt;logger  name=&quot;com.twodragonlake.boot&quot;  level=&quot;INFO&quot; /&gt;</span><br><span class="line">&lt;/springProfile&gt;</span><br></pre></td></tr></table></figure>
<p>重新启动打印如下：<br>2019-07-28 10:24:26.552  INFO 10260 — [           main] com.twodragonlake.boot.MyApplication     : Info Message<br>2019-07-28 10:24:26.553  WARN 10260 — [           main] com.twodragonlake.boot.MyApplication     : Warn Message<br>2019-07-28 10:24:26.553 ERROR 10260 — [           main] com.twodragonlake.boot.MyApplication     : Error Message</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>如果我们logback-spring.xml里边的springProfile的name设置为default，而且logback-spring.xml里面存在单独的logger配置，诸如<br>【 <code>&lt;logger name=&quot;com.twodragonlake.boot&quot; level=&quot;DEBUG&quot;/&gt;</code>】，那么springProfile name为default的级别要高；<br>如果我们把springProfile的name改为非default的，那么单独的logger配置的优先级要高。</p>
</li>
<li><p>可以在application.yml里边指定profile，比如指定当前环境为test，相应的把springProfile的name也为test：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: mytest</span><br><span class="line">  http:</span><br><span class="line">    encoding:</span><br><span class="line">      enabled: true</span><br><span class="line">      charset: UTF-8</span><br><span class="line">  profiles:</span><br><span class="line">    active: test</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 9090</span><br><span class="line"></span><br><span class="line">myConfig:</span><br><span class="line">  myObject:</span><br><span class="line">    myName: zhangsan</span><br><span class="line">    myAge: 20</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="spring-logging-profile配置"><a href="#spring-logging-profile配置" class="headerlink" title="spring logging profile配置"></a>spring logging profile配置</h3><p>为了演示去掉小结里边的application.yml如下配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#  profiles:</span><br><span class="line">#    active: test</span><br></pre></td></tr></table></figure>
<p>springProfile的name改为default<br>增加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    root: debug</span><br></pre></td></tr></table></figure>
<p>启动信息会非常的多，不在罗列。</p>
<h4 id="指定日志文件"><a href="#指定日志文件" class="headerlink" title="指定日志文件"></a>指定日志文件</h4><p>application.yml配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    root: debug</span><br><span class="line">  path: logs/mylog</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>spring_boot_cloud</category>
      </categories>
      <tags>
        <tag>SpringBootApplication</tag>
      </tags>
  </entry>
  <entry>
    <title>spring_boot_cloud(7)SpringBoot整合jsp详解</title>
    <url>/2019/07/28/spring_boot_and_cloud/spring_boot_cloud(7)SpringBoot%E6%95%B4%E5%90%88jsp%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h3><p>类似于freemarker的模板引擎</p>
<span id="more"></span>

<h3 id="jsp-demo"><a href="#jsp-demo" class="headerlink" title="jsp demo"></a>jsp demo</h3><h4 id="编写controller代码："><a href="#编写controller代码：" class="headerlink" title="编写controller代码："></a>编写controller代码：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class JspController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/jsp&quot;)</span><br><span class="line">    public String jsp(Map&lt;String,Object&gt; model)&#123;</span><br><span class="line">        model.put(&quot;date&quot;,new Date());</span><br><span class="line">        model.put(&quot;message&quot;, &quot;hello world&quot;);</span><br><span class="line">        return &quot;result&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/jspError&quot;)</span><br><span class="line">    public String jspError(Map&lt;String,Object&gt; model)&#123;</span><br><span class="line">        throw new RuntimeException(&quot;jsp error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在工程main目录下边新建webapp目录，在webapp下边新建WEB-INF目录,WEB-INF下边新建jsp文件夹；</p>
<h4 id="在jsp下边新建result-jsp文件："><a href="#在jsp下边新建result-jsp文件：" class="headerlink" title="在jsp下边新建result.jsp文件："></a>在jsp下边新建result.jsp文件：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    Date: $&#123;date&#125; &lt;br/&gt;</span><br><span class="line">    Message: $&#123;message&#125;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="新建error-jsp文件："><a href="#新建error-jsp文件：" class="headerlink" title="新建error.jsp文件："></a>新建error.jsp文件：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">error occured : $&#123;status&#125;, $&#123;error&#125;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="application-yml配置"><a href="#application-yml配置" class="headerlink" title="application.yml配置"></a>application.yml配置</h4><p>在spring结构下增加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvc:</span><br><span class="line">  view:</span><br><span class="line">    prefix: /WEB-INF/jsp</span><br><span class="line">    suffix: .jsp</span><br></pre></td></tr></table></figure>

<h4 id="浏览器访问"><a href="#浏览器访问" class="headerlink" title="浏览器访问"></a>浏览器访问</h4><p><span class="exturl" data-url="aHR0cDovLzEyNy4wLjAuMTo5MDkwL2pzcA==">http://127.0.0.1:9090/jsp<i class="fa fa-external-link-alt"></i></span><br>得到的页面：<br><img src="/Whitelabel-Error-Page.png" alt="Whitelabel-Error-Page.png"><br>这个页面是spring的默认错误页面</p>
<p>错误的原因是我们的 application.yml配置没有配置正确，重新修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvc:</span><br><span class="line">  view:</span><br><span class="line">    prefix: /WEB-INF/jsp/</span><br><span class="line">    suffix: .jsp</span><br></pre></td></tr></table></figure>
<p>然后gradle配置文件引入servlet的相关配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;javax.servlet:jstl&quot;,</span><br><span class="line">&quot;org.apache.tomcat.embed:tomcat-embed-jasper&quot;</span><br></pre></td></tr></table></figure>
<p>在&#x2F;WEB-INF&#x2F;jsp加了“&#x2F;”，重启然后再次访问：<br><span class="exturl" data-url="aHR0cDovLzEyNy4wLjAuMTo5MDkwL2pzcA==">http://127.0.0.1:9090/jsp<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>spring_boot_cloud</category>
      </categories>
      <tags>
        <tag>SpringBoot jsp</tag>
      </tags>
  </entry>
  <entry>
    <title>spring_boot_cloud(8)SpringBoot整合WebSocket</title>
    <url>/2019/07/28/spring_boot_and_cloud/spring_boot_cloud(8)SpringBoot%E6%95%B4%E5%90%88WebSocket/</url>
    <content><![CDATA[<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>gradle引入相关依赖：</p>
<span id="more"></span>
<p>“org.springframework.boot:spring-boot-starter-websocket”,<br>“org.springframework.boot:spring-boot-starter-json”</p>
<h3 id="新建一个接口EchoService，用来对消息进行处理"><a href="#新建一个接口EchoService，用来对消息进行处理" class="headerlink" title="新建一个接口EchoService，用来对消息进行处理"></a>新建一个接口EchoService，用来对消息进行处理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface EchoService &#123;</span><br><span class="line">    //接受消息，然后处理返回处理结果</span><br><span class="line">    String getMessage(String message);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后定义一个实现类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DefaultEchoService implements EchoService &#123;</span><br><span class="line"></span><br><span class="line">    private final String echoFormat;</span><br><span class="line"></span><br><span class="line">    public DefaultEchoService(String echoFormat)&#123;</span><br><span class="line">        this.echoFormat = (null != echoFormat) ? echoFormat : &quot;%s&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getMessage(String message) &#123;</span><br><span class="line">      //消息处理就是简单的消息格式化</span><br><span class="line">        return String.format(this.echoFormat, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义Handler"><a href="#定义Handler" class="headerlink" title="定义Handler"></a>定义Handler</h3><p>新建一个Handler，EchoWebSocketHandler springboot websocket 提供了一个简单的文本处理器TextWebSocketHandler，EchoWebSocketHandler继承TextWebSocketHandler。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class EchoWebSocketHandler extends TextWebSocketHandler &#123;</span><br><span class="line"></span><br><span class="line">    private EchoService echoService;</span><br><span class="line"></span><br><span class="line">    public EchoWebSocketHandler(EchoService echoService)&#123;</span><br><span class="line">        this.echoService = echoService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterConnectionEstablished(WebSocketSession session) throws Exception &#123;</span><br><span class="line">      //连接建立的时候，打印信息</span><br><span class="line">        System.out.println(&quot;建立连接&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception &#123;</span><br><span class="line">      //出现异常关闭连接</span><br><span class="line">       session.close(CloseStatus.SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception &#123;</span><br><span class="line">      //接受消息，然后对其进行处理，返回处理结果</span><br><span class="line">        String echoMessage = this.echoService.getMessage(message.getPayload());</span><br><span class="line">        session.sendMessage(new TextMessage(echoMessage));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MyApplication继承-WebSocketConfigurer"><a href="#MyApplication继承-WebSocketConfigurer" class="headerlink" title="MyApplication继承 WebSocketConfigurer"></a>MyApplication继承 WebSocketConfigurer</h3><p>在 MyApplication上加入注解：@EnableWebSocket<br>修改 MyApplication让其继承WebSocketConfigurer接口，然后重写registerWebSocketHandlers方法：<br>然后MyApplication会新增如下方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableWebSocket</span><br><span class="line">public class MyApplication  implements WebSocketConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    private static  final Logger logger = LoggerFactory.getLogger(MyApplication.class);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class,args);</span><br><span class="line">        /*SpringApplication application = new SpringApplication();</span><br><span class="line">        application.setBannerMode(Banner.Mode.OFF);//关闭banner</span><br><span class="line">        application.run(args);*/</span><br><span class="line">    &#125;</span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void myLog()&#123;</span><br><span class="line">        logger.trace(&quot;Trace Message&quot;);</span><br><span class="line">        logger.debug(&quot;Debug Message&quot;);</span><br><span class="line">        logger.info(&quot;Info Message&quot;);</span><br><span class="line">        logger.warn(&quot;Warn Message&quot;);</span><br><span class="line">        logger.error(&quot;Error Message&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void registerWebSocketHandlers(WebSocketHandlerRegistry webSocketHandlerRegistry) &#123;</span><br><span class="line">        webSocketHandlerRegistry.addHandler(webSocketHandler(), &quot;/echo&quot;).withSockJS();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public EchoService echoService()&#123;</span><br><span class="line">        return new DefaultEchoService(&quot;You said \&quot;%s\&quot;!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public WebSocketHandler webSocketHandler()&#123;</span><br><span class="line">        return new EchoWebSocketHandler(echoService());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="页面交互文件"><a href="#页面交互文件" class="headerlink" title="页面交互文件"></a>页面交互文件</h3><p>然后我们新建一个html交互页面，在工程的resources下新建一个static目录，注意static是springboot约定好的名称。<br>然后在其下新建echo.html:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=&quot;https://cdn.jsdeliver.net/sockjs/0.3.4/sockjs.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">    var ws = null;</span><br><span class="line"></span><br><span class="line">    function setConnected(connected) &#123;</span><br><span class="line">        document.getElementById(&quot;connect&quot;).disabled = connected;</span><br><span class="line">        document.getElementById(&quot;disconnect&quot;).disabled = !connected;</span><br><span class="line">        document.getElementById(&quot;echo&quot;).disabled = connected;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function connect() &#123;</span><br><span class="line">        var target = document.getElementById(&quot;target&quot;).value;</span><br><span class="line">        ws = new SockJS(target);</span><br><span class="line">        ws.onopen = function () &#123;</span><br><span class="line">            setConnected(true);</span><br><span class="line">            log(&quot;Info : WebSock connect opened.&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ws.onmessage = function (event) &#123;</span><br><span class="line">            log(&#x27;Received: &#x27; + event.data);</span><br><span class="line">        &#125;;</span><br><span class="line">        ws.onclose = function () &#123;</span><br><span class="line">            setConnected(false);</span><br><span class="line">            log(&#x27;Info: WebSocket connection close.&#x27;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        function disconnect() &#123;</span><br><span class="line">            if (ws != null)&#123;</span><br><span class="line">                ws.close();</span><br><span class="line">                ws = null;</span><br><span class="line">            &#125;</span><br><span class="line">            setConnected(false);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function echo() &#123;</span><br><span class="line">            if (ws != null)&#123;</span><br><span class="line">                var message = document.getElementById(&#x27;console&#x27;);</span><br><span class="line">                log(&#x27;Sent:&#x27; + message)；</span><br><span class="line">                s.send(message);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                alert(&#x27;WebSocket connect not establish, please connect.&#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function log(message) &#123;</span><br><span class="line">            var console = document.getElementById(&quot;console&quot;);</span><br><span class="line">            var p = document.createElement(&#x27;p&#x27;);</span><br><span class="line">            p.style.wordWrap = &#x27;break-word&#x27;;</span><br><span class="line">            p.appendChild(document.createTextNode(message));</span><br><span class="line">            console.appendChild(p);</span><br><span class="line">            while (console.childNodes.length &gt;  25) &#123;</span><br><span class="line">                console.removeChild(console.firstChild);</span><br><span class="line">            &#125;</span><br><span class="line">            console.scrollTop = console.scrollHeight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div id=&quot;connect-container&quot;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;input id=&quot;target&quot; type=&quot;text&quot; size=&quot;40&quot; style=&quot;width:350px;&quot; value=&quot;/echo&quot; /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button id=&quot;connect&quot; onclick=&quot;connect();&quot;&gt;Connect&lt;/button&gt;</span><br><span class="line">            &lt;button id=&quot;disconnect&quot; disabled=&quot;disabled&quot; onclick=&quot;disconnect();&quot;&gt;DisConnect&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;textarea id=&quot;message&quot; &gt;</span><br><span class="line">                a message to sent</span><br><span class="line">            &lt;/textarea&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button id=&quot;echo&quot; onclick=&quot;echo();&quot; disabled=&quot;disabled&quot;&gt; Echo message&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div id=&quot;console-container&quot;&gt;</span><br><span class="line">            &lt;div id=&quot;console&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>浏览器输入：<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo5MDkwL2VjaG8uaHRtbA==">http://localhost:9090/echo.html<i class="fa fa-external-link-alt"></i></span><br><img src="/websocket.png" alt="websocket.png"><br>可以看到<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo5MDkwL2VjaG8vaW5mbyVFOCVCRiU5NCVFNSU5QiU5RSVFNCVCOCU4MCVFNCVCOCVBQTIwMCVFNyU5QSU4NCVFNyU4QSVCNiVFNiU4MCU4MSVFRiVCQyU4QyVFOCVCRiU5OSVFNiU5OCVBRiVFNCVCOCU4MCVFNCVCOCVBQSVFNiVCNSU4QiVFOCVBRiU5NSVFRiVCQyU4QyVFNyU4NCVCNiVFNSU5MCU4RQ==">http://localhost:9090/echo/info返回一个200的状态，这是一个测试，然后<i class="fa fa-external-link-alt"></i></span><br>ws:&#x2F;&#x2F;localhost:9090&#x2F;echo&#x2F;546&#x2F;jgnuowqd&#x2F;websocket 的状态101，表示协议转换，升级之后连接就建立起来了。<br>收发消息：<br><img src="/websocket1.png" alt="websocket1.png"></p>
]]></content>
      <categories>
        <category>spring_boot_cloud</category>
      </categories>
      <tags>
        <tag>WebSocket SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>spring_boot_cloud(9)Spring_Boot开发者工具与单元测试详解</title>
    <url>/2019/07/28/spring_boot_and_cloud/spring_boot_cloud(9)Spring_Boot%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E4%B8%8E%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="devtools准备"><a href="#devtools准备" class="headerlink" title="devtools准备"></a>devtools准备</h3><span id="more"></span>
<p>gradle加入依赖：<br> “org.springframework.boot:spring-boot-devtools:2.1.3.RELEASE”,</p>
<p>devtools可以在不重启应用的情况下使修改的代码生效，也就是热部署。<br>然后对idea进行一下设置：<br><img src="/idea-devtools.png" alt="idea-devtools.png"><br>勾选这个选项。<br>执行快捷键：ctrl + alt + shift + &#x2F;<br><img src="/idea-devtools1.png" alt="idea-devtools1.png"><br>选择registry.<br>勾选这个选项：<br><img src="/idea-devtools2.png" alt="idea-devtools2.png"><br>此时我们修改的代码会及时编译和生效。</p>
<h3 id="devtools原理"><a href="#devtools原理" class="headerlink" title="devtools原理"></a>devtools原理</h3><p>devtools使用了2个不同的加载器，一个加载第三方jar包的classloader，另一个只加载当前工程里边的源代码的classloader，这样就加快了加载速度，而我们自己去重启会加载所有的类进行重启。</p>
<h3 id="单元测试准备"><a href="#单元测试准备" class="headerlink" title="单元测试准备"></a>单元测试准备</h3><p>添加gradle依赖：<br>  “org.springframework.boot:spring-boot-starter-test:2.1.3.RELEASE”</p>
<h4 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class MyControllerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private WebApplicationContext webApplicationContext;</span><br><span class="line"></span><br><span class="line">    private MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void setupMockMvc()&#123;</span><br><span class="line">        mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testGetPerson() throws  Exception&#123;</span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.get(&quot;/person/getPerson&quot;).</span><br><span class="line">                contentType(MediaType.APPLICATION_JSON_UTF8).</span><br><span class="line">                accept(MediaType.APPLICATION_JSON_UTF8)).</span><br><span class="line">                andExpect(MockMvcResultMatchers.status().isOk()).</span><br><span class="line">                andDo(MockMvcResultHandlers.print());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@RunWith(SpringRunner.class)<br>@SpringBootTest<br>这两个是必须写的。<br>MockMvc是对mvc的一种请求的mock，通过实例我们可以看到MockMvc为我们提供了丰富的mock api。</p>
]]></content>
      <categories>
        <category>spring_boot_cloud</category>
      </categories>
      <tags>
        <tag>单元测试 开发者工具 SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>tidb-install-pit</title>
    <url>/2019/07/25/tidb/tidb-install-pit/</url>
    <content><![CDATA[<p><a name="df368884"></a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>近期随着公司的业务发展，现有的mysql分库分表，无缝动态扩容，分布式事物，分布式id等等一些问题得不到满足，为此我们做了一次对tidb的考察，此文是记录tidb的安装遇到的坑进行记录,并做了一些功能性和性能方面的测试，详情按照官方doc进行。</p>
<p><a name="fa405f59"></a></p>
<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>集群规模：<br>node1 192.168.138.18  PD1, TiDB1        4c16G 200GHHD<br>node2 192.168.138.19  PD2, TiDB2        4c16G 200GHHD<br>node3 192.168.138.21  PD3               2c16G 200GHHD<br>node4 192.168.138.22  TiKV1,zk,kakfka   2c16G 200GHHD<br>node5 192.168.138.23  TiKV2,zk,kakfka   2c16G 200GHHD<br>node6 192.168.138.24  TiKV3,zk,kakfka   2c16G 200GHHD<br>当前os环境：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat /etc/redhat-release</span><br><span class="line">CentOS Linux release 7.5.1804 (Core)</span><br></pre></td></tr></table></figure>

<p>磁盘分布情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># lsblk -f</span><br><span class="line">NAME            FSTYPE      LABEL UUID                                   MOUNTPOINT</span><br><span class="line">sda                                                                      </span><br><span class="line">├─sda1          xfs               70b07712-9842-4618-9680-a9e8f7617bf0   /boot</span><br><span class="line">└─sda2          LVM2_member       etR92Z-w9Jt-Cxao-louw-Lgb2-hveD-knEFcQ</span><br><span class="line">  ├─centos-root xfs               dda73e1e-afd7-4d76-9ac7-c30ed0ace8d4   /</span><br><span class="line">  └─centos-swap swap              93faea67-8660-4c7d-85c1-a67ba4c4aad0   [SWAP]</span><br><span class="line">sdb                                                                      </span><br><span class="line">├─sdb1                                                                   </span><br><span class="line">└─sdb5          ext4              055154ea-fafd-4ddf-8a8b-7d26de10f98f   /data</span><br><span class="line">sr0</span><br><span class="line">【sdb5是一块ext4文件系统格式的，这个是tidb要求的】</span><br><span class="line"># fdisk -l</span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 107.4 GB, 107374182400 bytes, 209715200 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0x000d73fc</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *        2048      411647      204800   83  Linux</span><br><span class="line">/dev/sda2          411648   209715199   104651776   8e  Linux LVM</span><br><span class="line"></span><br><span class="line">Disk /dev/mapper/centos-root: 90.0 GB, 89980403712 bytes, 175742976 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/mapper/centos-swap: 17.2 GB, 17179869184 bytes, 33554432 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 107.4 GB, 107374182400 bytes, 209715200 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0x6ee43510</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1            2048   209715199   104856576    5  Extended</span><br><span class="line">/dev/sdb5            4096   209715199   104855552   83  Linux</span><br></pre></td></tr></table></figure>

<p>每台机器有2块硬盘，按照官方要求外挂的那块文件系统是ext4的。<br />然后机器需要安装git。</p>
<p><a name="374d66be"></a></p>
<h3 id="官方安装doc"><a href="#官方安装doc" class="headerlink" title="官方安装doc"></a>官方安装doc</h3><p><span class="exturl" data-url="aHR0cHM6Ly9waW5nY2FwLmNvbS9kb2NzLWNuL3YzLjAvaG93LXRvL2RlcGxveS9vcmNoZXN0cmF0ZWQvYW5zaWJsZS8=">https://pingcap.com/docs-cn/v3.0/how-to/deploy/orchestrated/ansible/<i class="fa fa-external-link-alt"></i></span></p>
<p>首先执行的是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># yum -y install epel-release git curl sshpass</span><br><span class="line">Loaded plugins: fastestmirror, langpacks</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">No package epel-release available.【lib未找到】</span><br><span class="line">Package git-1.8.3.1-13.el7.x86_64 already installed and latest version</span><br><span class="line">Package curl-7.29.0-46.el7.x86_64 already installed and latest version</span><br><span class="line">No package sshpass available.【lib未找到】</span><br><span class="line">Nothing to do</span><br></pre></td></tr></table></figure>

<p><a name="34916830"></a></p>
<h4 id="坑-No-package-epel-release-available"><a href="#坑-No-package-epel-release-available" class="headerlink" title="[坑]No package epel-release available"></a>[坑]No package epel-release available</h4><p>根据<span class="exturl" data-url="aHR0cHM6Ly93d3cuc2hlbGxoYWNrcy5jb20vZXBlbC1yZXBvLWNlbnRvcy03LTYtaW5zdGFsbC8=">epel-repo-centos-7<i class="fa fa-external-link-alt"></i></span>指南需要执行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># rpm -ivh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</span><br></pre></td></tr></table></figure>

<p>然后在执行[yum -y install epel-release git curl sshpass]才会成功.</p>
<p><a name="129fc895"></a></p>
<h4 id="坑-提前配置Grafana-Dashboard-上的-Report-按钮可用来生成-PDF-文件"><a href="#坑-提前配置Grafana-Dashboard-上的-Report-按钮可用来生成-PDF-文件" class="headerlink" title="[坑]提前配置Grafana Dashboard 上的 Report 按钮可用来生成 PDF 文件"></a>[坑]提前配置Grafana Dashboard 上的 Report 按钮可用来生成 PDF 文件</h4><p>在Grafana部署的机器上执行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install fontconfig open-sans-fonts</span><br></pre></td></tr></table></figure>

<p><a name="5c9f0649"></a></p>
<h4 id="坑-PD-和-TiDB-同时部署的机器要求要有8个cpu-core"><a href="#坑-PD-和-TiDB-同时部署的机器要求要有8个cpu-core" class="headerlink" title="[坑]PD 和 TiDB 同时部署的机器要求要有8个cpu core"></a>[坑]PD 和 TiDB 同时部署的机器要求要有8个cpu core</h4><p>异常如下：<br />[192.168.138.18]: Ansible FAILED! &#x3D;&gt; playbook: bootstrap.yml; TASK: check_system_optional : Preflight check - Check TiDB server’s CPU; message: {“changed”: false, “msg”: “This machine does not have sufficient CPU to run TiDB, at least 8 cores.”}</p>
<p>[192.168.138.19]: Ansible FAILED! &#x3D;&gt; playbook: bootstrap.yml; TASK: check_system_optional : Preflight check - Check TiDB server’s CPU; message: {“changed”: false, “msg”: “This machine does not have sufficient CPU to run TiDB, at least 8 cores.”}<br />解决方式：</p>
<ul>
<li>找运维增加虚拟机的cpu core数量</li>
<li>修改参数：vi roles&#x2F;check_system_optional&#x2F;defaults&#x2F;main.yml</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tidb_min_cpu: 2</span><br><span class="line">tikv_min_cpu: 2</span><br><span class="line">pd_min_cpu: 2</span><br><span class="line">monitor_min_cpu: 2</span><br></pre></td></tr></table></figure>

<p>其他的内存和硬盘的检查参数也在这个文件配置。</p>
<ul>
<li>参考： <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BpbmdjYXAvdGlkYi9pc3N1ZXMvNjQyMw==">https://github.com/pingcap/tidb/issues/6423<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p><a name="e1df35e7"></a></p>
<h4 id="坑-磁盘检查异常"><a href="#坑-磁盘检查异常" class="headerlink" title="[坑]磁盘检查异常"></a>[坑]磁盘检查异常</h4><p>异常信息：<br />[192.168.138.22]: Ansible FAILED! &#x3D;&gt; playbook: bootstrap.yml; TASK: machine_benchmark : Preflight check - Does fio randread iops of tikv_data_dir disk meet requirement; message: {“changed”: false, “msg”: “fio: randread iops of tikv_data_dir disk is too low: 7748 &lt; 40000, it is strongly recommended to use SSD disks for TiKV and PD, or there might be performance issues.”}</p>
<p>[192.168.138.23]: Ansible FAILED! &#x3D;&gt; playbook: bootstrap.yml; TASK: machine_benchmark : Preflight check - Does fio randread iops of tikv_data_dir disk meet requirement; message: {“changed”: false, “msg”: “fio: randread iops of tikv_data_dir disk is too low: 3128 &lt; 40000, it is strongly recommended to use SSD disks for TiKV and PD, or there might be performance issues.”}</p>
<p>[192.168.138.24]: Ansible FAILED! &#x3D;&gt; playbook: bootstrap.yml; TASK: machine_benchmark : Preflight check - Does fio randread iops of tikv_data_dir disk meet requirement; message: {“changed”: false, “msg”: “fio: randread iops of tikv_data_dir disk is too low: 8847 &lt; 40000, it is strongly recommended to use SSD disks for TiKV and PD, or there might be performance issues.”}</p>
<p>解决方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># vi roles/machine_benchmark/defaults/main.yml</span><br></pre></td></tr></table></figure>

<p>修改min_ssd_randread_iops的大小。</p>
<p><a name="244e1822"></a></p>
<h4 id="跳过cpu、mem、disk检查"><a href="#跳过cpu、mem、disk检查" class="headerlink" title="跳过cpu、mem、disk检查"></a>跳过cpu、mem、disk检查</h4><p>有些企业由于成本问题，在开发测试环境都是HHD，没法满足tidb的硬件要求，因此我们可以使用开发模式，跳过cpu、内存、硬盘的检查。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ansible-playbook bootstrap.yml --extra-vars &quot;dev_mode=True&quot;</span><br></pre></td></tr></table></figure>

<p><a name="f023e41c"></a></p>
<h4 id="注意事项-TiDB的binlog开启"><a href="#注意事项-TiDB的binlog开启" class="headerlink" title="[注意事项]TiDB的binlog开启"></a>[注意事项]TiDB的binlog开启</h4><p>&#x2F;home&#x2F;tidb&#x2F;tidb-ansible&#x2F;inventory.ini配置如果【enable_binlog &#x3D; True 】<br>意味着需要配置<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BpbmdjYXAvZG9jcy1jbi9ibG9iL21hc3Rlci92My4wL2hvdy10by9kZXBsb3kvdGlkYi1iaW5sb2cubWQ=">TiDB-Binlog<i class="fa fa-external-link-alt"></i></span>,当前集群按照<span class="exturl" data-url="aHR0cHM6Ly9waW5nY2FwLmNvbS9kb2NzLWNuL3YzLjAvaG93LXRvL2RlcGxveS90aWRiLWJpbmxvZy8=">官方doc<i class="fa fa-external-link-alt"></i></span>搭建了zk和kafka集群，然后部署了pump（抓取tidb的binlog塞到kafka集群）。</p>
<p><a name="f20fc258"></a></p>
<h4 id="坑-启动之后grafana进程没有"><a href="#坑-启动之后grafana进程没有" class="headerlink" title="[坑]启动之后grafana进程没有"></a>[坑]启动之后grafana进程没有</h4><p>切换到部署目录&#x2F;data&#x2F;deploy&#x2F;scripts<br />手动执行: .&#x2F;start_grafana.sh</p>
<p><a name="bcf29c71"></a></p>
<h4 id="tidb在navicat下修改表结构问题"><a href="#tidb在navicat下修改表结构问题" class="headerlink" title="tidb在navicat下修改表结构问题"></a>tidb在navicat下修改表结构问题</h4><p>tidb在navicat下修改表结构一次性不允许修改(添加或者修改)多个列，否则报错：<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/186520/1564467485930-4cbeac67-1485-488b-850a-d4744af936dc.png#align=left&display=inline&height=746&name=mutil-schema-error.png&originHeight=746&originWidth=1366&size=74707&status=done&width=1366" alt="mutil-schema-error.png"></p>
<p><a name="bb1c734e"></a></p>
<h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><ul>
<li>使用mysql客户端登陆<ul>
<li>使用tidb(密码：tidb)登陆开发机，注意：必须是tidb用户。<ul>
<li>mysql -u root -proot  -h 192.168.138.18 -P 4000</li>
<li>mysql -u tnp_test -ptnp_test  -h 192.168.138.18 -P 4000</li>
<li>PS:192.168.138.19 和 192.168.138.18都可以链接</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a name="1346328c"></a></p>
<h3 id="修改集群配置之后重启步骤-x2F-集群启动-x2F-集群关闭"><a href="#修改集群配置之后重启步骤-x2F-集群启动-x2F-集群关闭" class="headerlink" title="修改集群配置之后重启步骤&#x2F;集群启动&#x2F;集群关闭"></a>修改集群配置之后重启步骤&#x2F;集群启动&#x2F;集群关闭</h3><ul>
<li><p>配置<br /><br>对【&#x2F;home&#x2F;tidb&#x2F;tidb-ansible&#x2F;inventory.ini】进行修改后需要执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ansible-playbook deploy.yml</span><br></pre></td></tr></table></figure>
</li>
<li><p>目的是把配置下放到所有的机器。</p>
</li>
<li><p>启动集群<br /><br>ansible-playbook start.yml</p>
</li>
<li><p>关闭集群<br /><br>ansible-playbook stop.yml <br/></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>启动集群</th>
<th>ansible-playbook start.yml</th>
</tr>
</thead>
<tbody><tr>
<td>停止集群</td>
<td>ansible-playbook stop.yml</td>
</tr>
<tr>
<td>销毁集群</td>
<td>ansible-playbook unsafe_cleanup.yml (若部署目录为挂载点，会报错，可忽略）</td>
</tr>
<tr>
<td>清除数据(测试用)</td>
<td>ansible-playbook cleanup_data.yml</td>
</tr>
<tr>
<td>滚动升级</td>
<td>ansible-playbook rolling_update.yml</td>
</tr>
<tr>
<td>滚动升级 TiKV</td>
<td>ansible-playbook rolling_update.yml –tags&#x3D;tikv</td>
</tr>
<tr>
<td>滚动升级除 PD 外模块</td>
<td>ansible-playbook rolling_update.yml –skip-tags&#x3D;pd</td>
</tr>
<tr>
<td>滚动升级监控组件</td>
<td>ansible-playbook rolling_update_monitor.yml</td>
</tr>
</tbody></table>
<p><a name="5fca6be2"></a></p>
<h3 id="Prometheus访问地址"><a href="#Prometheus访问地址" class="headerlink" title="Prometheus访问地址"></a>Prometheus访问地址</h3><p><span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguMTM4LjE4OjkwOTAvZ3JhcGg=">http://192.168.138.18:9090/graph<i class="fa fa-external-link-alt"></i></span></p>
<p><a name="d3a39edf"></a></p>
<h3 id="Pushgateway访问地址"><a href="#Pushgateway访问地址" class="headerlink" title="Pushgateway访问地址"></a>Pushgateway访问地址</h3><p><span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguMTM4LjE4OjkwOTEv">http://192.168.138.18:9091/<i class="fa fa-external-link-alt"></i></span></p>
<p><a name="26614728"></a></p>
<h3 id="Node-exporter访问地址"><a href="#Node-exporter访问地址" class="headerlink" title="Node_exporter访问地址"></a>Node_exporter访问地址</h3><p><span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguMTM4LjE4OjkxMDAv">http://192.168.138.18:9100/<i class="fa fa-external-link-alt"></i></span></p>
<p><a name="ea8acfdf"></a></p>
<h3 id="grafana访问地址"><a href="#grafana访问地址" class="headerlink" title="grafana访问地址"></a>grafana访问地址</h3><p><span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguMTM4LjE4OjMwMDAv">http://192.168.138.18:3000<i class="fa fa-external-link-alt"></i></span><br />用户名&#x2F;密码:admin&#x2F;admin<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/186520/1564561812914-82ca10bb-9686-417e-af46-276341021cd9.png#align=left&display=inline&height=633&name=image.png&originHeight=633&originWidth=1360&size=88976&status=done&width=1360" alt="image.png"><br />指标解释：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BpbmdjYXAvZG9jcy1jbi9ibG9iL21hc3Rlci9kZXYvcmVmZXJlbmNlL2tleS1tb25pdG9yaW5nLW1ldHJpY3MvdGlkYi1kYXNoYm9hcmQubWQ=">https://github.com/pingcap/docs-cn/blob/master/dev/reference/key-monitoring-metrics/tidb-dashboard.md<i class="fa fa-external-link-alt"></i></span></p>
<p><a name="5f2e4fbc"></a><br>binlog监控：<br><img src="/2019/07/25/tidb-install-pit/binlog.png" alt="binlog.png"><br>manager监控：<br><img src="/2019/07/25/tidb-install-pit/manager.png" alt="manager.png"></p>
<h3 id="全量备份与恢复"><a href="#全量备份与恢复" class="headerlink" title="全量备份与恢复"></a>全量备份与恢复</h3><p><span class="exturl" data-url="aHR0cHM6Ly9waW5nY2FwLmNvbS9kb2NzLWNuL3YzLjAvaG93LXRvL21haW50YWluL2JhY2t1cC1hbmQtcmVzdG9yZS8=">https://pingcap.com/docs-cn/v3.0/how-to/maintain/backup-and-restore/<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="增量备份与恢复"><a href="#增量备份与恢复" class="headerlink" title="增量备份与恢复"></a>增量备份与恢复</h3><h4 id="TiDB-Binlog从kafka收集binlog给Drainer"><a href="#TiDB-Binlog从kafka收集binlog给Drainer" class="headerlink" title="TiDB Binlog从kafka收集binlog给Drainer"></a>TiDB Binlog从kafka收集binlog给Drainer</h4><p><span class="exturl" data-url="aHR0cHM6Ly9waW5nY2FwLmNvbS9kb2NzLWNuL3YzLjAvcmVmZXJlbmNlL3RpZGItYmlubG9nLW92ZXJ2aWV3Lw==">https://pingcap.com/docs-cn/v3.0/reference/tidb-binlog-overview/<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="Reparo从Drainer得到数据恢复到mysql-x2F-tidb"><a href="#Reparo从Drainer得到数据恢复到mysql-x2F-tidb" class="headerlink" title="Reparo从Drainer得到数据恢复到mysql&#x2F;tidb"></a>Reparo从Drainer得到数据恢复到mysql&#x2F;tidb</h4><p><span class="exturl" data-url="aHR0cHM6Ly9waW5nY2FwLmNvbS9kb2NzLWNuL3YzLjAvcmVmZXJlbmNlL3Rvb2xzL3RpZGItYmlubG9nL3JlcGFyby8=">https://pingcap.com/docs-cn/v3.0/reference/tools/tidb-binlog/reparo/<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>db-type &#x3D; “file”是为了Reparo做恢复用，和官方文档不同的是要创建<br>drainer_file_drainer-cluster.toml文件，而不是drainer_file_drainer.toml。<br>相关问答：<span class="exturl" data-url="aHR0cHM6Ly9hc2t0dWcuY29tL3QvZHJhaW5lci1maWxlLWRyYWluZXItY2x1c3Rlci10b21sLzQwNi8z">https://asktug.com/t/drainer-file-drainer-cluster-toml/406/3<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="定位慢查询"><a href="#定位慢查询" class="headerlink" title="定位慢查询"></a>定位慢查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select `Query_time`, query from INFORMATION_SCHEMA.`SLOW_QUERY` where `Is_internal`=false order by `Query_time` desc limit 2;</span><br></pre></td></tr></table></figure>

<p>官方doc：<span class="exturl" data-url="aHR0cHM6Ly9waW5nY2FwLmNvbS9kb2NzLWNuL3YzLjAvaG93LXRvL21haW50YWluL2lkZW50aWZ5LXNsb3ctcXVlcmllcy8=">https://pingcap.com/docs-cn/v3.0/how-to/maintain/identify-slow-queries/<i class="fa fa-external-link-alt"></i></span></p>
<p><a name="531e2324"></a></p>
<h3 id="扩容缩容"><a href="#扩容缩容" class="headerlink" title="扩容缩容"></a>扩容缩容</h3><p><span class="exturl" data-url="aHR0cHM6Ly9waW5nY2FwLmNvbS9kb2NzLWNuL3YzLjAvaG93LXRvL3NjYWxlL3dpdGgtYW5zaWJsZS8=">https://pingcap.com/docs-cn/v3.0/how-to/scale/with-ansible/<i class="fa fa-external-link-alt"></i></span></p>
<p><a name="888fb2f9"></a></p>
<h3 id="与-MySQL-安全特性差异"><a href="#与-MySQL-安全特性差异" class="headerlink" title="与 MySQL 安全特性差异"></a>与 MySQL 安全特性差异</h3><p>仅支持 mysql_native_password 身份验证方案。<br />不支持外部身份验证方式（如 LDAP）。<br />不支持列级别权限设置。<br />不支持使用证书验证身份。#9708<br />不支持密码过期，最后一次密码变更记录以及密码生存期。#9709<br />不支持权限属性 max_questions，max_updated，max_connections 以及 max_user_connections。<br />不支持密码验证。#9741<br />不支持透明数据加密（TDE）。</p>
<p><a name="DOG0X"></a></p>
<h3 id="对mysql的支持"><a href="#对mysql的支持" class="headerlink" title="对mysql的支持"></a>对mysql的支持</h3><p>TiDB 目前还不支持触发器、存储过程、自定义函数、外键，除此之外，TiDB 支持绝大部分 MySQL 5.7 的语法。</p>
<ul>
<li>支持分布式事物</li>
<li>TiDB 字符集默认就是 UTF8 而且目前只支持 UTF8，字符串就是 memcomparable 格式的。</li>
<li>自增id只保证自增和唯一，不保证顺序性(段式分配导致)。</li>
</ul>
<br />

<p><a name="gCrcg"></a></p>
<h3 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h3><p><a name="qA8ds"></a></p>
<h4 id="事物隔离级别Snapshot-Isolation"><a href="#事物隔离级别Snapshot-Isolation" class="headerlink" title="事物隔离级别Snapshot Isolation"></a>事物隔离级别Snapshot Isolation</h4><p>tidb只支持Snapshot Isolation事物隔离级别，TiDB 实现了快照隔离 (Snapshot Isolation) 级别的一致性。为与 MySQL 保持一致，又称其为“可重复读”。MySQL 可重复读隔离级别的一致性要弱于 Snapshot 隔离级别，也弱于 TiDB 的可重复读隔离级别。<br />另外多线程操作同一行数据，一定会有一个失败，失败的事物默认不会重试，而是以异常的形式抛出，是否重试交给应用来判断，但是也可以开启自动重试，只不过开启之后，重试事务可能会导致更新丢失，因为 TiDB 自动重试机制会把事务第一次执行的所有语句重新执行一遍，当一个事务里的后续语句是否执行取决于前面语句执行结果的时候，自动重试会违反快照隔离，导致更新丢失。<br />doc：<span class="exturl" data-url="aHR0cHM6Ly9waW5nY2FwLmNvbS9kb2NzLWNuL3YzLjAvcmVmZXJlbmNlL3RyYW5zYWN0aW9ucy90cmFuc2FjdGlvbi1pc29sYXRpb24v">https://pingcap.com/docs-cn/v3.0/reference/transactions/transaction-isolation/<i class="fa fa-external-link-alt"></i></span></p>
<p><a name="MII0H"></a></p>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><ul>
<li>数据操作冲突比较验证不适，会产生大量的重试，如果访问冲突并不十分严重，那么乐观锁模型具备较高的效率。</li>
<li>在冲突严重的场景下，推荐在系统架构层面解决问题，比如将计数器放在 Redis 中。</li>
</ul>
<p><a name="Z2FSN"></a></p>
<h4 id="事务大小限制"><a href="#事务大小限制" class="headerlink" title="事务大小限制"></a>事务大小限制</h4><ul>
<li>单个事务包含的 SQL 语句不超过 5000 条（默认）</li>
<li>单条 KV entry 不超过 6MB</li>
<li>KV entry 的总条数不超过 30W</li>
<li>KV entry 的总大小不超过 100MB</li>
</ul>
<p>建议无论是 Insert，Update 还是 Delete 语句，都通过分 Batch 或者是加 Limit 的方式限制。<br />具体罗亿乔之前的sql技术分享。</p>
<p><a name="NTzxl"></a></p>
<h4 id="支持悲观锁，但是官方不建议生产环境使用，因为在官方将其定义为实验性的特性"><a href="#支持悲观锁，但是官方不建议生产环境使用，因为在官方将其定义为实验性的特性" class="headerlink" title="支持悲观锁，但是官方不建议生产环境使用，因为在官方将其定义为实验性的特性"></a>支持悲观锁，但是官方不建议生产环境使用，因为在官方将其定义为实验性的特性</h4><ul>
<li>不支持 GAP Lock 和 Next Key Lock 在悲观事务内通过范围条件来更新多行数据的时候，其他的事务可以在这个范围内插入数据而不会被阻塞。<br /></li>
<li>不支持 SELECT LOCK IN SHARE MODE。</li>
</ul>
<p><a name="IPbGO"></a></p>
<h4 id="事物限制"><a href="#事物限制" class="headerlink" title="事物限制"></a>事物限制</h4><ul>
<li>小事物比单机mysql性能要低，以为有网络参与，用显式事务代替 <code>auto_commit</code>，可优化该性能。</li>
<li>事物惰性检查，执行insert语句，不在 <code>INSERT</code> 语句执行时进行唯一约束的检查，而在事务提交时进行唯一约束的检查。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE T (I INT KEY);</span><br><span class="line">INSERT INTO T VALUES (1);</span><br><span class="line">BEGIN;</span><br><span class="line">INSERT INTO T VALUES (1); -- MySQL 返回错误；TiDB 返回成功</span><br><span class="line">INSERT INTO T VALUES (2);</span><br><span class="line">COMMIT; -- MySQL 提交成功；TiDB 返回错误，事务回滚</span><br><span class="line">SELECT * FROM T; -- MySQL 返回 1 2；TiDB 返回 1</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这样做的目的是为了减少网络开销。</p>
<p><a name="UX5Mw"></a></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>总的来说事物这方面的最贱实践是：乐观锁+事物失败应用级别处理+分布式锁加强，不建议开启事物失败重试机制（除非事物之间没有任何关系）。事物结束之后(commit之后)要判断返回值是否成功.</p>
<p><a name="BuZyL"></a></p>
<h3 id="存在数据热点问题"><a href="#存在数据热点问题" class="headerlink" title="存在数据热点问题"></a>存在数据热点问题</h3><p>相同的表数据会优先聚集到TiKV节点，如果某个表的数据比较热，那么TiKV很有可能成为系统的瓶颈，尤其是在很小范围的数据频繁操作，某个region会成为系统的热点。<br /><span class="exturl" data-url="aHR0cHM6Ly9waW5nY2FwLmNvbS9ibG9nLWNuL3RpZGItYmVzdC1wcmFjdGljZS8=">https://pingcap.com/blog-cn/tidb-best-practice/<i class="fa fa-external-link-alt"></i></span><br />解决之道（通过设置 <code>SHARD_ROW_ID_BITS</code> 来适度分解 Region 分片）：<span class="exturl" data-url="aHR0cHM6Ly9waW5nY2FwLmNvbS9kb2NzLWNuL3YzLjAvcmVmZXJlbmNlL2NvbmZpZ3VyYXRpb24vdGlkYi1zZXJ2ZXIvdGlkYi1zcGVjaWZpYy12YXJpYWJsZXMvI3NoYXJkLXJvdy1pZC1iaXRz">https://pingcap.com/docs-cn/v3.0/reference/configuration/tidb-server/tidb-specific-variables/#shard-row-id-bits<i class="fa fa-external-link-alt"></i></span><br />热点问题官方FAQ：<span class="exturl" data-url="aHR0cHM6Ly9hc2t0dWcuY29tL3QvdGlkYi8zNTg=">https://asktug.com/t/tidb/358<i class="fa fa-external-link-alt"></i></span></p>
<p><a name="IOKxo"></a></p>
<h3 id="GC-垃圾回收"><a href="#GC-垃圾回收" class="headerlink" title="GC 垃圾回收"></a>GC 垃圾回收</h3><p>tidb使用MVCC关林数据的版本，老版本的数据通过垃圾收集器进行删除，时间默认是10分钟执行一次回收，回收线程和频率可以在系统表设置。</p>
<p><a name="KKFlJ"></a></p>
<h3 id="TiDB-的最佳适用场景"><a href="#TiDB-的最佳适用场景" class="headerlink" title="TiDB 的最佳适用场景"></a>TiDB 的最佳适用场景</h3><ul>
<li>数据量大，单机保存不下</li>
<li>不希望做 Sharding 或者懒得做 Sharding</li>
<li>访问模式上没有明显的热点</li>
<li>需要事务、需要强一致、需要灾备</li>
</ul>
<p><a name="mlgPE"></a></p>
<h3 id="在单台tidb做sybench"><a href="#在单台tidb做sybench" class="headerlink" title="在单台tidb做sybench"></a>在单台tidb做sybench</h3><p>参考官方doc:<span class="exturl" data-url="aHR0cHM6Ly9waW5nY2FwLmNvbS9kb2NzLWNuL3YzLjAvYmVuY2htYXJrL2hvdy10by1ydW4tc3lzYmVuY2gv">https://pingcap.com/docs-cn/v3.0/benchmark/how-to-run-sysbench/<i class="fa fa-external-link-alt"></i></span></p>
<p><a name="0f4b6559"></a></p>
<h4 id="坑-导入数据耗时较长，导入数据的命令要使用nohu执行"><a href="#坑-导入数据耗时较长，导入数据的命令要使用nohu执行" class="headerlink" title="[坑]导入数据耗时较长，导入数据的命令要使用nohu执行"></a>[坑]导入数据耗时较长，导入数据的命令要使用nohu执行</h4><p>官方doc导入数据的命令会执行很长一段时间，当xshell超时的时候，我们没法监控命令的执行日志，因此要使用nohup：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup sysbench --config-file=config oltp_point_select --tables=32 --table-size=1000000 prepare 2&gt;&amp;1 &amp;</span><br><span class="line">nohup sysbench --config-file=config oltp_point_select --tables=32 --table-size=1000000 run 2&gt;&amp;1 &amp;</span><br><span class="line">nohup sysbench --config-file=config oltp_update_index --tables=32 --table-size=1000000 run 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>



<ul>
<li>样本数据<ul>
<li>32张表、每张表100万条数据，每张表大约1M数据。</li>
</ul>
</li>
<li>集群规模</li>
</ul>
<p>node1 192.168.138.18  PD1, TiDB1   4c16G 200GHHD<br />node2 192.168.138.19  PD2, TiDB2   4c16G 200GHHD<br />node3 192.168.138.21  PD3              2c16G 200GHHD<br />node4 192.168.138.22  TiKV1           2c16G 200GHHD<br />node5 192.168.138.23  TiKV2           2c16G 200GHHD<br />node6 192.168.138.24  TiKV3           2c16G 200GHHD<br /> <br />sysbench所有测试结果详情在[192.168.138.18]: vi &#x2F;home&#x2F;tidb&#x2F;tidb-bench&#x2F;nohup.out<br><a name="oltp-point-select"></a><br>###<br><a name="FMg4L"></a></p>
<h4 id="oltp-point-select"><a href="#oltp-point-select" class="headerlink" title="oltp_point_select"></a>oltp_point_select</h4><ul>
<li>nohup sysbench –config-file&#x3D;config oltp_point_select –tables&#x3D;32 –table-size&#x3D;1000000 prepare 2&gt;&amp;1 &amp;</li>
</ul>
<table>
<thead>
<tr>
<th>threads</th>
<th>read</th>
<th>write</th>
<th>tps</th>
<th>qps</th>
<th>total time</th>
<th>min</th>
<th>avg</th>
<th>max</th>
<th>95th</th>
</tr>
</thead>
<tbody><tr>
<td>8</td>
<td>5937332</td>
<td>0</td>
<td>5937332 (9895.26 per sec.)</td>
<td>5937332 (9895.26 per sec.)</td>
<td>600.0156s</td>
<td>0.40</td>
<td>0.81</td>
<td>223.17</td>
<td>1.03</td>
</tr>
<tr>
<td>16</td>
<td>9396775</td>
<td>0</td>
<td>9396775 (15660.86 per sec.)</td>
<td>9396775 (15660.86 per sec.)</td>
<td>600.0148</td>
<td>0.39</td>
<td>1.02</td>
<td>177.08</td>
<td>1.52</td>
</tr>
<tr>
<td>32</td>
<td>12217819</td>
<td>0</td>
<td>12217819 (20362.72 per sec.)</td>
<td>12217819 (20362.72 per sec.)</td>
<td>600.0075s</td>
<td>0.39</td>
<td>1.57</td>
<td>119.33</td>
<td>3.75</td>
</tr>
<tr>
<td>64</td>
<td>13085444</td>
<td>0</td>
<td>13085444 (21808.49 per sec.)</td>
<td>13085444 (21808.49 per sec.)</td>
<td>600.0142s</td>
<td>0.41</td>
<td>2.93</td>
<td>270.10</td>
<td>8.43</td>
</tr>
<tr>
<td>128</td>
<td>13680931</td>
<td>0</td>
<td>13680931 (22800.08 per sec.)</td>
<td>13680931 (22800.08 per sec.)</td>
<td>600.0370s</td>
<td>0.43</td>
<td>5.61</td>
<td>1033.14</td>
<td>13.70</td>
</tr>
</tbody></table>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/186520/1564482895735-883dcc49-2e4a-422b-be32-bd7ffa706d08.png#align=left&display=inline&height=400&name=oltp_point_select.png&originHeight=400&originWidth=1312&size=33302&status=done&width=1312" alt="oltp_point_select.png"></p>
<p>95th :<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwNTc1Mjkx">https://www.zhihu.com/question/20575291<i class="fa fa-external-link-alt"></i></span></p>
<p><a name="tHki6"></a></p>
<h4 id="oltp-update-index"><a href="#oltp-update-index" class="headerlink" title="oltp_update_index"></a>oltp_update_index</h4><ul>
<li>nohup sysbench –config-file&#x3D;config oltp_update_index –tables&#x3D;32 –table-size&#x3D;10000000 run 2&gt;&amp;1 &amp;</li>
</ul>
<table>
<thead>
<tr>
<th>threads</th>
<th>read</th>
<th>write</th>
<th>tps</th>
<th>qps</th>
<th>total time</th>
<th>min</th>
<th>avg</th>
<th>max</th>
<th>95th</th>
</tr>
</thead>
<tbody><tr>
<td>8</td>
<td>0</td>
<td>149902</td>
<td>149902 (249.82 per sec.)</td>
<td>149902 (249.82 per sec.)</td>
<td>600.0418s</td>
<td>10.26</td>
<td>32.02</td>
<td>475.79</td>
<td>46.63</td>
</tr>
<tr>
<td>16</td>
<td>0</td>
<td>213850</td>
<td>213850 (356.39 per sec.)</td>
<td>213850 (356.39 per sec.)</td>
<td>600.0444s</td>
<td>9.30</td>
<td>44.89</td>
<td>659.85</td>
<td>142.39</td>
</tr>
<tr>
<td>32</td>
<td>0</td>
<td>483912</td>
<td>483912 (806.47 per sec.)</td>
<td>483912 (806.47 per sec.)</td>
<td>600.0370s</td>
<td>10.34</td>
<td>39.68</td>
<td>689.26</td>
<td>54.83</td>
</tr>
<tr>
<td>64</td>
<td>0</td>
<td>880168</td>
<td>880168 (1466.72 per sec.)</td>
<td>880168 (1466.72 per sec.)</td>
<td>600.0897s</td>
<td>10.60</td>
<td>43.63</td>
<td>1109.14</td>
<td>58.92</td>
</tr>
<tr>
<td>128</td>
<td>0</td>
<td>1344814</td>
<td>1344814 (2241.17 per sec.)</td>
<td>1344814 (2241.17 per sec.)</td>
<td>600.0473s</td>
<td>9.90</td>
<td>57.11</td>
<td>8177.34</td>
<td>75.82</td>
</tr>
<tr>
<td>256</td>
<td>0</td>
<td>1882603</td>
<td>1882603 (3137.16 per sec.)</td>
<td>1882603 (3137.16 per sec.)</td>
<td>600.0950s</td>
<td>11.88</td>
<td>81.59</td>
<td>1418.85</td>
<td>211.60</td>
</tr>
</tbody></table>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/186520/1564483495647-455b41ad-0547-47dd-aa64-439eba7858e7.png#align=left&display=inline&height=400&name=oltp_update_index.png&originHeight=400&originWidth=1312&size=35286&status=done&width=1312" alt="oltp_update_index.png"><br><a name="c1OR4"></a></p>
<h4 id="oltp-read-only"><a href="#oltp-read-only" class="headerlink" title="oltp_read_only"></a>oltp_read_only</h4><ul>
<li>nohup sysbench –config-file&#x3D;config oltp_read_only –tables&#x3D;32 –table-size&#x3D;10000000 run 2&gt;&amp;1 &amp;</li>
</ul>
<table>
<thead>
<tr>
<th>threads</th>
<th>total</th>
<th>tps</th>
<th>qps</th>
<th>total time</th>
<th>min</th>
<th>avg</th>
<th>max</th>
<th>95th</th>
</tr>
</thead>
<tbody><tr>
<td>8</td>
<td>6204464</td>
<td>387779 (646.28 per sec.)</td>
<td>6204464 (10340.44 per sec.)</td>
<td>600.0174s</td>
<td>8.88</td>
<td>12.38</td>
<td>427.50</td>
<td>16.41</td>
</tr>
<tr>
<td>16</td>
<td>9270576</td>
<td>579411 (965.65 per sec.)</td>
<td>9270576 (15450.37 per sec.)</td>
<td>600.0211s</td>
<td>10.03</td>
<td>16.57</td>
<td>1203.28</td>
<td>26.20</td>
</tr>
<tr>
<td>32</td>
<td>11644768</td>
<td>727798 (1212.92 per sec.)</td>
<td>11644768 (19406.73 per sec.)</td>
<td>600.0359s</td>
<td>9.18</td>
<td>26.38</td>
<td>1132.08</td>
<td>46.63</td>
</tr>
<tr>
<td>64</td>
<td>12632864</td>
<td>789554 (1315.79 per sec.)</td>
<td>12632864 (21052.63 per sec.)</td>
<td>600.0590s</td>
<td>11.66</td>
<td>48.63</td>
<td>423.32</td>
<td>84.47</td>
</tr>
<tr>
<td>128</td>
<td>12792912</td>
<td>799557 (1332.37 per sec.)</td>
<td>12792912 (21317.86 per sec.)</td>
<td>600.1013s</td>
<td>10.65</td>
<td>96.06</td>
<td>3153.57</td>
<td>150.29</td>
</tr>
</tbody></table>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/186520/1564487404538-aa194ea1-8f25-411f-adc8-a92502c2a8e0.png#align=left&display=inline&height=400&name=oltp_read_only.png&originHeight=400&originWidth=1312&size=34084&status=done&width=1312" alt="oltp_read_only.png"><br><a name="fqVte"></a><br>#<br><a name="xBFtr"></a></p>
<h3 id="TPC-C测试"><a href="#TPC-C测试" class="headerlink" title="TPC-C测试"></a>TPC-C测试</h3><p><span class="exturl" data-url="aHR0cHM6Ly9waW5nY2FwLmNvbS9kb2NzLWNuL3YzLjAvYmVuY2htYXJrL2hvdy10by1ydW4tdHBjYy8=">https://pingcap.com/docs-cn/v3.0/benchmark/how-to-run-tpcc/<i class="fa fa-external-link-alt"></i></span><br />TPC-C 是一个对 OLTP（联机交易处理）系统进行测试的规范，使用一个商品销售模型对 OLTP 系统进行测试。<br />TPC-C 使用 tpmC 值（Transactions per Minute）来衡量系统最大有效吞吐量 (MQTh, Max Qualified Throughput)，其中 Transactions 以 NewOrder Transaction 为准，即最终衡量单位为每分钟处理的新订单数。</p>
<p><a name="feB7I"></a></p>
<h4 id="BenchmarkSQL-配置"><a href="#BenchmarkSQL-配置" class="headerlink" title="BenchmarkSQL 配置"></a>BenchmarkSQL 配置</h4><p>修改 <code>benchmarksql/run/props.mysql</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conn=jdbc:mysql://&#123;HAPROXY-HOST&#125;:&#123;HAPROXY-PORT&#125;/tpcc?useSSL=false&amp;useServerPrepStmts=true&amp;useConfigs=maxPerformance</span><br><span class="line">warehouses=1000 # 使用 1000 个 warehouse</span><br><span class="line">terminals=500   # 使用 500 个终端</span><br><span class="line">loadWorkers=32  # 导入数据的并发数</span><br></pre></td></tr></table></figure>
<p><a name="3blds"></a></p>
<h4 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database tpcc</span><br></pre></td></tr></table></figure>

<p>之后在 shell 中运行 BenchmarkSQL 建表脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd run</span><br><span class="line">nohup  ./runSQL.sh props.mysql sql.mysql/tableCreates.sql  2&gt;&amp;1 &amp;</span><br><span class="line">nohup ./runSQL.sh props.mysql sql.mysql/indexCreates.sql 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>运行导入数据脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup ./runLoader.sh props.mysql 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<p>这个过程时间会有点长（我们的测试环境集群这条命令运行了6个小时，等的花儿都谢了。。。）。<br />验证导入的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup  ./runSQL.sh props.mysql  sql.common/test.sql 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p><a name="lc6vK"></a></p>
<h4 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup ./runBenchmark.sh props.mysql &amp;&gt; test.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a name="waCKQ"></a></p>
<h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p>[192.168.138.18]  vi &#x2F;home&#x2F;tidb&#x2F;benchmarksql&#x2F;run&#x2F;test.log</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/186520/1564626255512-417c0a26-cd7a-4af9-a6c3-ae48919b56c8.png#align=left&display=inline&height=92&name=tpc-c-result.png&originHeight=92&originWidth=659&size=9234&status=done&width=659" alt="tpc-c-result.png"></p>
<p>系统每分钟的吞吐量是在4399.16(官方机器配置结果是：77373.25)，即集群每分钟能承载的订单数量是4399个订单。</p>
<p><a name="FUbxC"></a></p>
<h3 id="其他企业在tidb的实践与分享"><a href="#其他企业在tidb的实践与分享" class="headerlink" title="其他企业在tidb的实践与分享"></a>其他企业在tidb的实践与分享</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BpbmdjYXAvcHJlc2VudGF0aW9ucw==">https://github.com/pingcap/presentations<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>tidb-install</tag>
      </tags>
  </entry>
  <entry>
    <title>shardingsphere_jdbc_starter</title>
    <url>/2021/07/18/starter_struct/shardingsphere_jdbc_starter/</url>
    <content><![CDATA[<h3 id="Sharding-JDBC简介"><a href="#Sharding-JDBC简介" class="headerlink" title="Sharding-JDBC简介"></a>Sharding-JDBC简介</h3><p>定位为轻量级Java框架，在Java的JDBC层提供的额外服务。 它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。</p>
<ul>
<li>适用于任何基于JDBC的ORM框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC。</li>
<li>支持任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP等。<br> 支持任意实现JDBC规范的数据库。目前支持MySQL，Oracle，SQLServer，PostgreSQL以及任何遵循SQL92标准的数据库。</li>
</ul>
<p> <img src="https://shardingsphere.apache.org/document/legacy/4.x/document/img/sharding-jdbc-brief.png" alt="image.png"></p>
<span id="more"></span>
<p>官方提供了数据分片、读写分离、数据脱敏的三种配置:<br><span class="exturl" data-url="aHR0cHM6Ly9zaGFyZGluZ3NwaGVyZS5hcGFjaGUub3JnL2RvY3VtZW50L2xlZ2FjeS80LngvZG9jdW1lbnQvY24vbWFudWFsL3NoYXJkaW5nLWpkYmMvY29uZmlndXJhdGlvbi9jb25maWctc3ByaW5nLWJvb3Qv">SPRING BOOT配置<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Sharding-JDBC在使用上的问题"><a href="#Sharding-JDBC在使用上的问题" class="headerlink" title="Sharding-JDBC在使用上的问题"></a>Sharding-JDBC在使用上的问题</h3><p>Sharding-JDBC 在启动的时候需要加载分片、脱敏、读写分离等这些配置，加载时候只认识以spring.shardingsphere开头的配置信息，并且不支持加载多次，什么意思呢，加入我的app使用了2套数据库系统，订单系统使用了oracle，商品系统使用了mysql，但是他们的代码逻辑存在耦合，放在一个app里边，在一个jvm里边启动app，同时呢，订单和商品都是分库分表的，并且订单数据有些字段需要加密，这就使用到了Sharding-jdbc的数据分片，数据脱敏，而且分别应用到2套数据库分片系统，需要加载好多datasource，一个逻辑库，对应n个实体库，每个实体库都是一个datasource对象，如果使用Sharding-jdbc原来的加载机制，是无法完成这个工作的，因为shardingsphere对的配置都是spring.shardingsphere开头的，但是我的多个不同的逻辑数据库使用了不同的分片策略，需要另外一套spring.shardingsphere前缀开头的配置，因此需要进行一次Sharding-jdbc的封装，做一个springboot的starter。</p>
<h3 id="twodragonlake-sharding-jdbc-starter设计"><a href="#twodragonlake-sharding-jdbc-starter设计" class="headerlink" title="twodragonlake-sharding-jdbc-starter设计"></a>twodragonlake-sharding-jdbc-starter设计</h3><p>假如我们有一个逻辑数据库：cs，然后分了三个实体数据库cs1、cs2、cs3.<br>然后有一个ds逻辑数据库，他有三个实体数据库:ds1、ds2、ds3.<br>然后我们还设置了一个默认实体数据库cs1.<br>我们先用我们自己的定义规范定义这些数据库:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#默认实体数据库cs1</span><br><span class="line">jdbc.datasource.defaultDS=ds</span><br><span class="line"></span><br><span class="line"># 独立的一个数据源</span><br><span class="line">jdbc.datasource.tnp_product.url = jdbc:mysql://192.168.120.17:3306/tnp_product?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">jdbc.datasource.tnp_product.username = tnp_dev</span><br><span class="line">jdbc.datasource.tnp_product.password = tnp_dev</span><br><span class="line">jdbc.datasource.tnp_product.pool = druid</span><br><span class="line">jdbc.datasource.tnp_product.driverClass = com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">jdbc.datasource.ds.names = ds1,ds2,ds3</span><br><span class="line"></span><br><span class="line"># ds1的数据源配置</span><br><span class="line">jdbc.datasource.ds.ds1.url = jdbc:mysql://192.168.120.17:3306/ds1?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">jdbc.datasource.ds.ds1.username = ds1</span><br><span class="line">jdbc.datasource.ds.ds1.password = ds1</span><br><span class="line">jdbc.datasource.ds.ds1.pool = druid</span><br><span class="line">jdbc.datasource.ds.ds1.driverClass = com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line"># ds2的数据源配置</span><br><span class="line">jdbc.datasource.ds.ds2.url = jdbc:mysql://192.168.120.17:3306/ds2?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">jdbc.datasource.ds.ds2.username = tnp_dev</span><br><span class="line">jdbc.datasource.ds.ds2.password = tnp_dev</span><br><span class="line">jdbc.datasource.ds.ds2.pool = druid</span><br><span class="line">jdbc.datasource.ds.ds2.driverClass = com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line"># ds3的数据源配置</span><br><span class="line">jdbc.datasource.ds.ds3.url = jdbc:mysql://192.168.120.17:3306/ds3?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">jdbc.datasource.ds.ds3.username = tnp_dev</span><br><span class="line">jdbc.datasource.ds.ds3.password = tnp_dev</span><br><span class="line">jdbc.datasource.ds.ds3.pool = druid</span><br><span class="line">jdbc.datasource.ds.ds3.driverClass = com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">#对ds逻辑数据库进行分片+数据脱敏配置，没有ds前缀意味着ds是一个默认数据源</span><br><span class="line">spring.shardingsphere.sharding.default-database-strategy.inline.sharding-column = user_id</span><br><span class="line">spring.shardingsphere.sharding.default-database-strategy.inline.algorithm-expression = ds$-&gt;&#123;user_id % 3 + 3&#125;</span><br><span class="line">spring.shardingsphere.sharding.binding-tables = health_record,health_task</span><br><span class="line">spring.shardingsphere.sharding.broadcast-tables = health_level</span><br><span class="line">spring.shardingsphere.sharding.tables.health_record.actual-data-nodes = ds$-&gt;&#123;1..3&#125;.health_record$-&gt;&#123;0..2&#125;</span><br><span class="line">spring.shardingsphere.sharding.tables.health_record.table-strategy.inline.sharding-column = record_id</span><br><span class="line">spring.shardingsphere.sharding.tables.health_record.table-strategy.inline.algorithm-expression = health_record$-&gt;&#123;record_id % 3&#125;</span><br><span class="line">spring.shardingsphere.sharding.tables.health_record.key-generator.column = record_id</span><br><span class="line">spring.shardingsphere.sharding.tables.health_record.key-generator.type = SNOWFLAKE</span><br><span class="line">spring.shardingsphere.sharding.tables.health_record.key-generator.props.worker.id = 33</span><br><span class="line">spring.shardingsphere.sharding.tables.health_task.actual-data-nodes = ds$-&gt;&#123;1..3&#125;.health_task$-&gt;&#123;0..2&#125;</span><br><span class="line">spring.shardingsphere.sharding.tables.health_task.table-strategy.inline.sharding-column = record_id</span><br><span class="line">spring.shardingsphere.sharding.tables.health_task.table-strategy.inline.algorithm-expression = health_task$-&gt;&#123;record_id % 3&#125;</span><br><span class="line">spring.shardingsphere.sharding.tables.health_task.key-generator.column = task_id</span><br><span class="line">spring.shardingsphere.sharding.tables.health_task.key-generator.type = SNOWFLAKE</span><br><span class="line">spring.shardingsphere.sharding.tables.health_task.key-generator.props.worker.id = 33</span><br><span class="line">spring.shardingsphere.sharding.tables.encrypt_user.actual-data-nodes = ds$-&gt;&#123;1..3&#125;.encrypt_user$-&gt;&#123;0..2&#125;</span><br><span class="line">spring.shardingsphere.sharding.tables.encrypt_user.table-strategy.inline.sharding-column = user_id</span><br><span class="line">spring.shardingsphere.sharding.tables.encrypt_user.table-strategy.inline.algorithm-expression = encrypt_user$-&gt;&#123;user_id % 3&#125;</span><br><span class="line">spring.shardingsphere.sharding.tables.encrypt_user.key-generator.column = user_id</span><br><span class="line">spring.shardingsphere.sharding.tables.encrypt_user.key-generator.type = SNOWFLAKE</span><br><span class="line">spring.shardingsphere.sharding.tables.encrypt_user.key-generator.props.worker.id = 33</span><br><span class="line">spring.shardingsphere.sharding.encrypt-rule.encryptors.encryptor_aes.type = LLPayAES</span><br><span class="line">spring.shardingsphere.sharding.encrypt-rule.encryptors.encryptor_aes.props.aes.key.value = 123456</span><br><span class="line">spring.shardingsphere.sharding.encrypt-rule.tables.encrypt_user.columns.user_name.plain-column = user_name_plain</span><br><span class="line">spring.shardingsphere.sharding.encrypt-rule.tables.encrypt_user.columns.user_name.cipher-column = user_name</span><br><span class="line">spring.shardingsphere.sharding.encrypt-rule.tables.encrypt_user.columns.user_name.encryptor = encryptor_aes</span><br><span class="line">spring.shardingsphere.sharding.encrypt-rule.tables.encrypt_user.columns.pwd.cipher-column = pwd</span><br><span class="line">spring.shardingsphere.sharding.encrypt-rule.tables.encrypt_user.columns.pwd.encryptor = encryptor_aes</span><br><span class="line">spring.shardingsphere.sharding.props.sql.show = true</span><br><span class="line"></span><br><span class="line">#cs逻辑数据库有三个实体数据库分片</span><br><span class="line">jdbc.datasource.cs.names = cs1,cs2,cs3</span><br><span class="line"></span><br><span class="line"># cs1的数据源配置</span><br><span class="line">jdbc.datasource.cs.cs1.url = jdbc:mysql://192.168.120.17:3306/cs1?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">jdbc.datasource.cs.cs1.username = tnp_dev</span><br><span class="line">jdbc.datasource.cs.cs1.password = tnp_dev</span><br><span class="line">jdbc.datasource.cs.cs1.pool = druid</span><br><span class="line">jdbc.datasource.cs.cs1.driverClass = com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line"># cs2的数据源配置</span><br><span class="line">jdbc.datasource.cs.cs2.url = jdbc:mysql://192.168.120.17:3306/cs2?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">jdbc.datasource.cs.cs2.username = tnp_dev</span><br><span class="line">jdbc.datasource.cs.cs2.password = tnp_dev</span><br><span class="line">jdbc.datasource.cs.cs2.pool = druid</span><br><span class="line">jdbc.datasource.cs.cs2.driverClass = com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line"># cs3的数据源配置</span><br><span class="line">jdbc.datasource.cs.cs3.url = jdbc:mysql://192.168.120.17:3306/cs3?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">jdbc.datasource.cs.cs3.username = tnp_dev</span><br><span class="line">jdbc.datasource.cs.cs3.password = tnp_dev</span><br><span class="line">jdbc.datasource.cs.cs3.pool = druid</span><br><span class="line">jdbc.datasource.cs.cs3.driverClass = com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">#对cs逻辑数据库进行分片+数据脱敏配置</span><br><span class="line">cs.spring.shardingsphere.sharding.default-database-strategy.inline.sharding-column = user_id</span><br><span class="line">cs.spring.shardingsphere.sharding.default-database-strategy.inline.algorithm-expression = cs$-&gt;&#123;user_id % 3 + 3&#125;</span><br><span class="line">cs.spring.shardingsphere.sharding.binding-tables = health_record,health_task</span><br><span class="line">cs.spring.shardingsphere.sharding.broadcast-tables = health_level</span><br><span class="line">cs.spring.shardingsphere.sharding.tables.health_record.actual-data-nodes = cs$-&gt;&#123;1..3&#125;.health_record$-&gt;&#123;0..2&#125;</span><br><span class="line">cs.spring.shardingsphere.sharding.tables.health_record.table-strategy.inline.sharding-column = record_id</span><br><span class="line">cs.spring.shardingsphere.sharding.tables.health_record.table-strategy.inline.algorithm-expression = health_record$-&gt;&#123;record_id % 3&#125;</span><br><span class="line">cs.spring.shardingsphere.sharding.tables.health_record.key-generator.column = record_id</span><br><span class="line">cs.spring.shardingsphere.sharding.tables.health_record.key-generator.type = SNOWFLAKE</span><br><span class="line">cs.spring.shardingsphere.sharding.tables.health_record.key-generator.props.worker.id = 33</span><br><span class="line">cs.spring.shardingsphere.sharding.tables.health_task.actual-data-nodes = cs$-&gt;&#123;1..3&#125;.health_task$-&gt;&#123;0..2&#125;</span><br><span class="line">cs.spring.shardingsphere.sharding.tables.health_task.table-strategy.inline.sharding-column = record_id</span><br><span class="line">cs.spring.shardingsphere.sharding.tables.health_task.table-strategy.inline.algorithm-expression = health_task$-&gt;&#123;record_id % 3&#125;</span><br><span class="line">cs.spring.shardingsphere.sharding.tables.health_task.key-generator.column = task_id</span><br><span class="line">cs.spring.shardingsphere.sharding.tables.health_task.key-generator.type = SNOWFLAKE</span><br><span class="line">cs.spring.shardingsphere.sharding.tables.health_task.key-generator.props.worker.id = 33</span><br><span class="line">cs.spring.shardingsphere.sharding.tables.encrypt_user.actual-data-nodes = cs$-&gt;&#123;1..3&#125;.encrypt_user$-&gt;&#123;0..2&#125;</span><br><span class="line">cs.spring.shardingsphere.sharding.tables.encrypt_user.table-strategy.inline.sharding-column = user_id</span><br><span class="line">cs.spring.shardingsphere.sharding.tables.encrypt_user.table-strategy.inline.algorithm-expression = encrypt_user$-&gt;&#123;user_id % 3&#125;</span><br><span class="line">cs.spring.shardingsphere.sharding.tables.encrypt_user.key-generator.column = user_id</span><br><span class="line">cs.spring.shardingsphere.sharding.tables.encrypt_user.key-generator.type = SNOWFLAKE</span><br><span class="line">cs.spring.shardingsphere.sharding.tables.encrypt_user.key-generator.props.worker.id = 33</span><br><span class="line">cs.spring.shardingsphere.sharding.encrypt-rule.encryptors.encryptor_aes.type = LLPayAES</span><br><span class="line">cs.spring.shardingsphere.sharding.encrypt-rule.encryptors.encryptor_aes.props.aes.key.value = 123456</span><br><span class="line">cs.spring.shardingsphere.sharding.encrypt-rule.tables.encrypt_user.columns.user_name.plain-column = user_name_plain</span><br><span class="line">cs.spring.shardingsphere.sharding.encrypt-rule.tables.encrypt_user.columns.user_name.cipher-column = user_name</span><br><span class="line">cs.spring.shardingsphere.sharding.encrypt-rule.tables.encrypt_user.columns.user_name.encryptor = encryptor_aes</span><br><span class="line">cs.spring.shardingsphere.sharding.encrypt-rule.tables.encrypt_user.columns.pwd.cipher-column = pwd</span><br><span class="line">cs.spring.shardingsphere.sharding.encrypt-rule.tables.encrypt_user.columns.pwd.encryptor = encryptor_aes</span><br><span class="line">cs.spring.shardingsphere.sharding.props.sql.show = true</span><br></pre></td></tr></table></figure>

<h4 id="加载配置，生成datasource"><a href="#加载配置，生成datasource" class="headerlink" title="加载配置，生成datasource"></a>加载配置，生成datasource</h4><p>我们定义DataSourceConfiger类，是一个数据源配置管理器，它实现了EnvironmentAware、BeanFactoryPostProcessor。</p>
<h5 id="DataSourceConfiger的成员"><a href="#DataSourceConfiger的成员" class="headerlink" title="DataSourceConfiger的成员"></a>DataSourceConfiger的成员</h5><ul>
<li>PropertiesReader、Environment，PropertiesReader用来读取Environment当中的配置。</li>
<li>String defaultLogicDsName：默认的逻辑数据源，这里是ds。</li>
<li>Map&lt;String, Map&lt;String, DataSource&gt;&gt; originalDataSourceMaps：<ul>
<li>key:logicDsName;value:{key:realDsName,value:DataSource}，即一个逻辑数据源对应多个真实的实体数据源。</li>
</ul>
</li>
<li>Map&lt;String,ShardingspherePropertiesConfig&gt; logicDsNameToshardingspherePropertiesConfigs：<ul>
<li>shardingsphere的逻辑数据源和数据源配置的映射。</li>
</ul>
</li>
</ul>
<h5 id="EnvironmentAware"><a href="#EnvironmentAware" class="headerlink" title="EnvironmentAware"></a>EnvironmentAware</h5><p>EnvironmentAware的作用主要是用来配置DataSourceConfiger的环境，为DataSourceConfiger提供配置环境管理的能力，DataSourceConfiger需要实现EnvironmentAware的setEnvironment<br>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void setEnvironment(Environment environment) &#123;</span><br><span class="line">    this.environment = environment;</span><br><span class="line">    this.propertiesReader = new PropertiesReader() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String getString(String propertyName) &#123;</span><br><span class="line">            return environment.getProperty(propertyName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 初始化所有的实体数据源，设置默认数据源</span><br><span class="line">    initDataSourceMap(environment);</span><br><span class="line">    //加载所有逻辑数据源的shardingsphere配置，包括默认逻辑数据源的配置</span><br><span class="line">    initPropertiesAndDataSource(environment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="初始化所有的实体数据源，设置默认数据源"><a href="#初始化所有的实体数据源，设置默认数据源" class="headerlink" title="初始化所有的实体数据源，设置默认数据源"></a>初始化所有的实体数据源，设置默认数据源</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void initDataSourceMap(Environment environment) throws Throwable &#123;</span><br><span class="line">    StandardEnvironment standardEnv = (StandardEnvironment) environment;</span><br><span class="line">    defaultLogicDsName = standardEnv.getProperty(&quot;jdbc.datasource.defaultDS&quot;);</span><br><span class="line">    // 默认数据源没有配置启动异常</span><br><span class="line">    if(StringUtils.isBlank(defaultLogicDsName))&#123;</span><br><span class="line">        logger.error(&quot;you should point jdbc.datasource.defaultDS key.&quot;);</span><br><span class="line">        throw new Throwable(&quot;you should point jdbc.datasource.defaultDS key.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //实例化所有逻辑数据源的实体数据源</span><br><span class="line">    List&lt;String&gt; logicNames = new InlineExpressionParser(environment.getProperty(&quot;jdbc.datasource.names&quot;)).splitAndEvaluate();</span><br><span class="line">    for(String logicDsName : logicNames)&#123;</span><br><span class="line">        List&lt;String&gt; realDsNames = new InlineExpressionParser(environment.getProperty(&quot;jdbc.datasource.&quot; + logicDsName.trim()+&quot;.names&quot;)).splitAndEvaluate();</span><br><span class="line">        //加载shardingsphere的sharding配置的数据源</span><br><span class="line">        if(!CollectionUtils.isEmpty(realDsNames))&#123;</span><br><span class="line">            Map&lt;String, DataSource&gt; oneLogicDataSources = new HashMap&lt;&gt;();</span><br><span class="line">            for(String realDsName: realDsNames)&#123;</span><br><span class="line">                DataSource dataSource = DataSourceFactory.createDataSource(new DataSourceConfig(logicDsName,realDsName,</span><br><span class="line">                        DataSourcesEnum.getDataSourcesEnumByName(standardEnv.getProperty(&quot;jdbc.datasource.&quot;+logicDsName+&quot;.&quot;+realDsName+&quot;.pool&quot;)),propertiesReader));</span><br><span class="line">                oneLogicDataSources.put(realDsName,dataSource);</span><br><span class="line">            &#125;</span><br><span class="line">            originalDataSourceMaps.put(logicDsName, oneLogicDataSources);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            // single ds</span><br><span class="line">            /**</span><br><span class="line">            加载如下形式的数据源配置，这种数据源不使用shardingsphere</span><br><span class="line">            jdbc.datasource.tnp_product.url = jdbc:mysql://192.168.120.17:3306/tnp_product?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">            jdbc.datasource.tnp_product.username = tnp_dev</span><br><span class="line">            jdbc.datasource.tnp_product.password = tnp_dev</span><br><span class="line">            jdbc.datasource.tnp_product.pool = druid</span><br><span class="line">            jdbc.datasource.tnp_product.driverClass = com.mysql.jdbc.Driver</span><br><span class="line">            **/</span><br><span class="line">            if(environment.containsProperty(&quot;jdbc.datasource.&quot;+logicDsName+&quot;.url&quot;))&#123;</span><br><span class="line">                Map&lt;String, DataSource&gt; oneSingleLogicDataSources = new HashMap&lt;&gt;();</span><br><span class="line">                DataSource dataSource =  DataSourceFactory.createDataSource(new DataSourceConfig(null,logicDsName,</span><br><span class="line">                        DataSourcesEnum.getDataSourcesEnumByName(standardEnv.getProperty(&quot;jdbc.datasource.&quot;+logicDsName+&quot;.pool&quot;)), propertiesReader));</span><br><span class="line">                oneSingleLogicDataSources.put(logicDsName, dataSource);</span><br><span class="line">                originalDataSourceMaps.put(logicDsName, oneSingleLogicDataSources);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="加载所有逻辑数据源的shardingsphere配置，包括默认逻辑数据源的配置"><a href="#加载所有逻辑数据源的shardingsphere配置，包括默认逻辑数据源的配置" class="headerlink" title="加载所有逻辑数据源的shardingsphere配置，包括默认逻辑数据源的配置"></a>加载所有逻辑数据源的shardingsphere配置，包括默认逻辑数据源的配置</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void initPropertiesAndDataSource(Environment environment) &#123;</span><br><span class="line">   //定义分库分片、读写分离、数据脱敏、影子库的Sharding配置</span><br><span class="line">    ShardingRuleConfigurationProperties defaultShardingProperties = new ShardingRuleConfigurationProperties();</span><br><span class="line">    MasterSlaveRuleConfigurationProperties defaultMasterSlaveProperties = new MasterSlaveRuleConfigurationProperties();</span><br><span class="line">    EncryptRuleConfigurationProperties defaultEncryptProperties = new EncryptRuleConfigurationProperties();</span><br><span class="line">    PropertiesConfigurationProperties defaultPropMapProperties = new PropertiesConfigurationProperties();</span><br><span class="line">    ShadowRuleConfigurationProperties defaultShadowProperties = new ShadowRuleConfigurationProperties();</span><br><span class="line">    try &#123;</span><br><span class="line">       //默认配置</span><br><span class="line">        PropertiesConfigurationUtils.bindPropertiesToTarget(&quot;spring.shardingsphere.sharding&quot;, defaultShardingProperties, environment);</span><br><span class="line">        PropertiesConfigurationUtils.bindPropertiesToTarget(&quot;spring.shardingsphere.masterslave&quot;, defaultMasterSlaveProperties, environment);</span><br><span class="line">        PropertiesConfigurationUtils.bindPropertiesToTarget(&quot;spring.shardingsphere.encrypt&quot;, defaultEncryptProperties, environment);</span><br><span class="line">        PropertiesConfigurationUtils.bindPropertiesToTarget(&quot;spring.shardingsphere.shadow&quot;, defaultShadowProperties, environment);</span><br><span class="line">        PropertiesConfigurationUtils.bindPropertiesToTarget(&quot;spring.shardingsphere&quot;, defaultPropMapProperties, environment);</span><br><span class="line">        ShardingspherePropertiesConfig defaultShardingspherePropertiesConfig = new ShardingspherePropertiesConfig(defaultShardingProperties,defaultEncryptProperties,defaultMasterSlaveProperties,defaultShadowProperties,defaultPropMapProperties);</span><br><span class="line">        logicDsNameToshardingspherePropertiesConfigs.put(defaultLogicDsName, defaultShardingspherePropertiesConfig);</span><br><span class="line"></span><br><span class="line">        //加载逻辑库的Sharding配置</span><br><span class="line">        List&lt;String&gt; logicNames = new InlineExpressionParser(environment.getProperty(&quot;jdbc.datasource.names&quot;)).splitAndEvaluate();</span><br><span class="line">        for(String logicDsName : logicNames)&#123;</span><br><span class="line">            //datasource have specific sharding configs，比如以cs开头的配置</span><br><span class="line">            if(PropertyUtil.containPropertyPrefix(environment, logicDsName ))&#123;</span><br><span class="line">               // 得到逻辑库名称后边的配置字符串，比如cs.spring.shardingsphere.sharding.props.sql.show = true</span><br><span class="line">               //经过handle会得到spring.shardingsphere.sharding.props.sql.show = true</span><br><span class="line">                Map&lt;String,Object&gt; kvs =  PropertyUtil.handle(environment, logicDsName , Map.class);</span><br><span class="line">                Environment transferEnv = new StandardEnvironment();</span><br><span class="line">                ConfigurableEnvironment configurableEnvironment = (ConfigurableEnvironment)transferEnv;</span><br><span class="line">                MapPropertySource  propertiesPropertySource = new MapPropertySource(&quot;spring.shardingsphere&quot;, kvs);</span><br><span class="line">                configurableEnvironment.getPropertySources().addLast(propertiesPropertySource);</span><br><span class="line"></span><br><span class="line">                ShardingRuleConfigurationProperties shardingProperties = new ShardingRuleConfigurationProperties();</span><br><span class="line">                MasterSlaveRuleConfigurationProperties masterSlaveProperties = new MasterSlaveRuleConfigurationProperties();</span><br><span class="line">                EncryptRuleConfigurationProperties encryptProperties = new EncryptRuleConfigurationProperties();</span><br><span class="line">                PropertiesConfigurationProperties propMapProperties = new PropertiesConfigurationProperties();</span><br><span class="line">                ShadowRuleConfigurationProperties shadowProperties = new ShadowRuleConfigurationProperties();</span><br><span class="line">                PropertiesConfigurationUtils.bindPropertiesToTarget(&quot;spring.shardingsphere.sharding&quot;, shardingProperties, transferEnv);</span><br><span class="line">                PropertiesConfigurationUtils.bindPropertiesToTarget(&quot;spring.shardingsphere.masterslave&quot;, masterSlaveProperties, transferEnv);</span><br><span class="line">                PropertiesConfigurationUtils.bindPropertiesToTarget(&quot;spring.shardingsphere.encrypt&quot;, encryptProperties, transferEnv);</span><br><span class="line">                PropertiesConfigurationUtils.bindPropertiesToTarget(&quot;spring.shardingsphere.shadow&quot;, shadowProperties, transferEnv);</span><br><span class="line">                PropertiesConfigurationUtils.bindPropertiesToTarget(&quot;spring.shardingsphere&quot;, propMapProperties, transferEnv);</span><br><span class="line">                // 每一个逻辑数据库都有可能存在四种可能的shardingsphere的配置，不管有没有，到放到一个ShardingspherePropertiesConfig对象当中</span><br><span class="line">                logicDsNameToshardingspherePropertiesConfigs.put(logicDsName, new ShardingspherePropertiesConfig(shardingProperties,encryptProperties,</span><br><span class="line">                        masterSlaveProperties,shadowProperties,propMapProperties));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new RuntimeException(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是对实体数据源和逻辑数据源的准备工作，实体化了所有的实体数据源，以及加载了逻辑数据源的shardingsphere配置到logicDsNameToshardingspherePropertiesConfigs当中。<br>由于DataSourceConfiger实现了BeanFactoryPostProcessor，因此DataSourceConfiger需要override BeanFactoryPostProcessor的postProcessBeanFactory方法，即在BeanFactory就绪完毕执行的逻辑。</p>
<h3 id="创建Shardingsphere逻辑数据源实例对象，配置事物管理器"><a href="#创建Shardingsphere逻辑数据源实例对象，配置事物管理器" class="headerlink" title="创建Shardingsphere逻辑数据源实例对象，配置事物管理器"></a>创建Shardingsphere逻辑数据源实例对象，配置事物管理器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">    BeanDefinitionRegistry registry = (BeanDefinitionRegistry)beanFactory;</span><br><span class="line">    // key:logicDsName;value:&#123;key:realDsName,value:DataSource&#125;</span><br><span class="line">    for(Map.Entry&lt;String, Map&lt;String, DataSource&gt;&gt; oneLogicDs: originalDataSourceMaps.entrySet())&#123;</span><br><span class="line">        // 在环境配置当中寻找，是否存在一种Shardingsphere配置。</span><br><span class="line">        // 而且一个逻辑数据源只能配置为一种模式（ps:分片策略可以和数据脱敏同时配置，不冲突，参考cs逻辑数据源的配置）</span><br><span class="line">        List&lt;ShardingType&gt; shardingTypes = RuleCondition.getShardingTypes(environment,oneLogicDs.getKey());</span><br><span class="line">        if(1 != shardingTypes.size())&#123;</span><br><span class="line">            throw new Throwable(&quot;only setting one mode in shardingDataSource,masterSlaveDataSource,encryptDataSource,shadowDataSource options&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //sharding逻辑数据源的shardingsphere实例化，根据配置不同，分化为分片、脱敏、读写分离、影子库模式其中一个策略。</span><br><span class="line">        //create and register sharding dataSource</span><br><span class="line">        if(logicDsNameToshardingspherePropertiesConfigs.containsKey(oneLogicDs.getKey()))&#123;</span><br><span class="line">            ShardingsphereDataSourceRegisterFactory.newInstance(shardingTypes.get(0),oneLogicDs.getKey(), oneLogicDs.getValue(),</span><br><span class="line">                    logicDsNameToshardingspherePropertiesConfigs.get(oneLogicDs.getKey()), registry);</span><br><span class="line">        &#125;else if(defaultLogicDsName.equals(oneLogicDs.getKey()))&#123;</span><br><span class="line">            // 默认数据源的shardingsphere实例化</span><br><span class="line">            ShardingsphereDataSourceRegisterFactory.newInstance(shardingTypes.get(0),oneLogicDs.getKey(), oneLogicDs.getValue(),</span><br><span class="line">                    logicDsNameToshardingspherePropertiesConfigs.get(defaultLogicDsName), registry);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //独立数据源的shardingsphere实例化（独立数据源在shardingsphere也是支持的，即没有任何分库分表配置）</span><br><span class="line">            ShardingsphereDataSourceRegisterFactory.newInstance(ShardingType.EMPTY,oneLogicDs.getKey(), oneLogicDs.getValue(),</span><br><span class="line">                    logicDsNameToshardingspherePropertiesConfigs.get(defaultLogicDsName), registry);</span><br><span class="line">        &#125;</span><br><span class="line">        // 为每个shardingsphere逻辑数据源配置事物管理器</span><br><span class="line">        //create and register sharding dataSource`s transactionManager</span><br><span class="line">        String eachTxManagerBeanName = oneLogicDs.getKey()+&quot;TXManager&quot;;</span><br><span class="line">        GenericBeanDefinition eachTxDefinition = new GenericBeanDefinition();</span><br><span class="line">        eachTxDefinition.setBeanClass(DataSourceTransactionManager.class);</span><br><span class="line">        eachTxDefinition.setScope(BeanDefinition.SCOPE_SINGLETON);</span><br><span class="line">        eachTxDefinition.getPropertyValues().addPropertyValue(&quot;dataSource&quot;, new RuntimeBeanReference(oneLogicDs.getKey()));</span><br><span class="line">        eachTxDefinition.addQualifier(new AutowireCandidateQualifier(Qualifier.class, oneLogicDs.getKey()));</span><br><span class="line">        registry.registerBeanDefinition(eachTxManagerBeanName, eachTxDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    // 事物管理器扫描</span><br><span class="line">    //register sharding transaction scanner</span><br><span class="line">    String shardingTransactionTypeScanner = &quot;shardingTransactionTypeScanner&quot;;</span><br><span class="line">    BeanDefinitionBuilder factory = BeanDefinitionBuilder.rootBeanDefinition(ShardingTransactionTypeScanner.class);</span><br><span class="line">    registry.registerBeanDefinition(shardingTransactionTypeScanner, factory.getBeanDefinition());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>DataSourceConfiger实现了将所有的分库数据源和单库数据源全部同一位shardingsphere的数据源的形式，为后续mybatis的初始化提供了参数。</p>
<h3 id="MybatisConfigure实例化mybatis的配置"><a href="#MybatisConfigure实例化mybatis的配置" class="headerlink" title="MybatisConfigure实例化mybatis的配置"></a>MybatisConfigure实例化mybatis的配置</h3><p>MybatisConfigure实现了 EnvironmentAware, BeanFactoryPostProcessor, ApplicationContextAware三个接口，分别具有了环境配置拉取、bean配置后置处理、以及获取spring上下文的能力。<br>内部有三个成员:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 从environment读取配置</span><br><span class="line">private PropertiesReader propertiesReader;</span><br><span class="line">//spring上下文</span><br><span class="line">private ApplicationContext applicationContext;</span><br><span class="line">//环境元数据</span><br><span class="line">private Environment environment;</span><br></pre></td></tr></table></figure>

<p>成员变量的初始化:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">    this.applicationContext = applicationContext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void setEnvironment(Environment environment) &#123;</span><br><span class="line">    this.environment = environment;</span><br><span class="line">    this.propertiesReader = new PropertiesReader() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String getString(String propertyName) &#123;</span><br><span class="line">            return environment.getProperty(propertyName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是BeanFactoryPostProcessor接口的能力，借助实现postProcessBeanFactory方法初始化mybatis的配置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">    BeanDefinitionRegistry registry = (BeanDefinitionRegistry)beanFactory;</span><br><span class="line">    //把DataSourceConfiger加载完毕的数据源信息拿过来</span><br><span class="line">    //key:logicDsName;value:&#123;key:realDsName,value:DataSource&#125;，即一个逻辑数据源对应多个真实的实体数据源。</span><br><span class="line">    for(Map.Entry&lt;String, Map&lt;String, DataSource&gt;&gt; entity: DataSourceConfiger.originalDataSourceMaps.entrySet())&#123;</span><br><span class="line">        // register  SqlSessionFactoryBean，即构建SqlSessionFactoryBean，SqlSessionFactoryBean封装了mybatis-config.xml的位置、mapper的xml位置信息等</span><br><span class="line">        GenericBeanDefinition definition =  buildSessionFactoryBeanDefinition(entity.getKey());</span><br><span class="line">        //将SqlSessionFactoryBean注册到spring容器</span><br><span class="line">        registry.registerBeanDefinition(entity.getKey() + &quot;sqlSessionFactoryBean&quot;, definition);</span><br><span class="line">        // register  sqlTemplate</span><br><span class="line">        // SqlSessionTemplate是给mapper类使用的，mapper 的java类在访问数据源的时候是通过 SqlSessionTemplate去访问的。</span><br><span class="line">        GenericBeanDefinition eachSqlTemplatedefinition = new GenericBeanDefinition();</span><br><span class="line">        eachSqlTemplatedefinition.setBeanClass(SqlSessionTemplate.class);</span><br><span class="line">        eachSqlTemplatedefinition.setScope(BeanDefinition.SCOPE_SINGLETON);</span><br><span class="line">        eachSqlTemplatedefinition.getConstructorArgumentValues().addIndexedArgumentValue(0, new RuntimeBeanReference(entity.getKey()+&quot;sqlSessionFactoryBean&quot;));</span><br><span class="line">        registry.registerBeanDefinition(entity.getKey()+&quot;sqlTemplate&quot;, eachSqlTemplatedefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    //配置mapper 的java类的扫描（根据mapper上的注解实现扫描的）</span><br><span class="line">    Set&lt;String&gt; basePackages = this.resolveBasePackages();</span><br><span class="line">    MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer();</span><br><span class="line">    mapperScannerConfigurer.setApplicationContext(applicationContext);</span><br><span class="line">    mapperScannerConfigurer.setMarkerInterface(Mapper.class);</span><br><span class="line">    //mapper类被注解了@Mapper 会被认为是一个mubatis的mapper</span><br><span class="line">    mapperScannerConfigurer.setAnnotationClass(com.twodragonlake.sharding.jdbc.mapper.annotation.Mapper.class);</span><br><span class="line">    //扫描的根目录</span><br><span class="line">    mapperScannerConfigurer.setBasePackage(com.twodragonlake.sharding.jdbc.common.utils.StringUtils.join(basePackages, &quot;,&quot;));</span><br><span class="line">    //mapper默认使用默认的数据源的sqlTemplate</span><br><span class="line">    mapperScannerConfigurer.setSqlSessionTemplateBeanName(DataSourceConfiger.defaultLogicDsName + &quot;sqlTemplate&quot;);</span><br><span class="line">    //配置为自动扫描生效，mapperScannerConfigurer会根据mapper上的DBSwitch注解，切换为实际的sqlTemplate，稍后讲解mapperScannerConfigurer的逻辑</span><br><span class="line">    int mapperCount = mapperScannerConfigurer.autoConfigure(registry);</span><br><span class="line">    logger.info(&quot;&#123;&#125; mappers have been found and been added to spring container.&quot;, mapperCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建SqlSessionFactoryBean</span><br><span class="line">//SqlSessionFactoryBean封装了mybatis-config.xml的位置、mapper的xml位置信息等</span><br><span class="line">private GenericBeanDefinition buildSessionFactoryBeanDefinition(String dataBaseName) &#123;</span><br><span class="line">    GenericBeanDefinition definition = new GenericBeanDefinition();</span><br><span class="line">    definition.setBeanClass(SqlSessionFactoryBean.class);</span><br><span class="line">    definition.setScope(BeanDefinition.SCOPE_SINGLETON);</span><br><span class="line">    definition.getPropertyValues().addPropertyValue(&quot;dataSource&quot;, new RuntimeBeanReference(dataBaseName));</span><br><span class="line">    Resource mybatisResource;</span><br><span class="line">    try &#123;</span><br><span class="line">        Resource[] mybatisResources  = this.applicationContext.getResources(&quot;classpath*:/mybatis-config.xml&quot;);</span><br><span class="line">        mybatisResource = mybatisResources[0];</span><br><span class="line">    &#125; catch (IllegalConfigException e) &#123;</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new IllegalConfigException(&quot;no mybatis-config.xml file exists in classpath.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    definition.getPropertyValues().addPropertyValue(&quot;configLocation&quot;, mybatisResource);</span><br><span class="line"></span><br><span class="line">    String typeAliasesPackage = propertiesReader.getString(&quot;spring.shardingsphere.datasource.typeAliasesPackage&quot;, &quot;&quot;);</span><br><span class="line">    if (!StringUtils.isEmpty(typeAliasesPackage)) &#123;</span><br><span class="line">        definition.getPropertyValues().addPropertyValue(&quot;typeAliasesPackage&quot;, typeAliasesPackage);</span><br><span class="line">    &#125;</span><br><span class="line">    String typeHandlersPackage = propertiesReader.getString(&quot;spring.shardingsphere.datasource.typeHandlersPackage&quot;, &quot;&quot;);</span><br><span class="line">    if (!StringUtils.isEmpty(typeHandlersPackage)) &#123;</span><br><span class="line">        definition.getPropertyValues().addPropertyValue(&quot;typeHandlersPackage&quot;, typeHandlersPackage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        definition.getPropertyValues().addPropertyValue(&quot;mapperLocations&quot;, this.applicationContext.getResources(&quot;classpath*:/mybatis/**/*.xml&quot;));</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;IOException when loading mapper resource under classpath*:/mybatis/**/*.xml&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return definition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取扫描的package根路径</span><br><span class="line">private Set&lt;String&gt; resolveBasePackages() &#123;</span><br><span class="line">    // 获取main方法启动的类(使用异常取巧的编程方式)</span><br><span class="line">    Class&lt;?&gt; main = CommonUtils.findMainClass();</span><br><span class="line">    Set&lt;String&gt; scanPackages = new HashSet&lt;&gt;();</span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; scanPackageClasses = new ArrayList&lt;&gt;();</span><br><span class="line">    String basePackages = this.propertiesReader.getString(&quot; &quot;);</span><br><span class="line">    if(StringUtils.isEmpty(basePackages)) &#123;</span><br><span class="line">        //兼容starter，MapperComponentScan 可以配置扫描的路径</span><br><span class="line">        MapperComponentScan mapperComponentScan = main.getAnnotation(MapperComponentScan.class);</span><br><span class="line">        if(mapperComponentScan != null) &#123;</span><br><span class="line">            scanPackages.addAll(Arrays.asList(mapperComponentScan.basePackage()));</span><br><span class="line">            scanPackageClasses.addAll(Arrays.asList(mapperComponentScan.basePackageClasses()));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // MapperScan也可以配置扫描的路径</span><br><span class="line">            MapperScan mapperScan = main.getAnnotation(MapperScan.class);</span><br><span class="line">            if(mapperScan != null) &#123;</span><br><span class="line">                scanPackages.addAll(Arrays.asList(mapperScan.basePackages()));</span><br><span class="line">                scanPackageClasses.addAll(Arrays.asList(mapperScan.basePackageClasses()));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                scanPackageClasses.add(main);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(scanPackageClasses != null) &#123;</span><br><span class="line">            for(Class&lt;?&gt; packageClass : scanPackageClasses)&#123;</span><br><span class="line">                scanPackages.add(packageClass.getPackage().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        scanPackages.add(basePackages);</span><br><span class="line">    &#125;</span><br><span class="line">    return scanPackages;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MapperScannerConfigurer切换mapper的sqlTemplate为实际需要的sqlTemplate"><a href="#MapperScannerConfigurer切换mapper的sqlTemplate为实际需要的sqlTemplate" class="headerlink" title="MapperScannerConfigurer切换mapper的sqlTemplate为实际需要的sqlTemplate"></a>MapperScannerConfigurer切换mapper的sqlTemplate为实际需要的sqlTemplate</h4><p> 这里不对mybatis的一些组件细化讲解，有兴趣可以参考这个课程深化了解mybatis:<br> <img src="https://i.loli.net/2021/07/18/5bMpSuartDmW2L7.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MapperScannerConfigurer extends org.mybatis.spring.mapper.MapperScannerConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(MapperScannerConfigurer.class);</span><br><span class="line"></span><br><span class="line">    private MapperHelper mapperHelper = new MapperHelper();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setMarkerInterface(Class&lt;?&gt; superClass) &#123;</span><br><span class="line">        super.setMarkerInterface(superClass);</span><br><span class="line">        if (Marker.class.isAssignableFrom(superClass)) &#123;</span><br><span class="line">            mapperHelper.registerMapper(superClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MapperHelper getMapperHelper() &#123;</span><br><span class="line">        return mapperHelper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMapperHelper(MapperHelper mapperHelper) &#123;</span><br><span class="line">        this.mapperHelper = mapperHelper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 属性注入</span><br><span class="line">     *</span><br><span class="line">     * @param properties</span><br><span class="line">     */</span><br><span class="line">    public void setProperties(Properties properties) &#123;</span><br><span class="line">        mapperHelper.setProperties(properties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int autoConfigure( BeanDefinitionRegistry registry) &#123;</span><br><span class="line">        super.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">        //如果没有注册过接口，就注册默认的Mapper接口</span><br><span class="line">        this.mapperHelper.ifEmptyRegisterDefaultInterface();</span><br><span class="line">        String[] names = registry.getBeanDefinitionNames();</span><br><span class="line">        GenericBeanDefinition definition;</span><br><span class="line">        int mapperCount = 0;</span><br><span class="line">        for (String name : names) &#123;</span><br><span class="line">            BeanDefinition beanDefinition = registry.getBeanDefinition(name);</span><br><span class="line">            if (beanDefinition instanceof GenericBeanDefinition) &#123;</span><br><span class="line">                definition = (GenericBeanDefinition) beanDefinition;</span><br><span class="line">                //MapperFactoryBean 是mybatis对mapper在spring当中的抽象，适配了springbean的规范，是一个FactoryBean，FactoryBean其实是一个代理，getObject才是正真的对象</span><br><span class="line">                //这里的意思是如果是一个mybatis的mapper的封装，那么进行一波逻辑操作</span><br><span class="line">                if (StringUtil.isNotEmpty(definition.getBeanClassName()) &amp;&amp; definition.getBeanClassName().equals(&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;)) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        //definition.getPropertyValues().add(&quot;sqlSessionTemplate&quot;, new RuntimeBeanReference(&quot;sqlTemplate&quot;));</span><br><span class="line">                        //得到mapper类的元信息</span><br><span class="line">                        String value = ((ScannedGenericBeanDefinition) definition).getMetadata().getClassName();</span><br><span class="line">                        //得到mapper类对象</span><br><span class="line">                        Class&lt;?&gt; valueClass = Class.forName(value);</span><br><span class="line">                        //尝试得到DBSwitch注解</span><br><span class="line">                        DBSwitch dbSwitch = valueClass.getAnnotation(DBSwitch.class);</span><br><span class="line">                        if(dbSwitch == null || StringUtils.isEmpty(dbSwitch.value()))&#123;</span><br><span class="line">                            // mapper没有配置DBSwitch，则使用默认的sqlTemplate</span><br><span class="line">                            definition.getPropertyValues().add(&quot;sqlSessionTemplate&quot;, new RuntimeBeanReference(DataSourceConfiger.defaultLogicDsName + &quot;sqlTemplate&quot;));</span><br><span class="line">                        &#125;else&#123;</span><br><span class="line">                            //mapper配置了DBSwitch，则使用DBSwitch配置的数据源名称对应的sqlTemplate</span><br><span class="line">                            definition.getPropertyValues().add(&quot;sqlSessionTemplate&quot;, new RuntimeBeanReference(dbSwitch.value()+&quot;sqlTemplate&quot;));</span><br><span class="line">                        &#125;</span><br><span class="line">                        mapperCount++;</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        throw new IllegalStateException(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    definition.setBeanClass(tk.mybatis.spring.mapper.MapperFactoryBean.class);</span><br><span class="line">                    definition.getPropertyValues().add(&quot;mapperHelper&quot;, this.mapperHelper);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return mapperCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>MybatisConfigure 使用DataSourceConfiger里边初始化的数据源，创建了mybatis访问数据源用的SqlSessionTemplate，之后使用SqlSessionTemplate作为参数创建mapper，<br>加载了mapper到spring容器。</p>
<h3 id="使用Encryptor实现定制化脱敏编解码器"><a href="#使用Encryptor实现定制化脱敏编解码器" class="headerlink" title="使用Encryptor实现定制化脱敏编解码器"></a>使用Encryptor实现定制化脱敏编解码器</h3><p>关于shardingsphere的实现方案，参考官方的介绍，<span class="exturl" data-url="aHR0cHM6Ly9zaGFyZGluZ3NwaGVyZS5hcGFjaGUub3JnL2RvY3VtZW50L2xlZ2FjeS80LngvZG9jdW1lbnQvY24vZmVhdHVyZXMvb3JjaGVzdHJhdGlvbi9lbmNyeXB0Lw==">数据脱敏<i class="fa fa-external-link-alt"></i></span><br>次数不再单独讲解。<br>Encryptor的加载，shardingsphere使用了java的spi机制，首先我们先介绍些 怎么实现一个定制化的Encryptor:</p>
<h4 id="实现Encryptor接口定制一个脱敏编解码器"><a href="#实现Encryptor接口定制一个脱敏编解码器" class="headerlink" title="实现Encryptor接口定制一个脱敏编解码器"></a>实现Encryptor接口定制一个脱敏编解码器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class LLPayAESEncryptor implements Encryptor &#123;</span><br><span class="line">    // Encryptor的配置信息</span><br><span class="line">    private Properties properties = new Properties();</span><br><span class="line">    // IAESCryptService是一个rpc服务，对外提供了信息加密解密的能力</span><br><span class="line">    private static IAESCryptService aESCryptService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        //初始化</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 使用aESCryptService加密</span><br><span class="line">    @Override</span><br><span class="line">    public String encrypt(Object plaintext) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (null != plaintext &amp;&amp; !StringUtils.isEmpty(plaintext)) &#123;</span><br><span class="line">                return aESCryptService.encrypt(plaintext.toString().getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (AESException aesException)&#123;</span><br><span class="line">            throw new RuntimeException(aesException);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //使用aESCryptService解密</span><br><span class="line">    @Override</span><br><span class="line">    public Object decrypt(String ciphertext) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (null != ciphertext &amp;&amp; !StringUtils.isEmpty(ciphertext)) &#123;</span><br><span class="line">                return new String (aESCryptService.decrypt(ciphertext),StandardCharsets.UTF_8);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (AESException aesException)&#123;</span><br><span class="line">            throw new RuntimeException(aesException);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 编解码器的类型，EncryptorServiceLoader加载器会根据这个类型字符串加载当前的LLPayAESEncryptor实现</span><br><span class="line">    @Override</span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return EncryptConstants.LLPAYENCRYPT_AES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Properties getProperties() &#123;</span><br><span class="line">        return properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setProperties(Properties properties) &#123;</span><br><span class="line">        this.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //初始化aESCryptService（如果是dubbo服务，要提前将服务注册到spring容器当中）</span><br><span class="line">    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        if (null ==  aESCryptService) &#123;</span><br><span class="line">            aESCryptService = beanFactory.getBean(IAESCryptService.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加载Encryptor"><a href="#加载Encryptor" class="headerlink" title="加载Encryptor"></a>加载Encryptor</h3><p>shardingsphere使用java的spi机制加载脱敏编解码器，shardingsphere有自己封装的loader：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.twodragonlake.sharding.jdbc.encrypt.constants.EncryptConstants;</span><br><span class="line">import com.twodragonlake.sharding.jdbc.encrypt.llaes.LLPayAESEncryptor;</span><br><span class="line">import org.apache.shardingsphere.encrypt.strategy.spi.loader.EncryptorServiceLoader;</span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.beans.factory.config.BeanFactoryPostProcessor;</span><br><span class="line">import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</span><br><span class="line"></span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">public class EncryptConfigurer implements  BeanFactoryPostProcessor &#123;</span><br><span class="line">    //EncryptorServiceLoaders相当于jdk当中的ServiceLoader，shardingsphere实现了一套适合自己的EncryptorServiceLoader，换汤不换药</span><br><span class="line">    private EncryptorServiceLoader serviceLoader = new EncryptorServiceLoader();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        // 使用EncryptorServiceLoader加载指定类型的Encryptor</span><br><span class="line">        LLPayAESEncryptor llPayEncryptor = (LLPayAESEncryptor) serviceLoader.newService(EncryptConstants.LLPAYENCRYPT_AES, new Properties());</span><br><span class="line">        //注册到spring容器当中</span><br><span class="line">        llPayEncryptor.postProcessBeanFactory(beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="引导"><a href="#引导" class="headerlink" title="引导"></a>引导</h4><p>最后需要配置入口，让EncryptorServiceLoader可以加载到LLPayAESEncryptor，我们把上述EncryptConfigurer和LLPayAESEncryptor可以封装到一个jar当中，业务系统可以直接用maven引入，当业务app启动的时候要想加载LLPayAESEncryptor生效需要遵守java的spi规范，因此需要在我们的jar包当中的resources目录下创建如下结构的文件：<br>-resources<br>  -META-INF.services<br>    org.apache.shardingsphere.encrypt.strategy.spi.Encryptor</p>
<p>org.apache.shardingsphere.encrypt.strategy.spi.Encryptor文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.twodragonlake.sharding.jdbc.encrypt.llaes.LLPayAESEncryptor</span><br></pre></td></tr></table></figure>
<p>即Encryptor的实现LLPayAESEncryptor。</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>shardingsphere提供了一套脱敏方案，并且暴露了接口给开发者，可以实现定制化的数据脱敏实现，在我们的例子当中，IAESCryptService的实现可以是阿里云、aws等服务上提供的加密服务，这样就能灵活的配置数据脱敏。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本章主要介绍了 shardin-jdbc在不同的数据库，使用不同的策略的封装和实现，配合mybatis去做了mapper上的兼容，最后介绍了sharding-jdbc脱敏的定制化实现。<br>源码目前还在内部优化，开源之后会放到<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1R3b0RyYWdvbkxha2U=">TwoDragonLake<i class="fa fa-external-link-alt"></i></span> Organization当中。</p>
]]></content>
      <categories>
        <category>starter_struct</category>
      </categories>
      <tags>
        <tag>shardingsphere</tag>
        <tag>jdbc</tag>
        <tag>starter</tag>
      </tags>
  </entry>
</search>
