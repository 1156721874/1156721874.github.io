---
title: 设计模式(2)-代理模式
date: 2018-09-28 20:20:31
tags: DesignPatterns
categories: DesignPatterns
---
![这里写图片描述](20151010130746987.png)
**1、静态代理：**
```
<!-- more -->
interface ProxyBase{
	public void f();
	public void g();
	public void h();
}
//代理程序
class Proxy implement ProxyBase{
	private ProxyBase implementation;
	public Proxy(){
		//目标程序
		implementation = new ProxyImplementation();
	}
	public void f(){
		implementation.f();
	}
	public void g(){
		implementation.g();
	}
	public void h(){
		implementation.h();
	}
}
//目标程序
class ProxyImplementation implements ProxyBase{
	public void f(){
		System.out.println(“ProxyImplementation.f()”);
	}
	public void g(){
		System.out.println(“ProxyImplementation.g()”);
	}
	public void h(){
		System.out.println(“ProxyImplementation.h()”);
	}
}
//客户端程序调用代理
public class ProxyDemo{
	public static void main(String[] args){
		//客户端调用代理程序
		Proxy p = new Proxy();
		p.f();
		p.g();
		p.h();
	}
}
```
**2、动态代理**
动态代理分为JDK的接口动态代理和CGLIB的基于类的动态代理，
JDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。
**jdk动态代理：**
**[jdk动态代理的实现原理参考](http://rejoy.iteye.com/blog/1627405)**
```
//代理接口
interface Foo{
	public void f(String s);
	public void g(int i);
	public void h(int i, String s);
}
//接口实现类，即被代理类
class FooImpl implements Foo{
	public void f(String s){
		System.out.println(“FooImpl.f(), s=” + s);
	}
	public void g(int i) {
		System.out.println(“FooImpl.g(), i=” + i);
	}
	public void h(int i, String s) {
		System.out.println(“FooImpl.h(), i=” + i + “, s=” + s);
	}
}
//动态代理处理类
class ProxyHandler implements InvocationHandler{
	//代理实现类
	private Object delegate;            
     	public ProxyHandler (Object obj) {    
         	delegate = obj;    
     	}    
	public Object invoke(Object proxy, Method method, Object[] args){
  		System.out.println(“Before mothod:” + method);
  		method.invoke(this.delegate, args);
  		System.out.println(“After mothod:” + method);
  		return null;
	}
}
public class DynamicProxyDemo{
	public static void main(String[] args){
		Foo foo = new FooImpl();
		ProxyHandler handler = new ProxyHandler(foo);
		//产生动态代理
	Foo proxy = (Foo)Proxy.newProxyInstance(Foo.class.getClassLoader(), new Class[]{Foo.class}, handler);
		proxy.f(“f”);
		proxy.g(1);
		proxy.h(“h”, 2);
	}
}
```
**CGLIB动态代理**
在使用CGLIB时需引入cglib-nodep-2.1_3.jar包
被代理对象
```
package com.ljq.test;

/**
 * 定义一个HelloWorld类
 *
 * @author jiqinlin
 *
 */
public class HelloWorld {
    public void sayHelloWorld() {
        System.out.println("HelloWorld!");
    }
}
```
代理类
```
package com.ljq.test;

import java.lang.reflect.Method;

import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

/**
 * 通过Cglib实现在方法调用前后向控制台输出两句字符串
 *
 * @author jiqinlin
 *
 */
public class CglibProxy implements MethodInterceptor {
    //要代理的原始对象
    private Object obj;

    public Object createProxy(Object target) {
        this.obj = target;
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(this.obj.getClass());// 设置代理目标
        enhancer.setCallback(this);// 设置回调
        enhancer.setClassLoader(target.getClass().getClassLoader());
        return enhancer.create();
    }


    /**
     * 在代理实例上处理方法调用并返回结果
     *
     * @param proxy
     *            代理类
     * @param method
     *            被代理的方法
     * @param params
     *            该方法的参数数组
     * @param methodProxy
     */
    public Object intercept(Object proxy, Method method, Object[] params,
            MethodProxy methodProxy) throws Throwable {
        Object result = null;
        // 调用之前
        doBefore();
        // 调用原始对象的方法
        result = methodProxy.invokeSuper(proxy, params);
        // 调用之后
        doAfter();
        return result;
    }

    private void doBefore() {
        System.out.println("before method invoke");
    }

    private void doAfter() {
        System.out.println("after method invoke");
    }

}
```
测试类

```
package com.ljq.test;

public class HelloWorldTest {

    public static void main(String[] args) {
        HelloWorld helloWorld=new HelloWorld();
        CglibProxy cglibProxy=new CglibProxy();
        HelloWorld hw=(HelloWorld)cglibProxy.createProxy(helloWorld);
        hw.sayHelloWorld();
    }
}
```
