---
title: 设计模式（11）-组合模式
date: 2018-09-28 21:08:52
tags: DesignPatterns
categories: DesignPatterns
---

**思想**：将 对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致 性。
**场景**：该 模式的应用场景极其类似，比如像图形系统，如电路设计、UML建模系统，或者像web的 显示元素等，都是那种需要整体和部分具有使用接口上的一定的一致性的需求的结构，实际上，我觉得这样的系统如果不使用Composite模 式将会是惨不忍睹的。
<!-- more -->
**实现**：该模式的实现主要就是要表示整体或部分的所有类都继承自同一的基类或接口，从而拥有使用接口上一定的一致性。
**重构成本**：高。

Composite组合设计模式属于对象的结构模式，有时又叫做部分－整体（Part－Whole）模式。
组合设计模式将对象组织到树型结构中，可以用来描述整体与部分的关系。组合模式可以使客户端将单纯元素与复合元素同等看待。
组合设计模式涉及到的三个角色
(1).抽象构件（Component）角色：这是一个抽象角色，它给参加组合的对象规定一个接口。这个角色给出共有的接口机器默认行为。
(2).树叶构件（Leaf）角色：代表参加组合的树叶对象。一个树叶没有下级的子对象。定义出参加组合的原始对象的行为。
(3).树枝构件（Composite）角色：代表参加组合的有子对象的对象，并给出树枝构件对象的行为。
Composite组合设计模式的实现根据所实现接口的区别分为两种形式，分别称为安全式和透明式：
(1).透明方式
   作为第一种选择，在Compotent里面声明所有的用来管理子类对象的方法，包括add()、remove()、以及getChild()方法。
   这样做的好处是所有的构件类都有相同的接口。在客户端看来，树叶类对象与合成类对象的区别起码在接口层次上消失了，客户端 可以同等地对待所有的对象。这就是透明形式的合成模式。 这个选择的缺点是不够安全，因为树叶对象和组合类对象的在本质上是有区别的。树叶类对象不可能有下一个层次的对象， 因此add() remove() getChild()方法没有意义，但是在编译时期不会出错，而只会在运行期出错。
Composite组合设计模式的透明方式结构如下：
![这里写图片描述](20160102200840852.png)
Composite组合设计模式的透明方式例子代码如下：

```
interface Component{
	public void operation();
	composite getComposite();
	public void add(Component component);
	public void remove(Component component);
	public Iterator iter();
}
class Composite implements Component(){
	private List< Component> components = new ArrayList< Component>();
	composite getComposite(){
	return this;
}
public void operation(){
	Iterator iter = iter ();
	while(iter.hasNext()){
	((Component)iter.next()).operation();
}
}

	public void add(Component component){
	components.add(component);
}
	public void remove(Component component){
	components.remove(component);
}
	public Iterator iter(){
	return components.iterator();
}
}
class Leaf implements Component{
composite getComposite(){
return null;
}

public void operation(){
System.out.println(“Leaf component operation”);
}
public void add(Component component){}
public void remove(Component component){}
public Iterator iter(){
return null;
}
}
```
(2).安全方式
   第二种选择是在Composite类里而声明所有的用来管理子类对象的方法。这样的做法是安全的做法。树叶类型的对象根本就没有管理子类对象的方法，因此，如果客户端对树叶类对象使用这些方法时，程序会在编译时期出错。  这个方式的缺点就是不够透明，因为树叶类和合成类将具有不同的接口。
Composite组合设计模式的安全方式结构如下：

```
interface Component{
	public void operation();
	composite getComposite();
}
class Composite implements Component(){
	private List< Component> components = new ArrayList< Component>();
	composite getComposite(){
	return this;
}
public void operation(){
	Iterator iter = iter ();
	while(iter.hasNext()){
	((Component)iter.next()).operation();
}
}
//管理方法只存在于Composite中
	public void add(Component component){
	components.add(component);
}
	public void remove(Component component){
	components.remove(component);
}
	public Iterator iter(){
	return components.iterator();
}
}
class Leaf implements Component{
	composite getComposite(){
	return null;
}
public void operation(){
	System.out.println(“Leaf component operation”);
}
}
```
组合模式通常和迭代器模式联合使用。
JDK中组合模式的应用：
•javax.swing.JComponent#add(Component)
•java.awt.Container#add(Component)
•java.util.Map#putAll(Map)
•java.util.List#addAll(Collection)
•java.util.Set#addAll(Collection)
•org.w3c.dom
