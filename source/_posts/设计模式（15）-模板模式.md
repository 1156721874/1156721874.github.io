---
title: 设计模式（15）-模板模式
date: 2018-09-28 21:33:50
tags: DesignPatterns
categories: DesignPatterns
---

**思想**：定 义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Te m p l a t e M e t h o d 使 得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
**场景**：该 模式实际上是一种非常直观和可理解的OO思想下的代码重用的实现。只需一次性实现一个算法的不变的 部分，并将可变的行为留给子类来实现。各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。模板方法只允许在特定点计算法的某个阶段被 过载，这样也就只允许在这些点进行扩展。
<!-- more -->
实现：见下图，太简单了，就不多说了。
**重构成本**：低。
Template Method模板方法设计模式定义一个操作中算法的骨架，将具体步骤的执行延迟到子类中实现。Java中的抽象类就是使用了模板方法设计模式。模板方法设计模式结构如下：
![这里写图片描述](20160723181450412.png)
```
 public abstract class Person {
	//模板方法，该方法定义具有相同的内容部分
	public void say() {
		System.out.println("Hello ");
		System.out.println("My name is :"+getName());
		System.out.println("Intruduce myself :"+getInfo());
		System.out.println("Thanks...bye :");
	}
	//抽象方法，模板方法中细节不同的内容
	public abstract String getName();
	public abstract String getInfo();
}

/**
 *模板模式
 *
 */
public class Student extends Person{

	@Override
	public String getInfo() {

		return "I`m a student ";
	}

	@Override
	public String getName() {

		return "jack";
	}

}
/**
 *模板模式
 *
 */
public class Teacher extends Person{

	@Override
	public String getInfo() {

		return "I`m a teacher ";
	}

	@Override
	public String getName() {

		return "Tom";
	}
}
/**
 *模板模式测试类
 *
 */
public class TestPersonOfMould {
	public static void main(String[] args) {
		Student s = new Student();
		s.say();
		Teacher t =new Teacher();
		t.say();
	}
}

```
很多学习设计模式的人看到上面的例子后，觉得Template Method模板方法设计模式非常类似Façade门面设计模式，Template Method模板方法设计模式和Façade门面设计模式的区别如下：

(1).Template Method模板方法设计模式可以先将一些流程和框架规定好，将这些流程和框架作为程序除了的模版。具体的细节除了留给子类去实现。

(2).Façade门面设计模式仅仅只定义对外操作接口，具体的实现全部交给子类。

策略模式使用组合，模板方法模式使用继承。工厂方法模式是模板模式的一种变体。

模板方法使得子类可以在不改变算法结构的情况下，重启定义算法中的某些步骤，模板方法有以下3种变体：
•模板方法模式中必须子类实现的方法定义为抽象方法。
•子类可选的方法可以在父类中提供默认版本即钩子（hook）。
•不希望子类重写的方法定义为final。
•

JDK中模板方法模式应用：

java.util.Collections#sort()

Java swing/applet#paint()

Java applet/servlet#init(), destory()

XML SAX#startDocument(), startElement(),endElement, endDocument()
