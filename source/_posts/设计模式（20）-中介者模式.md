---
title: 设计模式（20）-中介者模式
date: 2018-09-28 21:42:12
tags: DesignPatterns
categories: DesignPatterns
---

Mediator
**思想：**用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
**场景：**该模式主要用来进行降低一组相互关联调用的对象间的耦合度。如果您发现您的系统的某部分的一组对象间调用极其频繁的坏味道的话，可能您 需要考虑使用该模式来进行一些解耦，否则，这些对象中的任何一个的修改，都将可能导致其他对象许多地方的修改，可维护性就降低了。
**实现：**定义一个专门的中介对象来封装和传递一组对象间的调用。
**重构成本：中。**

Mediator中介者设计模式是通过一个中介对象封装一系列关于对象交互行为.
Mediator中介者设计模式中的角色如下：
(1).中介者（Mediator）：抽象定义了“同事”（colleagues，稍后有定义）们通信的接口。
(2).具体中介者（Concrete Mediator）：实现了“同事”间的通信接口。
(3).同事（Colleague）：参与通信的实体抽象。
(4).具体同事（Concrete Colleague）：实现的参与通信的实体。
Mediator中介者设计模式结构如下：
![这里写图片描述](20161027202246524.png)

以私信聊天为例来简单演示Mediator中介者设计模式，例子代码如下：


```
//中介者
interface Mediator{
	public void send(String msg, Person person);
}
//具体中介者
class ConcreteMediator implements Mediator{
	//中介者所联系的交互对象
	private PersonA personA;
	private PersonA personB;
	public void setPersonA(PersonA  personA){
	this.personA = personA;
}
Public void setPersonB(PersonB personB){
	this.personB = personB;
}
public void send(String msg, Person person){
	if(person.equals(personA)){
	personA.greeting(msg);
}else{
	personB.greeting(msg);
}
}
}
//抽象同事
abstract class Person{
	//同事和中介者打交道
	protected Mediator mediator;
	public Person(Mediator mediator){
	this.mediator = mediator;
}
}
//具体同事
class PersonA extends Person{
	public PersonA(Mediator mediator){
	super(mediator);
}
public void send(String msg){
	mediator.send(msg, this);
}
public void greeting(string msg){
	System.out.println(“PersonA: ” + msg);
}
}
class PersonB extends Person{
	public PersonB(Mediator mediator){
	super(mediator);
}
public void send(String msg){
	mediator.send(msg, this);
}
public void greeting(string msg){
	System.out.println(“PersonB: ” + msg);
}
}
public class MediatorDemo{
	public static void main(String[] args){
		//创建中介
		Mediator mediator = new ConcreteMediator();
//创建同事，并为同事设置中介
Person personA = new PersonA(mediator);
Person personB = new PersonB(mediator);

//向中介设置同事
mediator.setPersonA(personA);
mediator.setPersonB(personB);

//开始聊天
personA.send(“Hi, B!”);
personB.send(“Hello, A!”);
}
}
```
在对象之间的交互操作非常多的情况下;每个对象的行为操作都可能依赖很多其他对象,修改一个对象的行为的同时可能会影响到很多其他对象的行为,如果使用Mediator模式,可以使各个对象间的耦合松散,只需关心和 Mediator的关系,使多对多的关系变成了一对多的关系,在降低系统复杂性的同时提高可修改扩展性.
