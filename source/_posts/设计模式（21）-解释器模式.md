---
title: 设计模式（21）-解释器模式
date: 2018-09-28 21:43:39
tags: DesignPatterns
categories: DesignPatterns
---
**思想：**当 有一个语言需要解释执行, 并且你可将该语言中的句子表示为一个抽象语法树时，定义一个解释器，这 个解释器使用该表示来解释语言中的句子。
**场景：**其 实，从物理结构上，该模式的代码架构看起来可能和Composite模式一模一样，致使其针对的逻 辑语义不同。Composite模式描述一种一般的整体和部分使用接口上的一致性，而Interpreter模 式则侧重于语言解释器的实现构架。
**实现**：如 上图，基本同Composite模式。
<!-- more -->
**重构成本：**高。
Interpreter解释器设计模式的定义：给定一个语言，定义其文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
Interpreter解释器设计模式角色如下：
(1).抽象表达式(AbstractExpression)角色：声明一个所有的具体表达式角色都需要实现的抽象接口。这个接口主要定义一个interpret()方法，称做解释操作。
(2).终结符表达式(TerminalExpression)角色：没有子节点的表达式。
(3).非终结符表达式(NonterminalExpression)角色：有子节点的表达式，解释操作以递归方式调用其子节点表达式。
(4).上下文(Context)角色：上下文提供解释器之外的一些全局信息，比如变量的真实量值等。
Interpreter解释器设计模式结构如下：
![这里写图片描述](2018/09/28/设计模式（21）-解释器模式/20161027204106492.png)
通过编写一个模拟Java中日期格式化为指定字符串的例子来演示Interpreter解释器设计模式，代码如下：

```
//抽象表达式
interface AbstractExpression{
	public String format(Date date);
}
//具体的日期格式化表达式
class DataFormatExpression implements AbstractExpression{
	private static final String pattern1 = “yyyy-MM-dd”;
	private static final String pattern2 = “yyyy/MM/dd”;
	private static final Calendar calendar = Calendar.getInstance();
	//默认日期不分隔，如：20120606
	private String separator = “”;
	public DataFormatExpression(){}
	public DataFormatExpression(String pattern){
	if(pattern1.equals(pattern)){
	separator = “-”;
}
else if(pattern2.equals(pattern)){
	separator = “/”;
}
}
public String getYear(Calendar cal){
	return cal.get(Calendar.YEAR) + “”;
}
public String getMonth(Calendar cal){
	int month = cal.get(Calendar.MONTH) + 1;
	return month < 10 ? “0” + month : “” + month;
}
public String getDay(Calendar cal){
	int day = cal.get(Calendar.DAY_OF_MONTH);
	return day < 10 ? “0” + day : “” + day;
}
public String format(Date date){
	calendar.setTime(date);
	return getYear(calendar) + separator + getMonth(calendar) + separator + getDay(calendar);
}
}
public class InterpreterDemo{
	public static void main(String[] args){
		Date date = new Date();
	AbstractExpression expression1 = new DataFormatExpression()
	System.out.println(expression1.format(date));

AbstractExpression expression2 = new DataFormatExpression(“yyyy-MM-dd”)
	System.out.println(expression2.format(date));

AbstractExpression expression3 = new DataFormatExpression(“yyyy/MM/dd”)
	System.out.println(expression3.format(date));
}
}
```
Interpreter解释器设计模式的应用场景：
在软件构建过程中，若果某一特定领域的问题比较复杂，类似的模式不断重复出现，如果使用普通的编程方式来实现将面临非常频繁的变化。在这种情况下，将特定领域的问题表达为某种语法规则下的句子，再构建一个解释器来解释这样的句子，从而达到解决问题的目的。
JDK中解释器模式的应用：
•java.util.Pattern
•java.text.Normalizer
•java.text.DateFormat
•java.text.MessageFormat
•java.text.NumberFormat
